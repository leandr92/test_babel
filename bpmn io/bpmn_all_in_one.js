/*! Auto-generated bundle: includes BPMN modeler distro, jQuery and app code. */
var _excluded = ["selectedEntry", "setSelectedEntry", "groupedEntries"];
var _2 = function _2(t) {
    return t;
  },
  _t7,
  _t8,
  _t9,
  _t0,
  _t1,
  _t10,
  _t11,
  _t12,
  _t13,
  _t14,
  _t15,
  _t16,
  _t17,
  _t18,
  _t19,
  _t20,
  _t21,
  _t22,
  _t23,
  _t24,
  _t25,
  _t26,
  _t27;
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _regenerator2() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine4(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i.return) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine4(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine4(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine4(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine4(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine4(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine4(u), _regeneratorDefine4(u, o, "Generator"), _regeneratorDefine4(u, n, function () { return this; }), _regeneratorDefine4(u, "toString", function () { return "[object Generator]"; }), (_regenerator2 = function _regenerator2() { return { w: i, m: f }; })(); }
function _regeneratorDefine4(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine4 = function _regeneratorDefine2(e, r, n, t) { function o(r, n) { _regeneratorDefine4(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine4(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator2(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n2 = 0, F = function F() {}; return { s: F, n: function n() { return _n2 >= r.length ? { done: !0 } : { done: !1, value: r[_n2++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
/*!
 * bpmn-js - bpmn-modeler v18.7.0
 *
 * Copyright (c) 2014-present, camunda Services GmbH
 *
 * Released under the bpmn.io license
 * http://bpmn.io/license
 *
 * Source Code: https://github.com/bpmn-io/bpmn-js
 *
 * Date: 2025-09-23
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.BpmnJS = factory());
})(this, function () {
  'use strict';

  function e$2(e, t) {
    t && (e.super_ = t, e.prototype = Object.create(t.prototype, {
      constructor: {
        value: e,
        enumerable: false,
        writable: true,
        configurable: true
      }
    }));
  }
  function createCommonjsModule(fn, module) {
    return module = {
      exports: {}
    }, fn(module, module.exports), module.exports;
  }
  var hat_1 = createCommonjsModule(function (module) {
    var hat = module.exports = function (bits, base) {
      if (!base) base = 16;
      if (bits === undefined) bits = 128;
      if (bits <= 0) return '0';
      var digits = Math.log(Math.pow(2, bits)) / Math.log(base);
      for (var i = 2; digits === Infinity; i *= 2) {
        digits = Math.log(Math.pow(2, bits / i)) / Math.log(base) * i;
      }
      var rem = digits - Math.floor(digits);
      var res = '';
      for (var i = 0; i < Math.floor(digits); i++) {
        var x = Math.floor(Math.random() * base).toString(base);
        res = x + res;
      }
      if (rem) {
        var b = Math.pow(base, rem);
        var x = Math.floor(Math.random() * b).toString(base);
        res = x + res;
      }
      var parsed = parseInt(res, base);
      if (parsed !== Infinity && parsed >= Math.pow(2, bits)) {
        return hat(bits, base);
      } else return res;
    };
    hat.rack = function (bits, base, expandBy) {
      var fn = function fn(data) {
        var iters = 0;
        do {
          if (iters++ > 10) {
            if (expandBy) bits += expandBy;else throw new Error('too many ID collisions, use more bits');
          }
          var id = hat(bits, base);
        } while (Object.hasOwnProperty.call(hats, id));
        hats[id] = data;
        return id;
      };
      var hats = fn.hats = {};
      fn.get = function (id) {
        return fn.hats[id];
      };
      fn.set = function (id, value) {
        fn.hats[id] = value;
        return fn;
      };
      fn.bits = bits || 128;
      fn.base = base || 16;
      return fn;
    };
  });
  function Ids$1(seed) {
    if (!(this instanceof Ids$1)) {
      return new Ids$1(seed);
    }
    seed = seed || [128, 36, 1];
    this._seed = seed.length ? hat_1.rack(seed[0], seed[1], seed[2]) : seed;
  }
  Ids$1.prototype.next = function (element) {
    return this._seed(element || true);
  };
  Ids$1.prototype.nextPrefixed = function (prefix, element) {
    var id;
    do {
      id = prefix + this.next(true);
    } while (this.assigned(id));
    this.claim(id, element);
    return id;
  };
  Ids$1.prototype.claim = function (id, element) {
    this._seed.set(id, element || true);
  };
  Ids$1.prototype.assigned = function (id) {
    return this._seed.get(id) || false;
  };
  Ids$1.prototype.unclaim = function (id) {
    delete this._seed.hats[id];
  };
  Ids$1.prototype.clear = function () {
    var hats = this._seed.hats,
      id;
    for (id in hats) {
      this.unclaim(id);
    }
  };
  function flatten(arr) {
    return Array.prototype.concat.apply([], arr);
  }
  var nativeToString$1 = Object.prototype.toString;
  var nativeHasOwnProperty$1 = Object.prototype.hasOwnProperty;
  function isUndefined$2(obj) {
    return obj === undefined;
  }
  function isDefined(obj) {
    return obj !== undefined;
  }
  function isNil(obj) {
    return obj == null;
  }
  function isArray$3(obj) {
    return nativeToString$1.call(obj) === '[object Array]';
  }
  function isObject(obj) {
    return nativeToString$1.call(obj) === '[object Object]';
  }
  function isNumber(obj) {
    return nativeToString$1.call(obj) === '[object Number]';
  }
  function isFunction(obj) {
    var tag = nativeToString$1.call(obj);
    return tag === '[object Function]' || tag === '[object AsyncFunction]' || tag === '[object GeneratorFunction]' || tag === '[object AsyncGeneratorFunction]' || tag === '[object Proxy]';
  }
  function isString(obj) {
    return nativeToString$1.call(obj) === '[object String]';
  }
  function ensureArray(obj) {
    if (isArray$3(obj)) {
      return;
    }
    throw new Error('must supply array');
  }
  function has$1(target, key) {
    return nativeHasOwnProperty$1.call(target, key);
  }
  function find(collection, matcher) {
    var matchFn = toMatcher(matcher);
    var match;
    forEach$1(collection, function (val, key) {
      if (matchFn(val, key)) {
        match = val;
        return false;
      }
    });
    return match;
  }
  function findIndex(collection, matcher) {
    var matchFn = toMatcher(matcher);
    var idx = isArray$3(collection) ? -1 : undefined;
    forEach$1(collection, function (val, key) {
      if (matchFn(val, key)) {
        idx = key;
        return false;
      }
    });
    return idx;
  }
  function filter(collection, matcher) {
    var matchFn = toMatcher(matcher);
    var result = [];
    forEach$1(collection, function (val, key) {
      if (matchFn(val, key)) {
        result.push(val);
      }
    });
    return result;
  }
  function forEach$1(collection, iterator) {
    var val, result;
    if (isUndefined$2(collection)) {
      return;
    }
    var convertKey = isArray$3(collection) ? toNum$1 : identity$1;
    for (var key in collection) {
      if (has$1(collection, key)) {
        val = collection[key];
        result = iterator(val, convertKey(key));
        if (result === false) {
          return val;
        }
      }
    }
  }
  function without(arr, matcher) {
    if (isUndefined$2(arr)) {
      return [];
    }
    ensureArray(arr);
    var matchFn = toMatcher(matcher);
    return arr.filter(function (el, idx) {
      return !matchFn(el, idx);
    });
  }
  function reduce(collection, iterator, result) {
    forEach$1(collection, function (value, idx) {
      result = iterator(result, value, idx);
    });
    return result;
  }
  function every(collection, matcher) {
    return !!reduce(collection, function (matches, val, key) {
      return matches && matcher(val, key);
    }, true);
  }
  function some(collection, matcher) {
    return !!find(collection, matcher);
  }
  function map$1(collection, fn) {
    var result = [];
    forEach$1(collection, function (val, key) {
      result.push(fn(val, key));
    });
    return result;
  }
  function keys(collection) {
    return collection && Object.keys(collection) || [];
  }
  function size(collection) {
    return keys(collection).length;
  }
  function values(collection) {
    return map$1(collection, function (val) {
      return val;
    });
  }
  function groupBy(collection, extractor) {
    var grouped = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    extractor = toExtractor(extractor);
    forEach$1(collection, function (val) {
      var discriminator = extractor(val) || '_';
      var group = grouped[discriminator];
      if (!group) {
        group = grouped[discriminator] = [];
      }
      group.push(val);
    });
    return grouped;
  }
  function uniqueBy(extractor) {
    extractor = toExtractor(extractor);
    var grouped = {};
    for (var _len = arguments.length, collections = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      collections[_key - 1] = arguments[_key];
    }
    forEach$1(collections, function (c) {
      return groupBy(c, extractor, grouped);
    });
    var result = map$1(grouped, function (val, key) {
      return val[0];
    });
    return result;
  }
  var unionBy = uniqueBy;
  function sortBy(collection, extractor) {
    extractor = toExtractor(extractor);
    var sorted = [];
    forEach$1(collection, function (value, key) {
      var disc = extractor(value, key);
      var entry = {
        d: disc,
        v: value
      };
      for (var idx = 0; idx < sorted.length; idx++) {
        var _d = sorted[idx].d;
        if (disc < _d) {
          sorted.splice(idx, 0, entry);
          return;
        }
      }
      sorted.push(entry);
    });
    return map$1(sorted, function (e) {
      return e.v;
    });
  }
  function matchPattern(pattern) {
    return function (el) {
      return every(pattern, function (val, key) {
        return el[key] === val;
      });
    };
  }
  function toExtractor(extractor) {
    return isFunction(extractor) ? extractor : function (e) {
      return e[extractor];
    };
  }
  function toMatcher(matcher) {
    return isFunction(matcher) ? matcher : function (e) {
      return e === matcher;
    };
  }
  function identity$1(arg) {
    return arg;
  }
  function toNum$1(arg) {
    return Number(arg);
  }
  function debounce(fn, timeout) {
    var timer;
    var lastArgs;
    var lastThis;
    var lastNow;
    function fire(force) {
      var now = Date.now();
      var scheduledDiff = force ? 0 : lastNow + timeout - now;
      if (scheduledDiff > 0) {
        return schedule(scheduledDiff);
      }
      fn.apply(lastThis, lastArgs);
      clear();
    }
    function schedule(timeout) {
      timer = setTimeout(fire, timeout);
    }
    function clear() {
      if (timer) {
        clearTimeout(timer);
      }
      timer = lastNow = lastArgs = lastThis = undefined;
    }
    function flush() {
      if (timer) {
        fire(true);
      }
      clear();
    }
    function callback() {
      lastNow = Date.now();
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      lastArgs = args;
      lastThis = this;
      if (!timer) {
        schedule(timeout);
      }
    }
    callback.flush = flush;
    callback.cancel = clear;
    return callback;
  }
  function bind$2(fn, target) {
    return fn.bind(target);
  }
  function assign$1(target) {
    for (var _len3 = arguments.length, others = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      others[_key3 - 1] = arguments[_key3];
    }
    return Object.assign.apply(Object, [target].concat(others));
  }
  function set$1(target, path, value) {
    var currentTarget = target;
    forEach$1(path, function (key, idx) {
      if (typeof key !== 'number' && typeof key !== 'string') {
        throw new Error('illegal key type: ' + typeof key + '. Key should be of type number or string.');
      }
      if (key === 'constructor') {
        throw new Error('illegal key: constructor');
      }
      if (key === '__proto__') {
        throw new Error('illegal key: __proto__');
      }
      var nextKey = path[idx + 1];
      var nextTarget = currentTarget[key];
      if (isDefined(nextKey) && isNil(nextTarget)) {
        nextTarget = currentTarget[key] = isNaN(+nextKey) ? {} : [];
      }
      if (isUndefined$2(nextKey)) {
        if (isUndefined$2(value)) {
          delete currentTarget[key];
        } else {
          currentTarget[key] = value;
        }
      } else {
        currentTarget = nextTarget;
      }
    });
    return target;
  }
  function pick(target, properties) {
    var result = {};
    var obj = Object(target);
    forEach$1(properties, function (prop) {
      if (prop in obj) {
        result[prop] = target[prop];
      }
    });
    return result;
  }
  function omit(target, properties) {
    var result = {};
    var obj = Object(target);
    forEach$1(obj, function (prop, key) {
      if (properties.indexOf(key) === -1) {
        result[key] = prop;
      }
    });
    return result;
  }
  function _mergeNamespaces$1(n, m) {
    m.forEach(function (e) {
      e && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {
        if (k !== 'default' && !(k in n)) {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function get() {
              return e[k];
            }
          });
        }
      });
    });
    return Object.freeze(n);
  }
  var nativeToString = Object.prototype.toString;
  var nativeHasOwnProperty = Object.prototype.hasOwnProperty;
  function isUndefined$1(obj) {
    return obj === undefined;
  }
  function isArray$2(obj) {
    return nativeToString.call(obj) === '[object Array]';
  }
  function has(target, key) {
    return nativeHasOwnProperty.call(target, key);
  }
  function forEach(collection, iterator) {
    var val, result;
    if (isUndefined$1(collection)) {
      return;
    }
    var convertKey = isArray$2(collection) ? toNum : identity;
    for (var key in collection) {
      if (has(collection, key)) {
        val = collection[key];
        result = iterator(val, convertKey(key));
        if (result === false) {
          return val;
        }
      }
    }
  }
  function identity(arg) {
    return arg;
  }
  function toNum(arg) {
    return Number(arg);
  }
  function assign(element) {
    var target = element.style;
    for (var _len4 = arguments.length, styleSources = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
      styleSources[_key4 - 1] = arguments[_key4];
    }
    forEach(styleSources, function (style) {
      if (!style) {
        return;
      }
      forEach(style, function (value, key) {
        target[key] = value;
      });
    });
    return element;
  }
  function attr$1(el, name, val) {
    if (arguments.length == 2) {
      return el.getAttribute(name);
    }
    if (val === null) {
      return el.removeAttribute(name);
    }
    el.setAttribute(name, val);
    return el;
  }
  var toString$1 = Object.prototype.toString;
  function classes$1(el) {
    return new ClassList$1(el);
  }
  function ClassList$1(el) {
    if (!el || !el.nodeType) {
      throw new Error('A DOM element reference is required');
    }
    this.el = el;
    this.list = el.classList;
  }
  ClassList$1.prototype.add = function (name) {
    this.list.add(name);
    return this;
  };
  ClassList$1.prototype.remove = function (name) {
    if ('[object RegExp]' == toString$1.call(name)) {
      return this.removeMatching(name);
    }
    this.list.remove(name);
    return this;
  };
  ClassList$1.prototype.removeMatching = function (re) {
    var arr = this.array();
    for (var _i = 0; _i < arr.length; _i++) {
      if (re.test(arr[_i])) {
        this.remove(arr[_i]);
      }
    }
    return this;
  };
  ClassList$1.prototype.toggle = function (name, force) {
    if ('undefined' !== typeof force) {
      if (force !== this.list.toggle(name, force)) {
        this.list.toggle(name);
      }
    } else {
      this.list.toggle(name);
    }
    return this;
  };
  ClassList$1.prototype.array = function () {
    return Array.from(this.list);
  };
  ClassList$1.prototype.has = ClassList$1.prototype.contains = function (name) {
    return this.list.contains(name);
  };
  function clear$1(element) {
    var child;
    while (child = element.firstChild) {
      element.removeChild(child);
    }
    return element;
  }
  function closest(element, selector, checkYourSelf) {
    var actualElement = checkYourSelf ? element : element.parentNode;
    return actualElement && typeof actualElement.closest === 'function' && actualElement.closest(selector) || null;
  }
  var componentEvent = {};
  var bind$1, unbind$1, prefix$6;
  function detect() {
    bind$1 = window.addEventListener ? 'addEventListener' : 'attachEvent';
    unbind$1 = window.removeEventListener ? 'removeEventListener' : 'detachEvent';
    prefix$6 = bind$1 !== 'addEventListener' ? 'on' : '';
  }
  var bind_1 = componentEvent.bind = function (el, type, fn, capture) {
    if (!bind$1) detect();
    el[bind$1](prefix$6 + type, fn, capture || false);
    return fn;
  };
  var unbind_1 = componentEvent.unbind = function (el, type, fn, capture) {
    if (!unbind$1) detect();
    el[unbind$1](prefix$6 + type, fn, capture || false);
    return fn;
  };
  var event = _mergeNamespaces$1({
    __proto__: null,
    bind: bind_1,
    unbind: unbind_1,
    'default': componentEvent
  }, [componentEvent]);
  var forceCaptureEvents = ['focus', 'blur'];
  function bind(el, selector, type, fn, capture) {
    if (forceCaptureEvents.indexOf(type) !== -1) {
      capture = true;
    }
    return event.bind(el, type, function (e) {
      var target = e.target || e.srcElement;
      e.delegateTarget = closest(target, selector, true);
      if (e.delegateTarget) {
        fn.call(el, e);
      }
    }, capture);
  }
  function unbind(el, type, fn, capture) {
    if (forceCaptureEvents.indexOf(type) !== -1) {
      capture = true;
    }
    return event.unbind(el, type, fn, capture);
  }
  var delegate = {
    bind,
    unbind
  };
  var domify = parse$1;
  var innerHTMLBug = false;
  var bugTestDiv;
  if (typeof document !== 'undefined') {
    bugTestDiv = document.createElement('div');
    bugTestDiv.innerHTML = '  <link/><table></table><a href="/a">a</a><input type="checkbox"/>';
    innerHTMLBug = !bugTestDiv.getElementsByTagName('link').length;
    bugTestDiv = undefined;
  }
  var map = {
    legend: [1, '<fieldset>', '</fieldset>'],
    tr: [2, '<table><tbody>', '</tbody></table>'],
    col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
    _default: innerHTMLBug ? [1, 'X<div>', '</div>'] : [0, '', '']
  };
  map.td = map.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'];
  map.option = map.optgroup = [1, '<select multiple="multiple">', '</select>'];
  map.thead = map.tbody = map.colgroup = map.caption = map.tfoot = [1, '<table>', '</table>'];
  map.polyline = map.ellipse = map.polygon = map.circle = map.text = map.line = map.path = map.rect = map.g = [1, '<svg xmlns="http://www.w3.org/2000/svg" version="1.1">', '</svg>'];
  function parse$1(html, doc) {
    if ('string' != typeof html) throw new TypeError('String expected');
    if (!doc) doc = document;
    var m = /<([\w:]+)/.exec(html);
    if (!m) return doc.createTextNode(html);
    html = html.replace(/^\s+|\s+$/g, '');
    var tag = m[1];
    if (tag == 'body') {
      var el = doc.createElement('html');
      el.innerHTML = html;
      return el.removeChild(el.lastChild);
    }
    var wrap = Object.prototype.hasOwnProperty.call(map, tag) ? map[tag] : map._default;
    var depth = wrap[0];
    var prefix = wrap[1];
    var suffix = wrap[2];
    var el = doc.createElement('div');
    el.innerHTML = prefix + html + suffix;
    while (depth--) el = el.lastChild;
    if (el.firstChild == el.lastChild) {
      return el.removeChild(el.firstChild);
    }
    var fragment = doc.createDocumentFragment();
    while (el.firstChild) {
      fragment.appendChild(el.removeChild(el.firstChild));
    }
    return fragment;
  }
  var domify$1 = domify;
  function matches(element, selector) {
    return element && typeof element.matches === 'function' && element.matches(selector) || false;
  }
  function query(selector, el) {
    el = el || document;
    return el.querySelector(selector);
  }
  function all(selector, el) {
    el = el || document;
    return el.querySelectorAll(selector);
  }
  function remove$2(el) {
    el.parentNode && el.parentNode.removeChild(el);
  }
  function ensureImported(element, target) {
    if (element.ownerDocument !== target.ownerDocument) {
      try {
        return target.ownerDocument.importNode(element, true);
      } catch (e) {}
    }
    return element;
  }
  function appendTo(element, target) {
    return target.appendChild(ensureImported(element, target));
  }
  function append(target, node) {
    appendTo(node, target);
    return target;
  }
  var LENGTH_ATTR = 2;
  var CSS_PROPERTIES = {
    'alignment-baseline': 1,
    'baseline-shift': 1,
    'clip': 1,
    'clip-path': 1,
    'clip-rule': 1,
    'color': 1,
    'color-interpolation': 1,
    'color-interpolation-filters': 1,
    'color-profile': 1,
    'color-rendering': 1,
    'cursor': 1,
    'direction': 1,
    'display': 1,
    'dominant-baseline': 1,
    'enable-background': 1,
    'fill': 1,
    'fill-opacity': 1,
    'fill-rule': 1,
    'filter': 1,
    'flood-color': 1,
    'flood-opacity': 1,
    'font': 1,
    'font-family': 1,
    'font-size': LENGTH_ATTR,
    'font-size-adjust': 1,
    'font-stretch': 1,
    'font-style': 1,
    'font-variant': 1,
    'font-weight': 1,
    'glyph-orientation-horizontal': 1,
    'glyph-orientation-vertical': 1,
    'image-rendering': 1,
    'kerning': 1,
    'letter-spacing': 1,
    'lighting-color': 1,
    'marker': 1,
    'marker-end': 1,
    'marker-mid': 1,
    'marker-start': 1,
    'mask': 1,
    'opacity': 1,
    'overflow': 1,
    'pointer-events': 1,
    'shape-rendering': 1,
    'stop-color': 1,
    'stop-opacity': 1,
    'stroke': 1,
    'stroke-dasharray': 1,
    'stroke-dashoffset': 1,
    'stroke-linecap': 1,
    'stroke-linejoin': 1,
    'stroke-miterlimit': 1,
    'stroke-opacity': 1,
    'stroke-width': LENGTH_ATTR,
    'text-anchor': 1,
    'text-decoration': 1,
    'text-rendering': 1,
    'unicode-bidi': 1,
    'visibility': 1,
    'word-spacing': 1,
    'writing-mode': 1
  };
  function getAttribute(node, name) {
    if (CSS_PROPERTIES[name]) {
      return node.style[name];
    } else {
      return node.getAttributeNS(null, name);
    }
  }
  function setAttribute(node, name, value) {
    var hyphenated = name.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
    var type = CSS_PROPERTIES[hyphenated];
    if (type) {
      if (type === LENGTH_ATTR && typeof value === 'number') {
        value = String(value) + 'px';
      }
      node.style[hyphenated] = value;
    } else {
      node.setAttributeNS(null, name, value);
    }
  }
  function setAttributes(node, attrs) {
    var names = Object.keys(attrs),
      i,
      name;
    for (i = 0, name; name = names[i]; i++) {
      setAttribute(node, name, attrs[name]);
    }
  }
  function attr(node, name, value) {
    if (typeof name === 'string') {
      if (value !== undefined) {
        setAttribute(node, name, value);
      } else {
        return getAttribute(node, name);
      }
    } else {
      setAttributes(node, name);
    }
    return node;
  }
  var toString = Object.prototype.toString;
  function classes(el) {
    return new ClassList(el);
  }
  function ClassList(el) {
    if (!el || !el.nodeType) {
      throw new Error('A DOM element reference is required');
    }
    this.el = el;
    this.list = el.classList;
  }
  ClassList.prototype.add = function (name) {
    this.list.add(name);
    return this;
  };
  ClassList.prototype.remove = function (name) {
    if ('[object RegExp]' == toString.call(name)) {
      return this.removeMatching(name);
    }
    this.list.remove(name);
    return this;
  };
  ClassList.prototype.removeMatching = function (re) {
    var arr = this.array();
    for (var _i2 = 0; _i2 < arr.length; _i2++) {
      if (re.test(arr[_i2])) {
        this.remove(arr[_i2]);
      }
    }
    return this;
  };
  ClassList.prototype.toggle = function (name, force) {
    if ('undefined' !== typeof force) {
      if (force !== this.list.toggle(name, force)) {
        this.list.toggle(name);
      }
    } else {
      this.list.toggle(name);
    }
    return this;
  };
  ClassList.prototype.array = function () {
    return Array.from(this.list);
  };
  ClassList.prototype.has = ClassList.prototype.contains = function (name) {
    return this.list.contains(name);
  };
  function clear(element) {
    var child;
    while (child = element.firstChild) {
      element.removeChild(child);
    }
    return element;
  }
  function clone$1(element) {
    return element.cloneNode(true);
  }
  var ns = {
    svg: 'http://www.w3.org/2000/svg'
  };
  var SVG_START = '<svg xmlns="' + ns.svg + '"';
  function parse(svg) {
    var unwrap = false;
    if (svg.substring(0, 4) === '<svg') {
      if (svg.indexOf(ns.svg) === -1) {
        svg = SVG_START + svg.substring(4);
      }
    } else {
      svg = SVG_START + '>' + svg + '</svg>';
      unwrap = true;
    }
    var parsed = parseDocument(svg);
    if (!unwrap) {
      return parsed;
    }
    var fragment = document.createDocumentFragment();
    var parent = parsed.firstChild;
    while (parent.firstChild) {
      fragment.appendChild(parent.firstChild);
    }
    return fragment;
  }
  function parseDocument(svg) {
    var parser;
    parser = new DOMParser();
    parser.async = false;
    return parser.parseFromString(svg, 'text/xml');
  }
  function create$1(name, attrs) {
    var element;
    name = name.trim();
    if (name.charAt(0) === '<') {
      element = parse(name).firstChild;
      element = document.importNode(element, true);
    } else {
      element = document.createElementNS(ns.svg, name);
    }
    if (attrs) {
      attr(element, attrs);
    }
    return element;
  }
  var node = null;
  function getNode() {
    if (node === null) {
      node = create$1('svg');
    }
    return node;
  }
  function extend$1(object, props) {
    var i,
      k,
      keys = Object.keys(props);
    for (i = 0; k = keys[i]; i++) {
      object[k] = props[k];
    }
    return object;
  }
  function createMatrix(a, b, c, d, e, f) {
    var matrix = getNode().createSVGMatrix();
    switch (arguments.length) {
      case 0:
        return matrix;
      case 1:
        return extend$1(matrix, a);
      case 6:
        return extend$1(matrix, {
          a: a,
          b: b,
          c: c,
          d: d,
          e: e,
          f: f
        });
    }
  }
  function createTransform(matrix) {
    {
      return getNode().createSVGTransform();
    }
  }
  var TEXT_ENTITIES = /([&<>]{1})/g;
  var ATTR_ENTITIES = /([\n\r"]{1})/g;
  var ENTITY_REPLACEMENT = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '\''
  };
  function escape$1(str, pattern) {
    function replaceFn(match, entity) {
      return ENTITY_REPLACEMENT[entity] || entity;
    }
    return str.replace(pattern, replaceFn);
  }
  function serialize(node, output) {
    var i, len, attrMap, attrNode, childNodes;
    switch (node.nodeType) {
      case 3:
        output.push(escape$1(node.textContent, TEXT_ENTITIES));
        break;
      case 1:
        output.push('<', node.tagName);
        if (node.hasAttributes()) {
          attrMap = node.attributes;
          for (i = 0, len = attrMap.length; i < len; ++i) {
            attrNode = attrMap.item(i);
            output.push(' ', attrNode.name, '="', escape$1(attrNode.value, ATTR_ENTITIES), '"');
          }
        }
        if (node.hasChildNodes()) {
          output.push('>');
          childNodes = node.childNodes;
          for (i = 0, len = childNodes.length; i < len; ++i) {
            serialize(childNodes.item(i), output);
          }
          output.push('</', node.tagName, '>');
        } else {
          output.push('/>');
        }
        break;
      case 8:
        output.push('<!--', escape$1(node.nodeValue, TEXT_ENTITIES), '-->');
        break;
      case 4:
        output.push('<![CDATA[', node.nodeValue, ']]>');
        break;
      default:
        throw new Error('unable to handle node ' + node.nodeType);
    }
    return output;
  }
  function get(element) {
    var child = element.firstChild,
      output = [];
    while (child) {
      serialize(child, output);
      child = child.nextSibling;
    }
    return output.join('');
  }
  function innerSVG(element, svg) {
    {
      return get(element);
    }
  }
  function remove$1(element) {
    var parent = element.parentNode;
    if (parent) {
      parent.removeChild(element);
    }
    return element;
  }
  function wrapMatrix(transformList, transform) {
    if (transform instanceof SVGMatrix) {
      return transformList.createSVGTransformFromMatrix(transform);
    }
    return transform;
  }
  function setTransforms(transformList, transforms) {
    var i, t;
    transformList.clear();
    for (i = 0; t = transforms[i]; i++) {
      transformList.appendItem(wrapMatrix(transformList, t));
    }
  }
  function transform$1(node, transforms) {
    var transformList = node.transform.baseVal;
    if (transforms) {
      if (!Array.isArray(transforms)) {
        transforms = [transforms];
      }
      setTransforms(transformList, transforms);
    }
    return transformList.consolidate();
  }
  var CLASS_PATTERN = /^class[ {]/;
  function isClass(fn) {
    return CLASS_PATTERN.test(fn.toString());
  }
  function isArray$1(obj) {
    return Array.isArray(obj);
  }
  function hasOwnProp(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }
  function annotate() {
    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }
    if (args.length === 1 && isArray$1(args[0])) {
      args = args[0];
    }
    args = _toConsumableArray(args);
    var fn = args.pop();
    fn.$inject = args;
    return fn;
  }
  var CONSTRUCTOR_ARGS = /constructor\s*[^(]*\(\s*([^)]*)\)/m;
  var FN_ARGS = /^(?:async\s+)?(?:function\s*[^(]*)?(?:\(\s*([^)]*)\)|(\w+))/m;
  var FN_ARG = /\/\*([^*]*)\*\//m;
  function parseAnnotations(fn) {
    if (typeof fn !== 'function') {
      throw new Error(`Cannot annotate "${fn}". Expected a function!`);
    }
    var match = fn.toString().match(isClass(fn) ? CONSTRUCTOR_ARGS : FN_ARGS);
    if (!match) {
      return [];
    }
    var args = match[1] || match[2];
    return args && args.split(',').map(function (arg) {
      var argMatch = arg.match(FN_ARG);
      return (argMatch && argMatch[1] || arg).trim();
    }) || [];
  }
  function Injector(modules, _parent) {
    var parent = _parent || ({
      get: function get(name, strict) {
        currentlyResolving.push(name);
        if (strict === false) {
          return null;
        } else {
          throw error(`No provider for "${name}"!`);
        }
      }
    });
    var currentlyResolving = [];
    var providers = this._providers = Object.create(parent._providers || null);
    var instances = this._instances = Object.create(null);
    var self = instances.injector = this;
    var error = function error(msg) {
      var stack = currentlyResolving.join(' -> ');
      currentlyResolving.length = 0;
      return new Error(stack ? `${msg} (Resolving: ${stack})` : msg);
    };
    function get(name, strict) {
      if (!providers[name] && name.includes('.')) {
        var parts = name.split('.');
        var pivot = get(parts.shift());
        while (parts.length) {
          pivot = pivot[(parts.shift())];
        }
        return pivot;
      }
      if (hasOwnProp(instances, name)) {
        return instances[name];
      }
      if (hasOwnProp(providers, name)) {
        if (currentlyResolving.indexOf(name) !== -1) {
          currentlyResolving.push(name);
          throw error('Cannot resolve circular dependency!');
        }
        currentlyResolving.push(name);
        instances[name] = providers[name][0](providers[name][1]);
        currentlyResolving.pop();
        return instances[name];
      }
      return parent.get(name, strict);
    }
    function fnDef(fn, locals) {
      if (typeof locals === 'undefined') {
        locals = {};
      }
      if (typeof fn !== 'function') {
        if (isArray$1(fn)) {
          fn = annotate(fn.slice());
        } else {
          throw error(`Cannot invoke "${fn}". Expected a function!`);
        }
      }
      var inject = fn.$inject || parseAnnotations(fn);
      var dependencies = inject.map(function (dep) {
        if (hasOwnProp(locals, dep)) {
          return locals[dep];
        } else {
          return get(dep);
        }
      });
      return {
        fn: fn,
        dependencies
      };
    }
    function instantiate(type) {
      var _Function$prototype$b;
      var _fnDef = fnDef(type),
        fn = _fnDef.fn,
        dependencies = _fnDef.dependencies;
      var Constructor = (_Function$prototype$b = Function.prototype.bind).call.apply(_Function$prototype$b, [fn, null].concat(_toConsumableArray(dependencies)));
      return new Constructor();
    }
    function invoke(func, context, locals) {
      var _fnDef2 = fnDef(func, locals),
        fn = _fnDef2.fn,
        dependencies = _fnDef2.dependencies;
      return fn.apply(context, dependencies);
    }
    function createPrivateInjectorFactory(childInjector) {
      return annotate(function (key) {
        return childInjector.get(key);
      });
    }
    function createChild(modules, forceNewInstances) {
      if (forceNewInstances && forceNewInstances.length) {
        var fromParentModule = Object.create(null);
        var matchedScopes = Object.create(null);
        var privateInjectorsCache = [];
        var privateChildInjectors = [];
        var privateChildFactories = [];
        var provider;
        var cacheIdx;
        var privateChildInjector;
        var privateChildInjectorFactory;
        var _loop = function _loop(_name) {
          provider = providers[_name];
          if (forceNewInstances.indexOf(_name) !== -1) {
            if (provider[2] === 'private') {
              cacheIdx = privateInjectorsCache.indexOf(provider[3]);
              if (cacheIdx === -1) {
                privateChildInjector = provider[3].createChild([], forceNewInstances);
                privateChildInjectorFactory = createPrivateInjectorFactory(privateChildInjector);
                privateInjectorsCache.push(provider[3]);
                privateChildInjectors.push(privateChildInjector);
                privateChildFactories.push(privateChildInjectorFactory);
                fromParentModule[_name] = [privateChildInjectorFactory, _name, 'private', privateChildInjector];
              } else {
                fromParentModule[_name] = [privateChildFactories[cacheIdx], _name, 'private', privateChildInjectors[cacheIdx]];
              }
            } else {
              fromParentModule[_name] = [provider[2], provider[1]];
            }
            matchedScopes[_name] = true;
          }
          if ((provider[2] === 'factory' || provider[2] === 'type') && provider[1].$scope) {
            forceNewInstances.forEach(function (scope) {
              if (provider[1].$scope.indexOf(scope) !== -1) {
                fromParentModule[_name] = [provider[2], provider[1]];
                matchedScopes[scope] = true;
              }
            });
          }
        };
        for (var _name in providers) {
          _loop(_name);
        }
        forceNewInstances.forEach(function (scope) {
          if (!matchedScopes[scope]) {
            throw new Error('No provider for "' + scope + '". Cannot use provider from the parent!');
          }
        });
        modules.unshift(fromParentModule);
      }
      return new Injector(modules, self);
    }
    var factoryMap = {
      factory: invoke,
      type: instantiate,
      value: function value(_value2) {
        return _value2;
      }
    };
    function createInitializer(moduleDefinition, injector) {
      var initializers = moduleDefinition.__init__ || [];
      return function () {
        initializers.forEach(function (initializer) {
          if (typeof initializer === 'string') {
            injector.get(initializer);
          } else {
            injector.invoke(initializer);
          }
        });
      };
    }
    function loadModule(moduleDefinition) {
      var moduleExports = moduleDefinition.__exports__;
      if (moduleExports) {
        var nestedModules = moduleDefinition.__modules__;
        var clonedModule = Object.keys(moduleDefinition).reduce(function (clonedModule, key) {
          if (key !== '__exports__' && key !== '__modules__' && key !== '__init__' && key !== '__depends__') {
            clonedModule[key] = moduleDefinition[key];
          }
          return clonedModule;
        }, Object.create(null));
        var childModules = (nestedModules || []).concat(clonedModule);
        var privateInjector = createChild(childModules);
        var getFromPrivateInjector = annotate(function (key) {
          return privateInjector.get(key);
        });
        moduleExports.forEach(function (key) {
          providers[key] = [getFromPrivateInjector, key, 'private', privateInjector];
        });
        var initializers = (moduleDefinition.__init__ || []).slice();
        initializers.unshift(function () {
          privateInjector.init();
        });
        moduleDefinition = Object.assign({}, moduleDefinition, {
          __init__: initializers
        });
        return createInitializer(moduleDefinition, privateInjector);
      }
      Object.keys(moduleDefinition).forEach(function (key) {
        if (key === '__init__' || key === '__depends__') {
          return;
        }
        var typeDeclaration = moduleDefinition[key];
        if (typeDeclaration[2] === 'private') {
          providers[key] = typeDeclaration;
          return;
        }
        var type = typeDeclaration[0];
        var value = typeDeclaration[1];
        providers[key] = [factoryMap[type], arrayUnwrap(type, value), type];
      });
      return createInitializer(moduleDefinition, self);
    }
    function resolveDependencies(moduleDefinitions, moduleDefinition) {
      if (moduleDefinitions.indexOf(moduleDefinition) !== -1) {
        return moduleDefinitions;
      }
      moduleDefinitions = (moduleDefinition.__depends__ || []).reduce(resolveDependencies, moduleDefinitions);
      if (moduleDefinitions.indexOf(moduleDefinition) !== -1) {
        return moduleDefinitions;
      }
      return moduleDefinitions.concat(moduleDefinition);
    }
    function bootstrap(moduleDefinitions) {
      var initializers = moduleDefinitions.reduce(resolveDependencies, []).map(loadModule);
      var initialized = false;
      return function () {
        if (initialized) {
          return;
        }
        initialized = true;
        initializers.forEach(function (initializer) {
          return initializer();
        });
      };
    }
    this.get = get;
    this.invoke = invoke;
    this.instantiate = instantiate;
    this.createChild = createChild;
    this.init = bootstrap(modules);
  }
  function arrayUnwrap(type, value) {
    if (type !== 'value' && isArray$1(value)) {
      value = annotate(value.slice());
    }
    return value;
  }
  var DEFAULT_RENDER_PRIORITY$1 = 1000;
  function BaseRenderer(eventBus, renderPriority) {
    var self = this;
    renderPriority = renderPriority || DEFAULT_RENDER_PRIORITY$1;
    eventBus.on(['render.shape', 'render.connection'], renderPriority, function (evt, context) {
      var type = evt.type,
        element = context.element,
        visuals = context.gfx,
        attrs = context.attrs;
      if (self.canRender(element)) {
        if (type === 'render.shape') {
          return self.drawShape(visuals, element, attrs);
        } else {
          return self.drawConnection(visuals, element, attrs);
        }
      }
    });
    eventBus.on(['render.getShapePath', 'render.getConnectionPath'], renderPriority, function (evt, element) {
      if (self.canRender(element)) {
        if (evt.type === 'render.getShapePath') {
          return self.getShapePath(element);
        } else {
          return self.getConnectionPath(element);
        }
      }
    });
  }
  BaseRenderer.prototype.canRender = function (element) {};
  BaseRenderer.prototype.drawShape = function (visuals, shape) {};
  BaseRenderer.prototype.drawConnection = function (visuals, connection) {};
  BaseRenderer.prototype.getShapePath = function (shape) {};
  BaseRenderer.prototype.getConnectionPath = function (connection) {};
  function componentsToPath(elements) {
    return elements.flat().join(',').replace(/,?([A-Za-z]),?/g, '$1');
  }
  function move(point) {
    return ['M', point.x, point.y];
  }
  function lineTo(point) {
    return ['L', point.x, point.y];
  }
  function curveTo(p1, p2, p3) {
    return ['C', p1.x, p1.y, p2.x, p2.y, p3.x, p3.y];
  }
  function drawPath(waypoints, cornerRadius) {
    var pointCount = waypoints.length;
    var path = [move(waypoints[0])];
    for (var _i3 = 1; _i3 < pointCount; _i3++) {
      var pointBefore = waypoints[_i3 - 1];
      var point = waypoints[_i3];
      var pointAfter = waypoints[_i3 + 1];
      if (!pointAfter || !cornerRadius) {
        path.push(lineTo(point));
        continue;
      }
      var effectiveRadius = Math.min(cornerRadius, vectorLength$1(point.x - pointBefore.x, point.y - pointBefore.y), vectorLength$1(pointAfter.x - point.x, pointAfter.y - point.y));
      if (!effectiveRadius) {
        path.push(lineTo(point));
        continue;
      }
      var beforePoint = getPointAtLength(point, pointBefore, effectiveRadius);
      var beforePoint2 = getPointAtLength(point, pointBefore, effectiveRadius * .5);
      var afterPoint = getPointAtLength(point, pointAfter, effectiveRadius);
      var afterPoint2 = getPointAtLength(point, pointAfter, effectiveRadius * .5);
      path.push(lineTo(beforePoint));
      path.push(curveTo(beforePoint2, afterPoint2, afterPoint));
    }
    return path;
  }
  function getPointAtLength(start, end, length) {
    var deltaX = end.x - start.x;
    var deltaY = end.y - start.y;
    var totalLength = vectorLength$1(deltaX, deltaY);
    var percent = length / totalLength;
    return {
      x: start.x + deltaX * percent,
      y: start.y + deltaY * percent
    };
  }
  function vectorLength$1(x, y) {
    return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
  }
  function createLine(points, attrs, radius) {
    if (isNumber(attrs)) {
      radius = attrs;
      attrs = null;
    }
    if (!attrs) {
      attrs = {};
    }
    var line = create$1('path', attrs);
    if (isNumber(radius)) {
      line.dataset.cornerRadius = String(radius);
    }
    return updateLine(line, points);
  }
  function updateLine(gfx, points) {
    var cornerRadius = parseInt(gfx.dataset.cornerRadius, 10) || 0;
    attr(gfx, {
      d: componentsToPath(drawPath(points, cornerRadius))
    });
    return gfx;
  }
  function getParents$1(elements) {
    return filter(elements, function (element) {
      return !find(elements, function (e) {
        return e !== element && getParent$1(element, e);
      });
    });
  }
  function getParent$1(element, parent) {
    if (!parent) {
      return;
    }
    if (element === parent) {
      return parent;
    }
    if (!element.parent) {
      return;
    }
    return getParent$1(element.parent, parent);
  }
  function add$1(elements, element, unique) {
    var canAdd = !unique || elements.indexOf(element) === -1;
    if (canAdd) {
      elements.push(element);
    }
    return canAdd;
  }
  function eachElement(elements, fn, depth) {
    depth = depth || 0;
    if (!isArray$3(elements)) {
      elements = [elements];
    }
    forEach$1(elements, function (s, i) {
      var filter = fn(s, i, depth);
      if (isArray$3(filter) && filter.length) {
        eachElement(filter, fn, depth + 1);
      }
    });
  }
  function selfAndChildren(elements, unique, maxDepth) {
    var result = [],
      processedChildren = [];
    eachElement(elements, function (element, i, depth) {
      add$1(result, element, unique);
      var children = element.children;
      {
        if (children && add$1(processedChildren, children, unique)) {
          return children;
        }
      }
    });
    return result;
  }
  function selfAndAllChildren(elements, allowDuplicates) {
    return selfAndChildren(elements, !allowDuplicates);
  }
  function getClosure(elements, isTopLevel, closure) {
    if (isUndefined$2(isTopLevel)) {
      isTopLevel = true;
    }
    if (isObject(isTopLevel)) {
      closure = isTopLevel;
      isTopLevel = true;
    }
    closure = closure || {};
    var allShapes = copyObject(closure.allShapes),
      allConnections = copyObject(closure.allConnections),
      enclosedElements = copyObject(closure.enclosedElements),
      enclosedConnections = copyObject(closure.enclosedConnections);
    var topLevel = copyObject(closure.topLevel, isTopLevel && groupBy(elements, function (e) {
      return e.id;
    }));
    function handleConnection(c) {
      if (topLevel[c.source.id] && topLevel[c.target.id]) {
        topLevel[c.id] = [c];
      }
      if (allShapes[c.source.id] && allShapes[c.target.id]) {
        enclosedConnections[c.id] = enclosedElements[c.id] = c;
      }
      allConnections[c.id] = c;
    }
    function handleElement(element) {
      enclosedElements[element.id] = element;
      if (element.waypoints) {
        enclosedConnections[element.id] = allConnections[element.id] = element;
      } else {
        allShapes[element.id] = element;
        forEach$1(element.incoming, handleConnection);
        forEach$1(element.outgoing, handleConnection);
        return element.children;
      }
    }
    eachElement(elements, handleElement);
    return {
      allShapes: allShapes,
      allConnections: allConnections,
      topLevel: topLevel,
      enclosedConnections: enclosedConnections,
      enclosedElements: enclosedElements
    };
  }
  function getBBox(elements, stopRecursion) {
    stopRecursion = !!stopRecursion;
    if (!isArray$3(elements)) {
      elements = [elements];
    }
    var minX, minY, maxX, maxY;
    forEach$1(elements, function (element) {
      var bbox = element;
      if (element.waypoints && !stopRecursion) {
        bbox = getBBox(element.waypoints, true);
      }
      var x = bbox.x,
        y = bbox.y,
        height = bbox.height || 0,
        width = bbox.width || 0;
      if (x < minX || minX === undefined) {
        minX = x;
      }
      if (y < minY || minY === undefined) {
        minY = y;
      }
      if (x + width > maxX || maxX === undefined) {
        maxX = x + width;
      }
      if (y + height > maxY || maxY === undefined) {
        maxY = y + height;
      }
    });
    return {
      x: minX,
      y: minY,
      height: maxY - minY,
      width: maxX - minX
    };
  }
  function getEnclosedElements(elements, bbox) {
    var filteredElements = {};
    forEach$1(elements, function (element) {
      var e = element;
      if (e.waypoints) {
        e = getBBox(e);
      }
      if (!isNumber(bbox.y) && e.x > bbox.x) {
        filteredElements[element.id] = element;
      }
      if (!isNumber(bbox.x) && e.y > bbox.y) {
        filteredElements[element.id] = element;
      }
      if (e.x > bbox.x && e.y > bbox.y) {
        if (isNumber(bbox.width) && isNumber(bbox.height) && e.width + e.x < bbox.width + bbox.x && e.height + e.y < bbox.height + bbox.y) {
          filteredElements[element.id] = element;
        } else if (!isNumber(bbox.width) || !isNumber(bbox.height)) {
          filteredElements[element.id] = element;
        }
      }
    });
    return filteredElements;
  }
  function getType(element) {
    if ('waypoints' in element) {
      return 'connection';
    }
    if ('x' in element) {
      return 'shape';
    }
    return 'root';
  }
  function isFrameElement$1(element) {
    return !!(element && element.isFrame);
  }
  function copyObject(src1, src2) {
    return assign$1({}, src1 || {}, src2 || {});
  }
  var DEFAULT_RENDER_PRIORITY = 1;
  function DefaultRenderer(eventBus, styles) {
    BaseRenderer.call(this, eventBus, DEFAULT_RENDER_PRIORITY);
    this.CONNECTION_STYLE = styles.style(['no-fill'], {
      strokeWidth: 5,
      stroke: 'fuchsia'
    });
    this.SHAPE_STYLE = styles.style({
      fill: 'white',
      stroke: 'fuchsia',
      strokeWidth: 2
    });
    this.FRAME_STYLE = styles.style(['no-fill'], {
      stroke: 'fuchsia',
      strokeDasharray: 4,
      strokeWidth: 2
    });
  }
  e$2(DefaultRenderer, BaseRenderer);
  DefaultRenderer.prototype.canRender = function () {
    return true;
  };
  DefaultRenderer.prototype.drawShape = function drawShape(visuals, element, attrs) {
    var rect = create$1('rect');
    attr(rect, {
      x: 0,
      y: 0,
      width: element.width || 0,
      height: element.height || 0
    });
    if (isFrameElement$1(element)) {
      attr(rect, assign$1({}, this.FRAME_STYLE, attrs || {}));
    } else {
      attr(rect, assign$1({}, this.SHAPE_STYLE, attrs || {}));
    }
    append(visuals, rect);
    return rect;
  };
  DefaultRenderer.prototype.drawConnection = function drawConnection(visuals, connection, attrs) {
    var line = createLine(connection.waypoints, assign$1({}, this.CONNECTION_STYLE, attrs || {}));
    append(visuals, line);
    return line;
  };
  DefaultRenderer.prototype.getShapePath = function getShapePath(shape) {
    var x = shape.x,
      y = shape.y,
      width = shape.width,
      height = shape.height;
    var shapePath = [['M', x, y], ['l', width, 0], ['l', 0, height], ['l', -width, 0], ['z']];
    return componentsToPath(shapePath);
  };
  DefaultRenderer.prototype.getConnectionPath = function getConnectionPath(connection) {
    var waypoints = connection.waypoints;
    var idx,
      point,
      connectionPath = [];
    for (idx = 0; point = waypoints[idx]; idx++) {
      point = point.original || point;
      connectionPath.push([idx === 0 ? 'M' : 'L', point.x, point.y]);
    }
    return componentsToPath(connectionPath);
  };
  DefaultRenderer.$inject = ['eventBus', 'styles'];
  function Styles() {
    var defaultTraits = {
      'no-fill': {
        fill: 'none'
      },
      'no-border': {
        strokeOpacity: 0.0
      },
      'no-events': {
        pointerEvents: 'none'
      }
    };
    var self = this;
    this.cls = function (className, traits, additionalAttrs) {
      var attrs = this.style(traits, additionalAttrs);
      return assign$1(attrs, {
        'class': className
      });
    };
    this.style = function (traits, additionalAttrs) {
      if (!isArray$3(traits) && !additionalAttrs) {
        additionalAttrs = traits;
        traits = [];
      }
      var attrs = reduce(traits, function (attrs, t) {
        return assign$1(attrs, defaultTraits[t] || {});
      }, {});
      return additionalAttrs ? assign$1(attrs, additionalAttrs) : attrs;
    };
    this.computeStyle = function (custom, traits, defaultStyles) {
      if (!isArray$3(traits)) {
        defaultStyles = traits;
        traits = [];
      }
      return self.style(traits || [], assign$1({}, defaultStyles, custom || {}));
    };
  }
  var DrawModule$1 = {
    __init__: ['defaultRenderer'],
    defaultRenderer: ['type', DefaultRenderer],
    styles: ['type', Styles]
  };
  function remove(collection, element) {
    if (!collection || !element) {
      return -1;
    }
    var idx = collection.indexOf(element);
    if (idx !== -1) {
      collection.splice(idx, 1);
    }
    return idx;
  }
  function add(collection, element, idx) {
    if (!collection || !element) {
      return;
    }
    if (typeof idx !== 'number') {
      idx = -1;
    }
    var currentIdx = collection.indexOf(element);
    if (currentIdx !== -1) {
      if (currentIdx === idx) {
        return;
      } else {
        if (idx !== -1) {
          collection.splice(currentIdx, 1);
        } else {
          return;
        }
      }
    }
    if (idx !== -1) {
      collection.splice(idx, 0, element);
    } else {
      collection.push(element);
    }
  }
  function indexOf(collection, element) {
    if (!collection || !element) {
      return -1;
    }
    return collection.indexOf(element);
  }
  function pointDistance(a, b) {
    if (!a || !b) {
      return -1;
    }
    return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
  }
  function pointsOnLine(p, q, r, accuracy) {
    if (typeof accuracy === 'undefined') {
      accuracy = 5;
    }
    if (!p || !q || !r) {
      return false;
    }
    var val = (q.x - p.x) * (r.y - p.y) - (q.y - p.y) * (r.x - p.x),
      dist = pointDistance(p, q);
    return Math.abs(val / dist) <= accuracy;
  }
  var ALIGNED_THRESHOLD = 2;
  function pointsAligned(a, b) {
    var points = Array.from(arguments).flat();
    var axisMap = {
      'x': 'v',
      'y': 'h'
    };
    for (var _i4 = 0, _Object$entries = Object.entries(axisMap); _i4 < _Object$entries.length; _i4++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i4], 2),
        axis = _Object$entries$_i[0],
        orientation = _Object$entries$_i[1];
      if (pointsAlignedOnAxis(axis, points)) {
        return orientation;
      }
    }
    return false;
  }
  function pointsAlignedOnAxis(axis, points) {
    var referencePoint = points[0];
    return every(points, function (point) {
      return Math.abs(referencePoint[axis] - point[axis]) <= ALIGNED_THRESHOLD;
    });
  }
  function pointInRect(p, rect, tolerance) {
    tolerance = tolerance || 0;
    return p.x > rect.x - tolerance && p.y > rect.y - tolerance && p.x < rect.x + rect.width + tolerance && p.y < rect.y + rect.height + tolerance;
  }
  function getMidPoint(p, q) {
    return {
      x: Math.round(p.x + (q.x - p.x) / 2.0),
      y: Math.round(p.y + (q.y - p.y) / 2.0)
    };
  }
  var p2s = /,?([a-z]),?/gi,
    toFloat = parseFloat,
    math = Math,
    PI = math.PI,
    mmin = math.min,
    mmax = math.max,
    pow = math.pow,
    abs$7 = math.abs,
    pathCommand = /([a-z])[\s,]*((-?\d*\.?\d*(?:e[-+]?\d+)?[\s]*,?[\s]*)+)/ig,
    pathValues = /(-?\d*\.?\d*(?:e[-+]?\d+)?)[\s]*,?[\s]*/ig;
  var isArray = Array.isArray || function (o) {
    return o instanceof Array;
  };
  function hasProperty(obj, property) {
    return Object.prototype.hasOwnProperty.call(obj, property);
  }
  function clone(obj) {
    if (typeof obj == 'function' || Object(obj) !== obj) {
      return obj;
    }
    var res = new obj.constructor();
    for (var key in obj) {
      if (hasProperty(obj, key)) {
        res[key] = clone(obj[key]);
      }
    }
    return res;
  }
  function repush(array, item) {
    for (var i = 0, ii = array.length; i < ii; i++) if (array[i] === item) {
      return array.push(array.splice(i, 1)[0]);
    }
  }
  function cacher(f) {
    function newf() {
      var arg = Array.prototype.slice.call(arguments, 0),
        args = arg.join('\u2400'),
        cache = newf.cache = newf.cache || {},
        count = newf.count = newf.count || [];
      if (hasProperty(cache, args)) {
        repush(count, args);
        return cache[args];
      }
      count.length >= 1e3 && delete cache[count.shift()];
      count.push(args);
      cache[args] = f.apply(void 0, arguments);
      return cache[args];
    }
    return newf;
  }
  function parsePathString(pathString) {
    if (!pathString) {
      return null;
    }
    var pth = paths(pathString);
    if (pth.arr) {
      return clone(pth.arr);
    }
    var paramCounts = {
        a: 7,
        c: 6,
        h: 1,
        l: 2,
        m: 2,
        q: 4,
        s: 4,
        t: 2,
        v: 1,
        z: 0
      },
      data = [];
    if (isArray(pathString) && isArray(pathString[0])) {
      data = clone(pathString);
    }
    if (!data.length) {
      String(pathString).replace(pathCommand, function (a, b, c) {
        var params = [],
          name = b.toLowerCase();
        c.replace(pathValues, function (a, b) {
          b && params.push(+b);
        });
        if (name == 'm' && params.length > 2) {
          data.push([b].concat(_toConsumableArray(params.splice(0, 2))));
          name = 'l';
          b = b == 'm' ? 'l' : 'L';
        }
        while (params.length >= paramCounts[name]) {
          data.push([b].concat(_toConsumableArray(params.splice(0, paramCounts[name]))));
          if (!paramCounts[name]) {
            break;
          }
        }
      });
    }
    data.toString = paths.toString;
    pth.arr = clone(data);
    return data;
  }
  function paths(ps) {
    var p = paths.ps = paths.ps || {};
    if (p[ps]) {
      p[ps].sleep = 100;
    } else {
      p[ps] = {
        sleep: 100
      };
    }
    setTimeout(function () {
      for (var key in p) {
        if (hasProperty(p, key) && key != ps) {
          p[key].sleep--;
          !p[key].sleep && delete p[key];
        }
      }
    });
    return p[ps];
  }
  function rectBBox(x, y, width, height) {
    if (arguments.length === 1) {
      y = x.y;
      width = x.width;
      height = x.height;
      x = x.x;
    }
    return {
      x: x,
      y: y,
      width: width,
      height: height,
      x2: x + width,
      y2: y + height
    };
  }
  function pathToString() {
    return this.join(',').replace(p2s, '$1');
  }
  function pathClone(pathArray) {
    var res = clone(pathArray);
    res.toString = pathToString;
    return res;
  }
  function findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
    var t1 = 1 - t,
      t13 = pow(t1, 3),
      t12 = pow(t1, 2),
      t2 = t * t,
      t3 = t2 * t,
      x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,
      y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y;
    return {
      x: fixError(x),
      y: fixError(y)
    };
  }
  function bezierBBox(points) {
    var bbox = curveBBox.apply(void 0, _toConsumableArray(points));
    return rectBBox(bbox.x0, bbox.y0, bbox.x1 - bbox.x0, bbox.y1 - bbox.y0);
  }
  function isPointInsideBBox$2(bbox, x, y) {
    return x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;
  }
  function isBBoxIntersect(bbox1, bbox2) {
    bbox1 = rectBBox(bbox1);
    bbox2 = rectBBox(bbox2);
    return isPointInsideBBox$2(bbox2, bbox1.x, bbox1.y) || isPointInsideBBox$2(bbox2, bbox1.x2, bbox1.y) || isPointInsideBBox$2(bbox2, bbox1.x, bbox1.y2) || isPointInsideBBox$2(bbox2, bbox1.x2, bbox1.y2) || isPointInsideBBox$2(bbox1, bbox2.x, bbox2.y) || isPointInsideBBox$2(bbox1, bbox2.x2, bbox2.y) || isPointInsideBBox$2(bbox1, bbox2.x, bbox2.y2) || isPointInsideBBox$2(bbox1, bbox2.x2, bbox2.y2) || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x) && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
  }
  function base3(t, p1, p2, p3, p4) {
    var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,
      t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
    return t * t2 - 3 * p1 + 3 * p2;
  }
  function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {
    if (z == null) {
      z = 1;
    }
    z = z > 1 ? 1 : z < 0 ? 0 : z;
    var z2 = z / 2,
      n = 12,
      Tvalues = [-0.1252, .1252, -0.3678, .3678, -0.5873, .5873, -0.7699, .7699, -0.9041, .9041, -0.9816, .9816],
      Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472],
      sum = 0;
    for (var i = 0; i < n; i++) {
      var ct = z2 * Tvalues[i] + z2,
        xbase = base3(ct, x1, x2, x3, x4),
        ybase = base3(ct, y1, y2, y3, y4),
        comb = xbase * xbase + ybase * ybase;
      sum += Cvalues[i] * math.sqrt(comb);
    }
    return z2 * sum;
  }
  function intersectLines(x1, y1, x2, y2, x3, y3, x4, y4) {
    if (mmax(x1, x2) < mmin(x3, x4) || mmin(x1, x2) > mmax(x3, x4) || mmax(y1, y2) < mmin(y3, y4) || mmin(y1, y2) > mmax(y3, y4)) {
      return;
    }
    var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),
      ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),
      denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
    if (!denominator) {
      return;
    }
    var px = fixError(nx / denominator),
      py = fixError(ny / denominator),
      px2 = +px.toFixed(2),
      py2 = +py.toFixed(2);
    if (px2 < +mmin(x1, x2).toFixed(2) || px2 > +mmax(x1, x2).toFixed(2) || px2 < +mmin(x3, x4).toFixed(2) || px2 > +mmax(x3, x4).toFixed(2) || py2 < +mmin(y1, y2).toFixed(2) || py2 > +mmax(y1, y2).toFixed(2) || py2 < +mmin(y3, y4).toFixed(2) || py2 > +mmax(y3, y4).toFixed(2)) {
      return;
    }
    return {
      x: px,
      y: py
    };
  }
  function fixError(number) {
    return Math.round(number * 100000000000) / 100000000000;
  }
  function findBezierIntersections(bez1, bez2, justCount) {
    var bbox1 = bezierBBox(bez1),
      bbox2 = bezierBBox(bez2);
    if (!isBBoxIntersect(bbox1, bbox2)) {
      return [];
    }
    var l1 = bezlen.apply(void 0, _toConsumableArray(bez1)),
      l2 = bezlen.apply(void 0, _toConsumableArray(bez2)),
      n1 = isLine(bez1) ? 1 : ~~(l1 / 5) || 1,
      n2 = isLine(bez2) ? 1 : ~~(l2 / 5) || 1,
      dots1 = [],
      dots2 = [],
      xy = {},
      res = [];
    for (var i = 0; i < n1 + 1; i++) {
      var p = findDotsAtSegment.apply(void 0, _toConsumableArray(bez1).concat([i / n1]));
      dots1.push({
        x: p.x,
        y: p.y,
        t: i / n1
      });
    }
    for (i = 0; i < n2 + 1; i++) {
      p = findDotsAtSegment.apply(void 0, _toConsumableArray(bez2).concat([i / n2]));
      dots2.push({
        x: p.x,
        y: p.y,
        t: i / n2
      });
    }
    for (i = 0; i < n1; i++) {
      for (var j = 0; j < n2; j++) {
        var di = dots1[i],
          di1 = dots1[i + 1],
          dj = dots2[j],
          dj1 = dots2[j + 1],
          ci = abs$7(di1.x - di.x) < .01 ? 'y' : 'x',
          cj = abs$7(dj1.x - dj.x) < .01 ? 'y' : 'x',
          is = intersectLines(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y),
          key;
        if (is) {
          key = is.x.toFixed(9) + '#' + is.y.toFixed(9);
          if (xy[key]) {
            continue;
          }
          xy[key] = true;
          var t1 = di.t + abs$7((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),
            t2 = dj.t + abs$7((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
          if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {
            {
              res.push({
                x: is.x,
                y: is.y,
                t1: t1,
                t2: t2
              });
            }
          }
        }
      }
    }
    return res;
  }
  function findPathIntersections(path1, path2, justCount) {
    path1 = pathToCurve(path1);
    path2 = pathToCurve(path2);
    var x1,
      y1,
      x2,
      y2,
      x1m,
      y1m,
      x2m,
      y2m,
      bez1,
      bez2,
      res = justCount ? 0 : [];
    for (var i = 0, ii = path1.length; i < ii; i++) {
      var pi = path1[i];
      if (pi[0] == 'M') {
        x1 = x1m = pi[1];
        y1 = y1m = pi[2];
      } else {
        if (pi[0] == 'C') {
          bez1 = [x1, y1].concat(_toConsumableArray(pi.slice(1)));
          x1 = bez1[6];
          y1 = bez1[7];
        } else {
          bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
          x1 = x1m;
          y1 = y1m;
        }
        for (var j = 0, jj = path2.length; j < jj; j++) {
          var pj = path2[j];
          if (pj[0] == 'M') {
            x2 = x2m = pj[1];
            y2 = y2m = pj[2];
          } else {
            if (pj[0] == 'C') {
              bez2 = [x2, y2].concat(_toConsumableArray(pj.slice(1)));
              x2 = bez2[6];
              y2 = bez2[7];
            } else {
              bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
              x2 = x2m;
              y2 = y2m;
            }
            var intr = findBezierIntersections(bez1, bez2);
            {
              for (var k = 0, kk = intr.length; k < kk; k++) {
                intr[k].segment1 = i;
                intr[k].segment2 = j;
                intr[k].bez1 = bez1;
                intr[k].bez2 = bez2;
              }
              res = res.concat(intr);
            }
          }
        }
      }
    }
    return res;
  }
  function pathToAbsolute(pathArray) {
    var pth = paths(pathArray);
    if (pth.abs) {
      return pathClone(pth.abs);
    }
    if (!isArray(pathArray) || !isArray(pathArray && pathArray[0])) {
      pathArray = parsePathString(pathArray);
    }
    if (!pathArray || !pathArray.length) {
      return [['M', 0, 0]];
    }
    var res = [],
      x = 0,
      y = 0,
      mx = 0,
      my = 0,
      start = 0,
      pa0;
    if (pathArray[0][0] == 'M') {
      x = +pathArray[0][1];
      y = +pathArray[0][2];
      mx = x;
      my = y;
      start++;
      res[0] = ['M', x, y];
    }
    for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {
      res.push(r = []);
      pa = pathArray[i];
      pa0 = pa[0];
      if (pa0 != pa0.toUpperCase()) {
        r[0] = pa0.toUpperCase();
        switch (r[0]) {
          case 'A':
            r[1] = pa[1];
            r[2] = pa[2];
            r[3] = pa[3];
            r[4] = pa[4];
            r[5] = pa[5];
            r[6] = +pa[6] + x;
            r[7] = +pa[7] + y;
            break;
          case 'V':
            r[1] = +pa[1] + y;
            break;
          case 'H':
            r[1] = +pa[1] + x;
            break;
          case 'M':
            mx = +pa[1] + x;
            my = +pa[2] + y;
          default:
            for (var j = 1, jj = pa.length; j < jj; j++) {
              r[j] = +pa[j] + (j % 2 ? x : y);
            }
        }
      } else {
        for (var k = 0, kk = pa.length; k < kk; k++) {
          r[k] = pa[k];
        }
      }
      pa0 = pa0.toUpperCase();
      switch (r[0]) {
        case 'Z':
          x = +mx;
          y = +my;
          break;
        case 'H':
          x = r[1];
          break;
        case 'V':
          y = r[1];
          break;
        case 'M':
          mx = r[r.length - 2];
          my = r[r.length - 1];
        default:
          x = r[r.length - 2];
          y = r[r.length - 1];
      }
    }
    res.toString = pathToString;
    pth.abs = pathClone(res);
    return res;
  }
  function isLine(bez) {
    return bez[0] === bez[2] && bez[1] === bez[3] && bez[4] === bez[6] && bez[5] === bez[7];
  }
  function lineToCurve(x1, y1, x2, y2) {
    return [x1, y1, x2, y2, x2, y2];
  }
  function qubicToCurve(x1, y1, ax, ay, x2, y2) {
    var _13 = 1 / 3,
      _23 = 2 / 3;
    return [_13 * x1 + _23 * ax, _13 * y1 + _23 * ay, _13 * x2 + _23 * ax, _13 * y2 + _23 * ay, x2, y2];
  }
  function arcToCurve(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
    var _120 = PI * 120 / 180,
      rad = PI / 180 * (+angle || 0),
      res = [],
      xy,
      rotate = cacher(function (x, y, rad) {
        var X = x * math.cos(rad) - y * math.sin(rad),
          Y = x * math.sin(rad) + y * math.cos(rad);
        return {
          x: X,
          y: Y
        };
      });
    if (!recursive) {
      xy = rotate(x1, y1, -rad);
      x1 = xy.x;
      y1 = xy.y;
      xy = rotate(x2, y2, -rad);
      x2 = xy.x;
      y2 = xy.y;
      var x = (x1 - x2) / 2,
        y = (y1 - y2) / 2;
      var h = x * x / (rx * rx) + y * y / (ry * ry);
      if (h > 1) {
        h = math.sqrt(h);
        rx = h * rx;
        ry = h * ry;
      }
      var rx2 = rx * rx,
        ry2 = ry * ry,
        k = (large_arc_flag == sweep_flag ? -1 : 1) * math.sqrt(abs$7((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),
        cx = k * rx * y / ry + (x1 + x2) / 2,
        cy = k * -ry * x / rx + (y1 + y2) / 2,
        f1 = math.asin(((y1 - cy) / ry).toFixed(9)),
        f2 = math.asin(((y2 - cy) / ry).toFixed(9));
      f1 = x1 < cx ? PI - f1 : f1;
      f2 = x2 < cx ? PI - f2 : f2;
      f1 < 0 && (f1 = PI * 2 + f1);
      f2 < 0 && (f2 = PI * 2 + f2);
      if (sweep_flag && f1 > f2) {
        f1 = f1 - PI * 2;
      }
      if (!sweep_flag && f2 > f1) {
        f2 = f2 - PI * 2;
      }
    } else {
      f1 = recursive[0];
      f2 = recursive[1];
      cx = recursive[2];
      cy = recursive[3];
    }
    var df = f2 - f1;
    if (abs$7(df) > _120) {
      var f2old = f2,
        x2old = x2,
        y2old = y2;
      f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
      x2 = cx + rx * math.cos(f2);
      y2 = cy + ry * math.sin(f2);
      res = arcToCurve(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
    }
    df = f2 - f1;
    var c1 = math.cos(f1),
      s1 = math.sin(f1),
      c2 = math.cos(f2),
      s2 = math.sin(f2),
      t = math.tan(df / 4),
      hx = 4 / 3 * rx * t,
      hy = 4 / 3 * ry * t,
      m1 = [x1, y1],
      m2 = [x1 + hx * s1, y1 - hy * c1],
      m3 = [x2 + hx * s2, y2 - hy * c2],
      m4 = [x2, y2];
    m2[0] = 2 * m1[0] - m2[0];
    m2[1] = 2 * m1[1] - m2[1];
    if (recursive) {
      return [m2, m3, m4].concat(res);
    } else {
      res = [m2, m3, m4].concat(res).join().split(',');
      var newres = [];
      for (var i = 0, ii = res.length; i < ii; i++) {
        newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
      }
      return newres;
    }
  }
  function curveBBox(x0, y0, x1, y1, x2, y2, x3, y3) {
    var tvalues = [],
      bounds = [[], []],
      a,
      b,
      c,
      t,
      t1,
      t2,
      b2ac,
      sqrtb2ac;
    for (var i = 0; i < 2; ++i) {
      if (i == 0) {
        b = 6 * x0 - 12 * x1 + 6 * x2;
        a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
        c = 3 * x1 - 3 * x0;
      } else {
        b = 6 * y0 - 12 * y1 + 6 * y2;
        a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
        c = 3 * y1 - 3 * y0;
      }
      if (abs$7(a) < 1e-12) {
        if (abs$7(b) < 1e-12) {
          continue;
        }
        t = -c / b;
        if (0 < t && t < 1) {
          tvalues.push(t);
        }
        continue;
      }
      b2ac = b * b - 4 * c * a;
      sqrtb2ac = math.sqrt(b2ac);
      if (b2ac < 0) {
        continue;
      }
      t1 = (-b + sqrtb2ac) / (2 * a);
      if (0 < t1 && t1 < 1) {
        tvalues.push(t1);
      }
      t2 = (-b - sqrtb2ac) / (2 * a);
      if (0 < t2 && t2 < 1) {
        tvalues.push(t2);
      }
    }
    var j = tvalues.length,
      jlen = j,
      mt;
    while (j--) {
      t = tvalues[j];
      mt = 1 - t;
      bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
      bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
    }
    bounds[0][jlen] = x0;
    bounds[1][jlen] = y0;
    bounds[0][jlen + 1] = x3;
    bounds[1][jlen + 1] = y3;
    bounds[0].length = bounds[1].length = jlen + 2;
    return {
      x0: mmin.apply(void 0, _toConsumableArray(bounds[0])),
      y0: mmin.apply(void 0, _toConsumableArray(bounds[1])),
      x1: mmax.apply(void 0, _toConsumableArray(bounds[0])),
      y1: mmax.apply(void 0, _toConsumableArray(bounds[1]))
    };
  }
  function pathToCurve(path) {
    var pth = paths(path);
    if (pth.curve) {
      return pathClone(pth.curve);
    }
    var curvedPath = pathToAbsolute(path),
      attrs = {
        x: 0,
        y: 0,
        bx: 0,
        by: 0,
        X: 0,
        Y: 0,
        qx: null,
        qy: null
      },
      processPath = function processPath(path, d, pathCommand) {
        var nx, ny;
        if (!path) {
          return ['C', d.x, d.y, d.x, d.y, d.x, d.y];
        }
        !(path[0] in {
          T: 1,
          Q: 1
        }) && (d.qx = d.qy = null);
        switch (path[0]) {
          case 'M':
            d.X = path[1];
            d.Y = path[2];
            break;
          case 'A':
            path = ['C'].concat(_toConsumableArray(arcToCurve.apply(void 0, [d.x, d.y].concat(_toConsumableArray(path.slice(1))))));
            break;
          case 'S':
            if (pathCommand == 'C' || pathCommand == 'S') {
              nx = d.x * 2 - d.bx;
              ny = d.y * 2 - d.by;
            } else {
              nx = d.x;
              ny = d.y;
            }
            path = ['C', nx, ny].concat(_toConsumableArray(path.slice(1)));
            break;
          case 'T':
            if (pathCommand == 'Q' || pathCommand == 'T') {
              d.qx = d.x * 2 - d.qx;
              d.qy = d.y * 2 - d.qy;
            } else {
              d.qx = d.x;
              d.qy = d.y;
            }
            path = ['C'].concat(_toConsumableArray(qubicToCurve(d.x, d.y, d.qx, d.qy, path[1], path[2])));
            break;
          case 'Q':
            d.qx = path[1];
            d.qy = path[2];
            path = ['C'].concat(_toConsumableArray(qubicToCurve(d.x, d.y, path[1], path[2], path[3], path[4])));
            break;
          case 'L':
            path = ['C'].concat(_toConsumableArray(lineToCurve(d.x, d.y, path[1], path[2])));
            break;
          case 'H':
            path = ['C'].concat(_toConsumableArray(lineToCurve(d.x, d.y, path[1], d.y)));
            break;
          case 'V':
            path = ['C'].concat(_toConsumableArray(lineToCurve(d.x, d.y, d.x, path[1])));
            break;
          case 'Z':
            path = ['C'].concat(_toConsumableArray(lineToCurve(d.x, d.y, d.X, d.Y)));
            break;
        }
        return path;
      },
      fixArc = function fixArc(pp, i) {
        if (pp[i].length > 7) {
          pp[i].shift();
          var pi = pp[i];
          while (pi.length) {
            pathCommands[i] = 'A';
            pp.splice(i++, 0, ['C'].concat(_toConsumableArray(pi.splice(0, 6))));
          }
          pp.splice(i, 1);
          ii = curvedPath.length;
        }
      },
      pathCommands = [],
      pfirst = '',
      pathCommand = '';
    for (var i = 0, ii = curvedPath.length; i < ii; i++) {
      curvedPath[i] && (pfirst = curvedPath[i][0]);
      if (pfirst != 'C') {
          pathCommands[i] = pfirst;
          i && (pathCommand = pathCommands[i - 1]);
        }
      curvedPath[i] = processPath(curvedPath[i], attrs, pathCommand);
      if (pathCommands[i] != 'A' && pfirst == 'C') pathCommands[i] = 'C';
      fixArc(curvedPath, i);
      var seg = curvedPath[i],
        seglen = seg.length;
      attrs.x = seg[seglen - 2];
      attrs.y = seg[seglen - 1];
      attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;
      attrs.by = toFloat(seg[seglen - 3]) || attrs.y;
    }
    pth.curve = pathClone(curvedPath);
    return curvedPath;
  }
  function isConnection(value) {
    return isObject(value) && has$1(value, 'waypoints');
  }
  function isLabel(value) {
    return isObject(value) && has$1(value, 'labelTarget');
  }
  function roundBounds(bounds) {
    return {
      x: Math.round(bounds.x),
      y: Math.round(bounds.y),
      width: Math.round(bounds.width),
      height: Math.round(bounds.height)
    };
  }
  function roundPoint(point) {
    return {
      x: Math.round(point.x),
      y: Math.round(point.y)
    };
  }
  function asTRBL(bounds) {
    return {
      top: bounds.y,
      right: bounds.x + (bounds.width || 0),
      bottom: bounds.y + (bounds.height || 0),
      left: bounds.x
    };
  }
  function asBounds(trbl) {
    return {
      x: trbl.left,
      y: trbl.top,
      width: trbl.right - trbl.left,
      height: trbl.bottom - trbl.top
    };
  }
  function getBoundsMid(bounds) {
    return roundPoint({
      x: bounds.x + (bounds.width || 0) / 2,
      y: bounds.y + (bounds.height || 0) / 2
    });
  }
  function getConnectionMid(connection) {
    var waypoints = connection.waypoints;
    var parts = waypoints.reduce(function (parts, point, index) {
      var lastPoint = waypoints[index - 1];
      if (lastPoint) {
        var lastPart = parts[parts.length - 1];
        var startLength = lastPart && lastPart.endLength || 0;
        var length = distance(lastPoint, point);
        parts.push({
          start: lastPoint,
          end: point,
          startLength: startLength,
          endLength: startLength + length,
          length: length
        });
      }
      return parts;
    }, []);
    var totalLength = parts.reduce(function (length, part) {
      return length + part.length;
    }, 0);
    var midLength = totalLength / 2;
    var i = 0;
    var midSegment = parts[i];
    while (midSegment.endLength < midLength) {
      midSegment = parts[++i];
    }
    var segmentProgress = (midLength - midSegment.startLength) / midSegment.length;
    var midPoint = {
      x: midSegment.start.x + (midSegment.end.x - midSegment.start.x) * segmentProgress,
      y: midSegment.start.y + (midSegment.end.y - midSegment.start.y) * segmentProgress
    };
    return midPoint;
  }
  function getMid(element) {
    if (isConnection(element)) {
      return getConnectionMid(element);
    }
    return getBoundsMid(element);
  }
  function getOrientation(rect, reference, padding) {
    padding = padding || 0;
    if (!isObject(padding)) {
      padding = {
        x: padding,
        y: padding
      };
    }
    var rectOrientation = asTRBL(rect),
      referenceOrientation = asTRBL(reference);
    var top = rectOrientation.bottom + padding.y <= referenceOrientation.top,
      right = rectOrientation.left - padding.x >= referenceOrientation.right,
      bottom = rectOrientation.top - padding.y >= referenceOrientation.bottom,
      left = rectOrientation.right + padding.x <= referenceOrientation.left;
    var vertical = top ? 'top' : bottom ? 'bottom' : null,
      horizontal = left ? 'left' : right ? 'right' : null;
    if (horizontal && vertical) {
      return vertical + '-' + horizontal;
    } else {
      return horizontal || vertical || 'intersect';
    }
  }
  function getElementLineIntersection(elementPath, linePath, cropStart) {
    var intersections = getIntersections(elementPath, linePath);
    if (intersections.length === 1) {
      return roundPoint(intersections[0]);
    } else if (intersections.length === 2 && pointDistance(intersections[0], intersections[1]) < 1) {
      return roundPoint(intersections[0]);
    } else if (intersections.length > 1) {
      intersections = sortBy(intersections, function (i) {
        var distance = Math.floor(i.t2 * 100) || 1;
        distance = 100 - distance;
        distance = (distance < 10 ? '0' : '') + distance;
        return i.segment2 + '#' + distance;
      });
      return roundPoint(intersections[cropStart ? 0 : intersections.length - 1]);
    }
    return null;
  }
  function getIntersections(a, b) {
    return findPathIntersections(a, b);
  }
  function filterRedundantWaypoints(waypoints) {
    waypoints = waypoints.slice();
    var idx = 0,
      point,
      previousPoint,
      nextPoint;
    while (waypoints[idx]) {
      point = waypoints[idx];
      previousPoint = waypoints[idx - 1];
      nextPoint = waypoints[idx + 1];
      if (pointDistance(point, nextPoint) === 0 || pointsOnLine(previousPoint, nextPoint, point)) {
        waypoints.splice(idx, 1);
      } else {
        idx++;
      }
    }
    return waypoints;
  }
  function distance(a, b) {
    return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
  }
  function round$c(number, resolution) {
    return Math.round(number * resolution) / resolution;
  }
  function ensurePx(number) {
    return isNumber(number) ? number + 'px' : number;
  }
  function findRoot(element) {
    while (element.parent) {
      element = element.parent;
    }
    return element;
  }
  function createContainer(options) {
    options = assign$1({}, {
      width: '100%',
      height: '100%'
    }, options);
    var container = options.container || document.body;
    var parent = document.createElement('div');
    parent.setAttribute('class', 'djs-container djs-parent');
    assign(parent, {
      position: 'relative',
      overflow: 'hidden',
      width: ensurePx(options.width),
      height: ensurePx(options.height)
    });
    container.appendChild(parent);
    return parent;
  }
  function createGroup(parent, cls, childIndex) {
    var group = create$1('g');
    classes(group).add(cls);
    var index = childIndex !== undefined ? childIndex : parent.childNodes.length - 1;
    parent.insertBefore(group, parent.childNodes[index] || null);
    return group;
  }
  var BASE_LAYER = 'base';
  var PLANE_LAYER_INDEX = 0;
  var UTILITY_LAYER_INDEX = 1;
  var REQUIRED_MODEL_ATTRS = {
    shape: ['x', 'y', 'width', 'height'],
    connection: ['waypoints']
  };
  function Canvas(config, eventBus, graphicsFactory, elementRegistry) {
    this._eventBus = eventBus;
    this._elementRegistry = elementRegistry;
    this._graphicsFactory = graphicsFactory;
    this._rootsIdx = 0;
    this._layers = {};
    this._planes = [];
    this._rootElement = null;
    this._focused = false;
    this._init(config || {});
  }
  Canvas.$inject = ['config.canvas', 'eventBus', 'graphicsFactory', 'elementRegistry'];
  Canvas.prototype._init = function (config) {
    var _this = this;
    var eventBus = this._eventBus;
    var container = this._container = createContainer(config);
    var svg = this._svg = create$1('svg');
    attr(svg, {
      width: '100%',
      height: '100%'
    });
    attr$1(svg, 'tabindex', 0);
    config.autoFocus && eventBus.on('element.hover', function () {
      _this.restoreFocus();
    });
    eventBus.on('element.mousedown', 500, function (event) {
      _this.focus();
    });
    svg.addEventListener('focusin', function () {
      _this._setFocused(true);
    });
    svg.addEventListener('focusout', function () {
      _this._setFocused(false);
    });
    append(container, svg);
    var viewport = this._viewport = createGroup(svg, 'viewport');
    if (config.deferUpdate) {
      this._viewboxChanged = debounce(bind$2(this._viewboxChanged, this), 300);
    }
    eventBus.on('diagram.init', function () {
      eventBus.fire('canvas.init', {
        svg: svg,
        viewport: viewport
      });
    });
    eventBus.on(['shape.added', 'connection.added', 'shape.removed', 'connection.removed', 'elements.changed', 'root.set'], function () {
      delete _this._cachedViewbox;
    });
    eventBus.on('diagram.destroy', 500, this._destroy, this);
    eventBus.on('diagram.clear', 500, this._clear, this);
  };
  Canvas.prototype._destroy = function () {
    this._eventBus.fire('canvas.destroy', {
      svg: this._svg,
      viewport: this._viewport
    });
    var parent = this._container.parentNode;
    if (parent) {
      parent.removeChild(this._container);
    }
    delete this._svg;
    delete this._container;
    delete this._layers;
    delete this._planes;
    delete this._rootElement;
    delete this._viewport;
  };
  Canvas.prototype._setFocused = function (focused) {
    if (focused == this._focused) {
      return;
    }
    this._focused = focused;
    this._eventBus.fire('canvas.focus.changed', {
      focused
    });
  };
  Canvas.prototype._clear = function () {
    var _this2 = this;
    var allElements = this._elementRegistry.getAll();
    allElements.forEach(function (element) {
      var type = getType(element);
      if (type === 'root') {
        _this2.removeRootElement(element);
      } else {
        _this2._removeElement(element, type);
      }
    });
    this._planes = [];
    this._rootElement = null;
    delete this._cachedViewbox;
  };
  Canvas.prototype.focus = function () {
    this._svg.focus({
      preventScroll: true
    });
    this._setFocused(true);
  };
  Canvas.prototype.restoreFocus = function () {
    if (document.activeElement === document.body) {
      this.focus();
    }
  };
  Canvas.prototype.isFocused = function () {
    return this._focused;
  };
  Canvas.prototype.getDefaultLayer = function () {
    return this.getLayer(BASE_LAYER, PLANE_LAYER_INDEX);
  };
  Canvas.prototype.getLayer = function (name, index) {
    if (!name) {
      throw new Error('must specify a name');
    }
    var layer = this._layers[name];
    if (!layer) {
      layer = this._layers[name] = this._createLayer(name, index);
    }
    if (typeof index !== 'undefined' && layer.index !== index) {
      throw new Error('layer <' + name + '> already created at index <' + index + '>');
    }
    return layer.group;
  };
  Canvas.prototype._getChildIndex = function (index) {
    return reduce(this._layers, function (childIndex, layer) {
      if (layer.visible && index >= layer.index) {
        childIndex++;
      }
      return childIndex;
    }, 0);
  };
  Canvas.prototype._createLayer = function (name, index) {
    if (typeof index === 'undefined') {
      index = UTILITY_LAYER_INDEX;
    }
    var childIndex = this._getChildIndex(index);
    return {
      group: createGroup(this._viewport, 'layer-' + name, childIndex),
      index: index,
      visible: true
    };
  };
  Canvas.prototype.showLayer = function (name) {
    if (!name) {
      throw new Error('must specify a name');
    }
    var layer = this._layers[name];
    if (!layer) {
      throw new Error('layer <' + name + '> does not exist');
    }
    var viewport = this._viewport;
    var group = layer.group;
    var index = layer.index;
    if (layer.visible) {
      return group;
    }
    var childIndex = this._getChildIndex(index);
    viewport.insertBefore(group, viewport.childNodes[childIndex] || null);
    layer.visible = true;
    return group;
  };
  Canvas.prototype.hideLayer = function (name) {
    if (!name) {
      throw new Error('must specify a name');
    }
    var layer = this._layers[name];
    if (!layer) {
      throw new Error('layer <' + name + '> does not exist');
    }
    var group = layer.group;
    if (!layer.visible) {
      return group;
    }
    remove$1(group);
    layer.visible = false;
    return group;
  };
  Canvas.prototype._removeLayer = function (name) {
    var layer = this._layers[name];
    if (layer) {
      delete this._layers[name];
      remove$1(layer.group);
    }
  };
  Canvas.prototype.getActiveLayer = function () {
    var plane = this._findPlaneForRoot(this.getRootElement());
    if (!plane) {
      return null;
    }
    return plane.layer;
  };
  Canvas.prototype.findRoot = function (element) {
    if (typeof element === 'string') {
      element = this._elementRegistry.get(element);
    }
    if (!element) {
      return;
    }
    var plane = this._findPlaneForRoot(findRoot(element)) || {};
    return plane.rootElement;
  };
  Canvas.prototype.getRootElements = function () {
    return this._planes.map(function (plane) {
      return plane.rootElement;
    });
  };
  Canvas.prototype._findPlaneForRoot = function (rootElement) {
    return find(this._planes, function (plane) {
      return plane.rootElement === rootElement;
    });
  };
  Canvas.prototype.getContainer = function () {
    return this._container;
  };
  Canvas.prototype._updateMarker = function (element, marker, add) {
    var container;
    if (!element.id) {
      element = this._elementRegistry.get(element);
    }
    element.markers = element.markers || new Set();
    container = this._elementRegistry._elements[element.id];
    if (!container) {
      return;
    }
    forEach$1([container.gfx, container.secondaryGfx], function (gfx) {
      if (gfx) {
        if (add) {
          element.markers.add(marker);
          classes(gfx).add(marker);
        } else {
          element.markers.delete(marker);
          classes(gfx).remove(marker);
        }
      }
    });
    this._eventBus.fire('element.marker.update', {
      element: element,
      gfx: container.gfx,
      marker: marker,
      add: !!add
    });
  };
  Canvas.prototype.addMarker = function (element, marker) {
    this._updateMarker(element, marker, true);
  };
  Canvas.prototype.removeMarker = function (element, marker) {
    this._updateMarker(element, marker, false);
  };
  Canvas.prototype.hasMarker = function (element, marker) {
    if (!element.id) {
      element = this._elementRegistry.get(element);
    }
    if (!element.markers) {
      return false;
    }
    return element.markers.has(marker);
  };
  Canvas.prototype.toggleMarker = function (element, marker) {
    if (this.hasMarker(element, marker)) {
      this.removeMarker(element, marker);
    } else {
      this.addMarker(element, marker);
    }
  };
  Canvas.prototype.getRootElement = function () {
    var rootElement = this._rootElement;
    if (rootElement || this._planes.length) {
      return rootElement;
    }
    return this.setRootElement(this.addRootElement(null));
  };
  Canvas.prototype.addRootElement = function (rootElement) {
    var idx = this._rootsIdx++;
    if (!rootElement) {
      rootElement = {
        id: '__implicitroot_' + idx,
        children: [],
        isImplicit: true
      };
    }
    var layerName = rootElement.layer = 'root-' + idx;
    this._ensureValid('root', rootElement);
    var layer = this.getLayer(layerName, PLANE_LAYER_INDEX);
    this.hideLayer(layerName);
    this._addRoot(rootElement, layer);
    this._planes.push({
      rootElement: rootElement,
      layer: layer
    });
    return rootElement;
  };
  Canvas.prototype.removeRootElement = function (rootElement) {
    if (typeof rootElement === 'string') {
      rootElement = this._elementRegistry.get(rootElement);
    }
    var plane = this._findPlaneForRoot(rootElement);
    if (!plane) {
      return;
    }
    this._removeRoot(rootElement);
    this._removeLayer(rootElement.layer);
    this._planes = this._planes.filter(function (plane) {
      return plane.rootElement !== rootElement;
    });
    if (this._rootElement === rootElement) {
      this._rootElement = null;
    }
    return rootElement;
  };
  Canvas.prototype.setRootElement = function (rootElement) {
    if (rootElement === this._rootElement) {
      return rootElement;
    }
    var plane;
    if (!rootElement) {
      throw new Error('rootElement required');
    }
    plane = this._findPlaneForRoot(rootElement);
    if (!plane) {
      rootElement = this.addRootElement(rootElement);
    }
    this._setRoot(rootElement);
    return rootElement;
  };
  Canvas.prototype._removeRoot = function (element) {
    var elementRegistry = this._elementRegistry,
      eventBus = this._eventBus;
    eventBus.fire('root.remove', {
      element: element
    });
    eventBus.fire('root.removed', {
      element: element
    });
    elementRegistry.remove(element);
  };
  Canvas.prototype._addRoot = function (element, gfx) {
    var elementRegistry = this._elementRegistry,
      eventBus = this._eventBus;
    eventBus.fire('root.add', {
      element: element
    });
    elementRegistry.add(element, gfx);
    eventBus.fire('root.added', {
      element: element,
      gfx: gfx
    });
  };
  Canvas.prototype._setRoot = function (rootElement, layer) {
    var currentRoot = this._rootElement;
    if (currentRoot) {
      this._elementRegistry.updateGraphics(currentRoot, null, true);
      this.hideLayer(currentRoot.layer);
    }
    if (rootElement) {
      if (!layer) {
        layer = this._findPlaneForRoot(rootElement).layer;
      }
      this._elementRegistry.updateGraphics(rootElement, this._svg, true);
      this.showLayer(rootElement.layer);
    }
    this._rootElement = rootElement;
    this._eventBus.fire('root.set', {
      element: rootElement
    });
  };
  Canvas.prototype._ensureValid = function (type, element) {
    if (!element.id) {
      throw new Error('element must have an id');
    }
    if (this._elementRegistry.get(element.id)) {
      throw new Error('element <' + element.id + '> already exists');
    }
    var requiredAttrs = REQUIRED_MODEL_ATTRS[type];
    var valid = every(requiredAttrs, function (attr) {
      return typeof element[attr] !== 'undefined';
    });
    if (!valid) {
      throw new Error('must supply { ' + requiredAttrs.join(', ') + ' } with ' + type);
    }
  };
  Canvas.prototype._setParent = function (element, parent, parentIndex) {
    add(parent.children, element, parentIndex);
    element.parent = parent;
  };
  Canvas.prototype._addElement = function (type, element, parent, parentIndex) {
    parent = parent || this.getRootElement();
    var eventBus = this._eventBus,
      graphicsFactory = this._graphicsFactory;
    this._ensureValid(type, element);
    eventBus.fire(type + '.add', {
      element: element,
      parent: parent
    });
    this._setParent(element, parent, parentIndex);
    var gfx = graphicsFactory.create(type, element, parentIndex);
    this._elementRegistry.add(element, gfx);
    graphicsFactory.update(type, element, gfx);
    eventBus.fire(type + '.added', {
      element: element,
      gfx: gfx
    });
    return element;
  };
  Canvas.prototype.addShape = function (shape, parent, parentIndex) {
    return this._addElement('shape', shape, parent, parentIndex);
  };
  Canvas.prototype.addConnection = function (connection, parent, parentIndex) {
    return this._addElement('connection', connection, parent, parentIndex);
  };
  Canvas.prototype._removeElement = function (element, type) {
    var elementRegistry = this._elementRegistry,
      graphicsFactory = this._graphicsFactory,
      eventBus = this._eventBus;
    element = elementRegistry.get(element.id || element);
    if (!element) {
      return;
    }
    eventBus.fire(type + '.remove', {
      element: element
    });
    graphicsFactory.remove(element);
    remove(element.parent && element.parent.children, element);
    element.parent = null;
    eventBus.fire(type + '.removed', {
      element: element
    });
    elementRegistry.remove(element);
    return element;
  };
  Canvas.prototype.removeShape = function (shape) {
    return this._removeElement(shape, 'shape');
  };
  Canvas.prototype.removeConnection = function (connection) {
    return this._removeElement(connection, 'connection');
  };
  Canvas.prototype.getGraphics = function (element, secondary) {
    return this._elementRegistry.getGraphics(element, secondary);
  };
  Canvas.prototype._changeViewbox = function (changeFn) {
    this._eventBus.fire('canvas.viewbox.changing');
    changeFn.apply(this);
    this._cachedViewbox = null;
    this._viewboxChanged();
  };
  Canvas.prototype._viewboxChanged = function () {
    this._eventBus.fire('canvas.viewbox.changed', {
      viewbox: this.viewbox()
    });
  };
  Canvas.prototype.viewbox = function (box) {
    if (box === undefined && this._cachedViewbox) {
      return structuredClone(this._cachedViewbox);
    }
    var viewport = this._viewport,
      outerBox = this.getSize();
    var innerBox, matrix, activeLayer, transform, scale, x, y;
    if (!box) {
      activeLayer = this._rootElement ? this.getActiveLayer() : null;
      innerBox = activeLayer && activeLayer.getBBox() || {};
      transform = transform$1(viewport);
      matrix = transform ? transform.matrix : createMatrix();
      scale = round$c(matrix.a, 1000);
      x = round$c(-matrix.e || 0, 1000);
      y = round$c(-matrix.f || 0, 1000);
      box = this._cachedViewbox = {
        x: x ? x / scale : 0,
        y: y ? y / scale : 0,
        width: outerBox.width / scale,
        height: outerBox.height / scale,
        scale: scale,
        inner: {
          width: innerBox.width || 0,
          height: innerBox.height || 0,
          x: innerBox.x || 0,
          y: innerBox.y || 0
        },
        outer: outerBox
      };
      return box;
    } else {
      this._changeViewbox(function () {
        scale = Math.min(outerBox.width / box.width, outerBox.height / box.height);
        var matrix = this._svg.createSVGMatrix().scale(scale).translate(-box.x, -box.y);
        transform$1(viewport, matrix);
      });
    }
    return box;
  };
  Canvas.prototype.scroll = function (delta) {
    var node = this._viewport;
    var matrix = node.getCTM();
    if (delta) {
      this._changeViewbox(function () {
        delta = assign$1({
          dx: 0,
          dy: 0
        }, delta || {});
        matrix = this._svg.createSVGMatrix().translate(delta.dx, delta.dy).multiply(matrix);
        setCTM(node, matrix);
      });
    }
    return {
      x: matrix.e,
      y: matrix.f
    };
  };
  Canvas.prototype.scrollToElement = function (element, padding) {
    var defaultPadding = 100;
    if (typeof element === 'string') {
      element = this._elementRegistry.get(element);
    }
    var rootElement = this.findRoot(element);
    if (rootElement !== this.getRootElement()) {
      this.setRootElement(rootElement);
    }
    if (rootElement === element) {
      return;
    }
    if (!padding) {
      padding = {};
    }
    if (typeof padding === 'number') {
      defaultPadding = padding;
    }
    padding = {
      top: padding.top || defaultPadding,
      right: padding.right || defaultPadding,
      bottom: padding.bottom || defaultPadding,
      left: padding.left || defaultPadding
    };
    var elementBounds = getBBox(element),
      elementTrbl = asTRBL(elementBounds),
      viewboxBounds = this.viewbox(),
      zoom = this.zoom();
    var dx, dy;
    viewboxBounds.y += padding.top / zoom;
    viewboxBounds.x += padding.left / zoom;
    viewboxBounds.width -= (padding.right + padding.left) / zoom;
    viewboxBounds.height -= (padding.bottom + padding.top) / zoom;
    var viewboxTrbl = asTRBL(viewboxBounds);
    var canFit = elementBounds.width < viewboxBounds.width && elementBounds.height < viewboxBounds.height;
    if (!canFit) {
      dx = elementBounds.x - viewboxBounds.x;
      dy = elementBounds.y - viewboxBounds.y;
    } else {
      var dRight = Math.max(0, elementTrbl.right - viewboxTrbl.right),
        dLeft = Math.min(0, elementTrbl.left - viewboxTrbl.left),
        dBottom = Math.max(0, elementTrbl.bottom - viewboxTrbl.bottom),
        dTop = Math.min(0, elementTrbl.top - viewboxTrbl.top);
      dx = dRight || dLeft;
      dy = dBottom || dTop;
    }
    this.scroll({
      dx: -dx * zoom,
      dy: -dy * zoom
    });
  };
  Canvas.prototype.zoom = function (newScale, center) {
    if (!newScale) {
      return this.viewbox(newScale).scale;
    }
    if (newScale === 'fit-viewport') {
      return this._fitViewport(center);
    }
    var outer, matrix;
    this._changeViewbox(function () {
      if (typeof center !== 'object') {
        outer = this.viewbox().outer;
        center = {
          x: outer.width / 2,
          y: outer.height / 2
        };
      }
      matrix = this._setZoom(newScale, center);
    });
    return round$c(matrix.a, 1000);
  };
  function setCTM(node, m) {
    var mstr = 'matrix(' + m.a + ',' + m.b + ',' + m.c + ',' + m.d + ',' + m.e + ',' + m.f + ')';
    node.setAttribute('transform', mstr);
  }
  Canvas.prototype._fitViewport = function (center) {
    var vbox = this.viewbox(),
      outer = vbox.outer,
      inner = vbox.inner;
    var newScale, newViewbox;
    if (inner.x >= 0 && inner.y >= 0 && inner.x + inner.width <= outer.width && inner.y + inner.height <= outer.height && !center) {
      newViewbox = {
        x: 0,
        y: 0,
        width: Math.max(inner.width + inner.x, outer.width),
        height: Math.max(inner.height + inner.y, outer.height)
      };
    } else {
      newScale = Math.min(1, outer.width / inner.width, outer.height / inner.height);
      newViewbox = {
        x: inner.x + (center ? inner.width / 2 - outer.width / newScale / 2 : 0),
        y: inner.y + (center ? inner.height / 2 - outer.height / newScale / 2 : 0),
        width: outer.width / newScale,
        height: outer.height / newScale
      };
    }
    this.viewbox(newViewbox);
    return this.viewbox(false).scale;
  };
  Canvas.prototype._setZoom = function (scale, center) {
    var svg = this._svg,
      viewport = this._viewport;
    var matrix = svg.createSVGMatrix();
    var point = svg.createSVGPoint();
    var centerPoint, originalPoint, currentMatrix, scaleMatrix, newMatrix;
    currentMatrix = viewport.getCTM();
    var currentScale = currentMatrix.a;
    if (center) {
      centerPoint = assign$1(point, center);
      originalPoint = centerPoint.matrixTransform(currentMatrix.inverse());
      scaleMatrix = matrix.translate(originalPoint.x, originalPoint.y).scale(1 / currentScale * scale).translate(-originalPoint.x, -originalPoint.y);
      newMatrix = currentMatrix.multiply(scaleMatrix);
    } else {
      newMatrix = matrix.scale(scale);
    }
    setCTM(this._viewport, newMatrix);
    return newMatrix;
  };
  Canvas.prototype.getSize = function () {
    return {
      width: this._container.clientWidth,
      height: this._container.clientHeight
    };
  };
  Canvas.prototype.getAbsoluteBBox = function (element) {
    var vbox = this.viewbox();
    var bbox;
    if (element.waypoints) {
      var gfx = this.getGraphics(element);
      bbox = gfx.getBBox();
    } else {
      bbox = element;
    }
    var x = bbox.x * vbox.scale - vbox.x * vbox.scale;
    var y = bbox.y * vbox.scale - vbox.y * vbox.scale;
    var width = bbox.width * vbox.scale;
    var height = bbox.height * vbox.scale;
    return {
      x: x,
      y: y,
      width: width,
      height: height
    };
  };
  Canvas.prototype.resized = function () {
    delete this._cachedViewbox;
    this._eventBus.fire('canvas.resized');
  };
  var ELEMENT_ID = 'data-element-id';
  function ElementRegistry(eventBus) {
    this._elements = {};
    this._eventBus = eventBus;
  }
  ElementRegistry.$inject = ['eventBus'];
  ElementRegistry.prototype.add = function (element, gfx, secondaryGfx) {
    var id = element.id;
    this._validateId(id);
    attr(gfx, ELEMENT_ID, id);
    if (secondaryGfx) {
      attr(secondaryGfx, ELEMENT_ID, id);
    }
    this._elements[id] = {
      element: element,
      gfx: gfx,
      secondaryGfx: secondaryGfx
    };
  };
  ElementRegistry.prototype.remove = function (element) {
    var elements = this._elements,
      id = element.id || element,
      container = id && elements[id];
    if (container) {
      attr(container.gfx, ELEMENT_ID, '');
      if (container.secondaryGfx) {
        attr(container.secondaryGfx, ELEMENT_ID, '');
      }
      delete elements[id];
    }
  };
  ElementRegistry.prototype.updateId = function (element, newId) {
    this._validateId(newId);
    if (typeof element === 'string') {
      element = this.get(element);
    }
    this._eventBus.fire('element.updateId', {
      element: element,
      newId: newId
    });
    var gfx = this.getGraphics(element),
      secondaryGfx = this.getGraphics(element, true);
    this.remove(element);
    element.id = newId;
    this.add(element, gfx, secondaryGfx);
  };
  ElementRegistry.prototype.updateGraphics = function (filter, gfx, secondary) {
    var id = filter.id || filter;
    var container = this._elements[id];
    if (secondary) {
      container.secondaryGfx = gfx;
    } else {
      container.gfx = gfx;
    }
    if (gfx) {
      attr(gfx, ELEMENT_ID, id);
    }
    return gfx;
  };
  ElementRegistry.prototype.get = function (filter) {
    var id;
    if (typeof filter === 'string') {
      id = filter;
    } else {
      id = filter && attr(filter, ELEMENT_ID);
    }
    var container = this._elements[id];
    return container && container.element;
  };
  ElementRegistry.prototype.filter = function (fn) {
    var filtered = [];
    this.forEach(function (element, gfx) {
      if (fn(element, gfx)) {
        filtered.push(element);
      }
    });
    return filtered;
  };
  ElementRegistry.prototype.find = function (fn) {
    var map = this._elements,
      keys = Object.keys(map);
    for (var i = 0; i < keys.length; i++) {
      var id = keys[i],
        container = map[id],
        element = container.element,
        gfx = container.gfx;
      if (fn(element, gfx)) {
        return element;
      }
    }
  };
  ElementRegistry.prototype.getAll = function () {
    return this.filter(function (e) {
      return e;
    });
  };
  ElementRegistry.prototype.forEach = function (fn) {
    var map = this._elements;
    Object.keys(map).forEach(function (id) {
      var container = map[id],
        element = container.element,
        gfx = container.gfx;
      return fn(element, gfx);
    });
  };
  ElementRegistry.prototype.getGraphics = function (filter, secondary) {
    var id = filter.id || filter;
    var container = this._elements[id];
    return container && (secondary ? container.secondaryGfx : container.gfx);
  };
  ElementRegistry.prototype._validateId = function (id) {
    if (!id) {
      throw new Error('element must have an id');
    }
    if (this._elements[id]) {
      throw new Error('element with id ' + id + ' already added');
    }
  };
  function extend(collection, refs, property, target) {
    var inverseProperty = property.inverse;
    Object.defineProperty(collection, 'remove', {
      value: function value(element) {
        var idx = this.indexOf(element);
        if (idx !== -1) {
          this.splice(idx, 1);
          refs.unset(element, inverseProperty, target);
        }
        return element;
      }
    });
    Object.defineProperty(collection, 'contains', {
      value: function value(element) {
        return this.indexOf(element) !== -1;
      }
    });
    Object.defineProperty(collection, 'add', {
      value: function value(element, idx) {
        var currentIdx = this.indexOf(element);
        if (typeof idx === 'undefined') {
          if (currentIdx !== -1) {
            return;
          }
          idx = this.length;
        }
        if (currentIdx !== -1) {
          this.splice(currentIdx, 1);
        }
        this.splice(idx, 0, element);
        if (currentIdx === -1) {
          refs.set(element, inverseProperty, target);
        }
      }
    });
    Object.defineProperty(collection, '__refs_collection', {
      value: true
    });
    return collection;
  }
  function isExtended(collection) {
    return collection.__refs_collection === true;
  }
  function hasOwnProperty$1(e, property) {
    return Object.prototype.hasOwnProperty.call(e, property.name || property);
  }
  function defineCollectionProperty(ref, property, target) {
    var collection = extend(target[property.name] || [], ref, property, target);
    Object.defineProperty(target, property.name, {
      enumerable: property.enumerable,
      value: collection
    });
    if (collection.length) {
      collection.forEach(function (o) {
        ref.set(o, property.inverse, target);
      });
    }
  }
  function defineProperty$1(ref, property, target) {
    var inverseProperty = property.inverse;
    var _value = target[property.name];
    Object.defineProperty(target, property.name, {
      configurable: property.configurable,
      enumerable: property.enumerable,
      get: function get() {
        return _value;
      },
      set: function set(value) {
        if (value === _value) {
          return;
        }
        var old = _value;
        _value = null;
        if (old) {
          ref.unset(old, inverseProperty, target);
        }
        _value = value;
        ref.set(_value, inverseProperty, target);
      }
    });
  }
  function Refs(a, b) {
    if (!(this instanceof Refs)) {
      return new Refs(a, b);
    }
    a.inverse = b;
    b.inverse = a;
    this.props = {};
    this.props[a.name] = a;
    this.props[b.name] = b;
  }
  Refs.prototype.bind = function (target, property) {
    if (typeof property === 'string') {
      if (!this.props[property]) {
        throw new Error('no property <' + property + '> in ref');
      }
      property = this.props[property];
    }
    if (property.collection) {
      defineCollectionProperty(this, property, target);
    } else {
      defineProperty$1(this, property, target);
    }
  };
  Refs.prototype.ensureRefsCollection = function (target, property) {
    var collection = target[property.name];
    if (!isExtended(collection)) {
      defineCollectionProperty(this, property, target);
    }
    return collection;
  };
  Refs.prototype.ensureBound = function (target, property) {
    if (!hasOwnProperty$1(target, property)) {
      this.bind(target, property);
    }
  };
  Refs.prototype.unset = function (target, property, value) {
    if (target) {
      this.ensureBound(target, property);
      if (property.collection) {
        this.ensureRefsCollection(target, property).remove(value);
      } else {
        target[property.name] = undefined;
      }
    }
  };
  Refs.prototype.set = function (target, property, value) {
    if (target) {
      this.ensureBound(target, property);
      if (property.collection) {
        this.ensureRefsCollection(target, property).add(value);
      } else {
        target[property.name] = value;
      }
    }
  };
  var parentRefs = new Refs({
      name: 'children',
      enumerable: true,
      collection: true
    }, {
      name: 'parent'
    }),
    labelRefs = new Refs({
      name: 'labels',
      enumerable: true,
      collection: true
    }, {
      name: 'labelTarget'
    }),
    attacherRefs = new Refs({
      name: 'attachers',
      collection: true
    }, {
      name: 'host'
    }),
    outgoingRefs = new Refs({
      name: 'outgoing',
      collection: true
    }, {
      name: 'source'
    }),
    incomingRefs = new Refs({
      name: 'incoming',
      collection: true
    }, {
      name: 'target'
    });
  function ElementImpl() {
    Object.defineProperty(this, 'businessObject', {
      writable: true
    });
    Object.defineProperty(this, 'label', {
      get: function get() {
        return this.labels[0];
      },
      set: function set(newLabel) {
        var label = this.label,
          labels = this.labels;
        if (!newLabel && label) {
          labels.remove(label);
        } else {
          labels.add(newLabel, 0);
        }
      }
    });
    parentRefs.bind(this, 'parent');
    labelRefs.bind(this, 'labels');
    outgoingRefs.bind(this, 'outgoing');
    incomingRefs.bind(this, 'incoming');
  }
  function ShapeImpl() {
    ElementImpl.call(this);
    parentRefs.bind(this, 'children');
    attacherRefs.bind(this, 'host');
    attacherRefs.bind(this, 'attachers');
  }
  e$2(ShapeImpl, ElementImpl);
  function RootImpl() {
    ElementImpl.call(this);
    parentRefs.bind(this, 'children');
  }
  e$2(RootImpl, ShapeImpl);
  function LabelImpl() {
    ShapeImpl.call(this);
    labelRefs.bind(this, 'labelTarget');
  }
  e$2(LabelImpl, ShapeImpl);
  function ConnectionImpl() {
    ElementImpl.call(this);
    outgoingRefs.bind(this, 'source');
    incomingRefs.bind(this, 'target');
  }
  e$2(ConnectionImpl, ElementImpl);
  var types$6 = {
    connection: ConnectionImpl,
    shape: ShapeImpl,
    label: LabelImpl,
    root: RootImpl
  };
  function create(type, attrs) {
    var Type = types$6[type];
    if (!Type) {
      throw new Error('unknown type: <' + type + '>');
    }
    return assign$1(new Type(), attrs);
  }
  function isModelElement(obj) {
    return obj instanceof ElementImpl;
  }
  function ElementFactory$1() {
    this._uid = 12;
  }
  ElementFactory$1.prototype.createRoot = function (attrs) {
    return this.create('root', attrs);
  };
  ElementFactory$1.prototype.createLabel = function (attrs) {
    return this.create('label', attrs);
  };
  ElementFactory$1.prototype.createShape = function (attrs) {
    return this.create('shape', attrs);
  };
  ElementFactory$1.prototype.createConnection = function (attrs) {
    return this.create('connection', attrs);
  };
  ElementFactory$1.prototype.create = function (type, attrs) {
    attrs = assign$1({}, attrs || {});
    if (!attrs.id) {
      attrs.id = type + '_' + this._uid++;
    }
    return create(type, attrs);
  };
  var FN_REF = '__fn';
  var DEFAULT_PRIORITY$6 = 1000;
  var slice = Array.prototype.slice;
  function EventBus() {
    this._listeners = {};
    this.on('diagram.destroy', 1, this._destroy, this);
  }
  EventBus.prototype.on = function (events, priority, callback, that) {
    events = isArray$3(events) ? events : [events];
    if (isFunction(priority)) {
      that = callback;
      callback = priority;
      priority = DEFAULT_PRIORITY$6;
    }
    if (!isNumber(priority)) {
      throw new Error('priority must be a number');
    }
    var actualCallback = callback;
    if (that) {
      actualCallback = bind$2(callback, that);
      actualCallback[FN_REF] = callback[FN_REF] || callback;
    }
    var self = this;
    events.forEach(function (e) {
      self._addListener(e, {
        priority: priority,
        callback: actualCallback,
        next: null
      });
    });
  };
  EventBus.prototype.once = function (events, priority, callback, that) {
    var self = this;
    if (isFunction(priority)) {
      that = callback;
      callback = priority;
      priority = DEFAULT_PRIORITY$6;
    }
    if (!isNumber(priority)) {
      throw new Error('priority must be a number');
    }
    function wrappedCallback() {
      wrappedCallback.__isTomb = true;
      var result = callback.apply(that, arguments);
      self.off(events, wrappedCallback);
      return result;
    }
    wrappedCallback[FN_REF] = callback;
    this.on(events, priority, wrappedCallback);
  };
  EventBus.prototype.off = function (events, callback) {
    events = isArray$3(events) ? events : [events];
    var self = this;
    events.forEach(function (event) {
      self._removeListener(event, callback);
    });
  };
  EventBus.prototype.createEvent = function (data) {
    var event = new InternalEvent();
    event.init(data);
    return event;
  };
  EventBus.prototype.fire = function (type, data) {
    var event, firstListener, returnValue, args;
    args = slice.call(arguments);
    if (typeof type === 'object') {
      data = type;
      type = data.type;
    }
    if (!type) {
      throw new Error('no event type specified');
    }
    firstListener = this._listeners[type];
    if (!firstListener) {
      return;
    }
    if (data instanceof InternalEvent) {
      event = data;
    } else {
      event = this.createEvent(data);
    }
    args[0] = event;
    var originalType = event.type;
    if (type !== originalType) {
      event.type = type;
    }
    try {
      returnValue = this._invokeListeners(event, args, firstListener);
    } finally {
      if (type !== originalType) {
        event.type = originalType;
      }
    }
    if (returnValue === undefined && event.defaultPrevented) {
      returnValue = false;
    }
    return returnValue;
  };
  EventBus.prototype.handleError = function (error) {
    return this.fire('error', {
      error: error
    }) === false;
  };
  EventBus.prototype._destroy = function () {
    this._listeners = {};
  };
  EventBus.prototype._invokeListeners = function (event, args, listener) {
    var returnValue;
    while (listener) {
      if (event.cancelBubble) {
        break;
      }
      returnValue = this._invokeListener(event, args, listener);
      listener = listener.next;
    }
    return returnValue;
  };
  EventBus.prototype._invokeListener = function (event, args, listener) {
    var returnValue;
    if (listener.callback.__isTomb) {
      return returnValue;
    }
    try {
      returnValue = invokeFunction(listener.callback, args);
      if (returnValue !== undefined) {
        event.returnValue = returnValue;
        event.stopPropagation();
      }
      if (returnValue === false) {
        event.preventDefault();
      }
    } catch (error) {
      if (!this.handleError(error)) {
        console.error('unhandled error in event listener', error);
        throw error;
      }
    }
    return returnValue;
  };
  EventBus.prototype._addListener = function (event, newListener) {
    var listener = this._getListeners(event),
      previousListener;
    if (!listener) {
      this._setListeners(event, newListener);
      return;
    }
    while (listener) {
      if (listener.priority < newListener.priority) {
        newListener.next = listener;
        if (previousListener) {
          previousListener.next = newListener;
        } else {
          this._setListeners(event, newListener);
        }
        return;
      }
      previousListener = listener;
      listener = listener.next;
    }
    previousListener.next = newListener;
  };
  EventBus.prototype._getListeners = function (name) {
    return this._listeners[name];
  };
  EventBus.prototype._setListeners = function (name, listener) {
    this._listeners[name] = listener;
  };
  EventBus.prototype._removeListener = function (event, callback) {
    var listener = this._getListeners(event),
      nextListener,
      previousListener,
      listenerCallback;
    if (!callback) {
      this._setListeners(event, null);
      return;
    }
    while (listener) {
      nextListener = listener.next;
      listenerCallback = listener.callback;
      if (listenerCallback === callback || listenerCallback[FN_REF] === callback) {
        if (previousListener) {
          previousListener.next = nextListener;
        } else {
          this._setListeners(event, nextListener);
        }
      }
      previousListener = listener;
      listener = nextListener;
    }
  };
  function InternalEvent() {}
  InternalEvent.prototype.stopPropagation = function () {
    this.cancelBubble = true;
  };
  InternalEvent.prototype.preventDefault = function () {
    this.defaultPrevented = true;
  };
  InternalEvent.prototype.init = function (data) {
    assign$1(this, data || {});
  };
  function invokeFunction(fn, args) {
    return fn.apply(null, args);
  }
  function getVisual(gfx) {
    return gfx.childNodes[0];
  }
  function getChildren$1(gfx) {
    return gfx.parentNode.childNodes[1];
  }
  function transform(gfx, x, y, angle, amount) {
    var translate = createTransform();
    translate.setTranslate(x, y);
    var rotate = createTransform();
    rotate.setRotate(angle || 0, 0, 0);
    var scale = createTransform();
    scale.setScale(1, 1);
    transform$1(gfx, [translate, rotate, scale]);
  }
  function translate$1(gfx, x, y) {
    var translate = createTransform();
    translate.setTranslate(x, y);
    transform$1(gfx, translate);
  }
  function rotate(gfx, angle) {
    var rotate = createTransform();
    rotate.setRotate(angle, 0, 0);
    transform$1(gfx, rotate);
  }
  function GraphicsFactory(eventBus, elementRegistry) {
    this._eventBus = eventBus;
    this._elementRegistry = elementRegistry;
  }
  GraphicsFactory.$inject = ['eventBus', 'elementRegistry'];
  GraphicsFactory.prototype._getChildrenContainer = function (element) {
    var gfx = this._elementRegistry.getGraphics(element);
    var childrenGfx;
    if (!element.parent) {
      childrenGfx = gfx;
    } else {
      childrenGfx = getChildren$1(gfx);
      if (!childrenGfx) {
        childrenGfx = create$1('g');
        classes(childrenGfx).add('djs-children');
        append(gfx.parentNode, childrenGfx);
      }
    }
    return childrenGfx;
  };
  GraphicsFactory.prototype._clear = function (gfx) {
    var visual = getVisual(gfx);
    clear$1(visual);
    return visual;
  };
  GraphicsFactory.prototype._createContainer = function (type, childrenGfx, parentIndex, isFrame) {
    var outerGfx = create$1('g');
    classes(outerGfx).add('djs-group');
    if (typeof parentIndex !== 'undefined') {
      prependTo(outerGfx, childrenGfx, childrenGfx.childNodes[parentIndex]);
    } else {
      append(childrenGfx, outerGfx);
    }
    var gfx = create$1('g');
    classes(gfx).add('djs-element');
    classes(gfx).add('djs-' + type);
    if (isFrame) {
      classes(gfx).add('djs-frame');
    }
    append(outerGfx, gfx);
    var visual = create$1('g');
    classes(visual).add('djs-visual');
    append(gfx, visual);
    return gfx;
  };
  GraphicsFactory.prototype.create = function (type, element, parentIndex) {
    var childrenGfx = this._getChildrenContainer(element.parent);
    return this._createContainer(type, childrenGfx, parentIndex, isFrameElement$1(element));
  };
  GraphicsFactory.prototype.updateContainments = function (elements) {
    var self = this,
      elementRegistry = this._elementRegistry,
      parents;
    parents = reduce(elements, function (map, e) {
      if (e.parent) {
        map[e.parent.id] = e.parent;
      }
      return map;
    }, {});
    forEach$1(parents, function (parent) {
      var children = parent.children;
      if (!children) {
        return;
      }
      var childrenGfx = self._getChildrenContainer(parent);
      forEach$1(children.slice().reverse(), function (child) {
        var childGfx = elementRegistry.getGraphics(child);
        prependTo(childGfx.parentNode, childrenGfx);
      });
    });
  };
  GraphicsFactory.prototype.drawShape = function (visual, element) {
    var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var eventBus = this._eventBus;
    return eventBus.fire('render.shape', {
      gfx: visual,
      element,
      attrs
    });
  };
  GraphicsFactory.prototype.getShapePath = function (element) {
    var eventBus = this._eventBus;
    return eventBus.fire('render.getShapePath', element);
  };
  GraphicsFactory.prototype.drawConnection = function (visual, element) {
    var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var eventBus = this._eventBus;
    return eventBus.fire('render.connection', {
      gfx: visual,
      element,
      attrs
    });
  };
  GraphicsFactory.prototype.getConnectionPath = function (connection) {
    var eventBus = this._eventBus;
    return eventBus.fire('render.getConnectionPath', connection);
  };
  GraphicsFactory.prototype.update = function (type, element, gfx) {
    if (!element.parent) {
      return;
    }
    var visual = this._clear(gfx);
    if (type === 'shape') {
      this.drawShape(visual, element);
      translate$1(gfx, element.x, element.y);
    } else if (type === 'connection') {
      this.drawConnection(visual, element);
    } else {
      throw new Error('unknown type: ' + type);
    }
    if (element.hidden) {
      attr(gfx, 'display', 'none');
    } else {
      attr(gfx, 'display', 'block');
    }
  };
  GraphicsFactory.prototype.remove = function (element) {
    var gfx = this._elementRegistry.getGraphics(element);
    remove$1(gfx.parentNode);
  };
  function prependTo(newNode, parentNode, siblingNode) {
    var node = siblingNode || parentNode.firstChild;
    if (newNode === node) {
      return;
    }
    parentNode.insertBefore(newNode, node);
  }
  var CoreModule$1 = {
    __depends__: [DrawModule$1],
    __init__: ['canvas'],
    canvas: ['type', Canvas],
    elementRegistry: ['type', ElementRegistry],
    elementFactory: ['type', ElementFactory$1],
    eventBus: ['type', EventBus],
    graphicsFactory: ['type', GraphicsFactory]
  };
  function bootstrap(modules) {
    var injector = new Injector(modules);
    injector.init();
    return injector;
  }
  function createInjector(options) {
    options = options || {};
    var configModule = {
      'config': ['value', options]
    };
    var modules = [configModule, CoreModule$1].concat(options.modules || []);
    return bootstrap(modules);
  }
  function Diagram(options, injector) {
    this._injector = injector || createInjector(options);
    this.get('eventBus').fire('diagram.init');
  }
  Diagram.prototype.get = function (name, strict) {
    return this._injector.get(name, strict);
  };
  Diagram.prototype.invoke = function (func, context, locals) {
    return this._injector.invoke(func, context, locals);
  };
  Diagram.prototype.destroy = function () {
    this.get('eventBus').fire('diagram.destroy');
  };
  Diagram.prototype.clear = function () {
    this.get('eventBus').fire('diagram.clear');
  };
  function Base() {}
  Base.prototype.get = function (name) {
    return this.$model.properties.get(this, name);
  };
  Base.prototype.set = function (name, value) {
    this.$model.properties.set(this, name, value);
  };
  function Factory(model, properties) {
    this.model = model;
    this.properties = properties;
  }
  Factory.prototype.createType = function (descriptor) {
    var model = this.model;
    var props = this.properties,
      prototype = Object.create(Base.prototype);
    forEach$1(descriptor.properties, function (p) {
      if (!p.isMany && p.default !== undefined) {
        prototype[p.name] = p.default;
      }
    });
    props.defineModel(prototype, model);
    props.defineDescriptor(prototype, descriptor);
    var name = descriptor.ns.name;
    function ModdleElement(attrs) {
      props.define(this, '$type', {
        value: name,
        enumerable: true
      });
      props.define(this, '$attrs', {
        value: {}
      });
      props.define(this, '$parent', {
        writable: true
      });
      forEach$1(attrs, bind$2(function (val, key) {
        this.set(key, val);
      }, this));
    }
    ModdleElement.prototype = prototype;
    ModdleElement.hasType = prototype.$instanceOf = this.model.hasType;
    props.defineModel(ModdleElement, model);
    props.defineDescriptor(ModdleElement, descriptor);
    return ModdleElement;
  };
  var BUILTINS = {
    String: true,
    Boolean: true,
    Integer: true,
    Real: true,
    Element: true
  };
  var TYPE_CONVERTERS = {
    String: function String(s) {
      return s;
    },
    Boolean: function Boolean(s) {
      return s === 'true';
    },
    Integer: function Integer(s) {
      return parseInt(s, 10);
    },
    Real: function Real(s) {
      return parseFloat(s);
    }
  };
  function coerceType(type, value) {
    var converter = TYPE_CONVERTERS[type];
    if (converter) {
      return converter(value);
    } else {
      return value;
    }
  }
  function isBuiltIn(type) {
    return !!BUILTINS[type];
  }
  function isSimple(type) {
    return !!TYPE_CONVERTERS[type];
  }
  function parseName(name, defaultPrefix) {
    var parts = name.split(/:/),
      localName,
      prefix;
    if (parts.length === 1) {
      localName = name;
      prefix = defaultPrefix;
    } else if (parts.length === 2) {
      localName = parts[1];
      prefix = parts[0];
    } else {
      throw new Error('expected <prefix:localName> or <localName>, got ' + name);
    }
    name = (prefix ? prefix + ':' : '') + localName;
    return {
      name: name,
      prefix: prefix,
      localName: localName
    };
  }
  function DescriptorBuilder(nameNs) {
    this.ns = nameNs;
    this.name = nameNs.name;
    this.allTypes = [];
    this.allTypesByName = {};
    this.properties = [];
    this.propertiesByName = {};
  }
  DescriptorBuilder.prototype.build = function () {
    return pick(this, ['ns', 'name', 'allTypes', 'allTypesByName', 'properties', 'propertiesByName', 'bodyProperty', 'idProperty']);
  };
  DescriptorBuilder.prototype.addProperty = function (p, idx, validate) {
    if (typeof idx === 'boolean') {
      validate = idx;
      idx = undefined;
    }
    this.addNamedProperty(p, validate !== false);
    var properties = this.properties;
    if (idx !== undefined) {
      properties.splice(idx, 0, p);
    } else {
      properties.push(p);
    }
  };
  DescriptorBuilder.prototype.replaceProperty = function (oldProperty, newProperty, replace) {
    var oldNameNs = oldProperty.ns;
    var props = this.properties,
      propertiesByName = this.propertiesByName,
      rename = oldProperty.name !== newProperty.name;
    if (oldProperty.isId) {
      if (!newProperty.isId) {
        throw new Error('property <' + newProperty.ns.name + '> must be id property ' + 'to refine <' + oldProperty.ns.name + '>');
      }
      this.setIdProperty(newProperty, false);
    }
    if (oldProperty.isBody) {
      if (!newProperty.isBody) {
        throw new Error('property <' + newProperty.ns.name + '> must be body property ' + 'to refine <' + oldProperty.ns.name + '>');
      }
      this.setBodyProperty(newProperty, false);
    }
    var idx = props.indexOf(oldProperty);
    if (idx === -1) {
      throw new Error('property <' + oldNameNs.name + '> not found in property list');
    }
    props.splice(idx, 1);
    this.addProperty(newProperty, replace ? undefined : idx, rename);
    propertiesByName[oldNameNs.name] = propertiesByName[oldNameNs.localName] = newProperty;
  };
  DescriptorBuilder.prototype.redefineProperty = function (p, targetPropertyName, replace) {
    var nsPrefix = p.ns.prefix;
    var parts = targetPropertyName.split('#');
    var name = parseName(parts[0], nsPrefix);
    var attrName = parseName(parts[1], name.prefix).name;
    var redefinedProperty = this.propertiesByName[attrName];
    if (!redefinedProperty) {
      throw new Error('refined property <' + attrName + '> not found');
    } else {
      this.replaceProperty(redefinedProperty, p, replace);
    }
    delete p.redefines;
  };
  DescriptorBuilder.prototype.addNamedProperty = function (p, validate) {
    var ns = p.ns,
      propsByName = this.propertiesByName;
    if (validate) {
      this.assertNotDefined(p, ns.name);
      this.assertNotDefined(p, ns.localName);
    }
    propsByName[ns.name] = propsByName[ns.localName] = p;
  };
  DescriptorBuilder.prototype.removeNamedProperty = function (p) {
    var ns = p.ns,
      propsByName = this.propertiesByName;
    delete propsByName[ns.name];
    delete propsByName[ns.localName];
  };
  DescriptorBuilder.prototype.setBodyProperty = function (p, validate) {
    if (validate && this.bodyProperty) {
      throw new Error('body property defined multiple times ' + '(<' + this.bodyProperty.ns.name + '>, <' + p.ns.name + '>)');
    }
    this.bodyProperty = p;
  };
  DescriptorBuilder.prototype.setIdProperty = function (p, validate) {
    if (validate && this.idProperty) {
      throw new Error('id property defined multiple times ' + '(<' + this.idProperty.ns.name + '>, <' + p.ns.name + '>)');
    }
    this.idProperty = p;
  };
  DescriptorBuilder.prototype.assertNotTrait = function (typeDescriptor) {
    var _extends = typeDescriptor.extends || [];
    if (_extends.length) {
      throw new Error(`cannot create <${typeDescriptor.name}> extending <${typeDescriptor.extends}>`);
    }
  };
  DescriptorBuilder.prototype.assertNotDefined = function (p, name) {
    var propertyName = p.name,
      definedProperty = this.propertiesByName[propertyName];
    if (definedProperty) {
      throw new Error('property <' + propertyName + '> already defined; ' + 'override of <' + definedProperty.definedBy.ns.name + '#' + definedProperty.ns.name + '> by ' + '<' + p.definedBy.ns.name + '#' + p.ns.name + '> not allowed without redefines');
    }
  };
  DescriptorBuilder.prototype.hasProperty = function (name) {
    return this.propertiesByName[name];
  };
  DescriptorBuilder.prototype.addTrait = function (t, inherited) {
    if (inherited) {
      this.assertNotTrait(t);
    }
    var typesByName = this.allTypesByName,
      types = this.allTypes;
    var typeName = t.name;
    if (typeName in typesByName) {
      return;
    }
    forEach$1(t.properties, bind$2(function (p) {
      p = assign$1({}, p, {
        name: p.ns.localName,
        inherited: inherited
      });
      Object.defineProperty(p, 'definedBy', {
        value: t
      });
      var replaces = p.replaces,
        redefines = p.redefines;
      if (replaces || redefines) {
        this.redefineProperty(p, replaces || redefines, replaces);
      } else {
        if (p.isBody) {
          this.setBodyProperty(p);
        }
        if (p.isId) {
          this.setIdProperty(p);
        }
        this.addProperty(p);
      }
    }, this));
    types.push(t);
    typesByName[typeName] = t;
  };
  function Registry(packages, properties) {
    this.packageMap = {};
    this.typeMap = {};
    this.packages = [];
    this.properties = properties;
    forEach$1(packages, bind$2(this.registerPackage, this));
  }
  Registry.prototype.getPackage = function (uriOrPrefix) {
    return this.packageMap[uriOrPrefix];
  };
  Registry.prototype.getPackages = function () {
    return this.packages;
  };
  Registry.prototype.registerPackage = function (pkg) {
    pkg = assign$1({}, pkg);
    var pkgMap = this.packageMap;
    ensureAvailable(pkgMap, pkg, 'prefix');
    ensureAvailable(pkgMap, pkg, 'uri');
    forEach$1(pkg.types, bind$2(function (descriptor) {
      this.registerType(descriptor, pkg);
    }, this));
    pkgMap[pkg.uri] = pkgMap[pkg.prefix] = pkg;
    this.packages.push(pkg);
  };
  Registry.prototype.registerType = function (type, pkg) {
    type = assign$1({}, type, {
      superClass: (type.superClass || []).slice(),
      extends: (type.extends || []).slice(),
      properties: (type.properties || []).slice(),
      meta: assign$1(type.meta || {})
    });
    var ns = parseName(type.name, pkg.prefix),
      name = ns.name,
      propertiesByName = {};
    forEach$1(type.properties, bind$2(function (p) {
      var propertyNs = parseName(p.name, ns.prefix),
        propertyName = propertyNs.name;
      if (!isBuiltIn(p.type)) {
        p.type = parseName(p.type, propertyNs.prefix).name;
      }
      assign$1(p, {
        ns: propertyNs,
        name: propertyName
      });
      propertiesByName[propertyName] = p;
    }, this));
    assign$1(type, {
      ns: ns,
      name: name,
      propertiesByName: propertiesByName
    });
    forEach$1(type.extends, bind$2(function (extendsName) {
      var extendsNameNs = parseName(extendsName, ns.prefix);
      var extended = this.typeMap[extendsNameNs.name];
      extended.traits = extended.traits || [];
      extended.traits.push(name);
    }, this));
    this.definePackage(type, pkg);
    this.typeMap[name] = type;
  };
  Registry.prototype.mapTypes = function (nsName, iterator, trait) {
    var type = isBuiltIn(nsName.name) ? {
      name: nsName.name
    } : this.typeMap[nsName.name];
    var self = this;
    function traverse(cls, trait) {
      var parentNs = parseName(cls, isBuiltIn(cls) ? '' : nsName.prefix);
      self.mapTypes(parentNs, iterator, trait);
    }
    function traverseTrait(cls) {
      return traverse(cls, true);
    }
    function traverseSuper(cls) {
      return traverse(cls, false);
    }
    if (!type) {
      throw new Error('unknown type <' + nsName.name + '>');
    }
    forEach$1(type.superClass, trait ? traverseTrait : traverseSuper);
    iterator(type, !trait);
    forEach$1(type.traits, traverseTrait);
  };
  Registry.prototype.getEffectiveDescriptor = function (name) {
    var nsName = parseName(name);
    var builder = new DescriptorBuilder(nsName);
    this.mapTypes(nsName, function (type, inherited) {
      builder.addTrait(type, inherited);
    });
    var descriptor = builder.build();
    this.definePackage(descriptor, descriptor.allTypes[descriptor.allTypes.length - 1].$pkg);
    return descriptor;
  };
  Registry.prototype.definePackage = function (target, pkg) {
    this.properties.define(target, '$pkg', {
      value: pkg
    });
  };
  function ensureAvailable(packageMap, pkg, identifierKey) {
    var value = pkg[identifierKey];
    if (value in packageMap) {
      throw new Error('package with ' + identifierKey + ' <' + value + '> already defined');
    }
  }
  function Properties(model) {
    this.model = model;
  }
  Properties.prototype.set = function (target, name, value) {
    if (!isString(name) || !name.length) {
      throw new TypeError('property name must be a non-empty string');
    }
    var property = this.getProperty(target, name);
    var propertyName = property && property.name;
    if (isUndefined(value)) {
      if (property) {
        delete target[propertyName];
      } else {
        delete target.$attrs[stripGlobal(name)];
      }
    } else {
      if (property) {
        if (propertyName in target) {
          target[propertyName] = value;
        } else {
          defineProperty(target, property, value);
        }
      } else {
        target.$attrs[stripGlobal(name)] = value;
      }
    }
  };
  Properties.prototype.get = function (target, name) {
    var property = this.getProperty(target, name);
    if (!property) {
      return target.$attrs[stripGlobal(name)];
    }
    var propertyName = property.name;
    if (!target[propertyName] && property.isMany) {
      defineProperty(target, property, []);
    }
    return target[propertyName];
  };
  Properties.prototype.define = function (target, name, options) {
    if (!options.writable) {
      var value = options.value;
      options = assign$1({}, options, {
        get: function get() {
          return value;
        }
      });
      delete options.value;
    }
    Object.defineProperty(target, name, options);
  };
  Properties.prototype.defineDescriptor = function (target, descriptor) {
    this.define(target, '$descriptor', {
      value: descriptor
    });
  };
  Properties.prototype.defineModel = function (target, model) {
    this.define(target, '$model', {
      value: model
    });
  };
  Properties.prototype.getProperty = function (target, name) {
    var model = this.model;
    var property = model.getPropertyDescriptor(target, name);
    if (property) {
      return property;
    }
    if (name.includes(':')) {
      return null;
    }
    var strict = model.config.strict;
    if (typeof strict !== 'undefined') {
      var _error = new TypeError(`unknown property <${name}> on <${target.$type}>`);
      if (strict) {
        throw _error;
      } else {
        typeof console !== 'undefined' && console.warn(_error);
      }
    }
    return null;
  };
  function isUndefined(val) {
    return typeof val === 'undefined';
  }
  function defineProperty(target, property, value) {
    Object.defineProperty(target, property.name, {
      enumerable: !property.isReference,
      writable: true,
      value: value,
      configurable: true
    });
  }
  function stripGlobal(name) {
    return name.replace(/^:/, '');
  }
  function Moddle(packages) {
    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.properties = new Properties(this);
    this.factory = new Factory(this, this.properties);
    this.registry = new Registry(packages, this.properties);
    this.typeCache = {};
    this.config = config;
  }
  Moddle.prototype.create = function (descriptor, attrs) {
    var Type = this.getType(descriptor);
    if (!Type) {
      throw new Error('unknown type <' + descriptor + '>');
    }
    return new Type(attrs);
  };
  Moddle.prototype.getType = function (descriptor) {
    var cache = this.typeCache;
    var name = isString(descriptor) ? descriptor : descriptor.ns.name;
    var type = cache[name];
    if (!type) {
      descriptor = this.registry.getEffectiveDescriptor(name);
      type = cache[name] = this.factory.createType(descriptor);
    }
    return type;
  };
  Moddle.prototype.createAny = function (name, nsUri, properties) {
    var nameNs = parseName(name);
    var element = {
      $type: name,
      $instanceOf: function $instanceOf(type) {
        return type === this.$type;
      },
      get: function get(key) {
        return this[key];
      },
      set: function set(key, value) {
        set$1(this, [key], value);
      }
    };
    var descriptor = {
      name: name,
      isGeneric: true,
      ns: {
        prefix: nameNs.prefix,
        localName: nameNs.localName,
        uri: nsUri
      }
    };
    this.properties.defineDescriptor(element, descriptor);
    this.properties.defineModel(element, this);
    this.properties.define(element, 'get', {
      enumerable: false,
      writable: true
    });
    this.properties.define(element, 'set', {
      enumerable: false,
      writable: true
    });
    this.properties.define(element, '$parent', {
      enumerable: false,
      writable: true
    });
    this.properties.define(element, '$instanceOf', {
      enumerable: false,
      writable: true
    });
    forEach$1(properties, function (a, key) {
      if (isObject(a) && a.value !== undefined) {
        element[a.name] = a.value;
      } else {
        element[key] = a;
      }
    });
    return element;
  };
  Moddle.prototype.getPackage = function (uriOrPrefix) {
    return this.registry.getPackage(uriOrPrefix);
  };
  Moddle.prototype.getPackages = function () {
    return this.registry.getPackages();
  };
  Moddle.prototype.getElementDescriptor = function (element) {
    return element.$descriptor;
  };
  Moddle.prototype.hasType = function (element, type) {
    if (type === undefined) {
      type = element;
      element = this;
    }
    var descriptor = element.$model.getElementDescriptor(element);
    return type in descriptor.allTypesByName;
  };
  Moddle.prototype.getPropertyDescriptor = function (element, property) {
    return this.getElementDescriptor(element).propertiesByName[property];
  };
  Moddle.prototype.getTypeDescriptor = function (type) {
    return this.registry.typeMap[type];
  };
  var fromCharCode = String.fromCharCode;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var ENTITY_PATTERN = /&#(\d+);|&#x([0-9a-f]+);|&(\w+);/ig;
  var ENTITY_MAPPING = {
    'amp': '&',
    'apos': '\'',
    'gt': '>',
    'lt': '<',
    'quot': '"'
  };
  Object.keys(ENTITY_MAPPING).forEach(function (k) {
    ENTITY_MAPPING[k.toUpperCase()] = ENTITY_MAPPING[k];
  });
  function replaceEntities(_, d, x, z) {
    if (z) {
      if (hasOwnProperty.call(ENTITY_MAPPING, z)) {
        return ENTITY_MAPPING[z];
      } else {
        return '&' + z + ';';
      }
    }
    if (d) {
      return fromCharCode(d);
    }
    return fromCharCode(parseInt(x, 16));
  }
  function decodeEntities(s) {
    if (s.length > 3 && s.indexOf('&') !== -1) {
      return s.replace(ENTITY_PATTERN, replaceEntities);
    }
    return s;
  }
  var NON_WHITESPACE_OUTSIDE_ROOT_NODE = 'non-whitespace outside of root node';
  function error$2(msg) {
    return new Error(msg);
  }
  function missingNamespaceForPrefix(prefix) {
    return 'missing namespace for prefix <' + prefix + '>';
  }
  function getter(getFn) {
    return {
      'get': getFn,
      'enumerable': true
    };
  }
  function cloneNsMatrix(nsMatrix) {
    var clone = {},
      key;
    for (key in nsMatrix) {
      clone[key] = nsMatrix[key];
    }
    return clone;
  }
  function uriPrefix(prefix) {
    return prefix + '$uri';
  }
  function buildNsMatrix(nsUriToPrefix) {
    var nsMatrix = {},
      uri,
      prefix;
    for (uri in nsUriToPrefix) {
      prefix = nsUriToPrefix[uri];
      nsMatrix[prefix] = prefix;
      nsMatrix[uriPrefix(prefix)] = uri;
    }
    return nsMatrix;
  }
  function noopGetContext() {
    return {
      line: 0,
      column: 0
    };
  }
  function throwFunc(err) {
    throw err;
  }
  function Parser(options) {
    if (!this) {
      return new Parser(options);
    }
    var proxy = options && options['proxy'];
    var onText,
      onOpenTag,
      onCloseTag,
      onCDATA,
      onError = throwFunc,
      onWarning,
      onComment,
      onQuestion,
      onAttention;
    var getContext = noopGetContext;
    var maybeNS = false;
    var isNamespace = false;
    var returnError = null;
    var parseStop = false;
    var nsUriToPrefix;
    function handleError(err) {
      if (!(err instanceof Error)) {
        err = error$2(err);
      }
      returnError = err;
      onError(err, getContext);
    }
    function handleWarning(err) {
      if (!onWarning) {
        return;
      }
      if (!(err instanceof Error)) {
        err = error$2(err);
      }
      onWarning(err, getContext);
    }
    this['on'] = function (name, cb) {
      if (typeof cb !== 'function') {
        throw error$2('required args <name, cb>');
      }
      switch (name) {
        case 'openTag':
          onOpenTag = cb;
          break;
        case 'text':
          onText = cb;
          break;
        case 'closeTag':
          onCloseTag = cb;
          break;
        case 'error':
          onError = cb;
          break;
        case 'warn':
          onWarning = cb;
          break;
        case 'cdata':
          onCDATA = cb;
          break;
        case 'attention':
          onAttention = cb;
          break;
        case 'question':
          onQuestion = cb;
          break;
        case 'comment':
          onComment = cb;
          break;
        default:
          throw error$2('unsupported event: ' + name);
      }
      return this;
    };
    this['ns'] = function (nsMap) {
      if (typeof nsMap === 'undefined') {
        nsMap = {};
      }
      if (typeof nsMap !== 'object') {
        throw error$2('required args <nsMap={}>');
      }
      var _nsUriToPrefix = {},
        k;
      for (k in nsMap) {
        _nsUriToPrefix[k] = nsMap[k];
      }
      isNamespace = true;
      nsUriToPrefix = _nsUriToPrefix;
      return this;
    };
    this['parse'] = function (xml) {
      if (typeof xml !== 'string') {
        throw error$2('required args <xml=string>');
      }
      returnError = null;
      parse(xml);
      getContext = noopGetContext;
      parseStop = false;
      return returnError;
    };
    this['stop'] = function () {
      parseStop = true;
    };
    function parse(xml) {
      var nsMatrixStack = isNamespace ? [] : null,
        nsMatrix = isNamespace ? buildNsMatrix(nsUriToPrefix) : null,
        _nsMatrix,
        nodeStack = [],
        anonymousNsCount = 0,
        tagStart = false,
        tagEnd = false,
        i = 0,
        j = 0,
        x,
        y,
        q,
        w,
        v,
        xmlns,
        elementName,
        _elementName,
        elementProxy;
      var attrsString = '',
        attrsStart = 0,
        cachedAttrs;
      function getAttrs() {
        if (cachedAttrs !== null) {
          return cachedAttrs;
        }
        var nsUri,
          nsUriPrefix,
          nsName,
          defaultAlias = isNamespace && nsMatrix['xmlns'],
          attrList = isNamespace && maybeNS ? [] : null,
          i = attrsStart,
          s = attrsString,
          l = s.length,
          hasNewMatrix,
          newalias,
          value,
          alias,
          name,
          attrs = {},
          seenAttrs = {},
          skipAttr,
          w,
          j;
        parseAttr: for (; i < l; i++) {
          skipAttr = false;
          w = s.charCodeAt(i);
          if (w === 32 || w < 14 && w > 8) {
            continue;
          }
          if (w < 65 || w > 122 || w > 90 && w < 97) {
            if (w !== 95 && w !== 58) {
              handleWarning('illegal first char attribute name');
              skipAttr = true;
            }
          }
          for (j = i + 1; j < l; j++) {
            w = s.charCodeAt(j);
            if (w > 96 && w < 123 || w > 64 && w < 91 || w > 47 && w < 59 || w === 46 || w === 45 || w === 95) {
              continue;
            }
            if (w === 32 || w < 14 && w > 8) {
              handleWarning('missing attribute value');
              i = j;
              continue parseAttr;
            }
            if (w === 61) {
              break;
            }
            handleWarning('illegal attribute name char');
            skipAttr = true;
          }
          name = s.substring(i, j);
          if (name === 'xmlns:xmlns') {
            handleWarning('illegal declaration of xmlns');
            skipAttr = true;
          }
          w = s.charCodeAt(j + 1);
          if (w === 34) {
            j = s.indexOf('"', i = j + 2);
            if (j === -1) {
              j = s.indexOf('\'', i);
              if (j !== -1) {
                handleWarning('attribute value quote missmatch');
                skipAttr = true;
              }
            }
          } else if (w === 39) {
            j = s.indexOf('\'', i = j + 2);
            if (j === -1) {
              j = s.indexOf('"', i);
              if (j !== -1) {
                handleWarning('attribute value quote missmatch');
                skipAttr = true;
              }
            }
          } else {
            handleWarning('missing attribute value quotes');
            skipAttr = true;
            for (j = j + 1; j < l; j++) {
              w = s.charCodeAt(j + 1);
              if (w === 32 || w < 14 && w > 8) {
                break;
              }
            }
          }
          if (j === -1) {
            handleWarning('missing closing quotes');
            j = l;
            skipAttr = true;
          }
          if (!skipAttr) {
            value = s.substring(i, j);
          }
          i = j;
          for (; j + 1 < l; j++) {
            w = s.charCodeAt(j + 1);
            if (w === 32 || w < 14 && w > 8) {
              break;
            }
            if (i === j) {
              handleWarning('illegal character after attribute end');
              skipAttr = true;
            }
          }
          i = j + 1;
          if (skipAttr) {
            continue parseAttr;
          }
          if (name in seenAttrs) {
            handleWarning('attribute <' + name + '> already defined');
            continue;
          }
          seenAttrs[name] = true;
          if (!isNamespace) {
            attrs[name] = value;
            continue;
          }
          if (maybeNS) {
            newalias = name === 'xmlns' ? 'xmlns' : name.charCodeAt(0) === 120 && name.substr(0, 6) === 'xmlns:' ? name.substr(6) : null;
            if (newalias !== null) {
              nsUri = decodeEntities(value);
              nsUriPrefix = uriPrefix(newalias);
              alias = nsUriToPrefix[nsUri];
              if (!alias) {
                if (newalias === 'xmlns' || nsUriPrefix in nsMatrix && nsMatrix[nsUriPrefix] !== nsUri) {
                  do {
                    alias = 'ns' + anonymousNsCount++;
                  } while (typeof nsMatrix[alias] !== 'undefined');
                } else {
                  alias = newalias;
                }
                nsUriToPrefix[nsUri] = alias;
              }
              if (nsMatrix[newalias] !== alias) {
                if (!hasNewMatrix) {
                  nsMatrix = cloneNsMatrix(nsMatrix);
                  hasNewMatrix = true;
                }
                nsMatrix[newalias] = alias;
                if (newalias === 'xmlns') {
                  nsMatrix[uriPrefix(alias)] = nsUri;
                  defaultAlias = alias;
                }
                nsMatrix[nsUriPrefix] = nsUri;
              }
              attrs[name] = value;
              continue;
            }
            attrList.push(name, value);
            continue;
          }
          w = name.indexOf(':');
          if (w === -1) {
            attrs[name] = value;
            continue;
          }
          if (!(nsName = nsMatrix[name.substring(0, w)])) {
            handleWarning(missingNamespaceForPrefix(name.substring(0, w)));
            continue;
          }
          name = defaultAlias === nsName ? name.substr(w + 1) : nsName + name.substr(w);
          attrs[name] = value;
        }
        if (maybeNS) {
          for (i = 0, l = attrList.length; i < l; i++) {
            name = attrList[i++];
            value = attrList[i];
            w = name.indexOf(':');
            if (w !== -1) {
              if (!(nsName = nsMatrix[name.substring(0, w)])) {
                handleWarning(missingNamespaceForPrefix(name.substring(0, w)));
                continue;
              }
              name = defaultAlias === nsName ? name.substr(w + 1) : nsName + name.substr(w);
            }
            attrs[name] = value;
          }
        }
        return cachedAttrs = attrs;
      }
      function getParseContext() {
        var splitsRe = /(\r\n|\r|\n)/g;
        var line = 0;
        var column = 0;
        var startOfLine = 0;
        var endOfLine = j;
        var match;
        var data;
        while (i >= startOfLine) {
          match = splitsRe.exec(xml);
          if (!match) {
            break;
          }
          endOfLine = match[0].length + match.index;
          if (endOfLine > i) {
            break;
          }
          line += 1;
          startOfLine = endOfLine;
        }
        if (i == -1) {
          column = endOfLine;
          data = xml.substring(j);
        } else if (j === 0) {
            data = xml.substring(j, i);
          } else {
            column = i - startOfLine;
            data = j == -1 ? xml.substring(i) : xml.substring(i, j + 1);
          }
        return {
          'data': data,
          'line': line,
          'column': column
        };
      }
      getContext = getParseContext;
      if (proxy) {
        elementProxy = Object.create({}, {
          'name': getter(function () {
            return elementName;
          }),
          'originalName': getter(function () {
            return _elementName;
          }),
          'attrs': getter(getAttrs),
          'ns': getter(function () {
            return nsMatrix;
          })
        });
      }
      while (j !== -1) {
        if (xml.charCodeAt(j) === 60) {
          i = j;
        } else {
          i = xml.indexOf('<', j);
        }
        if (i === -1) {
          if (nodeStack.length) {
            return handleError('unexpected end of file');
          }
          if (j === 0) {
            return handleError('missing start tag');
          }
          if (j < xml.length) {
            if (xml.substring(j).trim()) {
              handleWarning(NON_WHITESPACE_OUTSIDE_ROOT_NODE);
            }
          }
          return;
        }
        if (j !== i) {
          if (nodeStack.length) {
            if (onText) {
              onText(xml.substring(j, i), decodeEntities, getContext);
              if (parseStop) {
                return;
              }
            }
          } else {
            if (xml.substring(j, i).trim()) {
              handleWarning(NON_WHITESPACE_OUTSIDE_ROOT_NODE);
              if (parseStop) {
                return;
              }
            }
          }
        }
        w = xml.charCodeAt(i + 1);
        if (w === 33) {
          q = xml.charCodeAt(i + 2);
          if (q === 91 && xml.substr(i + 3, 6) === 'CDATA[') {
            j = xml.indexOf(']]>', i);
            if (j === -1) {
              return handleError('unclosed cdata');
            }
            if (onCDATA) {
              onCDATA(xml.substring(i + 9, j), getContext);
              if (parseStop) {
                return;
              }
            }
            j += 3;
            continue;
          }
          if (q === 45 && xml.charCodeAt(i + 3) === 45) {
            j = xml.indexOf('-->', i);
            if (j === -1) {
              return handleError('unclosed comment');
            }
            if (onComment) {
              onComment(xml.substring(i + 4, j), decodeEntities, getContext);
              if (parseStop) {
                return;
              }
            }
            j += 3;
            continue;
          }
        }
        if (w === 63) {
          j = xml.indexOf('?>', i);
          if (j === -1) {
            return handleError('unclosed question');
          }
          if (onQuestion) {
            onQuestion(xml.substring(i, j + 2), getContext);
            if (parseStop) {
              return;
            }
          }
          j += 2;
          continue;
        }
        for (x = i + 1;; x++) {
          v = xml.charCodeAt(x);
          if (isNaN(v)) {
            j = -1;
            return handleError('unclosed tag');
          }
          if (v === 34) {
            q = xml.indexOf('"', x + 1);
            x = q !== -1 ? q : x;
          } else if (v === 39) {
            q = xml.indexOf("'", x + 1);
            x = q !== -1 ? q : x;
          } else if (v === 62) {
            j = x;
            break;
          }
        }
        if (w === 33) {
          if (onAttention) {
            onAttention(xml.substring(i, j + 1), decodeEntities, getContext);
            if (parseStop) {
              return;
            }
          }
          j += 1;
          continue;
        }
        cachedAttrs = {};
        if (w === 47) {
          tagStart = false;
          tagEnd = true;
          if (!nodeStack.length) {
            return handleError('missing open tag');
          }
          x = elementName = nodeStack.pop();
          q = i + 2 + x.length;
          if (xml.substring(i + 2, q) !== x) {
            return handleError('closing tag mismatch');
          }
          for (; q < j; q++) {
            w = xml.charCodeAt(q);
            if (w === 32 || w > 8 && w < 14) {
              continue;
            }
            return handleError('close tag');
          }
        } else {
          if (xml.charCodeAt(j - 1) === 47) {
            x = elementName = xml.substring(i + 1, j - 1);
            tagStart = true;
            tagEnd = true;
          } else {
            x = elementName = xml.substring(i + 1, j);
            tagStart = true;
            tagEnd = false;
          }
          if (!(w > 96 && w < 123 || w > 64 && w < 91 || w === 95 || w === 58)) {
            return handleError('illegal first char nodeName');
          }
          for (q = 1, y = x.length; q < y; q++) {
            w = x.charCodeAt(q);
            if (w > 96 && w < 123 || w > 64 && w < 91 || w > 47 && w < 59 || w === 45 || w === 95 || w == 46) {
              continue;
            }
            if (w === 32 || w < 14 && w > 8) {
              elementName = x.substring(0, q);
              cachedAttrs = null;
              break;
            }
            return handleError('invalid nodeName');
          }
          if (!tagEnd) {
            nodeStack.push(elementName);
          }
        }
        if (isNamespace) {
          _nsMatrix = nsMatrix;
          if (tagStart) {
            if (!tagEnd) {
              nsMatrixStack.push(_nsMatrix);
            }
            if (cachedAttrs === null) {
              if (maybeNS = x.indexOf('xmlns', q) !== -1) {
                attrsStart = q;
                attrsString = x;
                getAttrs();
                maybeNS = false;
              }
            }
          }
          _elementName = elementName;
          w = elementName.indexOf(':');
          if (w !== -1) {
            xmlns = nsMatrix[elementName.substring(0, w)];
            if (!xmlns) {
              return handleError('missing namespace on <' + _elementName + '>');
            }
            elementName = elementName.substr(w + 1);
          } else {
            xmlns = nsMatrix['xmlns'];
          }
          if (xmlns) {
            elementName = xmlns + ':' + elementName;
          }
        }
        if (tagStart) {
          attrsStart = q;
          attrsString = x;
          if (onOpenTag) {
            if (proxy) {
              onOpenTag(elementProxy, decodeEntities, tagEnd, getContext);
            } else {
              onOpenTag(elementName, getAttrs, decodeEntities, tagEnd, getContext);
            }
            if (parseStop) {
              return;
            }
          }
        }
        if (tagEnd) {
          if (onCloseTag) {
            onCloseTag(proxy ? elementProxy : elementName, decodeEntities, tagStart, getContext);
            if (parseStop) {
              return;
            }
          }
          if (isNamespace) {
            if (!tagStart) {
              nsMatrix = nsMatrixStack.pop();
            } else {
              nsMatrix = _nsMatrix;
            }
          }
        }
        j += 1;
      }
    }
  }
  function hasLowerCaseAlias(pkg) {
    return pkg.xml && pkg.xml.tagAlias === 'lowerCase';
  }
  var DEFAULT_NS_MAP = {
    'xsi': 'http://www.w3.org/2001/XMLSchema-instance',
    'xml': 'http://www.w3.org/XML/1998/namespace'
  };
  var SERIALIZE_PROPERTY = 'property';
  function getSerialization(element) {
    return element.xml && element.xml.serialize;
  }
  function getSerializationType(element) {
    var type = getSerialization(element);
    return type !== SERIALIZE_PROPERTY && (type || null);
  }
  function capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
  function aliasToName(aliasNs, pkg) {
    if (!hasLowerCaseAlias(pkg)) {
      return aliasNs.name;
    }
    return aliasNs.prefix + ':' + capitalize(aliasNs.localName);
  }
  function prefixedToName(nameNs, pkg) {
    var name = nameNs.name,
      localName = nameNs.localName;
    var typePrefix = pkg && pkg.xml && pkg.xml.typePrefix;
    if (typePrefix && localName.indexOf(typePrefix) === 0) {
      return nameNs.prefix + ':' + localName.slice(typePrefix.length);
    } else {
      return name;
    }
  }
  function normalizeTypeName(name, nsMap, model) {
    var nameNs = parseName(name, nsMap.xmlns);
    var normalizedName = `${nsMap[nameNs.prefix] || nameNs.prefix}:${nameNs.localName}`;
    var normalizedNameNs = parseName(normalizedName);
    var pkg = model.getPackage(normalizedNameNs.prefix);
    return prefixedToName(normalizedNameNs, pkg);
  }
  function error$1(message) {
    return new Error(message);
  }
  function getModdleDescriptor(element) {
    return element.$descriptor;
  }
  function Context(options) {
    assign$1(this, options);
    this.elementsById = {};
    this.references = [];
    this.warnings = [];
    this.addReference = function (reference) {
      this.references.push(reference);
    };
    this.addElement = function (element) {
      if (!element) {
        throw error$1('expected element');
      }
      var elementsById = this.elementsById;
      var descriptor = getModdleDescriptor(element);
      var idProperty = descriptor.idProperty,
        id;
      if (idProperty) {
        id = element.get(idProperty.name);
        if (id) {
          if (!/^([a-z][\w-.]*:)?[a-z_][\w-.]*$/i.test(id)) {
            throw new Error('illegal ID <' + id + '>');
          }
          if (elementsById[id]) {
            throw error$1('duplicate ID <' + id + '>');
          }
          elementsById[id] = element;
        }
      }
    };
    this.addWarning = function (warning) {
      this.warnings.push(warning);
    };
  }
  function BaseHandler() {}
  BaseHandler.prototype.handleEnd = function () {};
  BaseHandler.prototype.handleText = function () {};
  BaseHandler.prototype.handleNode = function () {};
  function NoopHandler() {}
  NoopHandler.prototype = Object.create(BaseHandler.prototype);
  NoopHandler.prototype.handleNode = function () {
    return this;
  };
  function BodyHandler() {}
  BodyHandler.prototype = Object.create(BaseHandler.prototype);
  BodyHandler.prototype.handleText = function (text) {
    this.body = (this.body || '') + text;
  };
  function ReferenceHandler(property, context) {
    this.property = property;
    this.context = context;
  }
  ReferenceHandler.prototype = Object.create(BodyHandler.prototype);
  ReferenceHandler.prototype.handleNode = function (node) {
    if (this.element) {
      throw error$1('expected no sub nodes');
    } else {
      this.element = this.createReference(node);
    }
    return this;
  };
  ReferenceHandler.prototype.handleEnd = function () {
    this.element.id = this.body;
  };
  ReferenceHandler.prototype.createReference = function (node) {
    return {
      property: this.property.ns.name,
      id: ''
    };
  };
  function ValueHandler(propertyDesc, element) {
    this.element = element;
    this.propertyDesc = propertyDesc;
  }
  ValueHandler.prototype = Object.create(BodyHandler.prototype);
  ValueHandler.prototype.handleEnd = function () {
    var value = this.body || '',
      element = this.element,
      propertyDesc = this.propertyDesc;
    value = coerceType(propertyDesc.type, value);
    if (propertyDesc.isMany) {
      element.get(propertyDesc.name).push(value);
    } else {
      element.set(propertyDesc.name, value);
    }
  };
  function BaseElementHandler() {}
  BaseElementHandler.prototype = Object.create(BodyHandler.prototype);
  BaseElementHandler.prototype.handleNode = function (node) {
    var parser = this,
      element = this.element;
    if (!element) {
      element = this.element = this.createElement(node);
      this.context.addElement(element);
    } else {
      parser = this.handleChild(node);
    }
    return parser;
  };
  function ElementHandler(model, typeName, context) {
    this.model = model;
    this.type = model.getType(typeName);
    this.context = context;
  }
  ElementHandler.prototype = Object.create(BaseElementHandler.prototype);
  ElementHandler.prototype.addReference = function (reference) {
    this.context.addReference(reference);
  };
  ElementHandler.prototype.handleText = function (text) {
    var element = this.element,
      descriptor = getModdleDescriptor(element),
      bodyProperty = descriptor.bodyProperty;
    if (!bodyProperty) {
      throw error$1('unexpected body text <' + text + '>');
    }
    BodyHandler.prototype.handleText.call(this, text);
  };
  ElementHandler.prototype.handleEnd = function () {
    var value = this.body,
      element = this.element,
      descriptor = getModdleDescriptor(element),
      bodyProperty = descriptor.bodyProperty;
    if (bodyProperty && value !== undefined) {
      value = coerceType(bodyProperty.type, value);
      element.set(bodyProperty.name, value);
    }
  };
  ElementHandler.prototype.createElement = function (node) {
    var attributes = node.attributes,
      Type = this.type,
      descriptor = getModdleDescriptor(Type),
      context = this.context,
      instance = new Type({}),
      model = this.model,
      propNameNs;
    forEach$1(attributes, function (value, name) {
      var prop = descriptor.propertiesByName[name],
        values;
      if (prop && prop.isReference) {
        if (!prop.isMany) {
          context.addReference({
            element: instance,
            property: prop.ns.name,
            id: value
          });
        } else {
          values = value.split(' ');
          forEach$1(values, function (v) {
            context.addReference({
              element: instance,
              property: prop.ns.name,
              id: v
            });
          });
        }
      } else {
        if (prop) {
          value = coerceType(prop.type, value);
        } else if (name === 'xmlns') {
          name = ':' + name;
        } else {
          propNameNs = parseName(name, descriptor.ns.prefix);
          if (model.getPackage(propNameNs.prefix)) {
            context.addWarning({
              message: 'unknown attribute <' + name + '>',
              element: instance,
              property: name,
              value: value
            });
          }
        }
        instance.set(name, value);
      }
    });
    return instance;
  };
  ElementHandler.prototype.getPropertyForNode = function (node) {
    var name = node.name;
    var nameNs = parseName(name);
    var type = this.type,
      model = this.model,
      descriptor = getModdleDescriptor(type);
    var propertyName = nameNs.name,
      property = descriptor.propertiesByName[propertyName];
    if (property && !property.isAttr) {
      var serializationType = getSerializationType(property);
      if (serializationType) {
        var elementTypeName = node.attributes[serializationType];
        if (elementTypeName) {
          var normalizedTypeName = normalizeTypeName(elementTypeName, node.ns, model);
          var elementType = model.getType(normalizedTypeName);
          return assign$1({}, property, {
            effectiveType: getModdleDescriptor(elementType).name
          });
        }
      }
      return property;
    }
    var pkg = model.getPackage(nameNs.prefix);
    if (pkg) {
      var _elementTypeName = aliasToName(nameNs, pkg);
      var _elementType = model.getType(_elementTypeName);
      property = find(descriptor.properties, function (p) {
        return !p.isVirtual && !p.isReference && !p.isAttribute && _elementType.hasType(p.type);
      });
      if (property) {
        return assign$1({}, property, {
          effectiveType: getModdleDescriptor(_elementType).name
        });
      }
    } else {
      property = find(descriptor.properties, function (p) {
        return !p.isReference && !p.isAttribute && p.type === 'Element';
      });
      if (property) {
        return property;
      }
    }
    throw error$1('unrecognized element <' + nameNs.name + '>');
  };
  ElementHandler.prototype.toString = function () {
    return 'ElementDescriptor[' + getModdleDescriptor(this.type).name + ']';
  };
  ElementHandler.prototype.valueHandler = function (propertyDesc, element) {
    return new ValueHandler(propertyDesc, element);
  };
  ElementHandler.prototype.referenceHandler = function (propertyDesc) {
    return new ReferenceHandler(propertyDesc, this.context);
  };
  ElementHandler.prototype.handler = function (type) {
    if (type === 'Element') {
      return new GenericElementHandler(this.model, type, this.context);
    } else {
      return new ElementHandler(this.model, type, this.context);
    }
  };
  ElementHandler.prototype.handleChild = function (node) {
    var propertyDesc, type, element, childHandler;
    propertyDesc = this.getPropertyForNode(node);
    element = this.element;
    type = propertyDesc.effectiveType || propertyDesc.type;
    if (isSimple(type)) {
      return this.valueHandler(propertyDesc, element);
    }
    if (propertyDesc.isReference) {
      childHandler = this.referenceHandler(propertyDesc).handleNode(node);
    } else {
      childHandler = this.handler(type).handleNode(node);
    }
    var newElement = childHandler.element;
    if (newElement !== undefined) {
      if (propertyDesc.isMany) {
        element.get(propertyDesc.name).push(newElement);
      } else {
        element.set(propertyDesc.name, newElement);
      }
      if (propertyDesc.isReference) {
        assign$1(newElement, {
          element: element
        });
        this.context.addReference(newElement);
      } else {
        newElement.$parent = element;
      }
    }
    return childHandler;
  };
  function RootElementHandler(model, typeName, context) {
    ElementHandler.call(this, model, typeName, context);
  }
  RootElementHandler.prototype = Object.create(ElementHandler.prototype);
  RootElementHandler.prototype.createElement = function (node) {
    var name = node.name,
      nameNs = parseName(name),
      model = this.model,
      type = this.type,
      pkg = model.getPackage(nameNs.prefix),
      typeName = pkg && aliasToName(nameNs, pkg) || name;
    if (!type.hasType(typeName)) {
      throw error$1('unexpected element <' + node.originalName + '>');
    }
    return ElementHandler.prototype.createElement.call(this, node);
  };
  function GenericElementHandler(model, typeName, context) {
    this.model = model;
    this.context = context;
  }
  GenericElementHandler.prototype = Object.create(BaseElementHandler.prototype);
  GenericElementHandler.prototype.createElement = function (node) {
    var name = node.name,
      ns = parseName(name),
      prefix = ns.prefix,
      uri = node.ns[prefix + '$uri'],
      attributes = node.attributes;
    return this.model.createAny(name, uri, attributes);
  };
  GenericElementHandler.prototype.handleChild = function (node) {
    var handler = new GenericElementHandler(this.model, 'Element', this.context).handleNode(node),
      element = this.element;
    var newElement = handler.element,
      children;
    if (newElement !== undefined) {
      children = element.$children = element.$children || [];
      children.push(newElement);
      newElement.$parent = element;
    }
    return handler;
  };
  GenericElementHandler.prototype.handleEnd = function () {
    if (this.body) {
      this.element.$body = this.body;
    }
  };
  function Reader(options) {
    if (options instanceof Moddle) {
      options = {
        model: options
      };
    }
    assign$1(this, {
      lax: false
    }, options);
  }
  Reader.prototype.fromXML = function (xml, options, done) {
    var rootHandler = options.rootHandler;
    if (options instanceof ElementHandler) {
      rootHandler = options;
      options = {};
    } else {
      if (typeof options === 'string') {
        rootHandler = this.handler(options);
        options = {};
      } else if (typeof rootHandler === 'string') {
        rootHandler = this.handler(rootHandler);
      }
    }
    var model = this.model,
      lax = this.lax;
    var context = new Context(assign$1({}, options, {
        rootHandler: rootHandler
      })),
      parser = new Parser({
        proxy: true
      }),
      stack = createStack();
    rootHandler.context = context;
    stack.push(rootHandler);
    function handleError(err, getContext, lax) {
      var ctx = getContext();
      var line = ctx.line,
        column = ctx.column,
        data = ctx.data;
      if (data.charAt(0) === '<' && data.indexOf(' ') !== -1) {
        data = data.slice(0, data.indexOf(' ')) + '>';
      }
      var message = 'unparsable content ' + (data ? data + ' ' : '') + 'detected\n\t' + 'line: ' + line + '\n\t' + 'column: ' + column + '\n\t' + 'nested error: ' + err.message;
      if (lax) {
        context.addWarning({
          message: message,
          error: err
        });
        return true;
      } else {
        throw error$1(message);
      }
    }
    function handleWarning(err, getContext) {
      return handleError(err, getContext, true);
    }
    function resolveReferences() {
      var elementsById = context.elementsById;
      var references = context.references;
      var i, r;
      for (i = 0; r = references[i]; i++) {
        var element = r.element;
        var reference = elementsById[r.id];
        var property = getModdleDescriptor(element).propertiesByName[r.property];
        if (!reference) {
          context.addWarning({
            message: 'unresolved reference <' + r.id + '>',
            element: r.element,
            property: r.property,
            value: r.id
          });
        }
        if (property.isMany) {
          var collection = element.get(property.name),
            idx = collection.indexOf(r);
          if (idx === -1) {
            idx = collection.length;
          }
          if (!reference) {
            collection.splice(idx, 1);
          } else {
            collection[idx] = reference;
          }
        } else {
          element.set(property.name, reference);
        }
      }
    }
    function handleClose() {
      stack.pop().handleEnd();
    }
    var PREAMBLE_START_PATTERN = /^<\?xml /i;
    var ENCODING_PATTERN = / encoding="([^"]+)"/i;
    var UTF_8_PATTERN = /^utf-8$/i;
    function handleQuestion(question) {
      if (!PREAMBLE_START_PATTERN.test(question)) {
        return;
      }
      var match = ENCODING_PATTERN.exec(question);
      var encoding = match && match[1];
      if (!encoding || UTF_8_PATTERN.test(encoding)) {
        return;
      }
      context.addWarning({
        message: 'unsupported document encoding <' + encoding + '>, ' + 'falling back to UTF-8'
      });
    }
    function handleOpen(node, getContext) {
      var handler = stack.peek();
      try {
        stack.push(handler.handleNode(node));
      } catch (err) {
        if (handleError(err, getContext, lax)) {
          stack.push(new NoopHandler());
        }
      }
    }
    function handleCData(text, getContext) {
      try {
        stack.peek().handleText(text);
      } catch (err) {
        handleWarning(err, getContext);
      }
    }
    function handleText(text, getContext) {
      if (!text.trim()) {
        return;
      }
      handleCData(text, getContext);
    }
    var uriMap = model.getPackages().reduce(function (uriMap, p) {
      uriMap[p.uri] = p.prefix;
      return uriMap;
    }, Object.entries(DEFAULT_NS_MAP).reduce(function (map, _ref) {
      var _ref2 = _slicedToArray(_ref, 2),
        prefix = _ref2[0],
        url = _ref2[1];
      map[url] = prefix;
      return map;
    }, model.config && model.config.nsMap || {}));
    parser.ns(uriMap).on('openTag', function (obj, decodeStr, selfClosing, getContext) {
      var attrs = obj.attrs || {};
      var decodedAttrs = Object.keys(attrs).reduce(function (d, key) {
        var value = decodeStr(attrs[key]);
        d[key] = value;
        return d;
      }, {});
      var node = {
        name: obj.name,
        originalName: obj.originalName,
        attributes: decodedAttrs,
        ns: obj.ns
      };
      handleOpen(node, getContext);
    }).on('question', handleQuestion).on('closeTag', handleClose).on('cdata', handleCData).on('text', function (text, decodeEntities, getContext) {
      handleText(decodeEntities(text), getContext);
    }).on('error', handleError).on('warn', handleWarning);
    return new Promise(function (resolve, reject) {
      var err;
      try {
        parser.parse(xml);
        resolveReferences();
      } catch (e) {
        err = e;
      }
      var rootElement = rootHandler.element;
      if (!err && !rootElement) {
        err = error$1('failed to parse document as <' + rootHandler.type.$descriptor.name + '>');
      }
      var warnings = context.warnings;
      var references = context.references;
      var elementsById = context.elementsById;
      if (err) {
        err.warnings = warnings;
        return reject(err);
      } else {
        return resolve({
          rootElement: rootElement,
          elementsById: elementsById,
          references: references,
          warnings: warnings
        });
      }
    });
  };
  Reader.prototype.handler = function (name) {
    return new RootElementHandler(this.model, name);
  };
  function createStack() {
    var stack = [];
    Object.defineProperty(stack, 'peek', {
      value: function value() {
        return this[this.length - 1];
      }
    });
    return stack;
  }
  var XML_PREAMBLE = '<?xml version="1.0" encoding="UTF-8"?>\n';
  var ESCAPE_ATTR_CHARS = /<|>|'|"|&|\n\r|\n/g;
  var ESCAPE_CHARS = /<|>|&/g;
  function Namespaces(parent) {
    this.prefixMap = {};
    this.uriMap = {};
    this.used = {};
    this.wellknown = [];
    this.custom = [];
    this.parent = parent;
    this.defaultPrefixMap = parent && parent.defaultPrefixMap || {};
  }
  Namespaces.prototype.mapDefaultPrefixes = function (defaultPrefixMap) {
    this.defaultPrefixMap = defaultPrefixMap;
  };
  Namespaces.prototype.defaultUriByPrefix = function (prefix) {
    return this.defaultPrefixMap[prefix];
  };
  Namespaces.prototype.byUri = function (uri) {
    return this.uriMap[uri] || this.parent && this.parent.byUri(uri);
  };
  Namespaces.prototype.add = function (ns, isWellknown) {
    this.uriMap[ns.uri] = ns;
    if (isWellknown) {
      this.wellknown.push(ns);
    } else {
      this.custom.push(ns);
    }
    this.mapPrefix(ns.prefix, ns.uri);
  };
  Namespaces.prototype.uriByPrefix = function (prefix) {
    return this.prefixMap[prefix || 'xmlns'] || this.parent && this.parent.uriByPrefix(prefix);
  };
  Namespaces.prototype.mapPrefix = function (prefix, uri) {
    this.prefixMap[prefix || 'xmlns'] = uri;
  };
  Namespaces.prototype.getNSKey = function (ns) {
    return ns.prefix !== undefined ? ns.uri + '|' + ns.prefix : ns.uri;
  };
  Namespaces.prototype.logUsed = function (ns) {
    var uri = ns.uri;
    var nsKey = this.getNSKey(ns);
    this.used[nsKey] = this.byUri(uri);
    if (this.parent) {
      this.parent.logUsed(ns);
    }
  };
  Namespaces.prototype.getUsed = function (ns) {
    var _this3 = this;
    var allNs = [].concat(this.wellknown, this.custom);
    return allNs.filter(function (ns) {
      var nsKey = _this3.getNSKey(ns);
      return _this3.used[nsKey];
    });
  };
  function lower(string) {
    return string.charAt(0).toLowerCase() + string.slice(1);
  }
  function nameToAlias(name, pkg) {
    if (hasLowerCaseAlias(pkg)) {
      return lower(name);
    } else {
      return name;
    }
  }
  function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  }
  function nsName(ns) {
    if (isString(ns)) {
      return ns;
    } else {
      return (ns.prefix ? ns.prefix + ':' : '') + ns.localName;
    }
  }
  function getNsAttrs(namespaces) {
    return namespaces.getUsed().filter(function (ns) {
      return ns.prefix !== 'xml';
    }).map(function (ns) {
      var name = 'xmlns' + (ns.prefix ? ':' + ns.prefix : '');
      return {
        name: name,
        value: ns.uri
      };
    });
  }
  function getElementNs(ns, descriptor) {
    if (descriptor.isGeneric) {
      return assign$1({
        localName: descriptor.ns.localName
      }, ns);
    } else {
      return assign$1({
        localName: nameToAlias(descriptor.ns.localName, descriptor.$pkg)
      }, ns);
    }
  }
  function getPropertyNs(ns, descriptor) {
    return assign$1({
      localName: descriptor.ns.localName
    }, ns);
  }
  function getSerializableProperties(element) {
    var descriptor = element.$descriptor;
    return filter(descriptor.properties, function (p) {
      var name = p.name;
      if (p.isVirtual) {
        return false;
      }
      if (!has$1(element, name)) {
        return false;
      }
      var value = element[name];
      if (value === p.default) {
        return false;
      }
      if (value === null) {
        return false;
      }
      return p.isMany ? value.length : true;
    });
  }
  var ESCAPE_ATTR_MAP = {
    '\n': '#10',
    '\n\r': '#10',
    '"': '#34',
    '\'': '#39',
    '<': '#60',
    '>': '#62',
    '&': '#38'
  };
  var ESCAPE_MAP = {
    '<': 'lt',
    '>': 'gt',
    '&': 'amp'
  };
  function escape(str, charPattern, replaceMap) {
    str = isString(str) ? str : '' + str;
    return str.replace(charPattern, function (s) {
      return '&' + replaceMap[s] + ';';
    });
  }
  function escapeAttr(str) {
    return escape(str, ESCAPE_ATTR_CHARS, ESCAPE_ATTR_MAP);
  }
  function escapeBody(str) {
    return escape(str, ESCAPE_CHARS, ESCAPE_MAP);
  }
  function filterAttributes(props) {
    return filter(props, function (p) {
      return p.isAttr;
    });
  }
  function filterContained(props) {
    return filter(props, function (p) {
      return !p.isAttr;
    });
  }
  function ReferenceSerializer(tagName) {
    this.tagName = tagName;
  }
  ReferenceSerializer.prototype.build = function (element) {
    this.element = element;
    return this;
  };
  ReferenceSerializer.prototype.serializeTo = function (writer) {
    writer.appendIndent().append('<' + this.tagName + '>' + this.element.id + '</' + this.tagName + '>').appendNewLine();
  };
  function BodySerializer() {}
  BodySerializer.prototype.serializeValue = BodySerializer.prototype.serializeTo = function (writer) {
    writer.append(this.escape ? escapeBody(this.value) : this.value);
  };
  BodySerializer.prototype.build = function (prop, value) {
    this.value = value;
    if (prop.type === 'String' && value.search(ESCAPE_CHARS) !== -1) {
      this.escape = true;
    }
    return this;
  };
  function ValueSerializer(tagName) {
    this.tagName = tagName;
  }
  inherits(ValueSerializer, BodySerializer);
  ValueSerializer.prototype.serializeTo = function (writer) {
    writer.appendIndent().append('<' + this.tagName + '>');
    this.serializeValue(writer);
    writer.append('</' + this.tagName + '>').appendNewLine();
  };
  function ElementSerializer(parent, propertyDescriptor) {
    this.body = [];
    this.attrs = [];
    this.parent = parent;
    this.propertyDescriptor = propertyDescriptor;
  }
  ElementSerializer.prototype.build = function (element) {
    this.element = element;
    var elementDescriptor = element.$descriptor,
      propertyDescriptor = this.propertyDescriptor;
    var otherAttrs, properties;
    var isGeneric = elementDescriptor.isGeneric;
    if (isGeneric) {
      otherAttrs = this.parseGenericNsAttributes(element);
    } else {
      otherAttrs = this.parseNsAttributes(element);
    }
    if (propertyDescriptor) {
      this.ns = this.nsPropertyTagName(propertyDescriptor);
    } else {
      this.ns = this.nsTagName(elementDescriptor);
    }
    this.tagName = this.addTagName(this.ns);
    if (isGeneric) {
      this.parseGenericContainments(element);
    } else {
      properties = getSerializableProperties(element);
      this.parseAttributes(filterAttributes(properties));
      this.parseContainments(filterContained(properties));
    }
    this.parseGenericAttributes(element, otherAttrs);
    return this;
  };
  ElementSerializer.prototype.nsTagName = function (descriptor) {
    var effectiveNs = this.logNamespaceUsed(descriptor.ns);
    return getElementNs(effectiveNs, descriptor);
  };
  ElementSerializer.prototype.nsPropertyTagName = function (descriptor) {
    var effectiveNs = this.logNamespaceUsed(descriptor.ns);
    return getPropertyNs(effectiveNs, descriptor);
  };
  ElementSerializer.prototype.isLocalNs = function (ns) {
    return ns.uri === this.ns.uri;
  };
  ElementSerializer.prototype.nsAttributeName = function (element) {
    var ns;
    if (isString(element)) {
      ns = parseName(element);
    } else {
      ns = element.ns;
    }
    if (element.inherited) {
      return {
        localName: ns.localName
      };
    }
    var effectiveNs = this.logNamespaceUsed(ns);
    this.getNamespaces().logUsed(effectiveNs);
    if (this.isLocalNs(effectiveNs)) {
      return {
        localName: ns.localName
      };
    } else {
      return assign$1({
        localName: ns.localName
      }, effectiveNs);
    }
  };
  ElementSerializer.prototype.parseGenericNsAttributes = function (element) {
    var _this4 = this;
    return Object.entries(element).filter(function (_ref3) {
      var _ref4 = _slicedToArray(_ref3, 2),
        key = _ref4[0],
        value = _ref4[1];
      return !key.startsWith('$') && _this4.parseNsAttribute(element, key, value);
    }).map(function (_ref5) {
      var _ref6 = _slicedToArray(_ref5, 2),
        key = _ref6[0],
        value = _ref6[1];
      return {
        name: key,
        value: value
      };
    });
  };
  ElementSerializer.prototype.parseGenericContainments = function (element) {
    var _this5 = this;
    var body = element.$body;
    if (body) {
      this.body.push(new BodySerializer().build({
        type: 'String'
      }, body));
    }
    var children = element.$children;
    if (children) {
      forEach$1(children, function (child) {
        _this5.body.push(new ElementSerializer(_this5).build(child));
      });
    }
  };
  ElementSerializer.prototype.parseNsAttribute = function (element, name, value) {
    var model = element.$model;
    var nameNs = parseName(name);
    var ns;
    if (nameNs.prefix === 'xmlns') {
      ns = {
        prefix: nameNs.localName,
        uri: value
      };
    }
    if (!nameNs.prefix && nameNs.localName === 'xmlns') {
      ns = {
        uri: value
      };
    }
    if (!ns) {
      return {
        name: name,
        value: value
      };
    }
    if (model && model.getPackage(value)) {
      this.logNamespace(ns, true, true);
    } else {
      var actualNs = this.logNamespaceUsed(ns, true);
      this.getNamespaces().logUsed(actualNs);
    }
  };
  ElementSerializer.prototype.parseNsAttributes = function (element) {
    var self = this;
    var genericAttrs = element.$attrs;
    var attributes = [];
    forEach$1(genericAttrs, function (value, name) {
      var nonNsAttr = self.parseNsAttribute(element, name, value);
      if (nonNsAttr) {
        attributes.push(nonNsAttr);
      }
    });
    return attributes;
  };
  ElementSerializer.prototype.parseGenericAttributes = function (element, attributes) {
    var self = this;
    forEach$1(attributes, function (attr) {
      try {
        self.addAttribute(self.nsAttributeName(attr.name), attr.value);
      } catch (e) {
        typeof console !== 'undefined' && console.warn(`missing namespace information for <${attr.name}=${attr.value}> on`, element, e);
      }
    });
  };
  ElementSerializer.prototype.parseContainments = function (properties) {
    var self = this,
      body = this.body,
      element = this.element;
    forEach$1(properties, function (p) {
      var value = element.get(p.name),
        isReference = p.isReference,
        isMany = p.isMany;
      if (!isMany) {
        value = [value];
      }
      if (p.isBody) {
        body.push(new BodySerializer().build(p, value[0]));
      } else if (isSimple(p.type)) {
        forEach$1(value, function (v) {
          body.push(new ValueSerializer(self.addTagName(self.nsPropertyTagName(p))).build(p, v));
        });
      } else if (isReference) {
        forEach$1(value, function (v) {
          body.push(new ReferenceSerializer(self.addTagName(self.nsPropertyTagName(p))).build(v));
        });
      } else {
        var serialization = getSerialization(p);
        forEach$1(value, function (v) {
          var serializer;
          if (serialization) {
            if (serialization === SERIALIZE_PROPERTY) {
              serializer = new ElementSerializer(self, p);
            } else {
              serializer = new TypeSerializer(self, p, serialization);
            }
          } else {
            serializer = new ElementSerializer(self);
          }
          body.push(serializer.build(v));
        });
      }
    });
  };
  ElementSerializer.prototype.getNamespaces = function (local) {
    var namespaces = this.namespaces,
      parent = this.parent,
      parentNamespaces;
    if (!namespaces) {
      parentNamespaces = parent && parent.getNamespaces();
      if (local || !parentNamespaces) {
        this.namespaces = namespaces = new Namespaces(parentNamespaces);
      } else {
        namespaces = parentNamespaces;
      }
    }
    return namespaces;
  };
  ElementSerializer.prototype.logNamespace = function (ns, wellknown, local) {
    var namespaces = this.getNamespaces(local);
    var nsUri = ns.uri,
      nsPrefix = ns.prefix;
    var existing = namespaces.byUri(nsUri);
    if (!existing || local) {
      namespaces.add(ns, wellknown);
    }
    namespaces.mapPrefix(nsPrefix, nsUri);
    return ns;
  };
  ElementSerializer.prototype.logNamespaceUsed = function (ns, local) {
    var namespaces = this.getNamespaces(local);
    var prefix = ns.prefix,
      uri = ns.uri,
      newPrefix,
      idx,
      wellknownUri;
    if (!prefix && !uri) {
      return {
        localName: ns.localName
      };
    }
    wellknownUri = namespaces.defaultUriByPrefix(prefix);
    uri = uri || wellknownUri || namespaces.uriByPrefix(prefix);
    if (!uri) {
      throw new Error('no namespace uri given for prefix <' + prefix + '>');
    }
    ns = namespaces.byUri(uri);
    if (!ns && !prefix) {
      ns = this.logNamespace({
        uri
      }, wellknownUri === uri, true);
    }
    if (!ns) {
      newPrefix = prefix;
      idx = 1;
      while (namespaces.uriByPrefix(newPrefix)) {
        newPrefix = prefix + '_' + idx++;
      }
      ns = this.logNamespace({
        prefix: newPrefix,
        uri: uri
      }, wellknownUri === uri);
    }
    if (prefix) {
      namespaces.mapPrefix(prefix, uri);
    }
    return ns;
  };
  ElementSerializer.prototype.parseAttributes = function (properties) {
    var self = this,
      element = this.element;
    forEach$1(properties, function (p) {
      var value = element.get(p.name);
      if (p.isReference) {
        if (!p.isMany) {
          value = value.id;
        } else {
          var values = [];
          forEach$1(value, function (v) {
            values.push(v.id);
          });
          value = values.join(' ');
        }
      }
      self.addAttribute(self.nsAttributeName(p), value);
    });
  };
  ElementSerializer.prototype.addTagName = function (nsTagName) {
    var actualNs = this.logNamespaceUsed(nsTagName);
    this.getNamespaces().logUsed(actualNs);
    return nsName(nsTagName);
  };
  ElementSerializer.prototype.addAttribute = function (name, value) {
    var attrs = this.attrs;
    if (isString(value)) {
      value = escapeAttr(value);
    }
    var idx = findIndex(attrs, function (element) {
      return element.name.localName === name.localName && element.name.uri === name.uri && element.name.prefix === name.prefix;
    });
    var attr = {
      name: name,
      value: value
    };
    if (idx !== -1) {
      attrs.splice(idx, 1, attr);
    } else {
      attrs.push(attr);
    }
  };
  ElementSerializer.prototype.serializeAttributes = function (writer) {
    var attrs = this.attrs,
      namespaces = this.namespaces;
    if (namespaces) {
      attrs = getNsAttrs(namespaces).concat(attrs);
    }
    forEach$1(attrs, function (a) {
      writer.append(' ').append(nsName(a.name)).append('="').append(a.value).append('"');
    });
  };
  ElementSerializer.prototype.serializeTo = function (writer) {
    var firstBody = this.body[0],
      indent = firstBody && firstBody.constructor !== BodySerializer;
    writer.appendIndent().append('<' + this.tagName);
    this.serializeAttributes(writer);
    writer.append(firstBody ? '>' : ' />');
    if (firstBody) {
      if (indent) {
        writer.appendNewLine().indent();
      }
      forEach$1(this.body, function (b) {
        b.serializeTo(writer);
      });
      if (indent) {
        writer.unindent().appendIndent();
      }
      writer.append('</' + this.tagName + '>');
    }
    writer.appendNewLine();
  };
  function TypeSerializer(parent, propertyDescriptor, serialization) {
    ElementSerializer.call(this, parent, propertyDescriptor);
    this.serialization = serialization;
  }
  inherits(TypeSerializer, ElementSerializer);
  TypeSerializer.prototype.parseNsAttributes = function (element) {
    var _this6 = this;
    var attributes = ElementSerializer.prototype.parseNsAttributes.call(this, element).filter(function (attr) {
      return attr.name !== _this6.serialization;
    });
    var descriptor = element.$descriptor;
    if (descriptor.name === this.propertyDescriptor.type) {
      return attributes;
    }
    var typeNs = this.typeNs = this.nsTagName(descriptor);
    this.getNamespaces().logUsed(this.typeNs);
    var pkg = element.$model.getPackage(typeNs.uri),
      typePrefix = pkg.xml && pkg.xml.typePrefix || '';
    this.addAttribute(this.nsAttributeName(this.serialization), (typeNs.prefix ? typeNs.prefix + ':' : '') + typePrefix + descriptor.ns.localName);
    return attributes;
  };
  TypeSerializer.prototype.isLocalNs = function (ns) {
    return ns.uri === (this.typeNs || this.ns).uri;
  };
  function SavingWriter() {
    this.value = '';
    this.write = function (str) {
      this.value += str;
    };
  }
  function FormatingWriter(out, format) {
    var indent = [''];
    this.append = function (str) {
      out.write(str);
      return this;
    };
    this.appendNewLine = function () {
      if (format) {
        out.write('\n');
      }
      return this;
    };
    this.appendIndent = function () {
      if (format) {
        out.write(indent.join('  '));
      }
      return this;
    };
    this.indent = function () {
      indent.push('');
      return this;
    };
    this.unindent = function () {
      indent.pop();
      return this;
    };
  }
  function Writer(options) {
    options = assign$1({
      format: false,
      preamble: true
    }, options || {});
    function toXML(tree, writer) {
      var internalWriter = writer || new SavingWriter();
      var formatingWriter = new FormatingWriter(internalWriter, options.format);
      if (options.preamble) {
        formatingWriter.append(XML_PREAMBLE);
      }
      var serializer = new ElementSerializer();
      var model = tree.$model;
      serializer.getNamespaces().mapDefaultPrefixes(getDefaultPrefixMappings(model));
      serializer.build(tree).serializeTo(formatingWriter);
      if (!writer) {
        return internalWriter.value;
      }
    }
    return {
      toXML: toXML
    };
  }
  function getDefaultPrefixMappings(model) {
    var nsMap = model.config && model.config.nsMap || {};
    var prefixMap = {};
    for (var _prefix in DEFAULT_NS_MAP) {
      prefixMap[_prefix] = DEFAULT_NS_MAP[_prefix];
    }
    for (var _uri in nsMap) {
      var _prefix2 = nsMap[_uri];
      prefixMap[_prefix2] = _uri;
    }
    var _iterator = _createForOfIteratorHelper(model.getPackages()),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var pkg = _step.value;
        prefixMap[pkg.prefix] = pkg.uri;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return prefixMap;
  }
  function BpmnModdle(packages, options) {
    Moddle.call(this, packages, options);
  }
  BpmnModdle.prototype = Object.create(Moddle.prototype);
  BpmnModdle.prototype.fromXML = function (xmlStr, typeName, options) {
    if (!isString(typeName)) {
      options = typeName;
      typeName = 'bpmn:Definitions';
    }
    var reader = new Reader(assign$1({
      model: this,
      lax: true
    }, options));
    var rootHandler = reader.handler(typeName);
    return reader.fromXML(xmlStr, rootHandler);
  };
  BpmnModdle.prototype.toXML = function (element, options) {
    var writer = new Writer(options);
    return new Promise(function (resolve, reject) {
      try {
        var result = writer.toXML(element);
        return resolve({
          xml: result
        });
      } catch (err) {
        return reject(err);
      }
    });
  };
  var name$5 = "BPMN20";
  var uri$5 = "http://www.omg.org/spec/BPMN/20100524/MODEL";
  var prefix$5 = "bpmn";
  var associations$5 = [];
  var types$5 = [{
    name: "Interface",
    superClass: ["RootElement"],
    properties: [{
      name: "name",
      isAttr: true,
      type: "String"
    }, {
      name: "operations",
      type: "Operation",
      isMany: true
    }, {
      name: "implementationRef",
      isAttr: true,
      type: "String"
    }]
  }, {
    name: "Operation",
    superClass: ["BaseElement"],
    properties: [{
      name: "name",
      isAttr: true,
      type: "String"
    }, {
      name: "inMessageRef",
      type: "Message",
      isReference: true
    }, {
      name: "outMessageRef",
      type: "Message",
      isReference: true
    }, {
      name: "errorRef",
      type: "Error",
      isMany: true,
      isReference: true
    }, {
      name: "implementationRef",
      isAttr: true,
      type: "String"
    }]
  }, {
    name: "EndPoint",
    superClass: ["RootElement"]
  }, {
    name: "Auditing",
    superClass: ["BaseElement"]
  }, {
    name: "GlobalTask",
    superClass: ["CallableElement"],
    properties: [{
      name: "resources",
      type: "ResourceRole",
      isMany: true
    }]
  }, {
    name: "Monitoring",
    superClass: ["BaseElement"]
  }, {
    name: "Performer",
    superClass: ["ResourceRole"]
  }, {
    name: "Process",
    superClass: ["FlowElementsContainer", "CallableElement"],
    properties: [{
      name: "processType",
      type: "ProcessType",
      isAttr: true
    }, {
      name: "isClosed",
      isAttr: true,
      type: "Boolean"
    }, {
      name: "auditing",
      type: "Auditing"
    }, {
      name: "monitoring",
      type: "Monitoring"
    }, {
      name: "properties",
      type: "Property",
      isMany: true
    }, {
      name: "laneSets",
      isMany: true,
      replaces: "FlowElementsContainer#laneSets",
      type: "LaneSet"
    }, {
      name: "flowElements",
      isMany: true,
      replaces: "FlowElementsContainer#flowElements",
      type: "FlowElement"
    }, {
      name: "artifacts",
      type: "Artifact",
      isMany: true
    }, {
      name: "resources",
      type: "ResourceRole",
      isMany: true
    }, {
      name: "correlationSubscriptions",
      type: "CorrelationSubscription",
      isMany: true
    }, {
      name: "supports",
      type: "Process",
      isMany: true,
      isReference: true
    }, {
      name: "definitionalCollaborationRef",
      type: "Collaboration",
      isAttr: true,
      isReference: true
    }, {
      name: "isExecutable",
      isAttr: true,
      type: "Boolean"
    }]
  }, {
    name: "LaneSet",
    superClass: ["BaseElement"],
    properties: [{
      name: "lanes",
      type: "Lane",
      isMany: true
    }, {
      name: "name",
      isAttr: true,
      type: "String"
    }]
  }, {
    name: "Lane",
    superClass: ["BaseElement"],
    properties: [{
      name: "name",
      isAttr: true,
      type: "String"
    }, {
      name: "partitionElementRef",
      type: "BaseElement",
      isAttr: true,
      isReference: true
    }, {
      name: "partitionElement",
      type: "BaseElement"
    }, {
      name: "flowNodeRef",
      type: "FlowNode",
      isMany: true,
      isReference: true
    }, {
      name: "childLaneSet",
      type: "LaneSet",
      xml: {
        serialize: "xsi:type"
      }
    }]
  }, {
    name: "GlobalManualTask",
    superClass: ["GlobalTask"]
  }, {
    name: "ManualTask",
    superClass: ["Task"]
  }, {
    name: "UserTask",
    superClass: ["Task"],
    properties: [{
      name: "renderings",
      type: "Rendering",
      isMany: true
    }, {
      name: "implementation",
      isAttr: true,
      type: "String"
    }]
  }, {
    name: "Rendering",
    superClass: ["BaseElement"]
  }, {
    name: "HumanPerformer",
    superClass: ["Performer"]
  }, {
    name: "PotentialOwner",
    superClass: ["HumanPerformer"]
  }, {
    name: "GlobalUserTask",
    superClass: ["GlobalTask"],
    properties: [{
      name: "implementation",
      isAttr: true,
      type: "String"
    }, {
      name: "renderings",
      type: "Rendering",
      isMany: true
    }]
  }, {
    name: "Gateway",
    isAbstract: true,
    superClass: ["FlowNode"],
    properties: [{
      name: "gatewayDirection",
      type: "GatewayDirection",
      "default": "Unspecified",
      isAttr: true
    }]
  }, {
    name: "EventBasedGateway",
    superClass: ["Gateway"],
    properties: [{
      name: "instantiate",
      "default": false,
      isAttr: true,
      type: "Boolean"
    }, {
      name: "eventGatewayType",
      type: "EventBasedGatewayType",
      isAttr: true,
      "default": "Exclusive"
    }]
  }, {
    name: "ComplexGateway",
    superClass: ["Gateway"],
    properties: [{
      name: "activationCondition",
      type: "Expression",
      xml: {
        serialize: "xsi:type"
      }
    }, {
      name: "default",
      type: "SequenceFlow",
      isAttr: true,
      isReference: true
    }]
  }, {
    name: "ExclusiveGateway",
    superClass: ["Gateway"],
    properties: [{
      name: "default",
      type: "SequenceFlow",
      isAttr: true,
      isReference: true
    }]
  }, {
    name: "InclusiveGateway",
    superClass: ["Gateway"],
    properties: [{
      name: "default",
      type: "SequenceFlow",
      isAttr: true,
      isReference: true
    }]
  }, {
    name: "ParallelGateway",
    superClass: ["Gateway"]
  }, {
    name: "RootElement",
    isAbstract: true,
    superClass: ["BaseElement"]
  }, {
    name: "Relationship",
    superClass: ["BaseElement"],
    properties: [{
      name: "type",
      isAttr: true,
      type: "String"
    }, {
      name: "direction",
      type: "RelationshipDirection",
      isAttr: true
    }, {
      name: "source",
      isMany: true,
      isReference: true,
      type: "Element"
    }, {
      name: "target",
      isMany: true,
      isReference: true,
      type: "Element"
    }]
  }, {
    name: "BaseElement",
    isAbstract: true,
    properties: [{
      name: "id",
      isAttr: true,
      type: "String",
      isId: true
    }, {
      name: "documentation",
      type: "Documentation",
      isMany: true
    }, {
      name: "extensionDefinitions",
      type: "ExtensionDefinition",
      isMany: true,
      isReference: true
    }, {
      name: "extensionElements",
      type: "ExtensionElements"
    }]
  }, {
    name: "Extension",
    properties: [{
      name: "mustUnderstand",
      "default": false,
      isAttr: true,
      type: "Boolean"
    }, {
      name: "definition",
      type: "ExtensionDefinition",
      isAttr: true,
      isReference: true
    }]
  }, {
    name: "ExtensionDefinition",
    properties: [{
      name: "name",
      isAttr: true,
      type: "String"
    }, {
      name: "extensionAttributeDefinitions",
      type: "ExtensionAttributeDefinition",
      isMany: true
    }]
  }, {
    name: "ExtensionAttributeDefinition",
    properties: [{
      name: "name",
      isAttr: true,
      type: "String"
    }, {
      name: "type",
      isAttr: true,
      type: "String"
    }, {
      name: "isReference",
      "default": false,
      isAttr: true,
      type: "Boolean"
    }, {
      name: "extensionDefinition",
      type: "ExtensionDefinition",
      isAttr: true,
      isReference: true
    }]
  }, {
    name: "ExtensionElements",
    properties: [{
      name: "valueRef",
      isAttr: true,
      isReference: true,
      type: "Element"
    }, {
      name: "values",
      type: "Element",
      isMany: true
    }, {
      name: "extensionAttributeDefinition",
      type: "ExtensionAttributeDefinition",
      isAttr: true,
      isReference: true
    }]
  }, {
    name: "Documentation",
    superClass: ["BaseElement"],
    properties: [{
      name: "text",
      type: "String",
      isBody: true
    }, {
      name: "textFormat",
      "default": "text/plain",
      isAttr: true,
      type: "String"
    }]
  }, {
    name: "Event",
    isAbstract: true,
    superClass: ["FlowNode", "InteractionNode"],
    properties: [{
      name: "properties",
      type: "Property",
      isMany: true
    }]
  }, {
    name: "IntermediateCatchEvent",
    superClass: ["CatchEvent"]
  }, {
    name: "IntermediateThrowEvent",
    superClass: ["ThrowEvent"]
  }, {
    name: "EndEvent",
    superClass: ["ThrowEvent"]
  }, {
    name: "StartEvent",
    superClass: ["CatchEvent"],
    properties: [{
      name: "isInterrupting",
      "default": true,
      isAttr: true,
      type: "Boolean"
    }]
  }, {
    name: "ThrowEvent",
    isAbstract: true,
    superClass: ["Event"],
    properties: [{
      name: "dataInputs",
      type: "DataInput",
      isMany: true
    }, {
      name: "dataInputAssociations",
      type: "DataInputAssociation",
      isMany: true
    }, {
      name: "inputSet",
      type: "InputSet"
    }, {
      name: "eventDefinitions",
      type: "EventDefinition",
      isMany: true
    }, {
      name: "eventDefinitionRef",
      type: "EventDefinition",
      isMany: true,
      isReference: true
    }]
  }, {
    name: "CatchEvent",
    isAbstract: true,
    superClass: ["Event"],
    properties: [{
      name: "parallelMultiple",
      isAttr: true,
      type: "Boolean",
      "default": false
    }, {
      name: "dataOutputs",
      type: "DataOutput",
      isMany: true
    }, {
      name: "dataOutputAssociations",
      type: "DataOutputAssociation",
      isMany: true
    }, {
      name: "outputSet",
      type: "OutputSet"
    }, {
      name: "eventDefinitions",
      type: "EventDefinition",
      isMany: true
    }, {
      name: "eventDefinitionRef",
      type: "EventDefinition",
      isMany: true,
      isReference: true
    }]
  }, {
    name: "BoundaryEvent",
    superClass: ["CatchEvent"],
    properties: [{
      name: "cancelActivity",
      "default": true,
      isAttr: true,
      type: "Boolean"
    }, {
      name: "attachedToRef",
      type: "Activity",
      isAttr: true,
      isReference: true
    }]
  }, {
    name: "EventDefinition",
    isAbstract: true,
    superClass: ["RootElement"]
  }, {
    name: "CancelEventDefinition",
    superClass: ["EventDefinition"]
  }, {
    name: "ErrorEventDefinition",
    superClass: ["EventDefinition"],
    properties: [{
      name: "errorRef",
      type: "Error",
      isAttr: true,
      isReference: true
    }]
  }, {
    name: "TerminateEventDefinition",
    superClass: ["EventDefinition"]
  }, {
    name: "EscalationEventDefinition",
    superClass: ["EventDefinition"],
    properties: [{
      name: "escalationRef",
      type: "Escalation",
      isAttr: true,
      isReference: true
    }]
  }, {
    name: "Escalation",
    properties: [{
      name: "structureRef",
      type: "ItemDefinition",
      isAttr: true,
      isReference: true
    }, {
      name: "name",
      isAttr: true,
      type: "String"
    }, {
      name: "escalationCode",
      isAttr: true,
      type: "String"
    }],
    superClass: ["RootElement"]
  }, {
    name: "CompensateEventDefinition",
    superClass: ["EventDefinition"],
    properties: [{
      name: "waitForCompletion",
      isAttr: true,
      type: "Boolean",
      "default": true
    }, {
      name: "activityRef",
      type: "Activity",
      isAttr: true,
      isReference: true
    }]
  }, {
    name: "TimerEventDefinition",
    superClass: ["EventDefinition"],
    properties: [{
      name: "timeDate",
      type: "Expression",
      xml: {
        serialize: "xsi:type"
      }
    }, {
      name: "timeCycle",
      type: "Expression",
      xml: {
        serialize: "xsi:type"
      }
    }, {
      name: "timeDuration",
      type: "Expression",
      xml: {
        serialize: "xsi:type"
      }
    }]
  }, {
    name: "LinkEventDefinition",
    superClass: ["EventDefinition"],
    properties: [{
      name: "name",
      isAttr: true,
      type: "String"
    }, {
      name: "target",
      type: "LinkEventDefinition",
      isReference: true
    }, {
      name: "source",
      type: "LinkEventDefinition",
      isMany: true,
      isReference: true
    }]
  }, {
    name: "MessageEventDefinition",
    superClass: ["EventDefinition"],
    properties: [{
      name: "messageRef",
      type: "Message",
      isAttr: true,
      isReference: true
    }, {
      name: "operationRef",
      type: "Operation",
      isReference: true
    }]
  }, {
    name: "ConditionalEventDefinition",
    superClass: ["EventDefinition"],
    properties: [{
      name: "condition",
      type: "Expression",
      xml: {
        serialize: "xsi:type"
      }
    }]
  }, {
    name: "SignalEventDefinition",
    superClass: ["EventDefinition"],
    properties: [{
      name: "signalRef",
      type: "Signal",
      isAttr: true,
      isReference: true
    }]
  }, {
    name: "Signal",
    superClass: ["RootElement"],
    properties: [{
      name: "structureRef",
      type: "ItemDefinition",
      isAttr: true,
      isReference: true
    }, {
      name: "name",
      isAttr: true,
      type: "String"
    }]
  }, {
    name: "ImplicitThrowEvent",
    superClass: ["ThrowEvent"]
  }, {
    name: "DataState",
    superClass: ["BaseElement"],
    properties: [{
      name: "name",
      isAttr: true,
      type: "String"
    }]
  }, {
    name: "ItemAwareElement",
    superClass: ["BaseElement"],
    properties: [{
      name: "itemSubjectRef",
      type: "ItemDefinition",
      isAttr: true,
      isReference: true
    }, {
      name: "dataState",
      type: "DataState"
    }]
  }, {
    name: "DataAssociation",
    superClass: ["BaseElement"],
    properties: [{
      name: "sourceRef",
      type: "ItemAwareElement",
      isMany: true,
      isReference: true
    }, {
      name: "targetRef",
      type: "ItemAwareElement",
      isReference: true
    }, {
      name: "transformation",
      type: "FormalExpression",
      xml: {
        serialize: "property"
      }
    }, {
      name: "assignment",
      type: "Assignment",
      isMany: true
    }]
  }, {
    name: "DataInput",
    superClass: ["ItemAwareElement"],
    properties: [{
      name: "name",
      isAttr: true,
      type: "String"
    }, {
      name: "isCollection",
      "default": false,
      isAttr: true,
      type: "Boolean"
    }, {
      name: "inputSetRef",
      type: "InputSet",
      isMany: true,
      isVirtual: true,
      isReference: true
    }, {
      name: "inputSetWithOptional",
      type: "InputSet",
      isMany: true,
      isVirtual: true,
      isReference: true
    }, {
      name: "inputSetWithWhileExecuting",
      type: "InputSet",
      isMany: true,
      isVirtual: true,
      isReference: true
    }]
  }, {
    name: "DataOutput",
    superClass: ["ItemAwareElement"],
    properties: [{
      name: "name",
      isAttr: true,
      type: "String"
    }, {
      name: "isCollection",
      "default": false,
      isAttr: true,
      type: "Boolean"
    }, {
      name: "outputSetRef",
      type: "OutputSet",
      isMany: true,
      isVirtual: true,
      isReference: true
    }, {
      name: "outputSetWithOptional",
      type: "OutputSet",
      isMany: true,
      isVirtual: true,
      isReference: true
    }, {
      name: "outputSetWithWhileExecuting",
      type: "OutputSet",
      isMany: true,
      isVirtual: true,
      isReference: true
    }]
  }, {
    name: "InputSet",
    superClass: ["BaseElement"],
    properties: [{
      name: "name",
      isAttr: true,
      type: "String"
    }, {
      name: "dataInputRefs",
      type: "DataInput",
      isMany: true,
      isReference: true
    }, {
      name: "optionalInputRefs",
      type: "DataInput",
      isMany: true,
      isReference: true
    }, {
      name: "whileExecutingInputRefs",
      type: "DataInput",
      isMany: true,
      isReference: true
    }, {
      name: "outputSetRefs",
      type: "OutputSet",
      isMany: true,
      isReference: true
    }]
  }, {
    name: "OutputSet",
    superClass: ["BaseElement"],
    properties: [{
      name: "dataOutputRefs",
      type: "DataOutput",
      isMany: true,
      isReference: true
    }, {
      name: "name",
      isAttr: true,
      type: "String"
    }, {
      name: "inputSetRefs",
      type: "InputSet",
      isMany: true,
      isReference: true
    }, {
      name: "optionalOutputRefs",
      type: "DataOutput",
      isMany: true,
      isReference: true
    }, {
      name: "whileExecutingOutputRefs",
      type: "DataOutput",
      isMany: true,
      isReference: true
    }]
  }, {
    name: "Property",
    superClass: ["ItemAwareElement"],
    properties: [{
      name: "name",
      isAttr: true,
      type: "String"
    }]
  }, {
    name: "DataInputAssociation",
    superClass: ["DataAssociation"]
  }, {
    name: "DataOutputAssociation",
    superClass: ["DataAssociation"]
  }, {
    name: "InputOutputSpecification",
    superClass: ["BaseElement"],
    properties: [{
      name: "dataInputs",
      type: "DataInput",
      isMany: true
    }, {
      name: "dataOutputs",
      type: "DataOutput",
      isMany: true
    }, {
      name: "inputSets",
      type: "InputSet",
      isMany: true
    }, {
      name: "outputSets",
      type: "OutputSet",
      isMany: true
    }]
  }, {
    name: "DataObject",
    superClass: ["FlowElement", "ItemAwareElement"],
    properties: [{
      name: "isCollection",
      "default": false,
      isAttr: true,
      type: "Boolean"
    }]
  }, {
    name: "InputOutputBinding",
    properties: [{
      name: "inputDataRef",
      type: "InputSet",
      isAttr: true,
      isReference: true
    }, {
      name: "outputDataRef",
      type: "OutputSet",
      isAttr: true,
      isReference: true
    }, {
      name: "operationRef",
      type: "Operation",
      isAttr: true,
      isReference: true
    }]
  }, {
    name: "Assignment",
    superClass: ["BaseElement"],
    properties: [{
      name: "from",
      type: "Expression",
      xml: {
        serialize: "xsi:type"
      }
    }, {
      name: "to",
      type: "Expression",
      xml: {
        serialize: "xsi:type"
      }
    }]
  }, {
    name: "DataStore",
    superClass: ["RootElement", "ItemAwareElement"],
    properties: [{
      name: "name",
      isAttr: true,
      type: "String"
    }, {
      name: "capacity",
      isAttr: true,
      type: "Integer"
    }, {
      name: "isUnlimited",
      "default": true,
      isAttr: true,
      type: "Boolean"
    }]
  }, {
    name: "DataStoreReference",
    superClass: ["ItemAwareElement", "FlowElement"],
    properties: [{
      name: "dataStoreRef",
      type: "DataStore",
      isAttr: true,
      isReference: true
    }]
  }, {
    name: "DataObjectReference",
    superClass: ["ItemAwareElement", "FlowElement"],
    properties: [{
      name: "dataObjectRef",
      type: "DataObject",
      isAttr: true,
      isReference: true
    }]
  }, {
    name: "ConversationLink",
    superClass: ["BaseElement"],
    properties: [{
      name: "sourceRef",
      type: "InteractionNode",
      isAttr: true,
      isReference: true
    }, {
      name: "targetRef",
      type: "InteractionNode",
      isAttr: true,
      isReference: true
    }, {
      name: "name",
      isAttr: true,
      type: "String"
    }]
  }, {
    name: "ConversationAssociation",
    superClass: ["BaseElement"],
    properties: [{
      name: "innerConversationNodeRef",
      type: "ConversationNode",
      isAttr: true,
      isReference: true
    }, {
      name: "outerConversationNodeRef",
      type: "ConversationNode",
      isAttr: true,
      isReference: true
    }]
  }, {
    name: "CallConversation",
    superClass: ["ConversationNode"],
    properties: [{
      name: "calledCollaborationRef",
      type: "Collaboration",
      isAttr: true,
      isReference: true
    }, {
      name: "participantAssociations",
      type: "ParticipantAssociation",
      isMany: true
    }]
  }, {
    name: "Conversation",
    superClass: ["ConversationNode"]
  }, {
    name: "SubConversation",
    superClass: ["ConversationNode"],
    properties: [{
      name: "conversationNodes",
      type: "ConversationNode",
      isMany: true
    }]
  }, {
    name: "ConversationNode",
    isAbstract: true,
    superClass: ["InteractionNode", "BaseElement"],
    properties: [{
      name: "name",
      isAttr: true,
      type: "String"
    }, {
      name: "participantRef",
      type: "Participant",
      isMany: true,
      isReference: true
    }, {
      name: "messageFlowRefs",
      type: "MessageFlow",
      isMany: true,
      isReference: true
    }, {
      name: "correlationKeys",
      type: "CorrelationKey",
      isMany: true
    }]
  }, {
    name: "GlobalConversation",
    superClass: ["Collaboration"]
  }, {
    name: "PartnerEntity",
    superClass: ["RootElement"],
    properties: [{
      name: "name",
      isAttr: true,
      type: "String"
    }, {
      name: "participantRef",
      type: "Participant",
      isMany: true,
      isReference: true
    }]
  }, {
    name: "PartnerRole",
    superClass: ["RootElement"],
    properties: [{
      name: "name",
      isAttr: true,
      type: "String"
    }, {
      name: "participantRef",
      type: "Participant",
      isMany: true,
      isReference: true
    }]
  }, {
    name: "CorrelationProperty",
    superClass: ["RootElement"],
    properties: [{
      name: "correlationPropertyRetrievalExpression",
      type: "CorrelationPropertyRetrievalExpression",
      isMany: true
    }, {
      name: "name",
      isAttr: true,
      type: "String"
    }, {
      name: "type",
      type: "ItemDefinition",
      isAttr: true,
      isReference: true
    }]
  }, {
    name: "Error",
    superClass: ["RootElement"],
    properties: [{
      name: "structureRef",
      type: "ItemDefinition",
      isAttr: true,
      isReference: true
    }, {
      name: "name",
      isAttr: true,
      type: "String"
    }, {
      name: "errorCode",
      isAttr: true,
      type: "String"
    }]
  }, {
    name: "CorrelationKey",
    superClass: ["BaseElement"],
    properties: [{
      name: "correlationPropertyRef",
      type: "CorrelationProperty",
      isMany: true,
      isReference: true
    }, {
      name: "name",
      isAttr: true,
      type: "String"
    }]
  }, {
    name: "Expression",
    superClass: ["BaseElement"],
    isAbstract: false,
    properties: [{
      name: "body",
      isBody: true,
      type: "String"
    }]
  }, {
    name: "FormalExpression",
    superClass: ["Expression"],
    properties: [{
      name: "language",
      isAttr: true,
      type: "String"
    }, {
      name: "evaluatesToTypeRef",
      type: "ItemDefinition",
      isAttr: true,
      isReference: true
    }]
  }, {
    name: "Message",
    superClass: ["RootElement"],
    properties: [{
      name: "name",
      isAttr: true,
      type: "String"
    }, {
      name: "itemRef",
      type: "ItemDefinition",
      isAttr: true,
      isReference: true
    }]
  }, {
    name: "ItemDefinition",
    superClass: ["RootElement"],
    properties: [{
      name: "itemKind",
      type: "ItemKind",
      isAttr: true
    }, {
      name: "structureRef",
      isAttr: true,
      type: "String"
    }, {
      name: "isCollection",
      "default": false,
      isAttr: true,
      type: "Boolean"
    }, {
      name: "import",
      type: "Import",
      isAttr: true,
      isReference: true
    }]
  }, {
    name: "FlowElement",
    isAbstract: true,
    superClass: ["BaseElement"],
    properties: [{
      name: "name",
      isAttr: true,
      type: "String"
    }, {
      name: "auditing",
      type: "Auditing"
    }, {
      name: "monitoring",
      type: "Monitoring"
    }, {
      name: "categoryValueRef",
      type: "CategoryValue",
      isMany: true,
      isReference: true
    }]
  }, {
    name: "SequenceFlow",
    superClass: ["FlowElement"],
    properties: [{
      name: "isImmediate",
      isAttr: true,
      type: "Boolean"
    }, {
      name: "conditionExpression",
      type: "Expression",
      xml: {
        serialize: "xsi:type"
      }
    }, {
      name: "sourceRef",
      type: "FlowNode",
      isAttr: true,
      isReference: true
    }, {
      name: "targetRef",
      type: "FlowNode",
      isAttr: true,
      isReference: true
    }]
  }, {
    name: "FlowElementsContainer",
    isAbstract: true,
    superClass: ["BaseElement"],
    properties: [{
      name: "laneSets",
      type: "LaneSet",
      isMany: true
    }, {
      name: "flowElements",
      type: "FlowElement",
      isMany: true
    }]
  }, {
    name: "CallableElement",
    isAbstract: true,
    superClass: ["RootElement"],
    properties: [{
      name: "name",
      isAttr: true,
      type: "String"
    }, {
      name: "ioSpecification",
      type: "InputOutputSpecification",
      xml: {
        serialize: "property"
      }
    }, {
      name: "supportedInterfaceRef",
      type: "Interface",
      isMany: true,
      isReference: true
    }, {
      name: "ioBinding",
      type: "InputOutputBinding",
      isMany: true,
      xml: {
        serialize: "property"
      }
    }]
  }, {
    name: "FlowNode",
    isAbstract: true,
    superClass: ["FlowElement"],
    properties: [{
      name: "incoming",
      type: "SequenceFlow",
      isMany: true,
      isReference: true
    }, {
      name: "outgoing",
      type: "SequenceFlow",
      isMany: true,
      isReference: true
    }, {
      name: "lanes",
      type: "Lane",
      isMany: true,
      isVirtual: true,
      isReference: true
    }]
  }, {
    name: "CorrelationPropertyRetrievalExpression",
    superClass: ["BaseElement"],
    properties: [{
      name: "messagePath",
      type: "FormalExpression"
    }, {
      name: "messageRef",
      type: "Message",
      isAttr: true,
      isReference: true
    }]
  }, {
    name: "CorrelationPropertyBinding",
    superClass: ["BaseElement"],
    properties: [{
      name: "dataPath",
      type: "FormalExpression"
    }, {
      name: "correlationPropertyRef",
      type: "CorrelationProperty",
      isAttr: true,
      isReference: true
    }]
  }, {
    name: "Resource",
    superClass: ["RootElement"],
    properties: [{
      name: "name",
      isAttr: true,
      type: "String"
    }, {
      name: "resourceParameters",
      type: "ResourceParameter",
      isMany: true
    }]
  }, {
    name: "ResourceParameter",
    superClass: ["BaseElement"],
    properties: [{
      name: "name",
      isAttr: true,
      type: "String"
    }, {
      name: "isRequired",
      isAttr: true,
      type: "Boolean"
    }, {
      name: "type",
      type: "ItemDefinition",
      isAttr: true,
      isReference: true
    }]
  }, {
    name: "CorrelationSubscription",
    superClass: ["BaseElement"],
    properties: [{
      name: "correlationKeyRef",
      type: "CorrelationKey",
      isAttr: true,
      isReference: true
    }, {
      name: "correlationPropertyBinding",
      type: "CorrelationPropertyBinding",
      isMany: true
    }]
  }, {
    name: "MessageFlow",
    superClass: ["BaseElement"],
    properties: [{
      name: "name",
      isAttr: true,
      type: "String"
    }, {
      name: "sourceRef",
      type: "InteractionNode",
      isAttr: true,
      isReference: true
    }, {
      name: "targetRef",
      type: "InteractionNode",
      isAttr: true,
      isReference: true
    }, {
      name: "messageRef",
      type: "Message",
      isAttr: true,
      isReference: true
    }]
  }, {
    name: "MessageFlowAssociation",
    superClass: ["BaseElement"],
    properties: [{
      name: "innerMessageFlowRef",
      type: "MessageFlow",
      isAttr: true,
      isReference: true
    }, {
      name: "outerMessageFlowRef",
      type: "MessageFlow",
      isAttr: true,
      isReference: true
    }]
  }, {
    name: "InteractionNode",
    isAbstract: true,
    properties: [{
      name: "incomingConversationLinks",
      type: "ConversationLink",
      isMany: true,
      isVirtual: true,
      isReference: true
    }, {
      name: "outgoingConversationLinks",
      type: "ConversationLink",
      isMany: true,
      isVirtual: true,
      isReference: true
    }]
  }, {
    name: "Participant",
    superClass: ["InteractionNode", "BaseElement"],
    properties: [{
      name: "name",
      isAttr: true,
      type: "String"
    }, {
      name: "interfaceRef",
      type: "Interface",
      isMany: true,
      isReference: true
    }, {
      name: "participantMultiplicity",
      type: "ParticipantMultiplicity"
    }, {
      name: "endPointRefs",
      type: "EndPoint",
      isMany: true,
      isReference: true
    }, {
      name: "processRef",
      type: "Process",
      isAttr: true,
      isReference: true
    }]
  }, {
    name: "ParticipantAssociation",
    superClass: ["BaseElement"],
    properties: [{
      name: "innerParticipantRef",
      type: "Participant",
      isAttr: true,
      isReference: true
    }, {
      name: "outerParticipantRef",
      type: "Participant",
      isAttr: true,
      isReference: true
    }]
  }, {
    name: "ParticipantMultiplicity",
    properties: [{
      name: "minimum",
      "default": 0,
      isAttr: true,
      type: "Integer"
    }, {
      name: "maximum",
      "default": 1,
      isAttr: true,
      type: "Integer"
    }],
    superClass: ["BaseElement"]
  }, {
    name: "Collaboration",
    superClass: ["RootElement"],
    properties: [{
      name: "name",
      isAttr: true,
      type: "String"
    }, {
      name: "isClosed",
      isAttr: true,
      type: "Boolean"
    }, {
      name: "participants",
      type: "Participant",
      isMany: true
    }, {
      name: "messageFlows",
      type: "MessageFlow",
      isMany: true
    }, {
      name: "artifacts",
      type: "Artifact",
      isMany: true
    }, {
      name: "conversations",
      type: "ConversationNode",
      isMany: true
    }, {
      name: "conversationAssociations",
      type: "ConversationAssociation"
    }, {
      name: "participantAssociations",
      type: "ParticipantAssociation",
      isMany: true
    }, {
      name: "messageFlowAssociations",
      type: "MessageFlowAssociation",
      isMany: true
    }, {
      name: "correlationKeys",
      type: "CorrelationKey",
      isMany: true
    }, {
      name: "choreographyRef",
      type: "Choreography",
      isMany: true,
      isReference: true
    }, {
      name: "conversationLinks",
      type: "ConversationLink",
      isMany: true
    }]
  }, {
    name: "ChoreographyActivity",
    isAbstract: true,
    superClass: ["FlowNode"],
    properties: [{
      name: "participantRef",
      type: "Participant",
      isMany: true,
      isReference: true
    }, {
      name: "initiatingParticipantRef",
      type: "Participant",
      isAttr: true,
      isReference: true
    }, {
      name: "correlationKeys",
      type: "CorrelationKey",
      isMany: true
    }, {
      name: "loopType",
      type: "ChoreographyLoopType",
      "default": "None",
      isAttr: true
    }]
  }, {
    name: "CallChoreography",
    superClass: ["ChoreographyActivity"],
    properties: [{
      name: "calledChoreographyRef",
      type: "Choreography",
      isAttr: true,
      isReference: true
    }, {
      name: "participantAssociations",
      type: "ParticipantAssociation",
      isMany: true
    }]
  }, {
    name: "SubChoreography",
    superClass: ["ChoreographyActivity", "FlowElementsContainer"],
    properties: [{
      name: "artifacts",
      type: "Artifact",
      isMany: true
    }]
  }, {
    name: "ChoreographyTask",
    superClass: ["ChoreographyActivity"],
    properties: [{
      name: "messageFlowRef",
      type: "MessageFlow",
      isMany: true,
      isReference: true
    }]
  }, {
    name: "Choreography",
    superClass: ["Collaboration", "FlowElementsContainer"]
  }, {
    name: "GlobalChoreographyTask",
    superClass: ["Choreography"],
    properties: [{
      name: "initiatingParticipantRef",
      type: "Participant",
      isAttr: true,
      isReference: true
    }]
  }, {
    name: "TextAnnotation",
    superClass: ["Artifact"],
    properties: [{
      name: "text",
      type: "String"
    }, {
      name: "textFormat",
      "default": "text/plain",
      isAttr: true,
      type: "String"
    }]
  }, {
    name: "Group",
    superClass: ["Artifact"],
    properties: [{
      name: "categoryValueRef",
      type: "CategoryValue",
      isAttr: true,
      isReference: true
    }]
  }, {
    name: "Association",
    superClass: ["Artifact"],
    properties: [{
      name: "associationDirection",
      type: "AssociationDirection",
      isAttr: true
    }, {
      name: "sourceRef",
      type: "BaseElement",
      isAttr: true,
      isReference: true
    }, {
      name: "targetRef",
      type: "BaseElement",
      isAttr: true,
      isReference: true
    }]
  }, {
    name: "Category",
    superClass: ["RootElement"],
    properties: [{
      name: "categoryValue",
      type: "CategoryValue",
      isMany: true
    }, {
      name: "name",
      isAttr: true,
      type: "String"
    }]
  }, {
    name: "Artifact",
    isAbstract: true,
    superClass: ["BaseElement"]
  }, {
    name: "CategoryValue",
    superClass: ["BaseElement"],
    properties: [{
      name: "categorizedFlowElements",
      type: "FlowElement",
      isMany: true,
      isVirtual: true,
      isReference: true
    }, {
      name: "value",
      isAttr: true,
      type: "String"
    }]
  }, {
    name: "Activity",
    isAbstract: true,
    superClass: ["FlowNode"],
    properties: [{
      name: "isForCompensation",
      "default": false,
      isAttr: true,
      type: "Boolean"
    }, {
      name: "default",
      type: "SequenceFlow",
      isAttr: true,
      isReference: true
    }, {
      name: "ioSpecification",
      type: "InputOutputSpecification",
      xml: {
        serialize: "property"
      }
    }, {
      name: "boundaryEventRefs",
      type: "BoundaryEvent",
      isMany: true,
      isReference: true
    }, {
      name: "properties",
      type: "Property",
      isMany: true
    }, {
      name: "dataInputAssociations",
      type: "DataInputAssociation",
      isMany: true
    }, {
      name: "dataOutputAssociations",
      type: "DataOutputAssociation",
      isMany: true
    }, {
      name: "startQuantity",
      "default": 1,
      isAttr: true,
      type: "Integer"
    }, {
      name: "resources",
      type: "ResourceRole",
      isMany: true
    }, {
      name: "completionQuantity",
      "default": 1,
      isAttr: true,
      type: "Integer"
    }, {
      name: "loopCharacteristics",
      type: "LoopCharacteristics"
    }]
  }, {
    name: "ServiceTask",
    superClass: ["Task"],
    properties: [{
      name: "implementation",
      isAttr: true,
      type: "String"
    }, {
      name: "operationRef",
      type: "Operation",
      isAttr: true,
      isReference: true
    }]
  }, {
    name: "SubProcess",
    superClass: ["Activity", "FlowElementsContainer", "InteractionNode"],
    properties: [{
      name: "triggeredByEvent",
      "default": false,
      isAttr: true,
      type: "Boolean"
    }, {
      name: "artifacts",
      type: "Artifact",
      isMany: true
    }]
  }, {
    name: "LoopCharacteristics",
    isAbstract: true,
    superClass: ["BaseElement"]
  }, {
    name: "MultiInstanceLoopCharacteristics",
    superClass: ["LoopCharacteristics"],
    properties: [{
      name: "isSequential",
      "default": false,
      isAttr: true,
      type: "Boolean"
    }, {
      name: "behavior",
      type: "MultiInstanceBehavior",
      "default": "All",
      isAttr: true
    }, {
      name: "loopCardinality",
      type: "Expression",
      xml: {
        serialize: "xsi:type"
      }
    }, {
      name: "loopDataInputRef",
      type: "ItemAwareElement",
      isReference: true
    }, {
      name: "loopDataOutputRef",
      type: "ItemAwareElement",
      isReference: true
    }, {
      name: "inputDataItem",
      type: "DataInput",
      xml: {
        serialize: "property"
      }
    }, {
      name: "outputDataItem",
      type: "DataOutput",
      xml: {
        serialize: "property"
      }
    }, {
      name: "complexBehaviorDefinition",
      type: "ComplexBehaviorDefinition",
      isMany: true
    }, {
      name: "completionCondition",
      type: "Expression",
      xml: {
        serialize: "xsi:type"
      }
    }, {
      name: "oneBehaviorEventRef",
      type: "EventDefinition",
      isAttr: true,
      isReference: true
    }, {
      name: "noneBehaviorEventRef",
      type: "EventDefinition",
      isAttr: true,
      isReference: true
    }]
  }, {
    name: "StandardLoopCharacteristics",
    superClass: ["LoopCharacteristics"],
    properties: [{
      name: "testBefore",
      "default": false,
      isAttr: true,
      type: "Boolean"
    }, {
      name: "loopCondition",
      type: "Expression",
      xml: {
        serialize: "xsi:type"
      }
    }, {
      name: "loopMaximum",
      type: "Integer",
      isAttr: true
    }]
  }, {
    name: "CallActivity",
    superClass: ["Activity", "InteractionNode"],
    properties: [{
      name: "calledElement",
      type: "String",
      isAttr: true
    }]
  }, {
    name: "Task",
    superClass: ["Activity", "InteractionNode"]
  }, {
    name: "SendTask",
    superClass: ["Task"],
    properties: [{
      name: "implementation",
      isAttr: true,
      type: "String"
    }, {
      name: "operationRef",
      type: "Operation",
      isAttr: true,
      isReference: true
    }, {
      name: "messageRef",
      type: "Message",
      isAttr: true,
      isReference: true
    }]
  }, {
    name: "ReceiveTask",
    superClass: ["Task"],
    properties: [{
      name: "implementation",
      isAttr: true,
      type: "String"
    }, {
      name: "instantiate",
      "default": false,
      isAttr: true,
      type: "Boolean"
    }, {
      name: "operationRef",
      type: "Operation",
      isAttr: true,
      isReference: true
    }, {
      name: "messageRef",
      type: "Message",
      isAttr: true,
      isReference: true
    }]
  }, {
    name: "ScriptTask",
    superClass: ["Task"],
    properties: [{
      name: "scriptFormat",
      isAttr: true,
      type: "String"
    }, {
      name: "script",
      type: "String"
    }]
  }, {
    name: "BusinessRuleTask",
    superClass: ["Task"],
    properties: [{
      name: "implementation",
      isAttr: true,
      type: "String"
    }]
  }, {
    name: "AdHocSubProcess",
    superClass: ["SubProcess"],
    properties: [{
      name: "completionCondition",
      type: "Expression",
      xml: {
        serialize: "xsi:type"
      }
    }, {
      name: "ordering",
      type: "AdHocOrdering",
      isAttr: true
    }, {
      name: "cancelRemainingInstances",
      "default": true,
      isAttr: true,
      type: "Boolean"
    }]
  }, {
    name: "Transaction",
    superClass: ["SubProcess"],
    properties: [{
      name: "protocol",
      isAttr: true,
      type: "String"
    }, {
      name: "method",
      isAttr: true,
      type: "String"
    }]
  }, {
    name: "GlobalScriptTask",
    superClass: ["GlobalTask"],
    properties: [{
      name: "scriptLanguage",
      isAttr: true,
      type: "String"
    }, {
      name: "script",
      isAttr: true,
      type: "String"
    }]
  }, {
    name: "GlobalBusinessRuleTask",
    superClass: ["GlobalTask"],
    properties: [{
      name: "implementation",
      isAttr: true,
      type: "String"
    }]
  }, {
    name: "ComplexBehaviorDefinition",
    superClass: ["BaseElement"],
    properties: [{
      name: "condition",
      type: "FormalExpression"
    }, {
      name: "event",
      type: "ImplicitThrowEvent"
    }]
  }, {
    name: "ResourceRole",
    superClass: ["BaseElement"],
    properties: [{
      name: "resourceRef",
      type: "Resource",
      isReference: true
    }, {
      name: "resourceParameterBindings",
      type: "ResourceParameterBinding",
      isMany: true
    }, {
      name: "resourceAssignmentExpression",
      type: "ResourceAssignmentExpression"
    }, {
      name: "name",
      isAttr: true,
      type: "String"
    }]
  }, {
    name: "ResourceParameterBinding",
    properties: [{
      name: "expression",
      type: "Expression",
      xml: {
        serialize: "xsi:type"
      }
    }, {
      name: "parameterRef",
      type: "ResourceParameter",
      isAttr: true,
      isReference: true
    }],
    superClass: ["BaseElement"]
  }, {
    name: "ResourceAssignmentExpression",
    properties: [{
      name: "expression",
      type: "Expression",
      xml: {
        serialize: "xsi:type"
      }
    }],
    superClass: ["BaseElement"]
  }, {
    name: "Import",
    properties: [{
      name: "importType",
      isAttr: true,
      type: "String"
    }, {
      name: "location",
      isAttr: true,
      type: "String"
    }, {
      name: "namespace",
      isAttr: true,
      type: "String"
    }]
  }, {
    name: "Definitions",
    superClass: ["BaseElement"],
    properties: [{
      name: "name",
      isAttr: true,
      type: "String"
    }, {
      name: "targetNamespace",
      isAttr: true,
      type: "String"
    }, {
      name: "expressionLanguage",
      "default": "http://www.w3.org/1999/XPath",
      isAttr: true,
      type: "String"
    }, {
      name: "typeLanguage",
      "default": "http://www.w3.org/2001/XMLSchema",
      isAttr: true,
      type: "String"
    }, {
      name: "imports",
      type: "Import",
      isMany: true
    }, {
      name: "extensions",
      type: "Extension",
      isMany: true
    }, {
      name: "rootElements",
      type: "RootElement",
      isMany: true
    }, {
      name: "diagrams",
      isMany: true,
      type: "bpmndi:BPMNDiagram"
    }, {
      name: "exporter",
      isAttr: true,
      type: "String"
    }, {
      name: "relationships",
      type: "Relationship",
      isMany: true
    }, {
      name: "exporterVersion",
      isAttr: true,
      type: "String"
    }]
  }];
  var enumerations$3 = [{
    name: "ProcessType",
    literalValues: [{
      name: "None"
    }, {
      name: "Public"
    }, {
      name: "Private"
    }]
  }, {
    name: "GatewayDirection",
    literalValues: [{
      name: "Unspecified"
    }, {
      name: "Converging"
    }, {
      name: "Diverging"
    }, {
      name: "Mixed"
    }]
  }, {
    name: "EventBasedGatewayType",
    literalValues: [{
      name: "Parallel"
    }, {
      name: "Exclusive"
    }]
  }, {
    name: "RelationshipDirection",
    literalValues: [{
      name: "None"
    }, {
      name: "Forward"
    }, {
      name: "Backward"
    }, {
      name: "Both"
    }]
  }, {
    name: "ItemKind",
    literalValues: [{
      name: "Physical"
    }, {
      name: "Information"
    }]
  }, {
    name: "ChoreographyLoopType",
    literalValues: [{
      name: "None"
    }, {
      name: "Standard"
    }, {
      name: "MultiInstanceSequential"
    }, {
      name: "MultiInstanceParallel"
    }]
  }, {
    name: "AssociationDirection",
    literalValues: [{
      name: "None"
    }, {
      name: "One"
    }, {
      name: "Both"
    }]
  }, {
    name: "MultiInstanceBehavior",
    literalValues: [{
      name: "None"
    }, {
      name: "One"
    }, {
      name: "All"
    }, {
      name: "Complex"
    }]
  }, {
    name: "AdHocOrdering",
    literalValues: [{
      name: "Parallel"
    }, {
      name: "Sequential"
    }]
  }];
  var xml$1 = {
    tagAlias: "lowerCase",
    typePrefix: "t"
  };
  var BpmnPackage = {
    name: name$5,
    uri: uri$5,
    prefix: prefix$5,
    associations: associations$5,
    types: types$5,
    enumerations: enumerations$3,
    xml: xml$1
  };
  var name$4 = "BPMNDI";
  var uri$4 = "http://www.omg.org/spec/BPMN/20100524/DI";
  var prefix$4 = "bpmndi";
  var types$4 = [{
    name: "BPMNDiagram",
    properties: [{
      name: "plane",
      type: "BPMNPlane",
      redefines: "di:Diagram#rootElement"
    }, {
      name: "labelStyle",
      type: "BPMNLabelStyle",
      isMany: true
    }],
    superClass: ["di:Diagram"]
  }, {
    name: "BPMNPlane",
    properties: [{
      name: "bpmnElement",
      isAttr: true,
      isReference: true,
      type: "bpmn:BaseElement",
      redefines: "di:DiagramElement#modelElement"
    }],
    superClass: ["di:Plane"]
  }, {
    name: "BPMNShape",
    properties: [{
      name: "bpmnElement",
      isAttr: true,
      isReference: true,
      type: "bpmn:BaseElement",
      redefines: "di:DiagramElement#modelElement"
    }, {
      name: "isHorizontal",
      isAttr: true,
      type: "Boolean"
    }, {
      name: "isExpanded",
      isAttr: true,
      type: "Boolean"
    }, {
      name: "isMarkerVisible",
      isAttr: true,
      type: "Boolean"
    }, {
      name: "label",
      type: "BPMNLabel"
    }, {
      name: "isMessageVisible",
      isAttr: true,
      type: "Boolean"
    }, {
      name: "participantBandKind",
      type: "ParticipantBandKind",
      isAttr: true
    }, {
      name: "choreographyActivityShape",
      type: "BPMNShape",
      isAttr: true,
      isReference: true
    }],
    superClass: ["di:LabeledShape"]
  }, {
    name: "BPMNEdge",
    properties: [{
      name: "label",
      type: "BPMNLabel"
    }, {
      name: "bpmnElement",
      isAttr: true,
      isReference: true,
      type: "bpmn:BaseElement",
      redefines: "di:DiagramElement#modelElement"
    }, {
      name: "sourceElement",
      isAttr: true,
      isReference: true,
      type: "di:DiagramElement",
      redefines: "di:Edge#source"
    }, {
      name: "targetElement",
      isAttr: true,
      isReference: true,
      type: "di:DiagramElement",
      redefines: "di:Edge#target"
    }, {
      name: "messageVisibleKind",
      type: "MessageVisibleKind",
      isAttr: true,
      "default": "initiating"
    }],
    superClass: ["di:LabeledEdge"]
  }, {
    name: "BPMNLabel",
    properties: [{
      name: "labelStyle",
      type: "BPMNLabelStyle",
      isAttr: true,
      isReference: true,
      redefines: "di:DiagramElement#style"
    }],
    superClass: ["di:Label"]
  }, {
    name: "BPMNLabelStyle",
    properties: [{
      name: "font",
      type: "dc:Font"
    }],
    superClass: ["di:Style"]
  }];
  var enumerations$2 = [{
    name: "ParticipantBandKind",
    literalValues: [{
      name: "top_initiating"
    }, {
      name: "middle_initiating"
    }, {
      name: "bottom_initiating"
    }, {
      name: "top_non_initiating"
    }, {
      name: "middle_non_initiating"
    }, {
      name: "bottom_non_initiating"
    }]
  }, {
    name: "MessageVisibleKind",
    literalValues: [{
      name: "initiating"
    }, {
      name: "non_initiating"
    }]
  }];
  var associations$4 = [];
  var BpmnDiPackage = {
    name: name$4,
    uri: uri$4,
    prefix: prefix$4,
    types: types$4,
    enumerations: enumerations$2,
    associations: associations$4
  };
  var name$3 = "DC";
  var uri$3 = "http://www.omg.org/spec/DD/20100524/DC";
  var prefix$3 = "dc";
  var types$3 = [{
    name: "Boolean"
  }, {
    name: "Integer"
  }, {
    name: "Real"
  }, {
    name: "String"
  }, {
    name: "Font",
    properties: [{
      name: "name",
      type: "String",
      isAttr: true
    }, {
      name: "size",
      type: "Real",
      isAttr: true
    }, {
      name: "isBold",
      type: "Boolean",
      isAttr: true
    }, {
      name: "isItalic",
      type: "Boolean",
      isAttr: true
    }, {
      name: "isUnderline",
      type: "Boolean",
      isAttr: true
    }, {
      name: "isStrikeThrough",
      type: "Boolean",
      isAttr: true
    }]
  }, {
    name: "Point",
    properties: [{
      name: "x",
      type: "Real",
      "default": "0",
      isAttr: true
    }, {
      name: "y",
      type: "Real",
      "default": "0",
      isAttr: true
    }]
  }, {
    name: "Bounds",
    properties: [{
      name: "x",
      type: "Real",
      "default": "0",
      isAttr: true
    }, {
      name: "y",
      type: "Real",
      "default": "0",
      isAttr: true
    }, {
      name: "width",
      type: "Real",
      isAttr: true
    }, {
      name: "height",
      type: "Real",
      isAttr: true
    }]
  }];
  var associations$3 = [];
  var DcPackage = {
    name: name$3,
    uri: uri$3,
    prefix: prefix$3,
    types: types$3,
    associations: associations$3
  };
  var name$2 = "DI";
  var uri$2 = "http://www.omg.org/spec/DD/20100524/DI";
  var prefix$2 = "di";
  var types$2 = [{
    name: "DiagramElement",
    isAbstract: true,
    properties: [{
      name: "id",
      isAttr: true,
      isId: true,
      type: "String"
    }, {
      name: "extension",
      type: "Extension"
    }, {
      name: "owningDiagram",
      type: "Diagram",
      isReadOnly: true,
      isVirtual: true,
      isReference: true
    }, {
      name: "owningElement",
      type: "DiagramElement",
      isReadOnly: true,
      isVirtual: true,
      isReference: true
    }, {
      name: "modelElement",
      isReadOnly: true,
      isVirtual: true,
      isReference: true,
      type: "Element"
    }, {
      name: "style",
      type: "Style",
      isReadOnly: true,
      isVirtual: true,
      isReference: true
    }, {
      name: "ownedElement",
      type: "DiagramElement",
      isReadOnly: true,
      isMany: true,
      isVirtual: true
    }]
  }, {
    name: "Node",
    isAbstract: true,
    superClass: ["DiagramElement"]
  }, {
    name: "Edge",
    isAbstract: true,
    superClass: ["DiagramElement"],
    properties: [{
      name: "source",
      type: "DiagramElement",
      isReadOnly: true,
      isVirtual: true,
      isReference: true
    }, {
      name: "target",
      type: "DiagramElement",
      isReadOnly: true,
      isVirtual: true,
      isReference: true
    }, {
      name: "waypoint",
      isUnique: false,
      isMany: true,
      type: "dc:Point",
      xml: {
        serialize: "xsi:type"
      }
    }]
  }, {
    name: "Diagram",
    isAbstract: true,
    properties: [{
      name: "id",
      isAttr: true,
      isId: true,
      type: "String"
    }, {
      name: "rootElement",
      type: "DiagramElement",
      isReadOnly: true,
      isVirtual: true
    }, {
      name: "name",
      isAttr: true,
      type: "String"
    }, {
      name: "documentation",
      isAttr: true,
      type: "String"
    }, {
      name: "resolution",
      isAttr: true,
      type: "Real"
    }, {
      name: "ownedStyle",
      type: "Style",
      isReadOnly: true,
      isMany: true,
      isVirtual: true
    }]
  }, {
    name: "Shape",
    isAbstract: true,
    superClass: ["Node"],
    properties: [{
      name: "bounds",
      type: "dc:Bounds"
    }]
  }, {
    name: "Plane",
    isAbstract: true,
    superClass: ["Node"],
    properties: [{
      name: "planeElement",
      type: "DiagramElement",
      subsettedProperty: "DiagramElement-ownedElement",
      isMany: true
    }]
  }, {
    name: "LabeledEdge",
    isAbstract: true,
    superClass: ["Edge"],
    properties: [{
      name: "ownedLabel",
      type: "Label",
      isReadOnly: true,
      subsettedProperty: "DiagramElement-ownedElement",
      isMany: true,
      isVirtual: true
    }]
  }, {
    name: "LabeledShape",
    isAbstract: true,
    superClass: ["Shape"],
    properties: [{
      name: "ownedLabel",
      type: "Label",
      isReadOnly: true,
      subsettedProperty: "DiagramElement-ownedElement",
      isMany: true,
      isVirtual: true
    }]
  }, {
    name: "Label",
    isAbstract: true,
    superClass: ["Node"],
    properties: [{
      name: "bounds",
      type: "dc:Bounds"
    }]
  }, {
    name: "Style",
    isAbstract: true,
    properties: [{
      name: "id",
      isAttr: true,
      isId: true,
      type: "String"
    }]
  }, {
    name: "Extension",
    properties: [{
      name: "values",
      isMany: true,
      type: "Element"
    }]
  }];
  var associations$2 = [];
  var xml = {
    tagAlias: "lowerCase"
  };
  var DiPackage = {
    name: name$2,
    uri: uri$2,
    prefix: prefix$2,
    types: types$2,
    associations: associations$2,
    xml: xml
  };
  var name$1 = "bpmn.io colors for BPMN";
  var uri$1 = "http://bpmn.io/schema/bpmn/biocolor/1.0";
  var prefix$1 = "bioc";
  var types$1 = [{
    name: "ColoredShape",
    "extends": ["bpmndi:BPMNShape"],
    properties: [{
      name: "stroke",
      isAttr: true,
      type: "String"
    }, {
      name: "fill",
      isAttr: true,
      type: "String"
    }]
  }, {
    name: "ColoredEdge",
    "extends": ["bpmndi:BPMNEdge"],
    properties: [{
      name: "stroke",
      isAttr: true,
      type: "String"
    }, {
      name: "fill",
      isAttr: true,
      type: "String"
    }]
  }];
  var enumerations$1 = [];
  var associations$1 = [];
  var BiocPackage = {
    name: name$1,
    uri: uri$1,
    prefix: prefix$1,
    types: types$1,
    enumerations: enumerations$1,
    associations: associations$1
  };
  var name = "BPMN in Color";
  var uri = "http://www.omg.org/spec/BPMN/non-normative/color/1.0";
  var prefix = "color";
  var types = [{
    name: "ColoredLabel",
    "extends": ["bpmndi:BPMNLabel"],
    properties: [{
      name: "color",
      isAttr: true,
      type: "String"
    }]
  }, {
    name: "ColoredShape",
    "extends": ["bpmndi:BPMNShape"],
    properties: [{
      name: "background-color",
      isAttr: true,
      type: "String"
    }, {
      name: "border-color",
      isAttr: true,
      type: "String"
    }]
  }, {
    name: "ColoredEdge",
    "extends": ["bpmndi:BPMNEdge"],
    properties: [{
      name: "border-color",
      isAttr: true,
      type: "String"
    }]
  }];
  var enumerations = [];
  var associations = [];
  var BpmnInColorPackage = {
    name: name,
    uri: uri,
    prefix: prefix,
    types: types,
    enumerations: enumerations,
    associations: associations
  };
  var packages = {
    bpmn: BpmnPackage,
    bpmndi: BpmnDiPackage,
    dc: DcPackage,
    di: DiPackage,
    bioc: BiocPackage,
    color: BpmnInColorPackage
  };
  function SimpleBpmnModdle(additionalPackages, options) {
    var pks = assign$1({}, packages, additionalPackages);
    return new BpmnModdle(pks, options);
  }
  function elementToString(e) {
    if (!e) {
      return '<null>';
    }
    return '<' + e.$type + (e.id ? ' id="' + e.id : '') + '" />';
  }
  var DI_ERROR_MESSAGE = 'Tried to access di from the businessObject. The di is available through the diagram element only. For more information, see https://github.com/bpmn-io/bpmn-js/issues/1472';
  function ensureCompatDiRef(businessObject) {
    if (!has$1(businessObject, 'di')) {
      Object.defineProperty(businessObject, 'di', {
        enumerable: false,
        get: function get() {
          throw new Error(DI_ERROR_MESSAGE);
        }
      });
    }
  }
  function is$1(element, type) {
    return element.$instanceOf(type);
  }
  function findDisplayCandidate(definitions) {
    return find(definitions.rootElements, function (e) {
      return is$1(e, 'bpmn:Process') || is$1(e, 'bpmn:Collaboration');
    });
  }
  function BpmnTreeWalker(handler) {
    var handledElements = {};
    var deferred = [];
    var diMap = {};
    function contextual(fn, ctx) {
      return function (e) {
        fn(e, ctx);
      };
    }
    function handled(element) {
      handledElements[element.id] = element;
    }
    function isHandled(element) {
      return handledElements[element.id];
    }
    function visit(element, ctx) {
      var gfx = element.gfx;
      if (gfx) {
        throw new Error(`already rendered ${elementToString(element)}`);
      }
      return handler.element(element, diMap[element.id], ctx);
    }
    function visitRoot(element, diagram) {
      return handler.root(element, diMap[element.id], diagram);
    }
    function visitIfDi(element, ctx) {
      try {
        var gfx = diMap[element.id] && visit(element, ctx);
        handled(element);
        return gfx;
      } catch (error) {
        logError(error.message, {
          element,
          error
        });
        console.error(`failed to import ${elementToString(element)}`, error);
      }
    }
    function logError(message, context) {
      handler.error(message, context);
    }
    var registerDi = this.registerDi = function registerDi(di) {
      var bpmnElement = di.bpmnElement;
      if (bpmnElement) {
        if (diMap[bpmnElement.id]) {
          logError(`multiple DI elements defined for ${elementToString(bpmnElement)}`, {
            element: bpmnElement
          });
        } else {
          diMap[bpmnElement.id] = di;
          ensureCompatDiRef(bpmnElement);
        }
      } else {
        logError(`no bpmnElement referenced in ${elementToString(di)}`, {
          element: di
        });
      }
    };
    function handleDiagram(diagram) {
      handlePlane(diagram.plane);
    }
    function handlePlane(plane) {
      registerDi(plane);
      forEach$1(plane.planeElement, handlePlaneElement);
    }
    function handlePlaneElement(planeElement) {
      registerDi(planeElement);
    }
    this.handleDefinitions = function handleDefinitions(definitions, diagram) {
      var diagrams = definitions.diagrams;
      if (diagram && diagrams.indexOf(diagram) === -1) {
        throw new Error('diagram not part of <bpmn:Definitions />');
      }
      if (!diagram && diagrams && diagrams.length) {
        diagram = diagrams[0];
      }
      if (!diagram) {
        throw new Error('no diagram to display');
      }
      diMap = {};
      handleDiagram(diagram);
      var plane = diagram.plane;
      if (!plane) {
        throw new Error(`no plane for ${elementToString(diagram)}`);
      }
      var rootElement = plane.bpmnElement;
      if (!rootElement) {
        rootElement = findDisplayCandidate(definitions);
        if (!rootElement) {
          throw new Error('no process or collaboration to display');
        } else {
          logError(`correcting missing bpmnElement on ${elementToString(plane)} to ${elementToString(rootElement)}`);
          plane.bpmnElement = rootElement;
          registerDi(plane);
        }
      }
      var ctx = visitRoot(rootElement, plane);
      if (is$1(rootElement, 'bpmn:Process') || is$1(rootElement, 'bpmn:SubProcess')) {
        handleProcess(rootElement, ctx);
      } else if (is$1(rootElement, 'bpmn:Collaboration')) {
        handleCollaboration(rootElement, ctx);
        handleUnhandledProcesses(definitions.rootElements, ctx);
      } else {
        throw new Error(`unsupported bpmnElement for ${elementToString(plane)}: ${elementToString(rootElement)}`);
      }
      handleDeferred(deferred);
    };
    var handleDeferred = this.handleDeferred = function handleDeferred() {
      var fn;
      while (deferred.length) {
        fn = deferred.shift();
        fn();
      }
    };
    function handleProcess(process, context) {
      handleFlowElementsContainer(process, context);
      handleIoSpecification(process.ioSpecification, context);
      handleArtifacts(process.artifacts, context);
      handled(process);
    }
    function handleUnhandledProcesses(rootElements, ctx) {
      var processes = filter(rootElements, function (e) {
        return !isHandled(e) && is$1(e, 'bpmn:Process') && e.laneSets;
      });
      processes.forEach(contextual(handleProcess, ctx));
    }
    function handleMessageFlow(messageFlow, context) {
      visitIfDi(messageFlow, context);
    }
    function handleMessageFlows(messageFlows, context) {
      forEach$1(messageFlows, contextual(handleMessageFlow, context));
    }
    function handleDataAssociation(association, context) {
      visitIfDi(association, context);
    }
    function handleDataInput(dataInput, context) {
      visitIfDi(dataInput, context);
    }
    function handleDataOutput(dataOutput, context) {
      visitIfDi(dataOutput, context);
    }
    function handleArtifact(artifact, context) {
      visitIfDi(artifact, context);
    }
    function handleArtifacts(artifacts, context) {
      forEach$1(artifacts, function (e) {
        if (is$1(e, 'bpmn:Association')) {
          deferred.push(function () {
            handleArtifact(e, context);
          });
        } else {
          handleArtifact(e, context);
        }
      });
    }
    function handleIoSpecification(ioSpecification, context) {
      if (!ioSpecification) {
        return;
      }
      forEach$1(ioSpecification.dataInputs, contextual(handleDataInput, context));
      forEach$1(ioSpecification.dataOutputs, contextual(handleDataOutput, context));
    }
    var handleSubProcess = this.handleSubProcess = function handleSubProcess(subProcess, context) {
      handleFlowElementsContainer(subProcess, context);
      handleArtifacts(subProcess.artifacts, context);
    };
    function handleFlowNode(flowNode, context) {
      var childCtx = visitIfDi(flowNode, context);
      if (is$1(flowNode, 'bpmn:SubProcess')) {
        handleSubProcess(flowNode, childCtx || context);
      }
      if (is$1(flowNode, 'bpmn:Activity')) {
        handleIoSpecification(flowNode.ioSpecification, context);
      }
      deferred.push(function () {
        forEach$1(flowNode.dataInputAssociations, contextual(handleDataAssociation, context));
        forEach$1(flowNode.dataOutputAssociations, contextual(handleDataAssociation, context));
      });
    }
    function handleSequenceFlow(sequenceFlow, context) {
      visitIfDi(sequenceFlow, context);
    }
    function handleDataElement(dataObject, context) {
      visitIfDi(dataObject, context);
    }
    function handleLane(lane, context) {
      deferred.push(function () {
        var newContext = visitIfDi(lane, context);
        if (lane.childLaneSet) {
          handleLaneSet(lane.childLaneSet, newContext || context);
        }
        wireFlowNodeRefs(lane);
      });
    }
    function handleLaneSet(laneSet, context) {
      forEach$1(laneSet.lanes, contextual(handleLane, context));
    }
    function handleLaneSets(laneSets, context) {
      forEach$1(laneSets, contextual(handleLaneSet, context));
    }
    function handleFlowElementsContainer(container, context) {
      handleFlowElements(container.flowElements, context);
      if (container.laneSets) {
        handleLaneSets(container.laneSets, context);
      }
    }
    function handleFlowElements(flowElements, context) {
      forEach$1(flowElements, function (flowElement) {
        if (is$1(flowElement, 'bpmn:SequenceFlow')) {
          deferred.push(function () {
            handleSequenceFlow(flowElement, context);
          });
        } else if (is$1(flowElement, 'bpmn:BoundaryEvent')) {
          deferred.unshift(function () {
            handleFlowNode(flowElement, context);
          });
        } else if (is$1(flowElement, 'bpmn:FlowNode')) {
          handleFlowNode(flowElement, context);
        } else if (is$1(flowElement, 'bpmn:DataObject')) ;else if (is$1(flowElement, 'bpmn:DataStoreReference')) {
          handleDataElement(flowElement, context);
        } else if (is$1(flowElement, 'bpmn:DataObjectReference')) {
          handleDataElement(flowElement, context);
        } else {
          logError(`unrecognized flowElement ${elementToString(flowElement)} in context ${elementToString(context && context.businessObject)}`, {
            element: flowElement,
            context
          });
        }
      });
    }
    function handleParticipant(participant, context) {
      var newCtx = visitIfDi(participant, context);
      var process = participant.processRef;
      if (process) {
        handleProcess(process, newCtx || context);
      }
    }
    function handleCollaboration(collaboration, context) {
      forEach$1(collaboration.participants, contextual(handleParticipant, context));
      deferred.push(function () {
        handleMessageFlows(collaboration.messageFlows, context);
      });
      handleArtifacts(collaboration.artifacts, context);
    }
    function wireFlowNodeRefs(lane) {
      forEach$1(lane.flowNodeRef, function (flowNode) {
        var lanes = flowNode.get('lanes');
        if (lanes) {
          lanes.push(lane);
        }
      });
    }
  }
  function is(element, type) {
    var bo = getBusinessObject(element);
    return bo && typeof bo.$instanceOf === 'function' && bo.$instanceOf(type);
  }
  function isAny(element, types) {
    return some(types, function (t) {
      return is(element, t);
    });
  }
  function getBusinessObject(element) {
    return element && element.businessObject || element;
  }
  function getDi(element) {
    return element && element.di;
  }
  function importBpmnDiagram(diagram, definitions, bpmnDiagram) {
    var importer, eventBus, canvas;
    var error,
      warnings = [];
    function render(definitions, bpmnDiagram) {
      var visitor = {
        root: function root(element, di) {
          return importer.add(element, di);
        },
        element: function element(_element, di, parentShape) {
          return importer.add(_element, di, parentShape);
        },
        error: function error(message, context) {
          warnings.push({
            message: message,
            context: context
          });
        }
      };
      var walker = new BpmnTreeWalker(visitor);
      bpmnDiagram = bpmnDiagram || definitions.diagrams && definitions.diagrams[0];
      var diagramsToImport = getDiagramsToImport(definitions, bpmnDiagram);
      if (!diagramsToImport) {
        throw new Error('no diagram to display');
      }
      forEach$1(diagramsToImport, function (diagram) {
        walker.handleDefinitions(definitions, diagram);
      });
      var rootId = bpmnDiagram.plane.bpmnElement.id;
      canvas.setRootElement(canvas.findRoot(rootId + '_plane') || canvas.findRoot(rootId));
    }
    return new Promise(function (resolve, reject) {
      try {
        importer = diagram.get('bpmnImporter');
        eventBus = diagram.get('eventBus');
        canvas = diagram.get('canvas');
        eventBus.fire('import.render.start', {
          definitions: definitions
        });
        render(definitions, bpmnDiagram);
        eventBus.fire('import.render.complete', {
          error: error,
          warnings: warnings
        });
        return resolve({
          warnings: warnings
        });
      } catch (e) {
        e.warnings = warnings;
        return reject(e);
      }
    });
  }
  function getDiagramsToImport(definitions, bpmnDiagram) {
    if (!bpmnDiagram || !bpmnDiagram.plane) {
      return;
    }
    var bpmnElement = bpmnDiagram.plane.bpmnElement,
      rootElement = bpmnElement;
    if (!is(bpmnElement, 'bpmn:Process') && !is(bpmnElement, 'bpmn:Collaboration')) {
      rootElement = findRootProcess(bpmnElement);
    }
    var collaboration;
    if (is(rootElement, 'bpmn:Collaboration')) {
      collaboration = rootElement;
    } else {
      collaboration = find(definitions.rootElements, function (element) {
        if (!is(element, 'bpmn:Collaboration')) {
          return;
        }
        return find(element.participants, function (participant) {
          return participant.processRef === rootElement;
        });
      });
    }
    var rootElements = [rootElement];
    if (collaboration) {
      rootElements = map$1(collaboration.participants, function (participant) {
        return participant.processRef;
      });
      rootElements.push(collaboration);
    }
    var allChildren = selfAndAllFlowElements(rootElements);
    var diagramsToImport = [bpmnDiagram];
    var handledElements = [bpmnElement];
    forEach$1(definitions.diagrams, function (diagram) {
      if (!diagram.plane) {
        return;
      }
      var businessObject = diagram.plane.bpmnElement;
      if (allChildren.indexOf(businessObject) !== -1 && handledElements.indexOf(businessObject) === -1) {
        diagramsToImport.push(diagram);
        handledElements.push(businessObject);
      }
    });
    return diagramsToImport;
  }
  function selfAndAllFlowElements(elements) {
    var result = [];
    forEach$1(elements, function (element) {
      if (!element) {
        return;
      }
      result.push(element);
      result = result.concat(selfAndAllFlowElements(element.flowElements));
    });
    return result;
  }
  function findRootProcess(element) {
    var parent = element;
    while (parent) {
      if (is(parent, 'bpmn:Process')) {
        return parent;
      }
      parent = parent.$parent;
    }
  }
  var BPMNIO_LOGO_SVG = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 14.02 5.57" width="53" height="21"><path fill="currentColor" d="M1.88.92v.14c0 .41-.13.68-.4.8.33.14.46.44.46.86v.33c0 .61-.33.95-.95.95H0V0h.95c.65 0 .93.3.93.92zM.63.57v1.06h.24c.24 0 .38-.1.38-.43V.98c0-.28-.1-.4-.32-.4zm0 1.63v1.22h.36c.2 0 .32-.1.32-.39v-.35c0-.37-.12-.48-.4-.48H.63zM4.18.99v.52c0 .64-.31.98-.94.98h-.3V4h-.62V0h.92c.63 0 .94.35.94.99zM2.94.57v1.35h.3c.2 0 .3-.09.3-.37v-.6c0-.29-.1-.38-.3-.38h-.3zm2.89 2.27L6.25 0h.88v4h-.6V1.12L6.1 3.99h-.6l-.46-2.82v2.82h-.55V0h.87zM8.14 1.1V4h-.56V0h.79L9 2.4V0h.56v4h-.64zm2.49 2.29v.6h-.6v-.6zM12.12 1c0-.63.33-1 .95-1 .61 0 .95.37.95 1v2.04c0 .64-.34 1-.95 1-.62 0-.95-.37-.95-1zm.62 2.08c0 .28.13.39.33.39s.32-.1.32-.4V.98c0-.29-.12-.4-.32-.4s-.33.11-.33.4z"/><path fill="currentColor" d="M0 4.53h14.02v1.04H0zM11.08 0h.63v.62h-.63zm.63 4V1h-.63v2.98z"/></svg>';
  var BPMNIO_IMG = BPMNIO_LOGO_SVG;
  var LOGO_STYLES = {
    verticalAlign: 'middle'
  };
  var LINK_STYLES = {
    'color': '#404040'
  };
  var LIGHTBOX_STYLES = {
    'zIndex': '1001',
    'position': 'fixed',
    'top': '0',
    'left': '0',
    'right': '0',
    'bottom': '0'
  };
  var BACKDROP_STYLES = {
    'width': '100%',
    'height': '100%',
    'background': 'rgba(40,40,40,0.2)'
  };
  var NOTICE_STYLES = {
    'position': 'absolute',
    'left': '50%',
    'top': '40%',
    'transform': 'translate(-50%)',
    'width': '260px',
    'padding': '10px',
    'background': 'white',
    'boxShadow': '0 1px 4px rgba(0,0,0,0.3)',
    'fontFamily': 'Helvetica, Arial, sans-serif',
    'fontSize': '14px',
    'display': 'flex',
    'lineHeight': '1.3'
  };
  var LIGHTBOX_MARKUP = '<div class="bjs-powered-by-lightbox">' + '<div class="backdrop"></div>' + '<div class="notice">' + '<a href="https://bpmn.io" target="_blank" rel="noopener" class="link">' + BPMNIO_IMG + '</a>' + '<span>' + 'Web-based tooling for BPMN, DMN and forms ' + 'powered by <a href="https://bpmn.io" target="_blank" rel="noopener">bpmn.io</a>.' + '</span>' + '</div>' + '</div>';
  var lightbox;
  function createLightbox() {
    lightbox = domify$1(LIGHTBOX_MARKUP);
    assign(lightbox, LIGHTBOX_STYLES);
    assign(query('svg', lightbox), LOGO_STYLES);
    assign(query('.backdrop', lightbox), BACKDROP_STYLES);
    assign(query('.notice', lightbox), NOTICE_STYLES);
    assign(query('.link', lightbox), LINK_STYLES, {
      'margin': '15px 20px 15px 10px',
      'alignSelf': 'center'
    });
  }
  function open() {
    if (!lightbox) {
      createLightbox();
      delegate.bind(lightbox, '.backdrop', 'click', function (event) {
        document.body.removeChild(lightbox);
      });
    }
    document.body.appendChild(lightbox);
  }
  function BaseViewer(options) {
    options = assign$1({}, DEFAULT_OPTIONS, options);
    this._moddle = this._createModdle(options);
    this._container = this._createContainer(options);
    this._init(this._container, this._moddle, options);
    addProjectLogo(this._container);
  }
  e$2(BaseViewer, Diagram);
  BaseViewer.prototype.importXML = function () {
    var _importXML = _asyncToGenerator2(_regenerator2().m(function _callee3(xml, bpmnDiagram) {
      var self, ParseCompleteEvent, aggregatedWarnings, parseResult, definitions, references, parseWarnings, elementsById, importResult, _error2, _t3, _t4;
      return _regenerator2().w(function (_context3) {
        while (1) switch (_context3.p = _context3.n) {
          case 0:
            ParseCompleteEvent = function _ParseCompleteEvent(data) {
              return self.get('eventBus').createEvent(data);
            };
            self = this;
            aggregatedWarnings = [];
            _context3.p = 1;
            xml = this._emit('import.parse.start', {
              xml: xml
            }) || xml;
            _context3.p = 2;
            _context3.n = 3;
            return this._moddle.fromXML(xml, 'bpmn:Definitions');
          case 3:
            parseResult = _context3.v;
            _context3.n = 5;
            break;
          case 4:
            _context3.p = 4;
            _t3 = _context3.v;
            this._emit('import.parse.complete', {
              error: _t3
            });
            throw _t3;
          case 5:
            definitions = parseResult.rootElement;
            references = parseResult.references;
            parseWarnings = parseResult.warnings;
            elementsById = parseResult.elementsById;
            aggregatedWarnings = aggregatedWarnings.concat(parseWarnings);
            definitions = this._emit('import.parse.complete', ParseCompleteEvent({
              error: null,
              definitions: definitions,
              elementsById: elementsById,
              references: references,
              warnings: aggregatedWarnings
            })) || definitions;
            _context3.n = 6;
            return this.importDefinitions(definitions, bpmnDiagram);
          case 6:
            importResult = _context3.v;
            aggregatedWarnings = aggregatedWarnings.concat(importResult.warnings);
            this._emit('import.done', {
              error: null,
              warnings: aggregatedWarnings
            });
            return _context3.a(2, {
              warnings: aggregatedWarnings
            });
          case 7:
            _context3.p = 7;
            _t4 = _context3.v;
            _error2 = _t4;
            aggregatedWarnings = aggregatedWarnings.concat(_error2.warnings || []);
            addWarningsToError(_error2, aggregatedWarnings);
            _error2 = checkValidationError(_error2);
            this._emit('import.done', {
              error: _error2,
              warnings: _error2.warnings
            });
            throw _error2;
          case 8:
            return _context3.a(2);
        }
      }, _callee3, this, [[2, 4], [1, 7]]);
    }));
    function importXML(_x2, _x3) {
      return _importXML.apply(this, arguments);
    }
    return importXML;
  }();
  BaseViewer.prototype.importDefinitions = function () {
    var _importDefinitions = _asyncToGenerator2(_regenerator2().m(function _callee4(definitions, bpmnDiagram) {
      var result;
      return _regenerator2().w(function (_context4) {
        while (1) switch (_context4.n) {
          case 0:
            this._setDefinitions(definitions);
            _context4.n = 1;
            return this.open(bpmnDiagram);
          case 1:
            result = _context4.v;
            return _context4.a(2, {
              warnings: result.warnings
            });
        }
      }, _callee4, this);
    }));
    function importDefinitions(_x4, _x5) {
      return _importDefinitions.apply(this, arguments);
    }
    return importDefinitions;
  }();
  BaseViewer.prototype.open = function () {
    var _open = _asyncToGenerator2(_regenerator2().m(function _callee5(bpmnDiagramOrId) {
      var definitions, bpmnDiagram, _error3, _error4, _yield$importBpmnDiag, warnings, _t5;
      return _regenerator2().w(function (_context5) {
        while (1) switch (_context5.p = _context5.n) {
          case 0:
            definitions = this._definitions;
            bpmnDiagram = bpmnDiagramOrId;
            if (definitions) {
              _context5.n = 1;
              break;
            }
            _error3 = new Error('no XML imported');
            addWarningsToError(_error3, []);
            throw _error3;
          case 1:
            if (!(typeof bpmnDiagramOrId === 'string')) {
              _context5.n = 2;
              break;
            }
            bpmnDiagram = findBPMNDiagram(definitions, bpmnDiagramOrId);
            if (bpmnDiagram) {
              _context5.n = 2;
              break;
            }
            _error4 = new Error('BPMNDiagram <' + bpmnDiagramOrId + '> not found');
            addWarningsToError(_error4, []);
            throw _error4;
          case 2:
            _context5.p = 2;
            this.clear();
            _context5.n = 4;
            break;
          case 3:
            _context5.p = 3;
            _t5 = _context5.v;
            addWarningsToError(_t5, []);
            throw _t5;
          case 4:
            _context5.n = 5;
            return importBpmnDiagram(this, definitions, bpmnDiagram);
          case 5:
            _yield$importBpmnDiag = _context5.v;
            warnings = _yield$importBpmnDiag.warnings;
            return _context5.a(2, {
              warnings
            });
        }
      }, _callee5, this, [[2, 3]]);
    }));
    function open(_x6) {
      return _open.apply(this, arguments);
    }
    return open;
  }();
  BaseViewer.prototype.saveXML = function () {
    var _saveXML = _asyncToGenerator2(_regenerator2().m(function _callee6(options) {
      var definitions, error, xml, _result, result, _t6;
      return _regenerator2().w(function (_context6) {
        while (1) switch (_context6.p = _context6.n) {
          case 0:
            options = options || {};
            definitions = this._definitions;
            _context6.p = 1;
            if (definitions) {
              _context6.n = 2;
              break;
            }
            throw new Error('no definitions loaded');
          case 2:
            definitions = this._emit('saveXML.start', {
              definitions
            }) || definitions;
            _context6.n = 3;
            return this._moddle.toXML(definitions, options);
          case 3:
            _result = _context6.v;
            xml = _result.xml;
            xml = this._emit('saveXML.serialized', {
              xml
            }) || xml;
            _context6.n = 5;
            break;
          case 4:
            _context6.p = 4;
            _t6 = _context6.v;
            error = _t6;
          case 5:
            result = error ? {
              error
            } : {
              xml
            };
            this._emit('saveXML.done', result);
            if (!error) {
              _context6.n = 6;
              break;
            }
            throw error;
          case 6:
            return _context6.a(2, result);
        }
      }, _callee6, this, [[1, 4]]);
    }));
    function saveXML(_x7) {
      return _saveXML.apply(this, arguments);
    }
    return saveXML;
  }();
  BaseViewer.prototype.saveSVG = function () {
    var _saveSVG = _asyncToGenerator2(_regenerator2().m(function _callee7() {
      var svg, err, canvas, contentNode, defsNode, contents, defs, bbox;
      return _regenerator2().w(function (_context7) {
        while (1) switch (_context7.n) {
          case 0:
            this._emit('saveSVG.start');
            try {
              canvas = this.get('canvas');
              contentNode = canvas.getActiveLayer(), defsNode = query(':scope > defs', canvas._svg);
              contents = innerSVG(contentNode), defs = defsNode ? '<defs>' + innerSVG(defsNode) + '</defs>' : '';
              bbox = contentNode.getBBox();
              svg = '<?xml version="1.0" encoding="utf-8"?>\n' + '<!-- created with bpmn-js / http://bpmn.io -->\n' + '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n' + '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" ' + 'width="' + bbox.width + '" height="' + bbox.height + '" ' + 'viewBox="' + bbox.x + ' ' + bbox.y + ' ' + bbox.width + ' ' + bbox.height + '" version="1.1">' + defs + contents + '</svg>';
            } catch (e) {
              err = e;
            }
            this._emit('saveSVG.done', {
              error: err,
              svg: svg
            });
            if (!err) {
              _context7.n = 1;
              break;
            }
            throw err;
          case 1:
            return _context7.a(2, {
              svg
            });
        }
      }, _callee7, this);
    }));
    function saveSVG() {
      return _saveSVG.apply(this, arguments);
    }
    return saveSVG;
  }();
  BaseViewer.prototype._setDefinitions = function (definitions) {
    this._definitions = definitions;
  };
  BaseViewer.prototype.getModules = function () {
    return this._modules;
  };
  BaseViewer.prototype.clear = function () {
    if (!this.getDefinitions()) {
      return;
    }
    Diagram.prototype.clear.call(this);
  };
  BaseViewer.prototype.destroy = function () {
    Diagram.prototype.destroy.call(this);
    remove$2(this._container);
  };
  BaseViewer.prototype.on = function (events, priority, callback, that) {
    return this.get('eventBus').on(events, priority, callback, that);
  };
  BaseViewer.prototype.off = function (events, callback) {
    this.get('eventBus').off(events, callback);
  };
  BaseViewer.prototype.attachTo = function (parentNode) {
    if (!parentNode) {
      throw new Error('parentNode required');
    }
    this.detach();
    if (parentNode.get && parentNode.constructor.prototype.jquery) {
      parentNode = parentNode.get(0);
    }
    if (typeof parentNode === 'string') {
      parentNode = query(parentNode);
    }
    parentNode.appendChild(this._container);
    this._emit('attach', {});
    this.get('canvas').resized();
  };
  BaseViewer.prototype.getDefinitions = function () {
    return this._definitions;
  };
  BaseViewer.prototype.detach = function () {
    var container = this._container,
      parentNode = container.parentNode;
    if (!parentNode) {
      return;
    }
    this._emit('detach', {});
    parentNode.removeChild(container);
  };
  BaseViewer.prototype._init = function (container, moddle, options) {
    var baseModules = options.modules || this.getModules(options),
      additionalModules = options.additionalModules || [],
      staticModules = [{
        bpmnjs: ['value', this],
        moddle: ['value', moddle]
      }];
    var diagramModules = [].concat(staticModules, baseModules, additionalModules);
    var diagramOptions = assign$1(omit(options, ['additionalModules']), {
      canvas: assign$1({}, options.canvas, {
        container: container
      }),
      modules: diagramModules
    });
    Diagram.call(this, diagramOptions);
    if (options && options.container) {
      this.attachTo(options.container);
    }
  };
  BaseViewer.prototype._emit = function (type, event) {
    return this.get('eventBus').fire(type, event);
  };
  BaseViewer.prototype._createContainer = function (options) {
    var container = domify$1('<div class="bjs-container"></div>');
    assign(container, {
      width: ensureUnit(options.width),
      height: ensureUnit(options.height),
      position: options.position
    });
    return container;
  };
  BaseViewer.prototype._createModdle = function (options) {
    var moddleOptions = assign$1({}, this._moddleExtensions, options.moddleExtensions);
    return new SimpleBpmnModdle(moddleOptions);
  };
  BaseViewer.prototype._modules = [];
  function addWarningsToError(err, warningsAry) {
    err.warnings = warningsAry;
    return err;
  }
  function checkValidationError(err) {
    var pattern = /unparsable content <([^>]+)> detected([\s\S]*)$/;
    var match = pattern.exec(err.message);
    if (match) {
      err.message = 'unparsable content <' + match[1] + '> detected; ' + 'this may indicate an invalid BPMN 2.0 diagram file' + match[2];
    }
    return err;
  }
  var DEFAULT_OPTIONS = {
    width: '100%',
    height: '100%',
    position: 'relative'
  };
  function ensureUnit(val) {
    return val + (isNumber(val) ? 'px' : '');
  }
  function findBPMNDiagram(definitions, diagramId) {
    if (!diagramId) {
      return null;
    }
    return find(definitions.diagrams, function (element) {
      return element.id === diagramId;
    }) || null;
  }
  function addProjectLogo(container) {
    var img = BPMNIO_IMG;
    var linkMarkup = '<a href="http://bpmn.io" ' + 'target="_blank" ' + 'class="bjs-powered-by" ' + 'title="Powered by bpmn.io" ' + '>' + img + '</a>';
    var linkElement = domify$1(linkMarkup);
    assign(query('svg', linkElement), LOGO_STYLES);
    assign(linkElement, LINK_STYLES, {
      position: 'absolute',
      bottom: '15px',
      right: '15px',
      zIndex: '100'
    });
    container.appendChild(linkElement);
    event.bind(linkElement, 'click', function (event) {
      open();
      event.preventDefault();
    });
  }
  function BaseModeler(options) {
    BaseViewer.call(this, options);
    this.on('import.parse.complete', function (event) {
      if (!event.error) {
        this._collectIds(event.definitions, event.elementsById);
      }
    }, this);
    this.on('diagram.destroy', function () {
      this.get('moddle').ids.clear();
    }, this);
  }
  e$2(BaseModeler, BaseViewer);
  BaseModeler.prototype._createModdle = function (options) {
    var moddle = BaseViewer.prototype._createModdle.call(this, options);
    moddle.ids = new Ids$1([32, 36, 1]);
    return moddle;
  };
  BaseModeler.prototype._collectIds = function (definitions, elementsById) {
    var moddle = definitions.$model,
      ids = moddle.ids,
      id;
    ids.clear();
    for (id in elementsById) {
      ids.claim(id, elementsById[id]);
    }
  };
  function isExpanded(element, di) {
    if (is(element, 'bpmn:CallActivity')) {
      return false;
    }
    if (is(element, 'bpmn:SubProcess')) {
      di = di || getDi(element);
      if (di && is(di, 'bpmndi:BPMNPlane')) {
        return true;
      }
      return di && !!di.isExpanded;
    }
    if (is(element, 'bpmn:Participant')) {
      return !!getBusinessObject(element).processRef;
    }
    return true;
  }
  function isHorizontal$3(element) {
    if (!is(element, 'bpmn:Participant') && !is(element, 'bpmn:Lane')) {
      return undefined;
    }
    var isHorizontal = getDi(element).isHorizontal;
    if (isHorizontal === undefined) {
      return true;
    }
    return isHorizontal;
  }
  function isInterrupting(element) {
    return element && getBusinessObject(element).isInterrupting !== false;
  }
  function isEventSubProcess(element) {
    return element && !!getBusinessObject(element).triggeredByEvent;
  }
  function hasEventDefinition$2(element, eventType) {
    var eventDefinitions = getBusinessObject(element).eventDefinitions;
    return some(eventDefinitions, function (event) {
      return is(event, eventType);
    });
  }
  function hasErrorEventDefinition(element) {
    return hasEventDefinition$2(element, 'bpmn:ErrorEventDefinition');
  }
  function hasEscalationEventDefinition(element) {
    return hasEventDefinition$2(element, 'bpmn:EscalationEventDefinition');
  }
  function hasCompensateEventDefinition(element) {
    return hasEventDefinition$2(element, 'bpmn:CompensateEventDefinition');
  }
  var DEFAULT_LABEL_SIZE$1 = {
    width: 90,
    height: 20
  };
  var FLOW_LABEL_INDENT = 15;
  function isLabelExternal(semantic) {
    return is(semantic, 'bpmn:Event') || is(semantic, 'bpmn:Gateway') || is(semantic, 'bpmn:DataStoreReference') || is(semantic, 'bpmn:DataObjectReference') || is(semantic, 'bpmn:DataInput') || is(semantic, 'bpmn:DataOutput') || is(semantic, 'bpmn:SequenceFlow') || is(semantic, 'bpmn:MessageFlow') || is(semantic, 'bpmn:Group');
  }
  function hasExternalLabel(element) {
    return isLabel(element.label);
  }
  function getFlowLabelPosition(waypoints) {
    var mid = waypoints.length / 2 - 1;
    var first = waypoints[Math.floor(mid)];
    var second = waypoints[Math.ceil(mid + 0.01)];
    var position = getWaypointsMid(waypoints);
    var angle = Math.atan((second.y - first.y) / (second.x - first.x));
    var x = position.x,
      y = position.y;
    if (Math.abs(angle) < Math.PI / 2) {
      y -= FLOW_LABEL_INDENT;
    } else {
      x += FLOW_LABEL_INDENT;
    }
    return {
      x: x,
      y: y
    };
  }
  function getWaypointsMid(waypoints) {
    var mid = waypoints.length / 2 - 1;
    var first = waypoints[Math.floor(mid)];
    var second = waypoints[Math.ceil(mid + 0.01)];
    return {
      x: first.x + (second.x - first.x) / 2,
      y: first.y + (second.y - first.y) / 2
    };
  }
  function getExternalLabelMid(element) {
    if (element.waypoints) {
      return getFlowLabelPosition(element.waypoints);
    } else if (is(element, 'bpmn:Group')) {
      return {
        x: element.x + element.width / 2,
        y: element.y + DEFAULT_LABEL_SIZE$1.height / 2
      };
    } else {
      return {
        x: element.x + element.width / 2,
        y: element.y + element.height + DEFAULT_LABEL_SIZE$1.height / 2
      };
    }
  }
  function getExternalLabelBounds(di, element) {
    var mid,
      size,
      bounds,
      label = di.label;
    if (label && label.bounds) {
      bounds = label.bounds;
      size = {
        width: Math.max(DEFAULT_LABEL_SIZE$1.width, bounds.width),
        height: bounds.height
      };
      mid = {
        x: bounds.x + bounds.width / 2,
        y: bounds.y + bounds.height / 2
      };
    } else {
      mid = getExternalLabelMid(element);
      size = DEFAULT_LABEL_SIZE$1;
    }
    return assign$1({
      x: mid.x - size.width / 2,
      y: mid.y - size.height / 2
    }, size);
  }
  function getLabelAttr(semantic) {
    if (is(semantic, 'bpmn:FlowElement') || is(semantic, 'bpmn:Participant') || is(semantic, 'bpmn:Lane') || is(semantic, 'bpmn:SequenceFlow') || is(semantic, 'bpmn:MessageFlow') || is(semantic, 'bpmn:DataInput') || is(semantic, 'bpmn:DataOutput')) {
      return 'name';
    }
    if (is(semantic, 'bpmn:TextAnnotation')) {
      return 'text';
    }
    if (is(semantic, 'bpmn:Group')) {
      return 'categoryValueRef';
    }
  }
  function getCategoryValue(semantic) {
    var categoryValueRef = semantic['categoryValueRef'];
    if (!categoryValueRef) {
      return '';
    }
    return categoryValueRef.value || '';
  }
  function getLabel(element) {
    var semantic = element.businessObject,
      attr = getLabelAttr(semantic);
    if (attr) {
      if (attr === 'categoryValueRef') {
        return getCategoryValue(semantic);
      }
      return semantic[attr] || '';
    }
  }
  function setLabel(element, text) {
    var semantic = element.businessObject,
      attr = getLabelAttr(semantic);
    if (attr) {
      if (attr === 'categoryValueRef') {
        if (!semantic[attr]) {
          return element;
        }
        semantic[attr].value = text;
      } else {
        semantic[attr] = text;
      }
    }
    return element;
  }
  var black = 'hsl(225, 10%, 15%)';
  var white = 'white';
  function isTypedEvent(event, eventDefinitionType) {
    return some(event.eventDefinitions, function (definition) {
      return definition.$type === eventDefinitionType;
    });
  }
  function isThrowEvent(event) {
    return event.$type === 'bpmn:IntermediateThrowEvent' || event.$type === 'bpmn:EndEvent';
  }
  function isCollection(element) {
    var dataObject = element.dataObjectRef;
    return element.isCollection || dataObject && dataObject.isCollection;
  }
  function getFillColor(element, defaultColor, overrideColor) {
    var di = getDi(element);
    return overrideColor || di.get('color:background-color') || di.get('bioc:fill') || defaultColor || white;
  }
  function getStrokeColor$1(element, defaultColor, overrideColor) {
    var di = getDi(element);
    return overrideColor || di.get('color:border-color') || di.get('bioc:stroke') || defaultColor || black;
  }
  function getLabelColor(element, defaultColor, defaultStrokeColor, overrideColor) {
    var di = getDi(element),
      label = di.get('label');
    return overrideColor || label && label.get('color:color') || defaultColor || getStrokeColor$1(element, defaultStrokeColor);
  }
  function getCirclePath(shape) {
    var cx = shape.x + shape.width / 2,
      cy = shape.y + shape.height / 2,
      radius = shape.width / 2;
    var circlePath = [['M', cx, cy], ['m', 0, -radius], ['a', radius, radius, 0, 1, 1, 0, 2 * radius], ['a', radius, radius, 0, 1, 1, 0, -2 * radius], ['z']];
    return componentsToPath(circlePath);
  }
  function getRoundRectPath(shape, borderRadius) {
    var x = shape.x,
      y = shape.y,
      width = shape.width,
      height = shape.height;
    var roundRectPath = [['M', x + borderRadius, y], ['l', width - borderRadius * 2, 0], ['a', borderRadius, borderRadius, 0, 0, 1, borderRadius, borderRadius], ['l', 0, height - borderRadius * 2], ['a', borderRadius, borderRadius, 0, 0, 1, -10, borderRadius], ['l', borderRadius * 2 - width, 0], ['a', borderRadius, borderRadius, 0, 0, 1, -10, -10], ['l', 0, borderRadius * 2 - height], ['a', borderRadius, borderRadius, 0, 0, 1, borderRadius, -10], ['z']];
    return componentsToPath(roundRectPath);
  }
  function getDiamondPath(shape) {
    var width = shape.width,
      height = shape.height,
      x = shape.x,
      y = shape.y,
      halfWidth = width / 2,
      halfHeight = height / 2;
    var diamondPath = [['M', x + halfWidth, y], ['l', halfWidth, halfHeight], ['l', -halfWidth, halfHeight], ['l', -halfWidth, -halfHeight], ['z']];
    return componentsToPath(diamondPath);
  }
  function getRectPath(shape) {
    var x = shape.x,
      y = shape.y,
      width = shape.width,
      height = shape.height;
    var rectPath = [['M', x, y], ['l', width, 0], ['l', 0, height], ['l', -width, 0], ['z']];
    return componentsToPath(rectPath);
  }
  function getBounds$1(bounds) {
    var overrides = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return {
      width: getWidth(bounds, overrides),
      height: getHeight(bounds, overrides)
    };
  }
  function getWidth(bounds) {
    var overrides = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return has$1(overrides, 'width') ? overrides.width : bounds.width;
  }
  function getHeight(bounds) {
    var overrides = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return has$1(overrides, 'height') ? overrides.height : bounds.height;
  }
  var markerIds = new Ids$1();
  var ELEMENT_LABEL_DISTANCE$1 = 10,
    INNER_OUTER_DIST = 3,
    PARTICIPANT_STROKE_WIDTH = 1.5,
    TASK_BORDER_RADIUS = 10;
  var DEFAULT_OPACITY = 0.95,
    FULL_OPACITY = 1,
    LOW_OPACITY = 0.25;
  function BpmnRenderer(config, eventBus, styles, pathMap, canvas, textRenderer, priority) {
    BaseRenderer.call(this, eventBus, priority);
    var defaultFillColor = config && config.defaultFillColor,
      defaultStrokeColor = config && config.defaultStrokeColor,
      defaultLabelColor = config && config.defaultLabelColor;
    function shapeStyle(attrs) {
      return styles.computeStyle(attrs, {
        strokeLinecap: 'round',
        strokeLinejoin: 'round',
        stroke: black,
        strokeWidth: 2,
        fill: 'white'
      });
    }
    function lineStyle(attrs) {
      return styles.computeStyle(attrs, ['no-fill'], {
        strokeLinecap: 'round',
        strokeLinejoin: 'round',
        stroke: black,
        strokeWidth: 2
      });
    }
    function addMarker(id, options) {
      var _options$ref = options.ref,
        ref = _options$ref === void 0 ? {
          x: 0,
          y: 0
        } : _options$ref,
        _options$scale = options.scale,
        scale = _options$scale === void 0 ? 1 : _options$scale,
        element = options.element,
        _options$parentGfx = options.parentGfx,
        parentGfx = _options$parentGfx === void 0 ? canvas._svg : _options$parentGfx;
      var marker = create$1('marker', {
        id: id,
        viewBox: '0 0 20 20',
        refX: ref.x,
        refY: ref.y,
        markerWidth: 20 * scale,
        markerHeight: 20 * scale,
        orient: 'auto'
      });
      append(marker, element);
      var defs = query(':scope > defs', parentGfx);
      if (!defs) {
        defs = create$1('defs');
        append(parentGfx, defs);
      }
      append(defs, marker);
    }
    function marker(parentGfx, type, fill, stroke) {
      var id = markerIds.nextPrefixed('marker-');
      createMarker(parentGfx, id, type, fill, stroke);
      return 'url(#' + id + ')';
    }
    function createMarker(parentGfx, id, type, fill, stroke) {
      if (type === 'sequenceflow-end') {
        var sequenceflowEnd = create$1('path', _objectSpread({
          d: 'M 1 5 L 11 10 L 1 15 Z'
        }, shapeStyle({
          fill: stroke,
          stroke: stroke,
          strokeWidth: 1
        })));
        addMarker(id, {
          element: sequenceflowEnd,
          ref: {
            x: 11,
            y: 10
          },
          scale: 0.5,
          parentGfx
        });
      }
      if (type === 'messageflow-start') {
        var messageflowStart = create$1('circle', _objectSpread({
          cx: 6,
          cy: 6,
          r: 3.5
        }, shapeStyle({
          fill,
          stroke: stroke,
          strokeWidth: 1,
          strokeDasharray: [10000, 1]
        })));
        addMarker(id, {
          element: messageflowStart,
          ref: {
            x: 6,
            y: 6
          },
          parentGfx
        });
      }
      if (type === 'messageflow-end') {
        var messageflowEnd = create$1('path', _objectSpread({
          d: 'm 1 5 l 0 -3 l 7 3 l -7 3 z'
        }, shapeStyle({
          fill,
          stroke: stroke,
          strokeWidth: 1,
          strokeDasharray: [10000, 1]
        })));
        addMarker(id, {
          element: messageflowEnd,
          ref: {
            x: 8.5,
            y: 5
          },
          parentGfx
        });
      }
      if (type === 'association-start') {
        var associationStart = create$1('path', _objectSpread({
          d: 'M 11 5 L 1 10 L 11 15'
        }, lineStyle({
          fill: 'none',
          stroke,
          strokeWidth: 1.5,
          strokeDasharray: [10000, 1]
        })));
        addMarker(id, {
          element: associationStart,
          ref: {
            x: 1,
            y: 10
          },
          scale: 0.5,
          parentGfx
        });
      }
      if (type === 'association-end') {
        var associationEnd = create$1('path', _objectSpread({
          d: 'M 1 5 L 11 10 L 1 15'
        }, lineStyle({
          fill: 'none',
          stroke,
          strokeWidth: 1.5,
          strokeDasharray: [10000, 1]
        })));
        addMarker(id, {
          element: associationEnd,
          ref: {
            x: 11,
            y: 10
          },
          scale: 0.5,
          parentGfx
        });
      }
      if (type === 'conditional-flow-marker') {
        var conditionalFlowMarker = create$1('path', _objectSpread({
          d: 'M 0 10 L 8 6 L 16 10 L 8 14 Z'
        }, shapeStyle({
          fill,
          stroke: stroke
        })));
        addMarker(id, {
          element: conditionalFlowMarker,
          ref: {
            x: -1,
            y: 10
          },
          scale: 0.5,
          parentGfx
        });
      }
      if (type === 'conditional-default-flow-marker') {
        var defaultFlowMarker = create$1('path', _objectSpread({
          d: 'M 6 4 L 10 16'
        }, shapeStyle({
          stroke: stroke,
          fill: 'none'
        })));
        addMarker(id, {
          element: defaultFlowMarker,
          ref: {
            x: 0,
            y: 10
          },
          scale: 0.5,
          parentGfx
        });
      }
    }
    function drawCircle(parentGfx, width, height, offset) {
      var attrs = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
      if (isObject(offset)) {
        attrs = offset;
        offset = 0;
      }
      offset = offset || 0;
      attrs = shapeStyle(attrs);
      var cx = width / 2,
        cy = height / 2;
      var circle = create$1('circle', _objectSpread({
        cx: cx,
        cy: cy,
        r: Math.round((width + height) / 4 - offset)
      }, attrs));
      append(parentGfx, circle);
      return circle;
    }
    function drawRect(parentGfx, width, height, r, offset, attrs) {
      if (isObject(offset)) {
        attrs = offset;
        offset = 0;
      }
      offset = offset || 0;
      attrs = shapeStyle(attrs);
      var rect = create$1('rect', _objectSpread({
        x: offset,
        y: offset,
        width: width - offset * 2,
        height: height - offset * 2,
        rx: r,
        ry: r
      }, attrs));
      append(parentGfx, rect);
      return rect;
    }
    function drawDiamond(parentGfx, width, height, attrs) {
      var x_2 = width / 2;
      var y_2 = height / 2;
      var points = [{
        x: x_2,
        y: 0
      }, {
        x: width,
        y: y_2
      }, {
        x: x_2,
        y: height
      }, {
        x: 0,
        y: y_2
      }];
      var pointsString = points.map(function (point) {
        return point.x + ',' + point.y;
      }).join(' ');
      attrs = shapeStyle(attrs);
      var polygon = create$1('polygon', _objectSpread(_objectSpread({}, attrs), {}, {
        points: pointsString
      }));
      append(parentGfx, polygon);
      return polygon;
    }
    function drawLine(parentGfx, waypoints, attrs, radius) {
      attrs = lineStyle(attrs);
      var line = createLine(waypoints, attrs, radius);
      append(parentGfx, line);
      return line;
    }
    function drawConnectionSegments(parentGfx, waypoints, attrs) {
      return drawLine(parentGfx, waypoints, attrs, 5);
    }
    function drawPath(parentGfx, d, attrs) {
      attrs = lineStyle(attrs);
      var path = create$1('path', _objectSpread(_objectSpread({}, attrs), {}, {
        d
      }));
      append(parentGfx, path);
      return path;
    }
    function drawMarker(type, parentGfx, path, attrs) {
      return drawPath(parentGfx, path, assign$1({
        'data-marker': type
      }, attrs));
    }
    function renderer(type) {
      return handlers[type];
    }
    function as(type) {
      return function (parentGfx, element, attrs) {
        return renderer(type)(parentGfx, element, attrs);
      };
    }
    var eventIconRenderers = {
      'bpmn:MessageEventDefinition': function bpmnMessageEventDefinition(parentGfx, element) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var isThrowing = arguments.length > 3 ? arguments[3] : undefined;
        var pathData = pathMap.getScaledPath('EVENT_MESSAGE', {
          xScaleFactor: 0.9,
          yScaleFactor: 0.9,
          containerWidth: attrs.width || element.width,
          containerHeight: attrs.height || element.height,
          position: {
            mx: 0.235,
            my: 0.315
          }
        });
        var fill = isThrowing ? getStrokeColor$1(element, defaultStrokeColor, attrs.stroke) : getFillColor(element, defaultFillColor, attrs.fill);
        var stroke = isThrowing ? getFillColor(element, defaultFillColor, attrs.fill) : getStrokeColor$1(element, defaultStrokeColor, attrs.stroke);
        var messagePath = drawPath(parentGfx, pathData, {
          fill,
          stroke,
          strokeWidth: 1
        });
        return messagePath;
      },
      'bpmn:TimerEventDefinition': function bpmnTimerEventDefinition(parentGfx, element) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var baseWidth = attrs.width || element.width;
        var baseHeight = attrs.height || element.height;
        var strokeWidth = attrs.width ? 1 : 2;
        var circle = drawCircle(parentGfx, baseWidth, baseHeight, 0.2 * baseHeight, {
          fill: getFillColor(element, defaultFillColor, attrs.fill),
          stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
          strokeWidth: strokeWidth
        });
        var pathData = pathMap.getScaledPath('EVENT_TIMER_WH', {
          xScaleFactor: 0.75,
          yScaleFactor: 0.75,
          containerWidth: baseWidth,
          containerHeight: baseHeight,
          position: {
            mx: 0.5,
            my: 0.5
          }
        });
        drawPath(parentGfx, pathData, {
          stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
          strokeWidth: strokeWidth
        });
        for (var i = 0; i < 12; i++) {
          var linePathData = pathMap.getScaledPath('EVENT_TIMER_LINE', {
            xScaleFactor: 0.75,
            yScaleFactor: 0.75,
            containerWidth: baseWidth,
            containerHeight: baseHeight,
            position: {
              mx: 0.5,
              my: 0.5
            }
          });
          var width = baseWidth / 2,
            height = baseHeight / 2;
          drawPath(parentGfx, linePathData, {
            strokeWidth: 1,
            stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
            transform: 'rotate(' + i * 30 + ',' + height + ',' + width + ')'
          });
        }
        return circle;
      },
      'bpmn:EscalationEventDefinition': function bpmnEscalationEventDefinition(parentGfx, event) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var isThrowing = arguments.length > 3 ? arguments[3] : undefined;
        var pathData = pathMap.getScaledPath('EVENT_ESCALATION', {
          xScaleFactor: 1,
          yScaleFactor: 1,
          containerWidth: attrs.width || event.width,
          containerHeight: attrs.height || event.height,
          position: {
            mx: 0.5,
            my: 0.2
          }
        });
        var fill = isThrowing ? getStrokeColor$1(event, defaultStrokeColor, attrs.stroke) : getFillColor(event, defaultFillColor, attrs.fill);
        return drawPath(parentGfx, pathData, {
          fill,
          stroke: getStrokeColor$1(event, defaultStrokeColor, attrs.stroke),
          strokeWidth: 1
        });
      },
      'bpmn:ConditionalEventDefinition': function bpmnConditionalEventDefinition(parentGfx, event) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var pathData = pathMap.getScaledPath('EVENT_CONDITIONAL', {
          xScaleFactor: 1,
          yScaleFactor: 1,
          containerWidth: attrs.width || event.width,
          containerHeight: attrs.height || event.height,
          position: {
            mx: 0.5,
            my: 0.222
          }
        });
        return drawPath(parentGfx, pathData, {
          fill: getFillColor(event, defaultFillColor, attrs.fill),
          stroke: getStrokeColor$1(event, defaultStrokeColor, attrs.stroke),
          strokeWidth: 1
        });
      },
      'bpmn:LinkEventDefinition': function bpmnLinkEventDefinition(parentGfx, event) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var isThrowing = arguments.length > 3 ? arguments[3] : undefined;
        var pathData = pathMap.getScaledPath('EVENT_LINK', {
          xScaleFactor: 1,
          yScaleFactor: 1,
          containerWidth: event.width,
          containerHeight: event.height,
          position: {
            mx: 0.57,
            my: 0.263
          }
        });
        var fill = isThrowing ? getStrokeColor$1(event, defaultStrokeColor, attrs.stroke) : getFillColor(event, defaultFillColor, attrs.fill);
        return drawPath(parentGfx, pathData, {
          fill,
          stroke: getStrokeColor$1(event, defaultStrokeColor, attrs.stroke),
          strokeWidth: 1
        });
      },
      'bpmn:ErrorEventDefinition': function bpmnErrorEventDefinition(parentGfx, event) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var isThrowing = arguments.length > 3 ? arguments[3] : undefined;
        var pathData = pathMap.getScaledPath('EVENT_ERROR', {
          xScaleFactor: 1.1,
          yScaleFactor: 1.1,
          containerWidth: attrs.width || event.width,
          containerHeight: attrs.height || event.height,
          position: {
            mx: 0.2,
            my: 0.722
          }
        });
        var fill = isThrowing ? getStrokeColor$1(event, defaultStrokeColor, attrs.stroke) : getFillColor(event, defaultFillColor, attrs.fill);
        return drawPath(parentGfx, pathData, {
          fill,
          stroke: getStrokeColor$1(event, defaultStrokeColor, attrs.stroke),
          strokeWidth: 1
        });
      },
      'bpmn:CancelEventDefinition': function bpmnCancelEventDefinition(parentGfx, event) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var isThrowing = arguments.length > 3 ? arguments[3] : undefined;
        var pathData = pathMap.getScaledPath('EVENT_CANCEL_45', {
          xScaleFactor: 1.0,
          yScaleFactor: 1.0,
          containerWidth: event.width,
          containerHeight: event.height,
          position: {
            mx: 0.638,
            my: -0.055
          }
        });
        var fill = isThrowing ? getStrokeColor$1(event, defaultStrokeColor, attrs.stroke) : 'none';
        var path = drawPath(parentGfx, pathData, {
          fill,
          stroke: getStrokeColor$1(event, defaultStrokeColor, attrs.stroke),
          strokeWidth: 1
        });
        rotate(path, 45);
        return path;
      },
      'bpmn:CompensateEventDefinition': function bpmnCompensateEventDefinition(parentGfx, event) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var isThrowing = arguments.length > 3 ? arguments[3] : undefined;
        var pathData = pathMap.getScaledPath('EVENT_COMPENSATION', {
          xScaleFactor: 1,
          yScaleFactor: 1,
          containerWidth: attrs.width || event.width,
          containerHeight: attrs.height || event.height,
          position: {
            mx: 0.22,
            my: 0.5
          }
        });
        var fill = isThrowing ? getStrokeColor$1(event, defaultStrokeColor, attrs.stroke) : getFillColor(event, defaultFillColor, attrs.fill);
        return drawPath(parentGfx, pathData, {
          fill,
          stroke: getStrokeColor$1(event, defaultStrokeColor, attrs.stroke),
          strokeWidth: 1
        });
      },
      'bpmn:SignalEventDefinition': function bpmnSignalEventDefinition(parentGfx, event) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var isThrowing = arguments.length > 3 ? arguments[3] : undefined;
        var pathData = pathMap.getScaledPath('EVENT_SIGNAL', {
          xScaleFactor: 0.9,
          yScaleFactor: 0.9,
          containerWidth: attrs.width || event.width,
          containerHeight: attrs.height || event.height,
          position: {
            mx: 0.5,
            my: 0.2
          }
        });
        var fill = isThrowing ? getStrokeColor$1(event, defaultStrokeColor, attrs.stroke) : getFillColor(event, defaultFillColor, attrs.fill);
        return drawPath(parentGfx, pathData, {
          strokeWidth: 1,
          fill,
          stroke: getStrokeColor$1(event, defaultStrokeColor, attrs.stroke)
        });
      },
      'bpmn:MultipleEventDefinition': function bpmnMultipleEventDefinition(parentGfx, event) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var isThrowing = arguments.length > 3 ? arguments[3] : undefined;
        var pathData = pathMap.getScaledPath('EVENT_MULTIPLE', {
          xScaleFactor: 1.1,
          yScaleFactor: 1.1,
          containerWidth: attrs.width || event.width,
          containerHeight: attrs.height || event.height,
          position: {
            mx: 0.211,
            my: 0.36
          }
        });
        var fill = isThrowing ? getStrokeColor$1(event, defaultStrokeColor, attrs.stroke) : getFillColor(event, defaultFillColor, attrs.fill);
        return drawPath(parentGfx, pathData, {
          fill,
          stroke: getStrokeColor$1(event, defaultStrokeColor, attrs.stroke),
          strokeWidth: 1
        });
      },
      'bpmn:ParallelMultipleEventDefinition': function bpmnParallelMultipleEventDefinition(parentGfx, event) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var pathData = pathMap.getScaledPath('EVENT_PARALLEL_MULTIPLE', {
          xScaleFactor: 1.2,
          yScaleFactor: 1.2,
          containerWidth: attrs.width || event.width,
          containerHeight: attrs.height || event.height,
          position: {
            mx: 0.458,
            my: 0.194
          }
        });
        return drawPath(parentGfx, pathData, {
          fill: getFillColor(event, defaultFillColor, attrs.fill),
          stroke: getStrokeColor$1(event, defaultStrokeColor, attrs.stroke),
          strokeWidth: 1
        });
      },
      'bpmn:TerminateEventDefinition': function bpmnTerminateEventDefinition(parentGfx, element) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var circle = drawCircle(parentGfx, element.width, element.height, 8, {
          fill: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
          stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
          strokeWidth: 4
        });
        return circle;
      }
    };
    function renderEventIcon(element, parentGfx) {
      var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var proxyElement = arguments.length > 3 ? arguments[3] : undefined;
      var semantic = getBusinessObject(element),
        isThrowing = isThrowEvent(semantic);
      var nodeElement = proxyElement || element;
      if (semantic.get('eventDefinitions') && semantic.get('eventDefinitions').length > 1) {
        if (semantic.get('parallelMultiple')) {
          return eventIconRenderers['bpmn:ParallelMultipleEventDefinition'](parentGfx, nodeElement, attrs, isThrowing);
        } else {
          return eventIconRenderers['bpmn:MultipleEventDefinition'](parentGfx, nodeElement, attrs, isThrowing);
        }
      }
      if (isTypedEvent(semantic, 'bpmn:MessageEventDefinition')) {
        return eventIconRenderers['bpmn:MessageEventDefinition'](parentGfx, nodeElement, attrs, isThrowing);
      }
      if (isTypedEvent(semantic, 'bpmn:TimerEventDefinition')) {
        return eventIconRenderers['bpmn:TimerEventDefinition'](parentGfx, nodeElement, attrs, isThrowing);
      }
      if (isTypedEvent(semantic, 'bpmn:ConditionalEventDefinition')) {
        return eventIconRenderers['bpmn:ConditionalEventDefinition'](parentGfx, nodeElement, attrs, isThrowing);
      }
      if (isTypedEvent(semantic, 'bpmn:SignalEventDefinition')) {
        return eventIconRenderers['bpmn:SignalEventDefinition'](parentGfx, nodeElement, attrs, isThrowing);
      }
      if (isTypedEvent(semantic, 'bpmn:EscalationEventDefinition')) {
        return eventIconRenderers['bpmn:EscalationEventDefinition'](parentGfx, nodeElement, attrs, isThrowing);
      }
      if (isTypedEvent(semantic, 'bpmn:LinkEventDefinition')) {
        return eventIconRenderers['bpmn:LinkEventDefinition'](parentGfx, nodeElement, attrs, isThrowing);
      }
      if (isTypedEvent(semantic, 'bpmn:ErrorEventDefinition')) {
        return eventIconRenderers['bpmn:ErrorEventDefinition'](parentGfx, nodeElement, attrs, isThrowing);
      }
      if (isTypedEvent(semantic, 'bpmn:CancelEventDefinition')) {
        return eventIconRenderers['bpmn:CancelEventDefinition'](parentGfx, nodeElement, attrs, isThrowing);
      }
      if (isTypedEvent(semantic, 'bpmn:CompensateEventDefinition')) {
        return eventIconRenderers['bpmn:CompensateEventDefinition'](parentGfx, nodeElement, attrs, isThrowing);
      }
      if (isTypedEvent(semantic, 'bpmn:TerminateEventDefinition')) {
        return eventIconRenderers['bpmn:TerminateEventDefinition'](parentGfx, nodeElement, attrs, isThrowing);
      }
      return null;
    }
    var taskMarkerRenderers = {
      'ParticipantMultiplicityMarker': function ParticipantMultiplicityMarker(parentGfx, element) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var width = getWidth(element, attrs),
          height = getHeight(element, attrs);
        var markerPath = pathMap.getScaledPath('MARKER_PARALLEL', {
          xScaleFactor: 1,
          yScaleFactor: 1,
          containerWidth: width,
          containerHeight: height,
          position: {
            mx: (width / 2 - 6) / width,
            my: (height - 15) / height
          }
        });
        drawMarker('participant-multiplicity', parentGfx, markerPath, {
          strokeWidth: 2,
          fill: getFillColor(element, defaultFillColor, attrs.fill),
          stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke)
        });
      },
      'SubProcessMarker': function SubProcessMarker(parentGfx, element) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var markerRect = drawRect(parentGfx, 14, 14, 0, {
          strokeWidth: 1,
          fill: getFillColor(element, defaultFillColor, attrs.fill),
          stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke)
        });
        translate$1(markerRect, element.width / 2 - 7.5, element.height - 20);
        var markerPath = pathMap.getScaledPath('MARKER_SUB_PROCESS', {
          xScaleFactor: 1.5,
          yScaleFactor: 1.5,
          containerWidth: element.width,
          containerHeight: element.height,
          position: {
            mx: (element.width / 2 - 7.5) / element.width,
            my: (element.height - 20) / element.height
          }
        });
        drawMarker('sub-process', parentGfx, markerPath, {
          fill: getFillColor(element, defaultFillColor, attrs.fill),
          stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke)
        });
      },
      'ParallelMarker': function ParallelMarker(parentGfx, element, attrs) {
        var width = getWidth(element, attrs),
          height = getHeight(element, attrs);
        var markerPath = pathMap.getScaledPath('MARKER_PARALLEL', {
          xScaleFactor: 1,
          yScaleFactor: 1,
          containerWidth: width,
          containerHeight: height,
          position: {
            mx: (width / 2 + attrs.parallel) / width,
            my: (height - 20) / height
          }
        });
        drawMarker('parallel', parentGfx, markerPath, {
          fill: getFillColor(element, defaultFillColor, attrs.fill),
          stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke)
        });
      },
      'SequentialMarker': function SequentialMarker(parentGfx, element, attrs) {
        var markerPath = pathMap.getScaledPath('MARKER_SEQUENTIAL', {
          xScaleFactor: 1,
          yScaleFactor: 1,
          containerWidth: element.width,
          containerHeight: element.height,
          position: {
            mx: (element.width / 2 + attrs.seq) / element.width,
            my: (element.height - 19) / element.height
          }
        });
        drawMarker('sequential', parentGfx, markerPath, {
          fill: getFillColor(element, defaultFillColor, attrs.fill),
          stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke)
        });
      },
      'CompensationMarker': function CompensationMarker(parentGfx, element, attrs) {
        var markerMath = pathMap.getScaledPath('MARKER_COMPENSATION', {
          xScaleFactor: 1,
          yScaleFactor: 1,
          containerWidth: element.width,
          containerHeight: element.height,
          position: {
            mx: (element.width / 2 + attrs.compensation) / element.width,
            my: (element.height - 13) / element.height
          }
        });
        drawMarker('compensation', parentGfx, markerMath, {
          strokeWidth: 1,
          fill: getFillColor(element, defaultFillColor, attrs.fill),
          stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke)
        });
      },
      'LoopMarker': function LoopMarker(parentGfx, element, attrs) {
        var width = getWidth(element, attrs),
          height = getHeight(element, attrs);
        var markerPath = pathMap.getScaledPath('MARKER_LOOP', {
          xScaleFactor: 1,
          yScaleFactor: 1,
          containerWidth: width,
          containerHeight: height,
          position: {
            mx: (width / 2 + attrs.loop) / width,
            my: (height - 7) / height
          }
        });
        drawMarker('loop', parentGfx, markerPath, {
          strokeWidth: 1.5,
          fill: 'none',
          stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
          strokeMiterlimit: 0.5
        });
      },
      'AdhocMarker': function AdhocMarker(parentGfx, element, attrs) {
        var width = getWidth(element, attrs),
          height = getHeight(element, attrs);
        var markerPath = pathMap.getScaledPath('MARKER_ADHOC', {
          xScaleFactor: 1,
          yScaleFactor: 1,
          containerWidth: width,
          containerHeight: height,
          position: {
            mx: (width / 2 + attrs.adhoc) / width,
            my: (height - 15) / height
          }
        });
        drawMarker('adhoc', parentGfx, markerPath, {
          strokeWidth: 1,
          fill: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
          stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke)
        });
      }
    };
    function renderTaskMarker(type, parentGfx, element, attrs) {
      taskMarkerRenderers[type](parentGfx, element, attrs);
    }
    function renderTaskMarkers(parentGfx, element) {
      var taskMarkers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      var attrs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      attrs = {
        fill: attrs.fill,
        stroke: attrs.stroke,
        width: getWidth(element, attrs),
        height: getHeight(element, attrs)
      };
      var semantic = getBusinessObject(element);
      var subprocess = taskMarkers.includes('SubProcessMarker');
      if (subprocess) {
        attrs = _objectSpread(_objectSpread({}, attrs), {}, {
          seq: -21,
          parallel: -22,
          compensation: -25,
          loop: -18,
          adhoc: 10
        });
      } else {
        attrs = _objectSpread(_objectSpread({}, attrs), {}, {
          seq: -5,
          parallel: -6,
          compensation: -7,
          loop: 0,
          adhoc: -8
        });
      }
      if (semantic.get('isForCompensation')) {
        taskMarkers.push('CompensationMarker');
      }
      if (is(semantic, 'bpmn:AdHocSubProcess')) {
        taskMarkers.push('AdhocMarker');
        if (!subprocess) {
          assign$1(attrs, {
            compensation: attrs.compensation - 18
          });
        }
      }
      var loopCharacteristics = semantic.get('loopCharacteristics'),
        isSequential = loopCharacteristics && loopCharacteristics.get('isSequential');
      if (loopCharacteristics) {
        assign$1(attrs, {
          compensation: attrs.compensation - 18
        });
        if (taskMarkers.includes('AdhocMarker')) {
          assign$1(attrs, {
            seq: -23,
            loop: -18,
            parallel: -24
          });
        }
        if (isSequential === undefined) {
          taskMarkers.push('LoopMarker');
        }
        if (isSequential === false) {
          taskMarkers.push('ParallelMarker');
        }
        if (isSequential === true) {
          taskMarkers.push('SequentialMarker');
        }
      }
      if (taskMarkers.includes('CompensationMarker') && taskMarkers.length === 1) {
        assign$1(attrs, {
          compensation: -8
        });
      }
      forEach$1(taskMarkers, function (marker) {
        renderTaskMarker(marker, parentGfx, element, attrs);
      });
    }
    function renderLabel(parentGfx, label) {
      var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      attrs = assign$1({
        size: {
          width: 100
        }
      }, attrs);
      var text = textRenderer.createText(label || '', attrs);
      classes(text).add('djs-label');
      append(parentGfx, text);
      return text;
    }
    function renderEmbeddedLabel(parentGfx, element, align) {
      var attrs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var semantic = getBusinessObject(element);
      var box = getBounds$1({
        x: element.x,
        y: element.y,
        width: element.width,
        height: element.height
      }, attrs);
      return renderLabel(parentGfx, semantic.name, {
        align,
        box,
        padding: 7,
        style: {
          fill: getLabelColor(element, defaultLabelColor, defaultStrokeColor, attrs.stroke)
        }
      });
    }
    function renderExternalLabel(parentGfx, element) {
      var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var box = {
        width: 90,
        height: 30,
        x: element.width / 2 + element.x,
        y: element.height / 2 + element.y
      };
      return renderLabel(parentGfx, getLabel(element), {
        box: box,
        fitBox: true,
        style: assign$1({}, textRenderer.getExternalStyle(), {
          fill: getLabelColor(element, defaultLabelColor, defaultStrokeColor, attrs.stroke)
        })
      });
    }
    function renderLaneLabel(parentGfx, text, element) {
      var attrs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var isHorizontalLane = isHorizontal$3(element);
      var textBox = renderLabel(parentGfx, text, {
        box: {
          height: 30,
          width: isHorizontalLane ? getHeight(element, attrs) : getWidth(element, attrs)
        },
        align: 'center-middle',
        style: {
          fill: getLabelColor(element, defaultLabelColor, defaultStrokeColor, attrs.stroke)
        }
      });
      if (isHorizontalLane) {
        var top = -1 * getHeight(element, attrs);
        transform(textBox, 0, -top, 270);
      }
    }
    function renderActivity(parentGfx, element) {
      var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var _getBounds$ = getBounds$1(element, attrs),
        width = _getBounds$.width,
        height = _getBounds$.height;
      return drawRect(parentGfx, width, height, TASK_BORDER_RADIUS, _objectSpread(_objectSpread({}, attrs), {}, {
        fill: getFillColor(element, defaultFillColor, attrs.fill),
        fillOpacity: DEFAULT_OPACITY,
        stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke)
      }));
    }
    function renderAssociation(parentGfx, element) {
      var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var semantic = getBusinessObject(element);
      var fill = getFillColor(element, defaultFillColor, attrs.fill),
        stroke = getStrokeColor$1(element, defaultStrokeColor, attrs.stroke);
      if (semantic.get('associationDirection') === 'One' || semantic.get('associationDirection') === 'Both') {
        attrs.markerEnd = marker(parentGfx, 'association-end', fill, stroke);
      }
      if (semantic.get('associationDirection') === 'Both') {
        attrs.markerStart = marker(parentGfx, 'association-start', fill, stroke);
      }
      attrs = pickAttrs(attrs, ['markerStart', 'markerEnd']);
      return drawConnectionSegments(parentGfx, element.waypoints, _objectSpread(_objectSpread({}, attrs), {}, {
        stroke,
        strokeDasharray: '0, 5'
      }));
    }
    function renderDataObject(parentGfx, element) {
      var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var fill = getFillColor(element, defaultFillColor, attrs.fill),
        stroke = getStrokeColor$1(element, defaultStrokeColor, attrs.stroke);
      var pathData = pathMap.getScaledPath('DATA_OBJECT_PATH', {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0.474,
          my: 0.296
        }
      });
      var dataObject = drawPath(parentGfx, pathData, {
        fill,
        fillOpacity: DEFAULT_OPACITY,
        stroke
      });
      var semantic = getBusinessObject(element);
      if (isCollection(semantic)) {
        var collectionPathData = pathMap.getScaledPath('DATA_OBJECT_COLLECTION_PATH', {
          xScaleFactor: 1,
          yScaleFactor: 1,
          containerWidth: element.width,
          containerHeight: element.height,
          position: {
            mx: 0.33,
            my: (element.height - 18) / element.height
          }
        });
        drawPath(parentGfx, collectionPathData, {
          strokeWidth: 2,
          fill,
          stroke
        });
      }
      return dataObject;
    }
    function renderEvent(parentGfx, element) {
      var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return drawCircle(parentGfx, element.width, element.height, _objectSpread(_objectSpread({
        fillOpacity: DEFAULT_OPACITY
      }, attrs), {}, {
        fill: getFillColor(element, defaultFillColor, attrs.fill),
        stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke)
      }));
    }
    function renderGateway(parentGfx, element) {
      var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return drawDiamond(parentGfx, element.width, element.height, {
        fill: getFillColor(element, defaultFillColor, attrs.fill),
        fillOpacity: DEFAULT_OPACITY,
        stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke)
      });
    }
    function renderLane(parentGfx, element) {
      var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var lane = drawRect(parentGfx, getWidth(element, attrs), getHeight(element, attrs), 0, {
        fill: getFillColor(element, defaultFillColor, attrs.fill),
        fillOpacity: attrs.fillOpacity || DEFAULT_OPACITY,
        stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
        strokeWidth: 1.5
      });
      var semantic = getBusinessObject(element);
      if (is(semantic, 'bpmn:Lane')) {
        var text = semantic.get('name');
        renderLaneLabel(parentGfx, text, element, attrs);
      }
      return lane;
    }
    function renderSubProcess(parentGfx, element) {
      var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var activity = renderActivity(parentGfx, element, attrs);
      var expanded = isExpanded(element);
      if (isEventSubProcess(element)) {
        attr(activity, {
          strokeDasharray: '0, 5.5',
          strokeWidth: 2.5
        });
        if (!expanded) {
          var flowElements = getBusinessObject(element).flowElements || [];
          var startEvents = flowElements.filter(function (e) {
            return is(e, 'bpmn:StartEvent');
          });
          if (startEvents.length === 1) {
            renderEventSubProcessIcon(startEvents[0], parentGfx, attrs, element);
          }
        }
      }
      renderEmbeddedLabel(parentGfx, element, expanded ? 'center-top' : 'center-middle', attrs);
      if (expanded) {
        renderTaskMarkers(parentGfx, element, undefined, attrs);
      } else {
        renderTaskMarkers(parentGfx, element, ['SubProcessMarker'], attrs);
      }
      return activity;
    }
    function renderEventSubProcessIcon(startEvent, parentGfx, attrs, proxyElement) {
      var iconSize = 22;
      var proxyAttrs = {
        fill: getFillColor(proxyElement, defaultFillColor, attrs.fill),
        stroke: getStrokeColor$1(proxyElement, defaultStrokeColor, attrs.stroke),
        width: iconSize,
        height: iconSize
      };
      var interrupting = getBusinessObject(startEvent).isInterrupting;
      var strokeDasharray = interrupting ? 0 : 3;
      var strokeWidth = interrupting ? 1 : 1.2;
      var circleSize = 20;
      var shift = (iconSize - circleSize) / 2;
      var transform = 'translate(' + shift + ',' + shift + ')';
      drawCircle(parentGfx, circleSize, circleSize, {
        fill: proxyAttrs.fill,
        stroke: proxyAttrs.stroke,
        strokeWidth,
        strokeDasharray,
        transform
      });
      renderEventIcon(startEvent, parentGfx, proxyAttrs, proxyElement);
    }
    function renderTask(parentGfx, element) {
      var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var activity = renderActivity(parentGfx, element, attrs);
      renderEmbeddedLabel(parentGfx, element, 'center-middle', attrs);
      renderTaskMarkers(parentGfx, element, undefined, attrs);
      return activity;
    }
    var handlers = this.handlers = {
      'bpmn:AdHocSubProcess': function bpmnAdHocSubProcess(parentGfx, element) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        if (isExpanded(element)) {
          attrs = pickAttrs(attrs, ['fill', 'stroke', 'width', 'height']);
        } else {
          attrs = pickAttrs(attrs, ['fill', 'stroke']);
        }
        return renderSubProcess(parentGfx, element, attrs);
      },
      'bpmn:Association': function bpmnAssociation(parentGfx, element) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        attrs = pickAttrs(attrs, ['fill', 'stroke']);
        return renderAssociation(parentGfx, element, attrs);
      },
      'bpmn:BoundaryEvent': function bpmnBoundaryEvent(parentGfx, element) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var _attrs = attrs,
          _attrs$renderIcon = _attrs.renderIcon,
          renderIcon = _attrs$renderIcon === void 0 ? true : _attrs$renderIcon;
        attrs = pickAttrs(attrs, ['fill', 'stroke']);
        var semantic = getBusinessObject(element),
          cancelActivity = semantic.get('cancelActivity');
        attrs = {
          strokeWidth: 1.5,
          fill: getFillColor(element, defaultFillColor, attrs.fill),
          fillOpacity: FULL_OPACITY,
          stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke)
        };
        if (!cancelActivity) {
          attrs.strokeDasharray = '6';
        }
        var event = renderEvent(parentGfx, element, attrs);
        drawCircle(parentGfx, element.width, element.height, INNER_OUTER_DIST, _objectSpread(_objectSpread({}, attrs), {}, {
          fill: 'none'
        }));
        if (renderIcon) {
          renderEventIcon(element, parentGfx, attrs);
        }
        return event;
      },
      'bpmn:BusinessRuleTask': function bpmnBusinessRuleTask(parentGfx, element) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        attrs = pickAttrs(attrs, ['fill', 'stroke']);
        var task = renderTask(parentGfx, element, attrs);
        var headerData = pathMap.getScaledPath('TASK_TYPE_BUSINESS_RULE_MAIN', {
          abspos: {
            x: 8,
            y: 8
          }
        });
        var businessPath = drawPath(parentGfx, headerData);
        attr(businessPath, {
          fill: getFillColor(element, defaultFillColor, attrs.fill),
          stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
          strokeWidth: 1
        });
        var headerPathData = pathMap.getScaledPath('TASK_TYPE_BUSINESS_RULE_HEADER', {
          abspos: {
            x: 8,
            y: 8
          }
        });
        var businessHeaderPath = drawPath(parentGfx, headerPathData);
        attr(businessHeaderPath, {
          fill: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
          stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
          strokeWidth: 1
        });
        return task;
      },
      'bpmn:CallActivity': function bpmnCallActivity(parentGfx, element) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        attrs = pickAttrs(attrs, ['fill', 'stroke']);
        return renderSubProcess(parentGfx, element, _objectSpread({
          strokeWidth: 5
        }, attrs));
      },
      'bpmn:ComplexGateway': function bpmnComplexGateway(parentGfx, element) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        attrs = pickAttrs(attrs, ['fill', 'stroke']);
        var gateway = renderGateway(parentGfx, element, attrs);
        var pathData = pathMap.getScaledPath('GATEWAY_COMPLEX', {
          xScaleFactor: 0.5,
          yScaleFactor: 0.5,
          containerWidth: element.width,
          containerHeight: element.height,
          position: {
            mx: 0.46,
            my: 0.26
          }
        });
        drawPath(parentGfx, pathData, {
          fill: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
          stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
          strokeWidth: 1
        });
        return gateway;
      },
      'bpmn:DataInput': function bpmnDataInput(parentGfx, element) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        attrs = pickAttrs(attrs, ['fill', 'stroke']);
        var arrowPathData = pathMap.getRawPath('DATA_ARROW');
        var dataObject = renderDataObject(parentGfx, element, attrs);
        drawPath(parentGfx, arrowPathData, {
          fill: 'none',
          stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
          strokeWidth: 1
        });
        return dataObject;
      },
      'bpmn:DataInputAssociation': function bpmnDataInputAssociation(parentGfx, element) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        attrs = pickAttrs(attrs, ['fill', 'stroke']);
        return renderAssociation(parentGfx, element, _objectSpread(_objectSpread({}, attrs), {}, {
          markerEnd: marker(parentGfx, 'association-end', getFillColor(element, defaultFillColor, attrs.fill), getStrokeColor$1(element, defaultStrokeColor, attrs.stroke))
        }));
      },
      'bpmn:DataObject': function bpmnDataObject(parentGfx, element) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        attrs = pickAttrs(attrs, ['fill', 'stroke']);
        return renderDataObject(parentGfx, element, attrs);
      },
      'bpmn:DataObjectReference': as('bpmn:DataObject'),
      'bpmn:DataOutput': function bpmnDataOutput(parentGfx, element) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        attrs = pickAttrs(attrs, ['fill', 'stroke']);
        var arrowPathData = pathMap.getRawPath('DATA_ARROW');
        var dataObject = renderDataObject(parentGfx, element, attrs);
        drawPath(parentGfx, arrowPathData, {
          strokeWidth: 1,
          fill: getFillColor(element, defaultFillColor, attrs.fill),
          stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke)
        });
        return dataObject;
      },
      'bpmn:DataOutputAssociation': function bpmnDataOutputAssociation(parentGfx, element) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        attrs = pickAttrs(attrs, ['fill', 'stroke']);
        return renderAssociation(parentGfx, element, _objectSpread(_objectSpread({}, attrs), {}, {
          markerEnd: marker(parentGfx, 'association-end', getFillColor(element, defaultFillColor, attrs.fill), getStrokeColor$1(element, defaultStrokeColor, attrs.stroke))
        }));
      },
      'bpmn:DataStoreReference': function bpmnDataStoreReference(parentGfx, element) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        attrs = pickAttrs(attrs, ['fill', 'stroke']);
        var dataStorePath = pathMap.getScaledPath('DATA_STORE', {
          xScaleFactor: 1,
          yScaleFactor: 1,
          containerWidth: element.width,
          containerHeight: element.height,
          position: {
            mx: 0,
            my: 0.133
          }
        });
        return drawPath(parentGfx, dataStorePath, {
          fill: getFillColor(element, defaultFillColor, attrs.fill),
          fillOpacity: DEFAULT_OPACITY,
          stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
          strokeWidth: 2
        });
      },
      'bpmn:EndEvent': function bpmnEndEvent(parentGfx, element) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var _attrs2 = attrs,
          _attrs2$renderIcon = _attrs2.renderIcon,
          renderIcon = _attrs2$renderIcon === void 0 ? true : _attrs2$renderIcon;
        attrs = pickAttrs(attrs, ['fill', 'stroke']);
        var event = renderEvent(parentGfx, element, _objectSpread(_objectSpread({}, attrs), {}, {
          strokeWidth: 4
        }));
        if (renderIcon) {
          renderEventIcon(element, parentGfx, attrs);
        }
        return event;
      },
      'bpmn:EventBasedGateway': function bpmnEventBasedGateway(parentGfx, element) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        attrs = pickAttrs(attrs, ['fill', 'stroke']);
        var semantic = getBusinessObject(element);
        var diamond = renderGateway(parentGfx, element, attrs);
        drawCircle(parentGfx, element.width, element.height, element.height * 0.20, {
          fill: getFillColor(element, 'none', attrs.fill),
          stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
          strokeWidth: 1
        });
        var type = semantic.get('eventGatewayType'),
          instantiate = !!semantic.get('instantiate');
        function drawEvent() {
          var pathData = pathMap.getScaledPath('GATEWAY_EVENT_BASED', {
            xScaleFactor: 0.18,
            yScaleFactor: 0.18,
            containerWidth: element.width,
            containerHeight: element.height,
            position: {
              mx: 0.36,
              my: 0.44
            }
          });
          drawPath(parentGfx, pathData, {
            fill: 'none',
            stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
            strokeWidth: 2
          });
        }
        if (type === 'Parallel') {
          var pathData = pathMap.getScaledPath('GATEWAY_PARALLEL', {
            xScaleFactor: 0.4,
            yScaleFactor: 0.4,
            containerWidth: element.width,
            containerHeight: element.height,
            position: {
              mx: 0.474,
              my: 0.296
            }
          });
          drawPath(parentGfx, pathData, {
            fill: 'none',
            stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
            strokeWidth: 1
          });
        } else if (type === 'Exclusive') {
          if (!instantiate) {
            drawCircle(parentGfx, element.width, element.height, element.height * 0.26, {
              fill: 'none',
              stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
              strokeWidth: 1
            });
          }
          drawEvent();
        }
        return diamond;
      },
      'bpmn:ExclusiveGateway': function bpmnExclusiveGateway(parentGfx, element) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        attrs = pickAttrs(attrs, ['fill', 'stroke']);
        var gateway = renderGateway(parentGfx, element, attrs);
        var pathData = pathMap.getScaledPath('GATEWAY_EXCLUSIVE', {
          xScaleFactor: 0.4,
          yScaleFactor: 0.4,
          containerWidth: element.width,
          containerHeight: element.height,
          position: {
            mx: 0.32,
            my: 0.3
          }
        });
        var di = getDi(element);
        if (di.get('isMarkerVisible')) {
          drawPath(parentGfx, pathData, {
            fill: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
            stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
            strokeWidth: 1
          });
        }
        return gateway;
      },
      'bpmn:Gateway': function bpmnGateway(parentGfx, element) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        attrs = pickAttrs(attrs, ['fill', 'stroke']);
        return renderGateway(parentGfx, element, attrs);
      },
      'bpmn:Group': function bpmnGroup(parentGfx, element) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        attrs = pickAttrs(attrs, ['fill', 'stroke', 'width', 'height']);
        return drawRect(parentGfx, element.width, element.height, TASK_BORDER_RADIUS, {
          stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
          strokeWidth: 1.5,
          strokeDasharray: '10, 6, 0, 6',
          fill: 'none',
          pointerEvents: 'none',
          width: getWidth(element, attrs),
          height: getHeight(element, attrs)
        });
      },
      'bpmn:InclusiveGateway': function bpmnInclusiveGateway(parentGfx, element) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        attrs = pickAttrs(attrs, ['fill', 'stroke']);
        var gateway = renderGateway(parentGfx, element, attrs);
        drawCircle(parentGfx, element.width, element.height, element.height * 0.24, {
          fill: getFillColor(element, defaultFillColor, attrs.fill),
          stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
          strokeWidth: 2.5
        });
        return gateway;
      },
      'bpmn:IntermediateEvent': function bpmnIntermediateEvent(parentGfx, element) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var _attrs3 = attrs,
          _attrs3$renderIcon = _attrs3.renderIcon,
          renderIcon = _attrs3$renderIcon === void 0 ? true : _attrs3$renderIcon;
        attrs = pickAttrs(attrs, ['fill', 'stroke']);
        var outer = renderEvent(parentGfx, element, _objectSpread(_objectSpread({}, attrs), {}, {
          strokeWidth: 1.5
        }));
        drawCircle(parentGfx, element.width, element.height, INNER_OUTER_DIST, {
          fill: 'none',
          stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
          strokeWidth: 1.5
        });
        if (renderIcon) {
          renderEventIcon(element, parentGfx, attrs);
        }
        return outer;
      },
      'bpmn:IntermediateCatchEvent': as('bpmn:IntermediateEvent'),
      'bpmn:IntermediateThrowEvent': as('bpmn:IntermediateEvent'),
      'bpmn:Lane': function bpmnLane(parentGfx, element) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        attrs = pickAttrs(attrs, ['fill', 'stroke', 'width', 'height']);
        return renderLane(parentGfx, element, _objectSpread(_objectSpread({}, attrs), {}, {
          fillOpacity: LOW_OPACITY
        }));
      },
      'bpmn:ManualTask': function bpmnManualTask(parentGfx, element) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        attrs = pickAttrs(attrs, ['fill', 'stroke']);
        var task = renderTask(parentGfx, element, attrs);
        var pathData = pathMap.getScaledPath('TASK_TYPE_MANUAL', {
          abspos: {
            x: 17,
            y: 15
          }
        });
        drawPath(parentGfx, pathData, {
          fill: getFillColor(element, defaultFillColor, attrs.fill),
          stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
          strokeWidth: 0.5
        });
        return task;
      },
      'bpmn:MessageFlow': function bpmnMessageFlow(parentGfx, element) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        attrs = pickAttrs(attrs, ['fill', 'stroke']);
        var semantic = getBusinessObject(element),
          di = getDi(element);
        var fill = getFillColor(element, defaultFillColor, attrs.fill),
          stroke = getStrokeColor$1(element, defaultStrokeColor, attrs.stroke);
        var path = drawConnectionSegments(parentGfx, element.waypoints, {
          markerEnd: marker(parentGfx, 'messageflow-end', fill, stroke),
          markerStart: marker(parentGfx, 'messageflow-start', fill, stroke),
          stroke,
          strokeDasharray: '10, 11',
          strokeWidth: 1.5
        });
        if (semantic.get('messageRef')) {
          var midPoint = path.getPointAtLength(path.getTotalLength() / 2);
          var markerPathData = pathMap.getScaledPath('MESSAGE_FLOW_MARKER', {
            abspos: {
              x: midPoint.x,
              y: midPoint.y
            }
          });
          var messageAttrs = {
            strokeWidth: 1
          };
          if (di.get('messageVisibleKind') === 'initiating') {
            messageAttrs.fill = fill;
            messageAttrs.stroke = stroke;
          } else {
            messageAttrs.fill = stroke;
            messageAttrs.stroke = fill;
          }
          var message = drawPath(parentGfx, markerPathData, messageAttrs);
          var messageRef = semantic.get('messageRef'),
            name = messageRef.get('name');
          var label = renderLabel(parentGfx, name, {
            align: 'center-top',
            fitBox: true,
            style: {
              fill: stroke
            }
          });
          var messageBounds = message.getBBox(),
            labelBounds = label.getBBox();
          var translateX = midPoint.x - labelBounds.width / 2,
            translateY = midPoint.y + messageBounds.height / 2 + ELEMENT_LABEL_DISTANCE$1;
          transform(label, translateX, translateY, 0);
        }
        return path;
      },
      'bpmn:ParallelGateway': function bpmnParallelGateway(parentGfx, element) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        attrs = pickAttrs(attrs, ['fill', 'stroke']);
        var diamond = renderGateway(parentGfx, element, attrs);
        var pathData = pathMap.getScaledPath('GATEWAY_PARALLEL', {
          xScaleFactor: 0.6,
          yScaleFactor: 0.6,
          containerWidth: element.width,
          containerHeight: element.height,
          position: {
            mx: 0.46,
            my: 0.2
          }
        });
        drawPath(parentGfx, pathData, {
          fill: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
          stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
          strokeWidth: 1
        });
        return diamond;
      },
      'bpmn:Participant': function bpmnParticipant(parentGfx, element) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        attrs = pickAttrs(attrs, ['fill', 'stroke', 'width', 'height']);
        var participant = renderLane(parentGfx, element, attrs);
        var expandedParticipant = isExpanded(element);
        var horizontalParticipant = isHorizontal$3(element);
        var semantic = getBusinessObject(element),
          name = semantic.get('name');
        if (expandedParticipant) {
          var waypoints = horizontalParticipant ? [{
            x: 30,
            y: 0
          }, {
            x: 30,
            y: getHeight(element, attrs)
          }] : [{
            x: 0,
            y: 30
          }, {
            x: getWidth(element, attrs),
            y: 30
          }];
          drawLine(parentGfx, waypoints, {
            stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
            strokeWidth: PARTICIPANT_STROKE_WIDTH
          });
          renderLaneLabel(parentGfx, name, element, attrs);
        } else {
          var bounds = getBounds$1(element, attrs);
          if (!horizontalParticipant) {
            bounds.height = getWidth(element, attrs);
            bounds.width = getHeight(element, attrs);
          }
          var textBox = renderLabel(parentGfx, name, {
            box: bounds,
            align: 'center-middle',
            style: {
              fill: getLabelColor(element, defaultLabelColor, defaultStrokeColor, attrs.stroke)
            }
          });
          if (!horizontalParticipant) {
            var top = -1 * getHeight(element, attrs);
            transform(textBox, 0, -top, 270);
          }
        }
        if (semantic.get('participantMultiplicity')) {
          renderTaskMarker('ParticipantMultiplicityMarker', parentGfx, element, attrs);
        }
        return participant;
      },
      'bpmn:ReceiveTask': function bpmnReceiveTask(parentGfx, element) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        attrs = pickAttrs(attrs, ['fill', 'stroke']);
        var semantic = getBusinessObject(element);
        var task = renderTask(parentGfx, element, attrs);
        var pathData;
        if (semantic.get('instantiate')) {
          drawCircle(parentGfx, 28, 28, 20 * 0.22, {
            fill: getFillColor(element, defaultFillColor, attrs.fill),
            stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
            strokeWidth: 1
          });
          pathData = pathMap.getScaledPath('TASK_TYPE_INSTANTIATING_SEND', {
            abspos: {
              x: 7.77,
              y: 9.52
            }
          });
        } else {
          pathData = pathMap.getScaledPath('TASK_TYPE_SEND', {
            xScaleFactor: 0.9,
            yScaleFactor: 0.9,
            containerWidth: 21,
            containerHeight: 14,
            position: {
              mx: 0.3,
              my: 0.4
            }
          });
        }
        drawPath(parentGfx, pathData, {
          fill: getFillColor(element, defaultFillColor, attrs.fill),
          stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
          strokeWidth: 1
        });
        return task;
      },
      'bpmn:ScriptTask': function bpmnScriptTask(parentGfx, element) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        attrs = pickAttrs(attrs, ['fill', 'stroke']);
        var task = renderTask(parentGfx, element, attrs);
        var pathData = pathMap.getScaledPath('TASK_TYPE_SCRIPT', {
          abspos: {
            x: 15,
            y: 20
          }
        });
        drawPath(parentGfx, pathData, {
          fill: getFillColor(element, defaultFillColor, attrs.fill),
          stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
          strokeWidth: 1
        });
        return task;
      },
      'bpmn:SendTask': function bpmnSendTask(parentGfx, element) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        attrs = pickAttrs(attrs, ['fill', 'stroke']);
        var task = renderTask(parentGfx, element, attrs);
        var pathData = pathMap.getScaledPath('TASK_TYPE_SEND', {
          xScaleFactor: 1,
          yScaleFactor: 1,
          containerWidth: 21,
          containerHeight: 14,
          position: {
            mx: 0.285,
            my: 0.357
          }
        });
        drawPath(parentGfx, pathData, {
          fill: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
          stroke: getFillColor(element, defaultFillColor, attrs.fill),
          strokeWidth: 1
        });
        return task;
      },
      'bpmn:SequenceFlow': function bpmnSequenceFlow(parentGfx, element) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        attrs = pickAttrs(attrs, ['fill', 'stroke']);
        var fill = getFillColor(element, defaultFillColor, attrs.fill),
          stroke = getStrokeColor$1(element, defaultStrokeColor, attrs.stroke);
        var connection = drawConnectionSegments(parentGfx, element.waypoints, {
          markerEnd: marker(parentGfx, 'sequenceflow-end', fill, stroke),
          stroke
        });
        var semantic = getBusinessObject(element);
        var source = element.source;
        if (source) {
          var sourceSemantic = getBusinessObject(source);
          if (semantic.get('conditionExpression') && is(sourceSemantic, 'bpmn:Activity')) {
            attr(connection, {
              markerStart: marker(parentGfx, 'conditional-flow-marker', fill, stroke)
            });
          }
          if (sourceSemantic.get('default') && (is(sourceSemantic, 'bpmn:Gateway') || is(sourceSemantic, 'bpmn:Activity')) && sourceSemantic.get('default') === semantic) {
            attr(connection, {
              markerStart: marker(parentGfx, 'conditional-default-flow-marker', fill, stroke)
            });
          }
        }
        return connection;
      },
      'bpmn:ServiceTask': function bpmnServiceTask(parentGfx, element) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        attrs = pickAttrs(attrs, ['fill', 'stroke']);
        var task = renderTask(parentGfx, element, attrs);
        drawCircle(parentGfx, 10, 10, {
          fill: getFillColor(element, defaultFillColor, attrs.fill),
          stroke: 'none',
          transform: 'translate(6, 6)'
        });
        var pathDataService1 = pathMap.getScaledPath('TASK_TYPE_SERVICE', {
          abspos: {
            x: 12,
            y: 18
          }
        });
        drawPath(parentGfx, pathDataService1, {
          fill: getFillColor(element, defaultFillColor, attrs.fill),
          stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
          strokeWidth: 1
        });
        drawCircle(parentGfx, 10, 10, {
          fill: getFillColor(element, defaultFillColor, attrs.fill),
          stroke: 'none',
          transform: 'translate(11, 10)'
        });
        var pathDataService2 = pathMap.getScaledPath('TASK_TYPE_SERVICE', {
          abspos: {
            x: 17,
            y: 22
          }
        });
        drawPath(parentGfx, pathDataService2, {
          fill: getFillColor(element, defaultFillColor, attrs.fill),
          stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
          strokeWidth: 1
        });
        return task;
      },
      'bpmn:StartEvent': function bpmnStartEvent(parentGfx, element) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var _attrs4 = attrs,
          _attrs4$renderIcon = _attrs4.renderIcon,
          renderIcon = _attrs4$renderIcon === void 0 ? true : _attrs4$renderIcon;
        attrs = pickAttrs(attrs, ['fill', 'stroke']);
        var semantic = getBusinessObject(element);
        if (!semantic.get('isInterrupting')) {
          attrs = _objectSpread(_objectSpread({}, attrs), {}, {
            strokeDasharray: '6'
          });
        }
        var event = renderEvent(parentGfx, element, attrs);
        if (renderIcon) {
          renderEventIcon(element, parentGfx, attrs);
        }
        return event;
      },
      'bpmn:SubProcess': function bpmnSubProcess(parentGfx, element) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        if (isExpanded(element)) {
          attrs = pickAttrs(attrs, ['fill', 'stroke', 'width', 'height']);
        } else {
          attrs = pickAttrs(attrs, ['fill', 'stroke']);
        }
        return renderSubProcess(parentGfx, element, attrs);
      },
      'bpmn:Task': function bpmnTask(parentGfx, element) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        attrs = pickAttrs(attrs, ['fill', 'stroke']);
        return renderTask(parentGfx, element, attrs);
      },
      'bpmn:TextAnnotation': function bpmnTextAnnotation(parentGfx, element) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        attrs = pickAttrs(attrs, ['fill', 'stroke', 'width', 'height']);
        var _getBounds$2 = getBounds$1(element, attrs),
          width = _getBounds$2.width,
          height = _getBounds$2.height;
        var textElement = drawRect(parentGfx, width, height, 0, 0, {
          fill: 'none',
          stroke: 'none'
        });
        var textPathData = pathMap.getScaledPath('TEXT_ANNOTATION', {
          xScaleFactor: 1,
          yScaleFactor: 1,
          containerWidth: width,
          containerHeight: height,
          position: {
            mx: 0.0,
            my: 0.0
          }
        });
        drawPath(parentGfx, textPathData, {
          stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke)
        });
        var semantic = getBusinessObject(element),
          text = semantic.get('text') || '';
        renderLabel(parentGfx, text, {
          align: 'left-top',
          box: getBounds$1(element, attrs),
          padding: 7,
          style: {
            fill: getLabelColor(element, defaultLabelColor, defaultStrokeColor, attrs.stroke)
          }
        });
        return textElement;
      },
      'bpmn:Transaction': function bpmnTransaction(parentGfx, element) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        if (isExpanded(element)) {
          attrs = pickAttrs(attrs, ['fill', 'stroke', 'width', 'height']);
        } else {
          attrs = pickAttrs(attrs, ['fill', 'stroke']);
        }
        var outer = renderSubProcess(parentGfx, element, _objectSpread({
          strokeWidth: 1.5
        }, attrs));
        var innerAttrs = styles.style(['no-fill', 'no-events'], {
          stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
          strokeWidth: 1.5
        });
        var expanded = isExpanded(element);
        if (!expanded) {
          attrs = {};
        }
        drawRect(parentGfx, getWidth(element, attrs), getHeight(element, attrs), TASK_BORDER_RADIUS - INNER_OUTER_DIST, INNER_OUTER_DIST, innerAttrs);
        return outer;
      },
      'bpmn:UserTask': function bpmnUserTask(parentGfx, element) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        attrs = pickAttrs(attrs, ['fill', 'stroke']);
        var task = renderTask(parentGfx, element, attrs);
        var x = 15;
        var y = 12;
        var pathDataUser1 = pathMap.getScaledPath('TASK_TYPE_USER_1', {
          abspos: {
            x: x,
            y: y
          }
        });
        drawPath(parentGfx, pathDataUser1, {
          fill: getFillColor(element, defaultFillColor, attrs.fill),
          stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
          strokeWidth: 0.5
        });
        var pathDataUser2 = pathMap.getScaledPath('TASK_TYPE_USER_2', {
          abspos: {
            x: x,
            y: y
          }
        });
        drawPath(parentGfx, pathDataUser2, {
          fill: getFillColor(element, defaultFillColor, attrs.fill),
          stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
          strokeWidth: 0.5
        });
        var pathDataUser3 = pathMap.getScaledPath('TASK_TYPE_USER_3', {
          abspos: {
            x: x,
            y: y
          }
        });
        drawPath(parentGfx, pathDataUser3, {
          fill: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
          stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
          strokeWidth: 0.5
        });
        return task;
      },
      'label': function label(parentGfx, element) {
        var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        return renderExternalLabel(parentGfx, element, attrs);
      }
    };
    this._drawPath = drawPath;
    this._renderer = renderer;
  }
  e$2(BpmnRenderer, BaseRenderer);
  BpmnRenderer.$inject = ['config.bpmnRenderer', 'eventBus', 'styles', 'pathMap', 'canvas', 'textRenderer'];
  BpmnRenderer.prototype.canRender = function (element) {
    return is(element, 'bpmn:BaseElement');
  };
  BpmnRenderer.prototype.drawShape = function (parentGfx, shape) {
    var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var type = shape.type;
    var handler = this._renderer(type);
    return handler(parentGfx, shape, attrs);
  };
  BpmnRenderer.prototype.drawConnection = function (parentGfx, connection) {
    var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var type = connection.type;
    var handler = this._renderer(type);
    return handler(parentGfx, connection, attrs);
  };
  BpmnRenderer.prototype.getShapePath = function (shape) {
    if (is(shape, 'bpmn:Event')) {
      return getCirclePath(shape);
    }
    if (is(shape, 'bpmn:Activity')) {
      return getRoundRectPath(shape, TASK_BORDER_RADIUS);
    }
    if (is(shape, 'bpmn:Gateway')) {
      return getDiamondPath(shape);
    }
    return getRectPath(shape);
  };
  function pickAttrs(attrs) {
    var keys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    return keys.reduce(function (pickedAttrs, key) {
      if (attrs[key]) {
        pickedAttrs[key] = attrs[key];
      }
      return pickedAttrs;
    }, {});
  }
  var DEFAULT_BOX_PADDING = 0;
  var DEFAULT_LABEL_SIZE = {
    width: 150,
    height: 50
  };
  function parseAlign(align) {
    var parts = align.split('-');
    return {
      horizontal: parts[0] || 'center',
      vertical: parts[1] || 'top'
    };
  }
  function parsePadding(padding) {
    if (isObject(padding)) {
      return assign$1({
        top: 0,
        left: 0,
        right: 0,
        bottom: 0
      }, padding);
    } else {
      return {
        top: padding,
        left: padding,
        right: padding,
        bottom: padding
      };
    }
  }
  function getTextBBox(text, fakeText) {
    fakeText.textContent = text;
    var textBBox;
    try {
      var bbox,
        emptyLine = text === '';
      fakeText.textContent = emptyLine ? 'dummy' : text;
      textBBox = fakeText.getBBox();
      bbox = {
        width: textBBox.width + textBBox.x * 2,
        height: textBBox.height
      };
      if (emptyLine) {
        bbox.width = 0;
      }
      return bbox;
    } catch (e) {
      console.log(e);
      return {
        width: 0,
        height: 0
      };
    }
  }
  function layoutNext(lines, maxWidth, fakeText) {
    var originalLine = lines.shift(),
      fitLine = originalLine;
    var textBBox;
    for (;;) {
      textBBox = getTextBBox(fitLine, fakeText);
      textBBox.width = fitLine ? textBBox.width : 0;
      if (fitLine === ' ' || fitLine === '' || textBBox.width < Math.round(maxWidth) || fitLine.length < 2) {
        return fit(lines, fitLine, originalLine, textBBox);
      }
      fitLine = shortenLine(fitLine, textBBox.width, maxWidth);
    }
  }
  function fit(lines, fitLine, originalLine, textBBox) {
    if (fitLine.length < originalLine.length) {
      var remainder = originalLine.slice(fitLine.length).trim();
      lines.unshift(remainder);
    }
    return {
      width: textBBox.width,
      height: textBBox.height,
      text: fitLine
    };
  }
  var SOFT_BREAK = '\u00AD';
  function semanticShorten(line, maxLength) {
    var parts = line.split(/(\s|-|\u00AD)/g),
      part,
      shortenedParts = [],
      length = 0;
    if (parts.length > 1) {
      while (part = parts.shift()) {
        if (part.length + length < maxLength) {
          shortenedParts.push(part);
          length += part.length;
        } else {
          if (part === '-' || part === SOFT_BREAK) {
            shortenedParts.pop();
          }
          break;
        }
      }
    }
    var last = shortenedParts[shortenedParts.length - 1];
    if (last && last === SOFT_BREAK) {
      shortenedParts[shortenedParts.length - 1] = '-';
    }
    return shortenedParts.join('');
  }
  function shortenLine(line, width, maxWidth) {
    var length = Math.max(line.length * (maxWidth / width), 1);
    var shortenedLine = semanticShorten(line, length);
    if (!shortenedLine) {
      shortenedLine = line.slice(0, Math.max(Math.round(length - 1), 1));
    }
    return shortenedLine;
  }
  function getHelperSvg() {
    var helperSvg = document.getElementById('helper-svg');
    if (!helperSvg) {
      helperSvg = create$1('svg');
      attr(helperSvg, {
        id: 'helper-svg'
      });
      assign(helperSvg, {
        visibility: 'hidden',
        position: 'fixed',
        width: 0,
        height: 0
      });
      document.body.appendChild(helperSvg);
    }
    return helperSvg;
  }
  function Text(config) {
    this._config = assign$1({}, {
      size: DEFAULT_LABEL_SIZE,
      padding: DEFAULT_BOX_PADDING,
      style: {},
      align: 'center-top'
    }, config || {});
  }
  Text.prototype.createText = function (text, options) {
    return this.layoutText(text, options).element;
  };
  Text.prototype.getDimensions = function (text, options) {
    return this.layoutText(text, options).dimensions;
  };
  Text.prototype.layoutText = function (text, options) {
    var box = assign$1({}, this._config.size, options.box),
      style = assign$1({}, this._config.style, options.style),
      align = parseAlign(options.align || this._config.align),
      padding = parsePadding(options.padding !== undefined ? options.padding : this._config.padding),
      fitBox = options.fitBox || false;
    var lineHeight = getLineHeight(style);
    var lines = text.split(/\u00AD?\r?\n/),
      layouted = [];
    var maxWidth = box.width - padding.left - padding.right;
    var helperText = create$1('text');
    attr(helperText, {
      x: 0,
      y: 0
    });
    attr(helperText, style);
    var helperSvg = getHelperSvg();
    append(helperSvg, helperText);
    while (lines.length) {
      layouted.push(layoutNext(lines, maxWidth, helperText));
    }
    if (align.vertical === 'middle') {
      padding.top = padding.bottom = 0;
    }
    var totalHeight = reduce(layouted, function (sum, line, idx) {
      return sum + (lineHeight || line.height);
    }, 0) + padding.top + padding.bottom;
    var maxLineWidth = reduce(layouted, function (sum, line, idx) {
      return line.width > sum ? line.width : sum;
    }, 0);
    var y = padding.top;
    if (align.vertical === 'middle') {
      y += (box.height - totalHeight) / 2;
    }
    y -= (lineHeight || layouted[0].height) / 4;
    var textElement = create$1('text');
    attr(textElement, style);
    forEach$1(layouted, function (line) {
      var x;
      y += lineHeight || line.height;
      switch (align.horizontal) {
        case 'left':
          x = padding.left;
          break;
        case 'right':
          x = (fitBox ? maxLineWidth : maxWidth) - padding.right - line.width;
          break;
        default:
          x = Math.max(((fitBox ? maxLineWidth : maxWidth) - line.width) / 2 + padding.left, 0);
      }
      var tspan = create$1('tspan');
      attr(tspan, {
        x: x,
        y: y
      });
      tspan.textContent = line.text;
      append(textElement, tspan);
    });
    remove$1(helperText);
    var dimensions = {
      width: maxLineWidth,
      height: totalHeight
    };
    return {
      dimensions: dimensions,
      element: textElement
    };
  };
  function getLineHeight(style) {
    if ('fontSize' in style && 'lineHeight' in style) {
      return style.lineHeight * parseInt(style.fontSize, 10);
    }
  }
  var DEFAULT_FONT_SIZE = 12;
  var LINE_HEIGHT_RATIO = 1.2;
  var MIN_TEXT_ANNOTATION_HEIGHT = 30;
  function TextRenderer(config) {
    var defaultStyle = assign$1({
      fontFamily: 'Arial, sans-serif',
      fontSize: DEFAULT_FONT_SIZE,
      fontWeight: 'normal',
      lineHeight: LINE_HEIGHT_RATIO
    }, config && config.defaultStyle || {});
    var fontSize = parseInt(defaultStyle.fontSize, 10) - 1;
    var externalStyle = assign$1({}, defaultStyle, {
      fontSize: fontSize
    }, config && config.externalStyle || {});
    var textUtil = new Text({
      style: defaultStyle
    });
    this.getExternalLabelBounds = function (bounds, text) {
      var layoutedDimensions = textUtil.getDimensions(text, {
        box: {
          width: 90,
          height: 30
        },
        style: externalStyle
      });
      return {
        x: Math.round(bounds.x + bounds.width / 2 - layoutedDimensions.width / 2),
        y: Math.round(bounds.y),
        width: Math.ceil(layoutedDimensions.width),
        height: Math.ceil(layoutedDimensions.height)
      };
    };
    this.getTextAnnotationBounds = function (bounds, text) {
      var layoutedDimensions = textUtil.getDimensions(text, {
        box: bounds,
        style: defaultStyle,
        align: 'left-top',
        padding: 5
      });
      return {
        x: bounds.x,
        y: bounds.y,
        width: bounds.width,
        height: Math.max(MIN_TEXT_ANNOTATION_HEIGHT, Math.round(layoutedDimensions.height))
      };
    };
    this.createText = function (text, options) {
      return textUtil.createText(text, options || {});
    };
    this.getDefaultStyle = function () {
      return defaultStyle;
    };
    this.getExternalStyle = function () {
      return externalStyle;
    };
  }
  TextRenderer.$inject = ['config.textRenderer'];
  function PathMap() {
    this.pathMap = {
      'EVENT_MESSAGE': {
        d: 'm {mx},{my} l 0,{e.y1} l {e.x1},0 l 0,-{e.y1} z l {e.x0},{e.y0} l {e.x0},-{e.y0}',
        height: 36,
        width: 36,
        heightElements: [6, 14],
        widthElements: [10.5, 21]
      },
      'EVENT_SIGNAL': {
        d: 'M {mx},{my} l {e.x0},{e.y0} l -{e.x1},0 Z',
        height: 36,
        width: 36,
        heightElements: [18],
        widthElements: [10, 20]
      },
      'EVENT_ESCALATION': {
        d: 'M {mx},{my} l {e.x0},{e.y0} l -{e.x0},-{e.y1} l -{e.x0},{e.y1} Z',
        height: 36,
        width: 36,
        heightElements: [20, 7],
        widthElements: [8]
      },
      'EVENT_CONDITIONAL': {
        d: 'M {e.x0},{e.y0} l {e.x1},0 l 0,{e.y2} l -{e.x1},0 Z ' + 'M {e.x2},{e.y3} l {e.x0},0 ' + 'M {e.x2},{e.y4} l {e.x0},0 ' + 'M {e.x2},{e.y5} l {e.x0},0 ' + 'M {e.x2},{e.y6} l {e.x0},0 ' + 'M {e.x2},{e.y7} l {e.x0},0 ' + 'M {e.x2},{e.y8} l {e.x0},0 ',
        height: 36,
        width: 36,
        heightElements: [8.5, 14.5, 18, 11.5, 14.5, 17.5, 20.5, 23.5, 26.5],
        widthElements: [10.5, 14.5, 12.5]
      },
      'EVENT_LINK': {
        d: 'm {mx},{my} 0,{e.y0} -{e.x1},0 0,{e.y1} {e.x1},0 0,{e.y0} {e.x0},-{e.y2} -{e.x0},-{e.y2} z',
        height: 36,
        width: 36,
        heightElements: [4.4375, 6.75, 7.8125],
        widthElements: [9.84375, 13.5]
      },
      'EVENT_ERROR': {
        d: 'm {mx},{my} {e.x0},-{e.y0} {e.x1},-{e.y1} {e.x2},{e.y2} {e.x3},-{e.y3} -{e.x4},{e.y4} -{e.x5},-{e.y5} z',
        height: 36,
        width: 36,
        heightElements: [0.023, 8.737, 8.151, 16.564, 10.591, 8.714],
        widthElements: [0.085, 6.672, 6.97, 4.273, 5.337, 6.636]
      },
      'EVENT_CANCEL_45': {
        d: 'm {mx},{my} -{e.x1},0 0,{e.x0} {e.x1},0 0,{e.y1} {e.x0},0 ' + '0,-{e.y1} {e.x1},0 0,-{e.y0} -{e.x1},0 0,-{e.y1} -{e.x0},0 z',
        height: 36,
        width: 36,
        heightElements: [4.75, 8.5],
        widthElements: [4.75, 8.5]
      },
      'EVENT_COMPENSATION': {
        d: 'm {mx},{my} {e.x0},-{e.y0} 0,{e.y1} z m {e.x1},-{e.y2} {e.x2},-{e.y3} 0,{e.y1} -{e.x2},-{e.y3} z',
        height: 36,
        width: 36,
        heightElements: [6.5, 13, 0.4, 6.1],
        widthElements: [9, 9.3, 8.7]
      },
      'EVENT_TIMER_WH': {
        d: 'M {mx},{my} l {e.x0},-{e.y0} m -{e.x0},{e.y0} l {e.x1},{e.y1} ',
        height: 36,
        width: 36,
        heightElements: [10, 2],
        widthElements: [3, 7]
      },
      'EVENT_TIMER_LINE': {
        d: 'M {mx},{my} ' + 'm {e.x0},{e.y0} l -{e.x1},{e.y1} ',
        height: 36,
        width: 36,
        heightElements: [10, 3],
        widthElements: [0, 0]
      },
      'EVENT_MULTIPLE': {
        d: 'm {mx},{my} {e.x1},-{e.y0} {e.x1},{e.y0} -{e.x0},{e.y1} -{e.x2},0 z',
        height: 36,
        width: 36,
        heightElements: [6.28099, 12.56199],
        widthElements: [3.1405, 9.42149, 12.56198]
      },
      'EVENT_PARALLEL_MULTIPLE': {
        d: 'm {mx},{my} {e.x0},0 0,{e.y1} {e.x1},0 0,{e.y0} -{e.x1},0 0,{e.y1} ' + '-{e.x0},0 0,-{e.y1} -{e.x1},0 0,-{e.y0} {e.x1},0 z',
        height: 36,
        width: 36,
        heightElements: [2.56228, 7.68683],
        widthElements: [2.56228, 7.68683]
      },
      'GATEWAY_EXCLUSIVE': {
        d: 'm {mx},{my} {e.x0},{e.y0} {e.x1},{e.y0} {e.x2},0 {e.x4},{e.y2} ' + '{e.x4},{e.y1} {e.x2},0 {e.x1},{e.y3} {e.x0},{e.y3} ' + '{e.x3},0 {e.x5},{e.y1} {e.x5},{e.y2} {e.x3},0 z',
        height: 17.5,
        width: 17.5,
        heightElements: [8.5, 6.5312, -6.5312, -8.5],
        widthElements: [6.5, -6.5, 3, -3, 5, -5]
      },
      'GATEWAY_PARALLEL': {
        d: 'm {mx},{my} 0,{e.y1} -{e.x1},0 0,{e.y0} {e.x1},0 0,{e.y1} {e.x0},0 ' + '0,-{e.y1} {e.x1},0 0,-{e.y0} -{e.x1},0 0,-{e.y1} -{e.x0},0 z',
        height: 30,
        width: 30,
        heightElements: [5, 12.5],
        widthElements: [5, 12.5]
      },
      'GATEWAY_EVENT_BASED': {
        d: 'm {mx},{my} {e.x0},{e.y0} {e.x0},{e.y1} {e.x1},{e.y2} {e.x2},0 z',
        height: 11,
        width: 11,
        heightElements: [-6, 6, 12, -12],
        widthElements: [9, -3, -12]
      },
      'GATEWAY_COMPLEX': {
        d: 'm {mx},{my} 0,{e.y0} -{e.x0},-{e.y1} -{e.x1},{e.y2} {e.x0},{e.y1} -{e.x2},0 0,{e.y3} ' + '{e.x2},0  -{e.x0},{e.y1} l {e.x1},{e.y2} {e.x0},-{e.y1} 0,{e.y0} {e.x3},0 0,-{e.y0} {e.x0},{e.y1} ' + '{e.x1},-{e.y2} -{e.x0},-{e.y1} {e.x2},0 0,-{e.y3} -{e.x2},0 {e.x0},-{e.y1} -{e.x1},-{e.y2} ' + '-{e.x0},{e.y1} 0,-{e.y0} -{e.x3},0 z',
        height: 17.125,
        width: 17.125,
        heightElements: [4.875, 3.4375, 2.125, 3],
        widthElements: [3.4375, 2.125, 4.875, 3]
      },
      'DATA_OBJECT_PATH': {
        d: 'm 0,0 {e.x1},0 {e.x0},{e.y0} 0,{e.y1} -{e.x2},0 0,-{e.y2} {e.x1},0 0,{e.y0} {e.x0},0',
        height: 61,
        width: 51,
        heightElements: [10, 50, 60],
        widthElements: [10, 40, 50, 60]
      },
      'DATA_OBJECT_COLLECTION_PATH': {
        d: 'm{mx},{my} m 3,2 l 0,10 m 3,-10 l 0,10 m 3,-10 l 0,10',
        height: 10,
        width: 10,
        heightElements: [],
        widthElements: []
      },
      'DATA_ARROW': {
        d: 'm 5,9 9,0 0,-3 5,5 -5,5 0,-3 -9,0 z',
        height: 61,
        width: 51,
        heightElements: [],
        widthElements: []
      },
      'DATA_STORE': {
        d: 'm  {mx},{my} ' + 'l  0,{e.y2} ' + 'c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0 ' + 'l  0,-{e.y2} ' + 'c -{e.x0},-{e.y1} -{e.x1},-{e.y1} -{e.x2},0' + 'c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0 ' + 'm  -{e.x2},{e.y0}' + 'c  {e.x0},{e.y1} {e.x1},{e.y1} {e.x2},0' + 'm  -{e.x2},{e.y0}' + 'c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0',
        height: 61,
        width: 61,
        heightElements: [7, 10, 45],
        widthElements: [2, 58, 60]
      },
      'TEXT_ANNOTATION': {
        d: 'm {mx}, {my} m 10,0 l -10,0 l 0,{e.y0} l 10,0',
        height: 30,
        width: 10,
        heightElements: [30],
        widthElements: [10]
      },
      'MARKER_SUB_PROCESS': {
        d: 'm{mx},{my} m 7,2 l 0,10 m -5,-5 l 10,0',
        height: 10,
        width: 10,
        heightElements: [],
        widthElements: []
      },
      'MARKER_PARALLEL': {
        d: 'm{mx},{my} m 3,2 l 0,10 m 3,-10 l 0,10 m 3,-10 l 0,10',
        height: 10,
        width: 10,
        heightElements: [],
        widthElements: []
      },
      'MARKER_SEQUENTIAL': {
        d: 'm{mx},{my} m 0,3 l 10,0 m -10,3 l 10,0 m -10,3 l 10,0',
        height: 10,
        width: 10,
        heightElements: [],
        widthElements: []
      },
      'MARKER_COMPENSATION': {
        d: 'm {mx},{my} 7,-5 0,10 z m 7.1,-0.3 6.9,-4.7 0,10 -6.9,-4.7 z',
        height: 10,
        width: 21,
        heightElements: [],
        widthElements: []
      },
      'MARKER_LOOP': {
        d: 'm {mx},{my} c 3.526979,0 6.386161,-2.829858 6.386161,-6.320661 0,-3.490806 -2.859182,-6.320661 ' + '-6.386161,-6.320661 -3.526978,0 -6.38616,2.829855 -6.38616,6.320661 0,1.745402 ' + '0.714797,3.325567 1.870463,4.469381 0.577834,0.571908 1.265885,1.034728 2.029916,1.35457 ' + 'l -0.718163,-3.909793 m 0.718163,3.909793 -3.885211,0.802902',
        height: 13.9,
        width: 13.7,
        heightElements: [],
        widthElements: []
      },
      'MARKER_ADHOC': {
        d: 'm {mx},{my} m 0.84461,2.64411 c 1.05533,-1.23780996 2.64337,-2.07882 4.29653,-1.97997996 2.05163,0.0805 ' + '3.85579,1.15803 5.76082,1.79107 1.06385,0.34139996 2.24454,0.1438 3.18759,-0.43767 0.61743,-0.33642 ' + '1.2775,-0.64078 1.7542,-1.17511 0,0.56023 0,1.12046 0,1.6807 -0.98706,0.96237996 -2.29792,1.62393996 ' + '-3.6918,1.66181996 -1.24459,0.0927 -2.46671,-0.2491 -3.59505,-0.74812 -1.35789,-0.55965 ' + '-2.75133,-1.33436996 -4.27027,-1.18121996 -1.37741,0.14601 -2.41842,1.13685996 -3.44288,1.96782996 z',
        height: 4,
        width: 15,
        heightElements: [],
        widthElements: []
      },
      'TASK_TYPE_SEND': {
        d: 'm {mx},{my} l 0,{e.y1} l {e.x1},0 l 0,-{e.y1} z l {e.x0},{e.y0} l {e.x0},-{e.y0}',
        height: 14,
        width: 21,
        heightElements: [6, 14],
        widthElements: [10.5, 21]
      },
      'TASK_TYPE_SCRIPT': {
        d: 'm {mx},{my} c 9.966553,-6.27276 -8.000926,-7.91932 2.968968,-14.938 l -8.802728,0 ' + 'c -10.969894,7.01868 6.997585,8.66524 -2.968967,14.938 z ' + 'm -7,-12 l 5,0 ' + 'm -4.5,3 l 4.5,0 ' + 'm -3,3 l 5,0' + 'm -4,3 l 5,0',
        height: 15,
        width: 12.6,
        heightElements: [6, 14],
        widthElements: [10.5, 21]
      },
      'TASK_TYPE_USER_1': {
        d: 'm {mx},{my} c 0.909,-0.845 1.594,-2.049 1.594,-3.385 0,-2.554 -1.805,-4.62199999 ' + '-4.357,-4.62199999 -2.55199998,0 -4.28799998,2.06799999 -4.28799998,4.62199999 0,1.348 ' + '0.974,2.562 1.89599998,3.405 -0.52899998,0.187 -5.669,2.097 -5.794,4.7560005 v 6.718 ' + 'h 17 v -6.718 c 0,-2.2980005 -5.5279996,-4.5950005 -6.0509996,-4.7760005 z' + 'm -8,6 l 0,5.5 m 11,0 l 0,-5'
      },
      'TASK_TYPE_USER_2': {
        d: 'm {mx},{my} m 2.162,1.009 c 0,2.4470005 -2.158,4.4310005 -4.821,4.4310005 ' + '-2.66499998,0 -4.822,-1.981 -4.822,-4.4310005 '
      },
      'TASK_TYPE_USER_3': {
        d: 'm {mx},{my} m -6.9,-3.80 c 0,0 2.25099998,-2.358 4.27399998,-1.177 2.024,1.181 4.221,1.537 ' + '4.124,0.965 -0.098,-0.57 -0.117,-3.79099999 -4.191,-4.13599999 -3.57499998,0.001 ' + '-4.20799998,3.36699999 -4.20699998,4.34799999 z'
      },
      'TASK_TYPE_MANUAL': {
        d: 'm {mx},{my} c 0.234,-0.01 5.604,0.008 8.029,0.004 0.808,0 1.271,-0.172 1.417,-0.752 0.227,-0.898 ' + '-0.334,-1.314 -1.338,-1.316 -2.467,-0.01 -7.886,-0.004 -8.108,-0.004 -0.014,-0.079 0.016,-0.533 0,-0.61 ' + '0.195,-0.042 8.507,0.006 9.616,0.002 0.877,-0.007 1.35,-0.438 1.353,-1.208 0.003,-0.768 -0.479,-1.09 ' + '-1.35,-1.091 -2.968,-0.002 -9.619,-0.013 -9.619,-0.013 v -0.591 c 0,0 5.052,-0.016 7.225,-0.016 ' + '0.888,-0.002 1.354,-0.416 1.351,-1.193 -0.006,-0.761 -0.492,-1.196 -1.361,-1.196 -3.473,-0.005 ' + '-10.86,-0.003 -11.0829995,-0.003 -0.022,-0.047 -0.045,-0.094 -0.069,-0.139 0.3939995,-0.319 ' + '2.0409995,-1.626 2.4149995,-2.017 0.469,-0.4870005 0.519,-1.1650005 0.162,-1.6040005 -0.414,-0.511 ' + '-0.973,-0.5 -1.48,-0.236 -1.4609995,0.764 -6.5999995,3.6430005 -7.7329995,4.2710005 -0.9,0.499 ' + '-1.516,1.253 -1.882,2.19 -0.37000002,0.95 -0.17,2.01 -0.166,2.979 0.004,0.718 -0.27300002,1.345 ' + '-0.055,2.063 0.629,2.087 2.425,3.312 4.859,3.318 4.6179995,0.014 9.2379995,-0.139 13.8569995,-0.158 ' + '0.755,-0.004 1.171,-0.301 1.182,-1.033 0.012,-0.754 -0.423,-0.969 -1.183,-0.973 -1.778,-0.01 ' + '-5.824,-0.004 -6.04,-0.004 10e-4,-0.084 0.003,-0.586 10e-4,-0.67 z'
      },
      'TASK_TYPE_INSTANTIATING_SEND': {
        d: 'm {mx},{my} l 0,8.4 l 12.6,0 l 0,-8.4 z l 6.3,3.6 l 6.3,-3.6'
      },
      'TASK_TYPE_SERVICE': {
        d: 'm {mx},{my} v -1.71335 c 0.352326,-0.0705 0.703932,-0.17838 1.047628,-0.32133 ' + '0.344416,-0.14465 0.665822,-0.32133 0.966377,-0.52145 l 1.19431,1.18005 1.567487,-1.57688 ' + '-1.195028,-1.18014 c 0.403376,-0.61394 0.683079,-1.29908 0.825447,-2.01824 l 1.622133,-0.01 ' + 'v -2.2196 l -1.636514,0.01 c -0.07333,-0.35153 -0.178319,-0.70024 -0.323564,-1.04372 ' + '-0.145244,-0.34406 -0.321407,-0.6644 -0.522735,-0.96217 l 1.131035,-1.13631 -1.583305,-1.56293 ' + '-1.129598,1.13589 c -0.614052,-0.40108 -1.302883,-0.68093 -2.022633,-0.82247 l 0.0093,-1.61852 ' + 'h -2.241173 l 0.0042,1.63124 c -0.353763,0.0736 -0.705369,0.17977 -1.049785,0.32371 -0.344415,0.14437 ' + '-0.665102,0.32092 -0.9635006,0.52046 l -1.1698628,-1.15823 -1.5667691,1.5792 1.1684265,1.15669 ' + 'c -0.4026573,0.61283 -0.68308,1.29797 -0.8247287,2.01713 l -1.6588041,0.003 v 2.22174 ' + 'l 1.6724648,-0.006 c 0.073327,0.35077 0.1797598,0.70243 0.3242851,1.04472 0.1452428,0.34448 ' + '0.3214064,0.6644 0.5227339,0.96066 l -1.1993431,1.19723 1.5840256,1.56011 1.1964668,-1.19348 ' + 'c 0.6140517,0.40346 1.3028827,0.68232 2.0233517,0.82331 l 7.19e-4,1.69892 h 2.226848 z ' + 'm 0.221462,-3.9957 c -1.788948,0.7502 -3.8576,-0.0928 -4.6097055,-1.87438 -0.7521065,-1.78321 ' + '0.090598,-3.84627 1.8802645,-4.59604 1.78823,-0.74936 3.856881,0.0929 4.608987,1.87437 ' + '0.752106,1.78165 -0.0906,3.84612 -1.879546,4.59605 z'
      },
      'TASK_TYPE_SERVICE_FILL': {
        d: 'm {mx},{my} c -1.788948,0.7502 -3.8576,-0.0928 -4.6097055,-1.87438 -0.7521065,-1.78321 ' + '0.090598,-3.84627 1.8802645,-4.59604 1.78823,-0.74936 3.856881,0.0929 4.608987,1.87437 ' + '0.752106,1.78165 -0.0906,3.84612 -1.879546,4.59605 z'
      },
      'TASK_TYPE_BUSINESS_RULE_HEADER': {
        d: 'm {mx},{my} 0,4 20,0 0,-4 z'
      },
      'TASK_TYPE_BUSINESS_RULE_MAIN': {
        d: 'm {mx},{my} 0,12 20,0 0,-12 z' + 'm 0,8 l 20,0 ' + 'm -13,-4 l 0,8'
      },
      'MESSAGE_FLOW_MARKER': {
        d: 'm {mx},{my} m -10.5 ,-7 l 0,14 l 21,0 l 0,-14 z l 10.5,6 l 10.5,-6'
      }
    };
    this.getRawPath = function getRawPath(pathId) {
      return this.pathMap[pathId].d;
    };
    this.getScaledPath = function getScaledPath(pathId, param) {
      var rawPath = this.pathMap[pathId];
      var mx, my;
      if (param.abspos) {
        mx = param.abspos.x;
        my = param.abspos.y;
      } else {
        mx = param.containerWidth * param.position.mx;
        my = param.containerHeight * param.position.my;
      }
      var coordinates = {};
      if (param.position) {
        var heightRatio = param.containerHeight / rawPath.height * param.yScaleFactor;
        var widthRatio = param.containerWidth / rawPath.width * param.xScaleFactor;
        for (var heightIndex = 0; heightIndex < rawPath.heightElements.length; heightIndex++) {
          coordinates['y' + heightIndex] = rawPath.heightElements[heightIndex] * heightRatio;
        }
        for (var widthIndex = 0; widthIndex < rawPath.widthElements.length; widthIndex++) {
          coordinates['x' + widthIndex] = rawPath.widthElements[widthIndex] * widthRatio;
        }
      }
      var path = format(rawPath.d, {
        mx: mx,
        my: my,
        e: coordinates
      });
      return path;
    };
  }
  var tokenRegex = /\{([^{}]+)\}/g,
    objNotationRegex = /(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g;
  function replacer(all, key, obj) {
    var res = obj;
    key.replace(objNotationRegex, function (all, name, quote, quotedName, isFunc) {
      name = name || quotedName;
      if (res) {
        if (name in res) {
          res = res[name];
        }
        typeof res == 'function' && isFunc && (res = res());
      }
    });
    res = (res == null || res == obj ? all : res) + '';
    return res;
  }
  function format(str, obj) {
    return String(str).replace(tokenRegex, function (all, key) {
      return replacer(all, key, obj);
    });
  }
  var DrawModule = {
    __init__: ['bpmnRenderer'],
    bpmnRenderer: ['type', BpmnRenderer],
    textRenderer: ['type', TextRenderer],
    pathMap: ['type', PathMap]
  };
  function translate(template, replacements) {
    replacements = replacements || {};
    return template.replace(/{([^}]+)}/g, function (_, key) {
      return replacements[key] || '{' + key + '}';
    });
  }
  var TranslateModule = {
    translate: ['value', translate]
  };
  function elementData(semantic, di, attrs) {
    return assign$1({
      id: semantic.id,
      type: semantic.$type,
      businessObject: semantic,
      di: di
    }, attrs);
  }
  function getWaypoints(di, source, target) {
    var waypoints = di.waypoint;
    if (!waypoints || waypoints.length < 2) {
      return [getMid(source), getMid(target)];
    }
    return waypoints.map(function (p) {
      return {
        x: p.x,
        y: p.y
      };
    });
  }
  function notYetDrawn(semantic, refSemantic, property) {
    return new Error(`element ${elementToString(refSemantic)} referenced by ${elementToString(semantic)}#${property} not yet drawn`);
  }
  function BpmnImporter(eventBus, canvas, elementFactory, elementRegistry, textRenderer) {
    this._eventBus = eventBus;
    this._canvas = canvas;
    this._elementFactory = elementFactory;
    this._elementRegistry = elementRegistry;
    this._textRenderer = textRenderer;
  }
  BpmnImporter.$inject = ['eventBus', 'canvas', 'elementFactory', 'elementRegistry', 'textRenderer'];
  BpmnImporter.prototype.add = function (semantic, di, parentElement) {
    var element, hidden;
    var parentIndex;
    if (is(di, 'bpmndi:BPMNPlane')) {
      var attrs = is(semantic, 'bpmn:SubProcess') ? {
        id: semantic.id + '_plane'
      } : {};
      element = this._elementFactory.createRoot(elementData(semantic, di, attrs));
      this._canvas.addRootElement(element);
    } else if (is(di, 'bpmndi:BPMNShape')) {
      var collapsed = !isExpanded(semantic, di),
        isFrame = isFrameElement(semantic);
      hidden = parentElement && (parentElement.hidden || parentElement.collapsed);
      var bounds = di.bounds;
      element = this._elementFactory.createShape(elementData(semantic, di, {
        collapsed: collapsed,
        hidden: hidden,
        x: Math.round(bounds.x),
        y: Math.round(bounds.y),
        width: Math.round(bounds.width),
        height: Math.round(bounds.height),
        isFrame: isFrame
      }));
      if (is(semantic, 'bpmn:BoundaryEvent')) {
        this._attachBoundary(semantic, element);
      }
      if (is(semantic, 'bpmn:Lane')) {
        parentIndex = 0;
      }
      if (is(semantic, 'bpmn:DataStoreReference')) {
        if (!isPointInsideBBox$1(parentElement, getMid(bounds))) {
          parentElement = this._canvas.findRoot(parentElement);
        }
      }
      this._canvas.addShape(element, parentElement, parentIndex);
    } else if (is(di, 'bpmndi:BPMNEdge')) {
      var source = this._getSource(semantic),
        target = this._getTarget(semantic);
      hidden = parentElement && (parentElement.hidden || parentElement.collapsed);
      element = this._elementFactory.createConnection(elementData(semantic, di, {
        hidden: hidden,
        source: source,
        target: target,
        waypoints: getWaypoints(di, source, target)
      }));
      if (is(semantic, 'bpmn:DataAssociation')) {
        parentElement = this._canvas.findRoot(parentElement);
      }
      this._canvas.addConnection(element, parentElement, parentIndex);
    } else {
      throw new Error(`unknown di ${elementToString(di)} for element ${elementToString(semantic)}`);
    }
    if (isLabelExternal(semantic) && getLabel(element)) {
      this.addLabel(semantic, di, element);
    }
    this._eventBus.fire('bpmnElement.added', {
      element: element
    });
    return element;
  };
  BpmnImporter.prototype._attachBoundary = function (boundarySemantic, boundaryElement) {
    var hostSemantic = boundarySemantic.attachedToRef;
    if (!hostSemantic) {
      throw new Error(`missing ${elementToString(boundarySemantic)}#attachedToRef`);
    }
    var host = this._elementRegistry.get(hostSemantic.id),
      attachers = host && host.attachers;
    if (!host) {
      throw notYetDrawn(boundarySemantic, hostSemantic, 'attachedToRef');
    }
    boundaryElement.host = host;
    if (!attachers) {
      host.attachers = attachers = [];
    }
    if (attachers.indexOf(boundaryElement) === -1) {
      attachers.push(boundaryElement);
    }
  };
  BpmnImporter.prototype.addLabel = function (semantic, di, element) {
    var bounds, text, label;
    bounds = getExternalLabelBounds(di, element);
    text = getLabel(element);
    if (text) {
      bounds = this._textRenderer.getExternalLabelBounds(bounds, text);
    }
    label = this._elementFactory.createLabel(elementData(semantic, di, {
      id: semantic.id + '_label',
      labelTarget: element,
      type: 'label',
      hidden: element.hidden || !getLabel(element),
      x: Math.round(bounds.x),
      y: Math.round(bounds.y),
      width: Math.round(bounds.width),
      height: Math.round(bounds.height)
    }));
    return this._canvas.addShape(label, element.parent);
  };
  BpmnImporter.prototype._getConnectedElement = function (semantic, side) {
    var element,
      refSemantic,
      type = semantic.$type;
    refSemantic = semantic[side + 'Ref'];
    if (side === 'source' && type === 'bpmn:DataInputAssociation') {
      refSemantic = refSemantic && refSemantic[0];
    }
    if (side === 'source' && type === 'bpmn:DataOutputAssociation' || side === 'target' && type === 'bpmn:DataInputAssociation') {
      refSemantic = semantic.$parent;
    }
    element = refSemantic && this._getElement(refSemantic);
    if (element) {
      return element;
    }
    if (refSemantic) {
      throw notYetDrawn(semantic, refSemantic, side + 'Ref');
    } else {
      throw new Error(`${elementToString(semantic)}#${side} Ref not specified`);
    }
  };
  BpmnImporter.prototype._getSource = function (semantic) {
    return this._getConnectedElement(semantic, 'source');
  };
  BpmnImporter.prototype._getTarget = function (semantic) {
    return this._getConnectedElement(semantic, 'target');
  };
  BpmnImporter.prototype._getElement = function (semantic) {
    return this._elementRegistry.get(semantic.id);
  };
  function isPointInsideBBox$1(bbox, point) {
    var x = point.x,
      y = point.y;
    return x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;
  }
  function isFrameElement(semantic) {
    return is(semantic, 'bpmn:Group');
  }
  var ImportModule = {
    __depends__: [TranslateModule],
    bpmnImporter: ['type', BpmnImporter]
  };
  var CoreModule = {
    __depends__: [DrawModule, ImportModule]
  };
  function IdGenerator(prefix) {
    this._counter = 0;
    this._prefix = (prefix ? prefix + '-' : '') + Math.floor(Math.random() * 1000000000) + '-';
  }
  IdGenerator.prototype.next = function () {
    return this._prefix + ++this._counter;
  };
  var ids$1 = new IdGenerator('ov');
  var LOW_PRIORITY$q = 500;
  function Overlays(config, eventBus, canvas, elementRegistry) {
    this._eventBus = eventBus;
    this._canvas = canvas;
    this._elementRegistry = elementRegistry;
    this._ids = ids$1;
    this._overlayDefaults = assign$1({
      show: null,
      scale: true
    }, config && config.defaults);
    this._overlays = {};
    this._overlayContainers = [];
    this._overlayRoot = createRoot$1(canvas.getContainer());
    this._init();
  }
  Overlays.$inject = ['config.overlays', 'eventBus', 'canvas', 'elementRegistry'];
  Overlays.prototype.get = function (search) {
    if (isString(search)) {
      search = {
        id: search
      };
    }
    if (isString(search.element)) {
      search.element = this._elementRegistry.get(search.element);
    }
    if (search.element) {
      var container = this._getOverlayContainer(search.element, true);
      if (container) {
        return search.type ? filter(container.overlays, matchPattern({
          type: search.type
        })) : container.overlays.slice();
      } else {
        return [];
      }
    } else if (search.type) {
      return filter(this._overlays, matchPattern({
        type: search.type
      }));
    } else {
      return search.id ? this._overlays[search.id] : null;
    }
  };
  Overlays.prototype.add = function (element, type, overlay) {
    if (isObject(type)) {
      overlay = type;
      type = null;
    }
    if (!element.id) {
      element = this._elementRegistry.get(element);
    }
    if (!overlay.position) {
      throw new Error('must specifiy overlay position');
    }
    if (!overlay.html) {
      throw new Error('must specifiy overlay html');
    }
    if (!element) {
      throw new Error('invalid element specified');
    }
    var id = this._ids.next();
    overlay = assign$1({}, this._overlayDefaults, overlay, {
      id: id,
      type: type,
      element: element,
      html: overlay.html
    });
    this._addOverlay(overlay);
    return id;
  };
  Overlays.prototype.remove = function (filter) {
    var overlays = this.get(filter) || [];
    if (!isArray$3(overlays)) {
      overlays = [overlays];
    }
    var self = this;
    forEach$1(overlays, function (overlay) {
      var container = self._getOverlayContainer(overlay.element, true);
      if (overlay) {
        remove$2(overlay.html);
        remove$2(overlay.htmlContainer);
        delete overlay.htmlContainer;
        delete overlay.element;
        delete self._overlays[overlay.id];
      }
      if (container) {
        var idx = container.overlays.indexOf(overlay);
        if (idx !== -1) {
          container.overlays.splice(idx, 1);
        }
      }
    });
  };
  Overlays.prototype.isShown = function () {
    return this._overlayRoot.style.display !== 'none';
  };
  Overlays.prototype.show = function () {
    setVisible$1(this._overlayRoot);
  };
  Overlays.prototype.hide = function () {
    setVisible$1(this._overlayRoot, false);
  };
  Overlays.prototype.clear = function () {
    this._overlays = {};
    this._overlayContainers = [];
    clear$1(this._overlayRoot);
  };
  Overlays.prototype._updateOverlayContainer = function (container) {
    var element = container.element,
      html = container.html;
    var x = element.x,
      y = element.y;
    if (element.waypoints) {
      var bbox = getBBox(element);
      x = bbox.x;
      y = bbox.y;
    }
    setPosition$1(html, x, y);
    attr$1(container.html, 'data-container-id', element.id);
  };
  Overlays.prototype._updateOverlay = function (overlay) {
    var position = overlay.position,
      htmlContainer = overlay.htmlContainer,
      element = overlay.element;
    var left = position.left,
      top = position.top;
    if (position.right !== undefined) {
      var width;
      if (element.waypoints) {
        width = getBBox(element).width;
      } else {
        width = element.width;
      }
      left = position.right * -1 + width;
    }
    if (position.bottom !== undefined) {
      var height;
      if (element.waypoints) {
        height = getBBox(element).height;
      } else {
        height = element.height;
      }
      top = position.bottom * -1 + height;
    }
    setPosition$1(htmlContainer, left || 0, top || 0);
    this._updateOverlayVisibilty(overlay, this._canvas.viewbox());
  };
  Overlays.prototype._createOverlayContainer = function (element) {
    var html = domify$1('<div class="djs-overlays" />');
    assign(html, {
      position: 'absolute'
    });
    this._overlayRoot.appendChild(html);
    var container = {
      html: html,
      element: element,
      overlays: []
    };
    this._updateOverlayContainer(container);
    this._overlayContainers.push(container);
    return container;
  };
  Overlays.prototype._updateRoot = function (viewbox) {
    var scale = viewbox.scale || 1;
    var matrix = 'matrix(' + [scale, 0, 0, scale, -1 * viewbox.x * scale, -1 * viewbox.y * scale].join(',') + ')';
    setTransform(this._overlayRoot, matrix);
  };
  Overlays.prototype._getOverlayContainer = function (element, raw) {
    var container = find(this._overlayContainers, function (c) {
      return c.element === element;
    });
    if (!container && !raw) {
      return this._createOverlayContainer(element);
    }
    return container;
  };
  Overlays.prototype._addOverlay = function (overlay) {
    var id = overlay.id,
      element = overlay.element,
      html = overlay.html,
      htmlContainer,
      overlayContainer;
    if (html.get && html.constructor.prototype.jquery) {
      html = html.get(0);
    }
    if (isString(html)) {
      html = domify$1(html);
    }
    overlayContainer = this._getOverlayContainer(element);
    htmlContainer = domify$1('<div class="djs-overlay" data-overlay-id="' + id + '">');
    assign(htmlContainer, {
      position: 'absolute'
    });
    htmlContainer.appendChild(html);
    if (overlay.type) {
      classes$1(htmlContainer).add('djs-overlay-' + overlay.type);
    }
    var elementRoot = this._canvas.findRoot(element);
    var activeRoot = this._canvas.getRootElement();
    setVisible$1(htmlContainer, elementRoot === activeRoot);
    overlay.htmlContainer = htmlContainer;
    overlayContainer.overlays.push(overlay);
    overlayContainer.html.appendChild(htmlContainer);
    this._overlays[id] = overlay;
    this._updateOverlay(overlay);
    this._updateOverlayVisibilty(overlay, this._canvas.viewbox());
  };
  Overlays.prototype._updateOverlayVisibilty = function (overlay, viewbox) {
    var show = overlay.show,
      rootElement = this._canvas.findRoot(overlay.element),
      minZoom = show && show.minZoom,
      maxZoom = show && show.maxZoom,
      htmlContainer = overlay.htmlContainer,
      activeRootElement = this._canvas.getRootElement(),
      visible = true;
    if (rootElement !== activeRootElement) {
      visible = false;
    } else if (show) {
      if (isDefined(minZoom) && minZoom > viewbox.scale || isDefined(maxZoom) && maxZoom < viewbox.scale) {
        visible = false;
      }
    }
    setVisible$1(htmlContainer, visible);
    this._updateOverlayScale(overlay, viewbox);
  };
  Overlays.prototype._updateOverlayScale = function (overlay, viewbox) {
    var shouldScale = overlay.scale,
      minScale,
      maxScale,
      htmlContainer = overlay.htmlContainer;
    var scale,
      transform = '';
    if (shouldScale !== true) {
      if (shouldScale === false) {
        minScale = 1;
        maxScale = 1;
      } else {
        minScale = shouldScale.min;
        maxScale = shouldScale.max;
      }
      if (isDefined(minScale) && viewbox.scale < minScale) {
        scale = (1 / viewbox.scale || 1) * minScale;
      }
      if (isDefined(maxScale) && viewbox.scale > maxScale) {
        scale = (1 / viewbox.scale || 1) * maxScale;
      }
    }
    if (isDefined(scale)) {
      transform = 'scale(' + scale + ',' + scale + ')';
    }
    setTransform(htmlContainer, transform);
  };
  Overlays.prototype._updateOverlaysVisibilty = function (viewbox) {
    var self = this;
    forEach$1(this._overlays, function (overlay) {
      self._updateOverlayVisibilty(overlay, viewbox);
    });
  };
  Overlays.prototype._init = function () {
    var eventBus = this._eventBus;
    var self = this;
    function updateViewbox(viewbox) {
      self._updateRoot(viewbox);
      self._updateOverlaysVisibilty(viewbox);
      self.show();
    }
    eventBus.on('canvas.viewbox.changing', function (event) {
      self.hide();
    });
    eventBus.on('canvas.viewbox.changed', function (event) {
      updateViewbox(event.viewbox);
    });
    eventBus.on(['shape.remove', 'connection.remove'], function (e) {
      var element = e.element;
      var overlays = self.get({
        element: element
      });
      forEach$1(overlays, function (o) {
        self.remove(o.id);
      });
      var container = self._getOverlayContainer(element);
      if (container) {
        remove$2(container.html);
        var i = self._overlayContainers.indexOf(container);
        if (i !== -1) {
          self._overlayContainers.splice(i, 1);
        }
      }
    });
    eventBus.on('element.changed', LOW_PRIORITY$q, function (e) {
      var element = e.element;
      var container = self._getOverlayContainer(element, true);
      if (container) {
        forEach$1(container.overlays, function (overlay) {
          self._updateOverlay(overlay);
        });
        self._updateOverlayContainer(container);
      }
    });
    eventBus.on('element.marker.update', function (e) {
      var container = self._getOverlayContainer(e.element, true);
      if (container) {
        classes$1(container.html)[e.add ? 'add' : 'remove'](e.marker);
      }
    });
    eventBus.on('root.set', function () {
      self._updateOverlaysVisibilty(self._canvas.viewbox());
    });
    eventBus.on('diagram.clear', this.clear, this);
  };
  function createRoot$1(parentNode) {
    var root = domify$1('<div class="djs-overlay-container" />');
    assign(root, {
      position: 'absolute',
      width: 0,
      height: 0
    });
    parentNode.insertBefore(root, parentNode.firstChild);
    return root;
  }
  function setPosition$1(el, x, y) {
    assign(el, {
      left: x + 'px',
      top: y + 'px'
    });
  }
  function setVisible$1(el, visible) {
    el.style.display = visible === false ? 'none' : '';
  }
  function setTransform(el, transform) {
    el.style['transform-origin'] = 'top left';
    ['', '-ms-', '-webkit-'].forEach(function (prefix) {
      el.style[prefix + 'transform'] = transform;
    });
  }
  var OverlaysModule = {
    __init__: ['overlays'],
    overlays: ['type', Overlays]
  };
  function ChangeSupport(eventBus, canvas, elementRegistry, graphicsFactory) {
    eventBus.on('element.changed', function (event) {
      var element = event.element;
      if (element.parent || element === canvas.getRootElement()) {
        event.gfx = elementRegistry.getGraphics(element);
      }
      if (!event.gfx) {
        return;
      }
      eventBus.fire(getType(element) + '.changed', event);
    });
    eventBus.on('elements.changed', function (event) {
      var elements = event.elements;
      elements.forEach(function (e) {
        eventBus.fire('element.changed', {
          element: e
        });
      });
      graphicsFactory.updateContainments(elements);
    });
    eventBus.on('shape.changed', function (event) {
      graphicsFactory.update('shape', event.element, event.gfx);
    });
    eventBus.on('connection.changed', function (event) {
      graphicsFactory.update('connection', event.element, event.gfx);
    });
  }
  ChangeSupport.$inject = ['eventBus', 'canvas', 'elementRegistry', 'graphicsFactory'];
  var ChangeSupportModule = {
    __init__: ['changeSupport'],
    changeSupport: ['type', ChangeSupport]
  };
  var DEFAULT_PRIORITY$5 = 1000;
  function CommandInterceptor(eventBus) {
    this._eventBus = eventBus;
  }
  CommandInterceptor.$inject = ['eventBus'];
  function unwrapEvent(fn, that) {
    return function (event) {
      return fn.call(that || null, event.context, event.command, event);
    };
  }
  CommandInterceptor.prototype.on = function (events, hook, priority, handlerFn, unwrap, that) {
    if (isFunction(hook) || isNumber(hook)) {
      that = unwrap;
      unwrap = handlerFn;
      handlerFn = priority;
      priority = hook;
      hook = null;
    }
    if (isFunction(priority)) {
      that = unwrap;
      unwrap = handlerFn;
      handlerFn = priority;
      priority = DEFAULT_PRIORITY$5;
    }
    if (isObject(unwrap)) {
      that = unwrap;
      unwrap = false;
    }
    if (!isFunction(handlerFn)) {
      throw new Error('handlerFn must be a function');
    }
    if (!isArray$3(events)) {
      events = [events];
    }
    var eventBus = this._eventBus;
    forEach$1(events, function (event) {
      var fullEvent = ['commandStack', event, hook].filter(function (e) {
        return e;
      }).join('.');
      eventBus.on(fullEvent, priority, unwrap ? unwrapEvent(handlerFn, that) : handlerFn, that);
    });
  };
  CommandInterceptor.prototype.canExecute = createHook('canExecute');
  CommandInterceptor.prototype.preExecute = createHook('preExecute');
  CommandInterceptor.prototype.preExecuted = createHook('preExecuted');
  CommandInterceptor.prototype.execute = createHook('execute');
  CommandInterceptor.prototype.executed = createHook('executed');
  CommandInterceptor.prototype.postExecute = createHook('postExecute');
  CommandInterceptor.prototype.postExecuted = createHook('postExecuted');
  CommandInterceptor.prototype.revert = createHook('revert');
  CommandInterceptor.prototype.reverted = createHook('reverted');
  function createHook(hook) {
    var hookFn = function hookFn(events, priority, handlerFn, unwrap, that) {
      if (isFunction(events) || isNumber(events)) {
        that = unwrap;
        unwrap = handlerFn;
        handlerFn = priority;
        priority = events;
        events = null;
      }
      this.on(events, hook, priority, handlerFn, unwrap, that);
    };
    return hookFn;
  }
  function RootElementsBehavior(canvas, injector) {
    injector.invoke(CommandInterceptor, this);
    this.executed(function (event) {
      var context = event.context;
      if (context.rootElement) {
        canvas.setRootElement(context.rootElement);
      } else {
        context.rootElement = canvas.getRootElement();
      }
    });
    this.revert(function (event) {
      var context = event.context;
      if (context.rootElement) {
        canvas.setRootElement(context.rootElement);
      }
    });
  }
  e$2(RootElementsBehavior, CommandInterceptor);
  RootElementsBehavior.$inject = ['canvas', 'injector'];
  var RootElementsModule = {
    __init__: ['rootElementsBehavior'],
    rootElementsBehavior: ['type', RootElementsBehavior]
  };
  function escapeCSS(str) {
    return CSS.escape(str);
  }
  var HTML_ESCAPE_MAP = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    '\'': '&#39;'
  };
  function escapeHTML(str) {
    str = '' + str;
    return str && str.replace(/[&<>"']/g, function (match) {
      return HTML_ESCAPE_MAP[match];
    });
  }
  var planeSuffix = '_plane';
  function getShapeIdFromPlane(element) {
    var id = element.id;
    return removePlaneSuffix(id);
  }
  function getPlaneIdFromShape(element) {
    var id = element.id;
    if (is(element, 'bpmn:SubProcess')) {
      return addPlaneSuffix(id);
    }
    return id;
  }
  function toPlaneId(id) {
    return addPlaneSuffix(id);
  }
  function isPlane(element) {
    var di = getDi(element);
    return is(di, 'bpmndi:BPMNPlane');
  }
  function addPlaneSuffix(id) {
    return id + planeSuffix;
  }
  function removePlaneSuffix(id) {
    return id.replace(new RegExp(planeSuffix + '$'), '');
  }
  var OPEN_CLASS = 'bjs-breadcrumbs-shown';
  function DrilldownBreadcrumbs(eventBus, elementRegistry, canvas) {
    var breadcrumbs = domify$1('<ul class="bjs-breadcrumbs"></ul>');
    var container = canvas.getContainer();
    var containerClasses = classes$1(container);
    container.appendChild(breadcrumbs);
    var businessObjectParents = [];
    eventBus.on('element.changed', function (event) {
      var shape = event.element,
        businessObject = getBusinessObject(shape);
      var isPresent = find(businessObjectParents, function (element) {
        return element === businessObject;
      });
      if (!isPresent) {
        return;
      }
      updateBreadcrumbs();
    });
    function updateBreadcrumbs(element) {
      if (element) {
        businessObjectParents = getBusinessObjectParentChain(element);
      }
      var path = businessObjectParents.flatMap(function (parent) {
        var parentPlane = canvas.findRoot(getPlaneIdFromShape(parent)) || canvas.findRoot(parent.id);
        if (!parentPlane && is(parent, 'bpmn:Process')) {
          var participant = elementRegistry.find(function (element) {
            var businessObject = getBusinessObject(element);
            return businessObject && businessObject.get('processRef') === parent;
          });
          parentPlane = participant && canvas.findRoot(participant.id);
        }
        if (!parentPlane) {
          return [];
        }
        var title = escapeHTML(parent.name || parent.id);
        var link = domify$1('<li><span class="bjs-crumb"><a title="' + title + '">' + title + '</a></span></li>');
        link.addEventListener('click', function () {
          canvas.setRootElement(parentPlane);
        });
        return link;
      });
      breadcrumbs.innerHTML = '';
      var visible = path.length > 1;
      containerClasses.toggle(OPEN_CLASS, visible);
      path.forEach(function (element) {
        breadcrumbs.appendChild(element);
      });
    }
    eventBus.on('root.set', function (event) {
      updateBreadcrumbs(event.element);
    });
  }
  DrilldownBreadcrumbs.$inject = ['eventBus', 'elementRegistry', 'canvas'];
  function getBusinessObjectParentChain(child) {
    var businessObject = getBusinessObject(child);
    var parents = [];
    for (var element = businessObject; element; element = element.$parent) {
      if (is(element, 'bpmn:SubProcess') || is(element, 'bpmn:Process')) {
        parents.push(element);
      }
    }
    return parents.reverse();
  }
  function DrilldownCentering(eventBus, canvas) {
    var currentRoot = null;
    var positionMap = new Map$1();
    eventBus.on('root.set', function (event) {
      var newRoot = event.element;
      var currentViewbox = canvas.viewbox();
      var storedViewbox = positionMap.get(newRoot);
      positionMap.set(currentRoot, {
        x: currentViewbox.x,
        y: currentViewbox.y,
        zoom: currentViewbox.scale
      });
      currentRoot = newRoot;
      if (!is(newRoot, 'bpmn:SubProcess') && !storedViewbox) {
        return;
      }
      storedViewbox = storedViewbox || {
        x: 0,
        y: 0,
        zoom: 1
      };
      var dx = (currentViewbox.x - storedViewbox.x) * currentViewbox.scale,
        dy = (currentViewbox.y - storedViewbox.y) * currentViewbox.scale;
      if (dx !== 0 || dy !== 0) {
        canvas.scroll({
          dx: dx,
          dy: dy
        });
      }
      if (storedViewbox.zoom !== currentViewbox.scale) {
        canvas.zoom(storedViewbox.zoom, {
          x: 0,
          y: 0
        });
      }
    });
    eventBus.on('diagram.clear', function () {
      positionMap.clear();
      currentRoot = null;
    });
  }
  DrilldownCentering.$inject = ['eventBus', 'canvas'];
  function Map$1() {
    this._entries = [];
    this.set = function (key, value) {
      var found = false;
      for (var k in this._entries) {
        if (this._entries[k][0] === key) {
          this._entries[k][1] = value;
          found = true;
          break;
        }
      }
      if (!found) {
        this._entries.push([key, value]);
      }
    };
    this.get = function (key) {
      for (var k in this._entries) {
        if (this._entries[k][0] === key) {
          return this._entries[k][1];
        }
      }
      return null;
    };
    this.clear = function () {
      this._entries.length = 0;
    };
    this.remove = function (key) {
      var idx = -1;
      for (var k in this._entries) {
        if (this._entries[k][0] === key) {
          idx = k;
          break;
        }
      }
      if (idx !== -1) {
        this._entries.splice(idx, 1);
      }
    };
  }
  var DEFAULT_POSITION$1 = {
    x: 180,
    y: 160
  };
  function SubprocessCompatibility(eventBus, moddle) {
    this._eventBus = eventBus;
    this._moddle = moddle;
    var self = this;
    eventBus.on('import.render.start', 1500, function (e, context) {
      self._handleImport(context.definitions);
    });
  }
  SubprocessCompatibility.prototype._handleImport = function (definitions) {
    if (!definitions.diagrams) {
      return;
    }
    var self = this;
    this._definitions = definitions;
    this._processToDiagramMap = {};
    definitions.diagrams.forEach(function (diagram) {
      if (!diagram.plane || !diagram.plane.bpmnElement) {
        return;
      }
      self._processToDiagramMap[diagram.plane.bpmnElement.id] = diagram;
    });
    var newDiagrams = definitions.diagrams.filter(function (diagram) {
      return diagram.plane;
    }).flatMap(function (diagram) {
      return self._createNewDiagrams(diagram.plane);
    });
    newDiagrams.forEach(function (diagram) {
      self._movePlaneElementsToOrigin(diagram.plane);
    });
  };
  SubprocessCompatibility.prototype._createNewDiagrams = function (plane) {
    var self = this;
    var collapsedElements = [];
    var elementsToMove = [];
    plane.get('planeElement').forEach(function (diElement) {
      var businessObject = diElement.bpmnElement;
      if (!businessObject) {
        return;
      }
      var parent = businessObject.$parent;
      if (is(businessObject, 'bpmn:SubProcess') && !diElement.isExpanded) {
        collapsedElements.push(businessObject);
      }
      if (shouldMoveToPlane(businessObject, plane)) {
        elementsToMove.push({
          diElement: diElement,
          parent: parent
        });
      }
    });
    var newDiagrams = [];
    collapsedElements.forEach(function (element) {
      if (!self._processToDiagramMap[element.id]) {
        var diagram = self._createDiagram(element);
        self._processToDiagramMap[element.id] = diagram;
        newDiagrams.push(diagram);
      }
    });
    elementsToMove.forEach(function (element) {
      var diElement = element.diElement;
      var parent = element.parent;
      while (parent && collapsedElements.indexOf(parent) === -1) {
        parent = parent.$parent;
      }
      if (!parent) {
        return;
      }
      var diagram = self._processToDiagramMap[parent.id];
      self._moveToDiPlane(diElement, diagram.plane);
    });
    return newDiagrams;
  };
  SubprocessCompatibility.prototype._movePlaneElementsToOrigin = function (plane) {
    var elements = plane.get('planeElement');
    var planeBounds = getPlaneBounds(plane);
    var offset = {
      x: planeBounds.x - DEFAULT_POSITION$1.x,
      y: planeBounds.y - DEFAULT_POSITION$1.y
    };
    elements.forEach(function (diElement) {
      if (diElement.waypoint) {
        diElement.waypoint.forEach(function (waypoint) {
          waypoint.x = waypoint.x - offset.x;
          waypoint.y = waypoint.y - offset.y;
        });
      } else if (diElement.bounds) {
        diElement.bounds.x = diElement.bounds.x - offset.x;
        diElement.bounds.y = diElement.bounds.y - offset.y;
      }
    });
  };
  SubprocessCompatibility.prototype._moveToDiPlane = function (diElement, newPlane) {
    var containingDiagram = findRootDiagram(diElement);
    var parentPlaneElement = containingDiagram.plane.get('planeElement');
    parentPlaneElement.splice(parentPlaneElement.indexOf(diElement), 1);
    newPlane.get('planeElement').push(diElement);
  };
  SubprocessCompatibility.prototype._createDiagram = function (businessObject) {
    var plane = this._moddle.create('bpmndi:BPMNPlane', {
      bpmnElement: businessObject
    });
    var diagram = this._moddle.create('bpmndi:BPMNDiagram', {
      plane: plane
    });
    plane.$parent = diagram;
    plane.bpmnElement = businessObject;
    diagram.$parent = this._definitions;
    this._definitions.diagrams.push(diagram);
    return diagram;
  };
  SubprocessCompatibility.$inject = ['eventBus', 'moddle'];
  function findRootDiagram(element) {
    if (is(element, 'bpmndi:BPMNDiagram')) {
      return element;
    } else {
      return findRootDiagram(element.$parent);
    }
  }
  function getPlaneBounds(plane) {
    var planeTrbl = {
      top: Infinity,
      right: -Infinity,
      bottom: -Infinity,
      left: Infinity
    };
    plane.planeElement.forEach(function (element) {
      if (!element.bounds) {
        return;
      }
      var trbl = asTRBL(element.bounds);
      planeTrbl.top = Math.min(trbl.top, planeTrbl.top);
      planeTrbl.left = Math.min(trbl.left, planeTrbl.left);
    });
    return asBounds(planeTrbl);
  }
  function shouldMoveToPlane(businessObject, plane) {
    var parent = businessObject.$parent;
    if (!is(parent, 'bpmn:SubProcess') || parent === plane.bpmnElement) {
      return false;
    }
    if (isAny(businessObject, ['bpmn:DataInputAssociation', 'bpmn:DataOutputAssociation'])) {
      return false;
    }
    return true;
  }
  var LOW_PRIORITY$p = 250;
  var ARROW_DOWN_SVG = '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4.81801948,3.50735931 L10.4996894,9.1896894 L10.5,4 L12,4 L12,12 L4,12 L4,10.5 L9.6896894,10.4996894 L3.75735931,4.56801948 C3.46446609,4.27512627 3.46446609,3.80025253 3.75735931,3.50735931 C4.05025253,3.21446609 4.52512627,3.21446609 4.81801948,3.50735931 Z"/></svg>';
  var EMPTY_MARKER = 'bjs-drilldown-empty';
  function DrilldownOverlayBehavior(canvas, eventBus, elementRegistry, overlays, translate) {
    CommandInterceptor.call(this, eventBus);
    this._canvas = canvas;
    this._eventBus = eventBus;
    this._elementRegistry = elementRegistry;
    this._overlays = overlays;
    this._translate = translate;
    var self = this;
    this.executed('shape.toggleCollapse', LOW_PRIORITY$p, function (context) {
      var shape = context.shape;
      if (self._canDrillDown(shape)) {
        self._addOverlay(shape);
      } else {
        self._removeOverlay(shape);
      }
    }, true);
    this.reverted('shape.toggleCollapse', LOW_PRIORITY$p, function (context) {
      var shape = context.shape;
      if (self._canDrillDown(shape)) {
        self._addOverlay(shape);
      } else {
        self._removeOverlay(shape);
      }
    }, true);
    this.executed(['shape.create', 'shape.move', 'shape.delete'], LOW_PRIORITY$p, function (context) {
      var oldParent = context.oldParent,
        newParent = context.newParent || context.parent,
        shape = context.shape;
      if (self._canDrillDown(shape)) {
        self._addOverlay(shape);
      }
      self._updateDrilldownOverlay(oldParent);
      self._updateDrilldownOverlay(newParent);
      self._updateDrilldownOverlay(shape);
    }, true);
    this.reverted(['shape.create', 'shape.move', 'shape.delete'], LOW_PRIORITY$p, function (context) {
      var oldParent = context.oldParent,
        newParent = context.newParent || context.parent,
        shape = context.shape;
      if (self._canDrillDown(shape)) {
        self._addOverlay(shape);
      }
      self._updateDrilldownOverlay(oldParent);
      self._updateDrilldownOverlay(newParent);
      self._updateDrilldownOverlay(shape);
    }, true);
    eventBus.on('import.render.complete', function () {
      elementRegistry.filter(function (e) {
        return self._canDrillDown(e);
      }).map(function (el) {
        self._addOverlay(el);
      });
    });
  }
  e$2(DrilldownOverlayBehavior, CommandInterceptor);
  DrilldownOverlayBehavior.prototype._updateDrilldownOverlay = function (shape) {
    var canvas = this._canvas;
    if (!shape) {
      return;
    }
    var root = canvas.findRoot(shape);
    if (root) {
      this._updateOverlayVisibility(root);
    }
  };
  DrilldownOverlayBehavior.prototype._canDrillDown = function (element) {
    var canvas = this._canvas;
    return is(element, 'bpmn:SubProcess') && canvas.findRoot(getPlaneIdFromShape(element));
  };
  DrilldownOverlayBehavior.prototype._updateOverlayVisibility = function (element) {
    var overlays = this._overlays;
    var businessObject = getBusinessObject(element);
    var overlay = overlays.get({
      element: businessObject.id,
      type: 'drilldown'
    })[0];
    if (!overlay) {
      return;
    }
    var hasFlowElements = businessObject && businessObject.get('flowElements') && businessObject.get('flowElements').length;
    classes$1(overlay.html).toggle(EMPTY_MARKER, !hasFlowElements);
  };
  DrilldownOverlayBehavior.prototype._addOverlay = function (element) {
    var canvas = this._canvas,
      overlays = this._overlays,
      bo = getBusinessObject(element);
    var existingOverlays = overlays.get({
      element: element,
      type: 'drilldown'
    });
    if (existingOverlays.length) {
      this._removeOverlay(element);
    }
    var button = domify$1('<button type="button" class="bjs-drilldown">' + ARROW_DOWN_SVG + '</button>'),
      elementName = bo.get('name') || bo.get('id'),
      title = this._translate('Open {element}', {
        element: elementName
      });
    button.setAttribute('title', title);
    button.addEventListener('click', function () {
      canvas.setRootElement(canvas.findRoot(getPlaneIdFromShape(element)));
    });
    overlays.add(element, 'drilldown', {
      position: {
        bottom: -7,
        right: -8
      },
      html: button
    });
    this._updateOverlayVisibility(element);
  };
  DrilldownOverlayBehavior.prototype._removeOverlay = function (element) {
    var overlays = this._overlays;
    overlays.remove({
      element: element,
      type: 'drilldown'
    });
  };
  DrilldownOverlayBehavior.$inject = ['canvas', 'eventBus', 'elementRegistry', 'overlays', 'translate'];
  var DrilldownModdule = {
    __depends__: [OverlaysModule, ChangeSupportModule, RootElementsModule],
    __init__: ['drilldownBreadcrumbs', 'drilldownOverlayBehavior', 'drilldownCentering', 'subprocessCompatibility'],
    drilldownBreadcrumbs: ['type', DrilldownBreadcrumbs],
    drilldownCentering: ['type', DrilldownCentering],
    drilldownOverlayBehavior: ['type', DrilldownOverlayBehavior],
    subprocessCompatibility: ['type', SubprocessCompatibility]
  };
  function __stopPropagation(event) {
    if (!event || typeof event.stopPropagation !== 'function') {
      return;
    }
    event.stopPropagation();
  }
  function getOriginal$1(event) {
    return event.originalEvent || event.srcEvent;
  }
  function stopPropagation$1(event) {
    __stopPropagation(event);
    __stopPropagation(getOriginal$1(event));
  }
  function toPoint(event) {
    if (event.pointers && event.pointers.length) {
      event = event.pointers[0];
    }
    if (event.touches && event.touches.length) {
      event = event.touches[0];
    }
    return event ? {
      x: event.clientX,
      y: event.clientY
    } : null;
  }
  function isMac() {
    return /mac/i.test(navigator.platform);
  }
  function isButton(event, button) {
    return (getOriginal$1(event) || event).button === button;
  }
  function isPrimaryButton(event) {
    return isButton(event, 0);
  }
  function isAuxiliaryButton(event) {
    return isButton(event, 1);
  }
  function hasPrimaryModifier(event) {
    var originalEvent = getOriginal$1(event) || event;
    if (!isPrimaryButton(event)) {
      return false;
    }
    if (isMac()) {
      return originalEvent.metaKey;
    } else {
      return originalEvent.ctrlKey;
    }
  }
  function hasSecondaryModifier(event) {
    var originalEvent = getOriginal$1(event) || event;
    return isPrimaryButton(event) && originalEvent.shiftKey;
  }
  function allowAll(event) {
    return true;
  }
  function allowPrimaryAndAuxiliary(event) {
    return isPrimaryButton(event) || isAuxiliaryButton(event);
  }
  var LOW_PRIORITY$o = 500;
  function InteractionEvents(eventBus, elementRegistry, styles) {
    var self = this;
    function fire(type, event, element) {
      if (isIgnored(type, event)) {
        return;
      }
      var target, gfx, returnValue;
      if (!element) {
        target = event.delegateTarget || event.target;
        if (target) {
          gfx = target;
          element = elementRegistry.get(gfx);
        }
      } else {
        gfx = elementRegistry.getGraphics(element);
      }
      if (!gfx || !element) {
        return;
      }
      returnValue = eventBus.fire(type, {
        element: element,
        gfx: gfx,
        originalEvent: event
      });
      if (returnValue === false) {
        event.stopPropagation();
        event.preventDefault();
      }
    }
    var handlers = {};
    function mouseHandler(localEventName) {
      return handlers[localEventName];
    }
    function isIgnored(localEventName, event) {
      var filter = ignoredFilters[localEventName] || isPrimaryButton;
      return !filter(event);
    }
    var bindings = {
      click: 'element.click',
      contextmenu: 'element.contextmenu',
      dblclick: 'element.dblclick',
      mousedown: 'element.mousedown',
      mousemove: 'element.mousemove',
      mouseover: 'element.hover',
      mouseout: 'element.out',
      mouseup: 'element.mouseup'
    };
    var ignoredFilters = {
      'element.contextmenu': allowAll,
      'element.mousedown': allowPrimaryAndAuxiliary,
      'element.mouseup': allowPrimaryAndAuxiliary,
      'element.click': allowPrimaryAndAuxiliary,
      'element.dblclick': allowPrimaryAndAuxiliary
    };
    function triggerMouseEvent(eventName, event, targetElement) {
      var localEventName = bindings[eventName];
      if (!localEventName) {
        throw new Error('unmapped DOM event name <' + eventName + '>');
      }
      return fire(localEventName, event, targetElement);
    }
    var ELEMENT_SELECTOR = 'svg, .djs-element';
    function registerEvent(node, event, localEvent, ignoredFilter) {
      var handler = handlers[localEvent] = function (event) {
        fire(localEvent, event);
      };
      if (ignoredFilter) {
        ignoredFilters[localEvent] = ignoredFilter;
      }
      handler.$delegate = delegate.bind(node, ELEMENT_SELECTOR, event, handler);
    }
    function unregisterEvent(node, event, localEvent) {
      var handler = mouseHandler(localEvent);
      if (!handler) {
        return;
      }
      delegate.unbind(node, event, handler.$delegate);
    }
    function registerEvents(svg) {
      forEach$1(bindings, function (val, key) {
        registerEvent(svg, key, val);
      });
    }
    function unregisterEvents(svg) {
      forEach$1(bindings, function (val, key) {
        unregisterEvent(svg, key, val);
      });
    }
    eventBus.on('canvas.destroy', function (event) {
      unregisterEvents(event.svg);
    });
    eventBus.on('canvas.init', function (event) {
      registerEvents(event.svg);
    });
    eventBus.on(['shape.added', 'connection.added'], function (event) {
      var element = event.element,
        gfx = event.gfx;
      eventBus.fire('interactionEvents.createHit', {
        element: element,
        gfx: gfx
      });
    });
    eventBus.on(['shape.changed', 'connection.changed'], LOW_PRIORITY$o, function (event) {
      var element = event.element,
        gfx = event.gfx;
      eventBus.fire('interactionEvents.updateHit', {
        element: element,
        gfx: gfx
      });
    });
    eventBus.on('interactionEvents.createHit', LOW_PRIORITY$o, function (event) {
      var element = event.element,
        gfx = event.gfx;
      self.createDefaultHit(element, gfx);
    });
    eventBus.on('interactionEvents.updateHit', function (event) {
      var element = event.element,
        gfx = event.gfx;
      self.updateDefaultHit(element, gfx);
    });
    var STROKE_HIT_STYLE = createHitStyle('djs-hit djs-hit-stroke');
    var CLICK_STROKE_HIT_STYLE = createHitStyle('djs-hit djs-hit-click-stroke');
    var ALL_HIT_STYLE = createHitStyle('djs-hit djs-hit-all');
    var NO_MOVE_HIT_STYLE = createHitStyle('djs-hit djs-hit-no-move');
    var HIT_TYPES = {
      'all': ALL_HIT_STYLE,
      'click-stroke': CLICK_STROKE_HIT_STYLE,
      'stroke': STROKE_HIT_STYLE,
      'no-move': NO_MOVE_HIT_STYLE
    };
    function createHitStyle(classNames, attrs) {
      attrs = assign$1({
        stroke: 'white',
        strokeWidth: 15
      }, attrs || {});
      return styles.cls(classNames, ['no-fill', 'no-border'], attrs);
    }
    function applyStyle(hit, type) {
      var attrs = HIT_TYPES[type];
      if (!attrs) {
        throw new Error('invalid hit type <' + type + '>');
      }
      attr(hit, attrs);
      return hit;
    }
    function appendHit(gfx, hit) {
      append(gfx, hit);
    }
    this.removeHits = function (gfx) {
      var hits = all('.djs-hit', gfx);
      forEach$1(hits, remove$1);
    };
    this.createDefaultHit = function (element, gfx) {
      var waypoints = element.waypoints,
        isFrame = element.isFrame,
        boxType;
      if (waypoints) {
        return this.createWaypointsHit(gfx, waypoints);
      } else {
        boxType = isFrame ? 'stroke' : 'all';
        return this.createBoxHit(gfx, boxType, {
          width: element.width,
          height: element.height
        });
      }
    };
    this.createWaypointsHit = function (gfx, waypoints) {
      var hit = createLine(waypoints);
      applyStyle(hit, 'stroke');
      appendHit(gfx, hit);
      return hit;
    };
    this.createBoxHit = function (gfx, type, attrs) {
      attrs = assign$1({
        x: 0,
        y: 0
      }, attrs);
      var hit = create$1('rect');
      applyStyle(hit, type);
      attr(hit, attrs);
      appendHit(gfx, hit);
      return hit;
    };
    this.updateDefaultHit = function (element, gfx) {
      var hit = query('.djs-hit', gfx);
      if (!hit) {
        return;
      }
      if (element.waypoints) {
        updateLine(hit, element.waypoints);
      } else {
        attr(hit, {
          width: element.width,
          height: element.height
        });
      }
      return hit;
    };
    this.fire = fire;
    this.triggerMouseEvent = triggerMouseEvent;
    this.mouseHandler = mouseHandler;
    this.registerEvent = registerEvent;
    this.unregisterEvent = unregisterEvent;
  }
  InteractionEvents.$inject = ['eventBus', 'elementRegistry', 'styles'];
  var InteractionEventsModule$1 = {
    __init__: ['interactionEvents'],
    interactionEvents: ['type', InteractionEvents]
  };
  function Selection(eventBus, canvas) {
    this._eventBus = eventBus;
    this._canvas = canvas;
    this._selectedElements = [];
    var self = this;
    eventBus.on(['shape.remove', 'connection.remove'], function (e) {
      var element = e.element;
      self.deselect(element);
    });
    eventBus.on(['diagram.clear', 'root.set'], function (e) {
      self.select(null);
    });
  }
  Selection.$inject = ['eventBus', 'canvas'];
  Selection.prototype.deselect = function (element) {
    var selectedElements = this._selectedElements;
    var idx = selectedElements.indexOf(element);
    if (idx !== -1) {
      var oldSelection = selectedElements.slice();
      selectedElements.splice(idx, 1);
      this._eventBus.fire('selection.changed', {
        oldSelection: oldSelection,
        newSelection: selectedElements
      });
    }
  };
  Selection.prototype.get = function () {
    return this._selectedElements;
  };
  Selection.prototype.isSelected = function (element) {
    return this._selectedElements.indexOf(element) !== -1;
  };
  Selection.prototype.select = function (elements, add) {
    var selectedElements = this._selectedElements,
      oldSelection = selectedElements.slice();
    if (!isArray$3(elements)) {
      elements = elements ? [elements] : [];
    }
    var canvas = this._canvas;
    var rootElement = canvas.getRootElement();
    elements = elements.filter(function (element) {
      var elementRoot = canvas.findRoot(element);
      return rootElement === elementRoot;
    });
    if (add) {
      forEach$1(elements, function (element) {
        if (selectedElements.indexOf(element) !== -1) {
          return;
        } else {
          selectedElements.push(element);
        }
      });
    } else {
      this._selectedElements = selectedElements = elements.slice();
    }
    this._eventBus.fire('selection.changed', {
      oldSelection: oldSelection,
      newSelection: selectedElements
    });
  };
  var MARKER_HOVER = 'hover',
    MARKER_SELECTED = 'selected';
  function SelectionVisuals(canvas, eventBus) {
    this._canvas = canvas;
    function addMarker(e, cls) {
      canvas.addMarker(e, cls);
    }
    function removeMarker(e, cls) {
      canvas.removeMarker(e, cls);
    }
    eventBus.on('element.hover', function (event) {
      addMarker(event.element, MARKER_HOVER);
    });
    eventBus.on('element.out', function (event) {
      removeMarker(event.element, MARKER_HOVER);
    });
    eventBus.on('selection.changed', function (event) {
      function deselect(s) {
        removeMarker(s, MARKER_SELECTED);
      }
      function select(s) {
        addMarker(s, MARKER_SELECTED);
      }
      var oldSelection = event.oldSelection,
        newSelection = event.newSelection;
      forEach$1(oldSelection, function (e) {
        if (newSelection.indexOf(e) === -1) {
          deselect(e);
        }
      });
      forEach$1(newSelection, function (e) {
        if (oldSelection.indexOf(e) === -1) {
          select(e);
        }
      });
    });
  }
  SelectionVisuals.$inject = ['canvas', 'eventBus'];
  function SelectionBehavior(eventBus, selection, canvas, elementRegistry) {
    eventBus.on('create.end', 500, function (event) {
      var context = event.context,
        canExecute = context.canExecute,
        elements = context.elements,
        hints = context.hints || {},
        autoSelect = hints.autoSelect;
      if (canExecute) {
        if (autoSelect === false) {
          return;
        }
        if (isArray$3(autoSelect)) {
          selection.select(autoSelect);
        } else {
          selection.select(elements.filter(isShown));
        }
      }
    });
    eventBus.on('connect.end', 500, function (event) {
      var context = event.context,
        connection = context.connection;
      if (connection) {
        selection.select(connection);
      }
    });
    eventBus.on('shape.move.end', 500, function (event) {
      var previousSelection = event.previousSelection || [];
      var shape = elementRegistry.get(event.context.shape.id);
      var isSelected = find(previousSelection, function (selectedShape) {
        return shape.id === selectedShape.id;
      });
      if (!isSelected) {
        selection.select(shape);
      }
    });
    eventBus.on('element.click', function (event) {
      if (!isPrimaryButton(event)) {
        return;
      }
      var element = event.element;
      if (element === canvas.getRootElement()) {
        element = null;
      }
      var isSelected = selection.isSelected(element),
        isMultiSelect = selection.get().length > 1;
      var add = hasSecondaryModifier(event);
      if (isSelected && isMultiSelect) {
        if (add) {
          return selection.deselect(element);
        } else {
          return selection.select(element);
        }
      } else if (!isSelected) {
        selection.select(element, add);
      } else {
        selection.deselect(element);
      }
    });
  }
  SelectionBehavior.$inject = ['eventBus', 'selection', 'canvas', 'elementRegistry'];
  function isShown(element) {
    return !element.hidden;
  }
  var SelectionModule = {
    __init__: ['selectionVisuals', 'selectionBehavior'],
    __depends__: [InteractionEventsModule$1],
    selection: ['type', Selection],
    selectionVisuals: ['type', SelectionVisuals],
    selectionBehavior: ['type', SelectionBehavior]
  };
  function Viewer(options) {
    BaseViewer.call(this, options);
  }
  e$2(Viewer, BaseViewer);
  Viewer.prototype._modules = [CoreModule, DrilldownModdule, OverlaysModule, SelectionModule, TranslateModule];
  Viewer.prototype._moddleExtensions = {};
  var KEYS_COPY = ['c', 'C'];
  var KEYS_PASTE = ['v', 'V'];
  var KEYS_REDO = ['y', 'Y'];
  var KEYS_UNDO = ['z', 'Z'];
  function hasModifier(event) {
    return event.ctrlKey || event.metaKey || event.shiftKey || event.altKey;
  }
  function isCmd(event) {
    if (event.altKey) {
      return false;
    }
    return event.ctrlKey || event.metaKey;
  }
  function isKey(keys, event) {
    keys = isArray$3(keys) ? keys : [keys];
    return keys.indexOf(event.key) !== -1 || keys.indexOf(event.code) !== -1;
  }
  function isShift(event) {
    return event.shiftKey;
  }
  function isCopy(event) {
    return isCmd(event) && isKey(KEYS_COPY, event);
  }
  function isPaste(event) {
    return isCmd(event) && isKey(KEYS_PASTE, event);
  }
  function isUndo(event) {
    return isCmd(event) && !isShift(event) && isKey(KEYS_UNDO, event);
  }
  function isRedo(event) {
    return isCmd(event) && (isKey(KEYS_REDO, event) || isKey(KEYS_UNDO, event) && isShift(event));
  }
  var KEYDOWN_EVENT = 'keyboard.keydown',
    KEYUP_EVENT = 'keyboard.keyup';
  var DEFAULT_PRIORITY$4 = 1000;
  var compatMessage = 'Keyboard binding is now implicit; explicit binding to an element got removed. For more information, see https://github.com/bpmn-io/diagram-js/issues/661';
  function Keyboard(config, eventBus) {
    var self = this;
    this._config = config = config || {};
    this._eventBus = eventBus;
    this._keydownHandler = this._keydownHandler.bind(this);
    this._keyupHandler = this._keyupHandler.bind(this);
    eventBus.on('diagram.destroy', function () {
      self._fire('destroy');
      self.unbind();
    });
    if (config.bindTo) {
      console.error('unsupported configuration <keyboard.bindTo>', new Error(compatMessage));
    }
    var bind = config && config.bind !== false;
    eventBus.on('canvas.init', function (event) {
      self._target = event.svg;
      if (bind) {
        self.bind();
      }
      self._fire('init');
    });
  }
  Keyboard.$inject = ['config.keyboard', 'eventBus'];
  Keyboard.prototype._keydownHandler = function (event) {
    this._keyHandler(event, KEYDOWN_EVENT);
  };
  Keyboard.prototype._keyupHandler = function (event) {
    this._keyHandler(event, KEYUP_EVENT);
  };
  Keyboard.prototype._keyHandler = function (event, type) {
    var eventBusResult;
    if (this._isEventIgnored(event)) {
      return;
    }
    var context = {
      keyEvent: event
    };
    eventBusResult = this._eventBus.fire(type || KEYDOWN_EVENT, context);
    if (eventBusResult) {
      event.preventDefault();
    }
  };
  Keyboard.prototype._isEventIgnored = function (event) {
    return false;
  };
  Keyboard.prototype.bind = function (node) {
    if (node) {
      console.error('unsupported argument <node>', new Error(compatMessage));
    }
    this.unbind();
    node = this._node = this._target;
    event.bind(node, 'keydown', this._keydownHandler);
    event.bind(node, 'keyup', this._keyupHandler);
    this._fire('bind');
  };
  Keyboard.prototype.getBinding = function () {
    return this._node;
  };
  Keyboard.prototype.unbind = function () {
    var node = this._node;
    if (node) {
      this._fire('unbind');
      event.unbind(node, 'keydown', this._keydownHandler);
      event.unbind(node, 'keyup', this._keyupHandler);
    }
    this._node = null;
  };
  Keyboard.prototype._fire = function (event) {
    this._eventBus.fire('keyboard.' + event, {
      node: this._node
    });
  };
  Keyboard.prototype.addListener = function (priority, listener, type) {
    if (isFunction(priority)) {
      type = listener;
      listener = priority;
      priority = DEFAULT_PRIORITY$4;
    }
    this._eventBus.on(type || KEYDOWN_EVENT, priority, listener);
  };
  Keyboard.prototype.removeListener = function (listener, type) {
    this._eventBus.off(type || KEYDOWN_EVENT, listener);
  };
  Keyboard.prototype.hasModifier = hasModifier;
  Keyboard.prototype.isCmd = isCmd;
  Keyboard.prototype.isShift = isShift;
  Keyboard.prototype.isKey = isKey;
  var LOW_PRIORITY$n = 500;
  function KeyboardBindings(eventBus, keyboard) {
    var self = this;
    eventBus.on('editorActions.init', LOW_PRIORITY$n, function (event) {
      var editorActions = event.editorActions;
      self.registerBindings(keyboard, editorActions);
    });
  }
  KeyboardBindings.$inject = ['eventBus', 'keyboard'];
  KeyboardBindings.prototype.registerBindings = function (keyboard, editorActions) {
    function addListener(action, fn) {
      if (editorActions.isRegistered(action)) {
        keyboard.addListener(fn);
      }
    }
    addListener('undo', function (context) {
      var event = context.keyEvent;
      if (isUndo(event)) {
        editorActions.trigger('undo');
        return true;
      }
    });
    addListener('redo', function (context) {
      var event = context.keyEvent;
      if (isRedo(event)) {
        editorActions.trigger('redo');
        return true;
      }
    });
    addListener('copy', function (context) {
      var event = context.keyEvent;
      if (isCopy(event)) {
        editorActions.trigger('copy');
        return true;
      }
    });
    addListener('paste', function (context) {
      var event = context.keyEvent;
      if (isPaste(event)) {
        editorActions.trigger('paste');
        return true;
      }
    });
    addListener('stepZoom', function (context) {
      var event = context.keyEvent;
      if (isKey(['+', 'Add', '='], event) && isCmd(event)) {
        editorActions.trigger('stepZoom', {
          value: 1
        });
        return true;
      }
    });
    addListener('stepZoom', function (context) {
      var event = context.keyEvent;
      if (isKey(['-', 'Subtract'], event) && isCmd(event)) {
        editorActions.trigger('stepZoom', {
          value: -1
        });
        return true;
      }
    });
    addListener('zoom', function (context) {
      var event = context.keyEvent;
      if (isKey('0', event) && isCmd(event)) {
        editorActions.trigger('zoom', {
          value: 1
        });
        return true;
      }
    });
    addListener('removeSelection', function (context) {
      var event = context.keyEvent;
      if (isKey(['Backspace', 'Delete', 'Del'], event)) {
        editorActions.trigger('removeSelection');
        return true;
      }
    });
  };
  var KeyboardModule$1 = {
    __init__: ['keyboard', 'keyboardBindings'],
    keyboard: ['type', Keyboard],
    keyboardBindings: ['type', KeyboardBindings]
  };
  var DEFAULT_CONFIG$1 = {
    moveSpeed: 50,
    moveSpeedAccelerated: 200
  };
  function KeyboardMove(config, keyboard, canvas) {
    var self = this;
    this._config = assign$1({}, DEFAULT_CONFIG$1, config || {});
    keyboard.addListener(arrowsListener);
    function arrowsListener(context) {
      var event = context.keyEvent,
        config = self._config;
      if (!keyboard.isCmd(event)) {
        return;
      }
      if (keyboard.isKey(['ArrowLeft', 'Left', 'ArrowUp', 'Up', 'ArrowDown', 'Down', 'ArrowRight', 'Right'], event)) {
        var speed = keyboard.isShift(event) ? config.moveSpeedAccelerated : config.moveSpeed;
        var direction;
        switch (event.key) {
          case 'ArrowLeft':
          case 'Left':
            direction = 'left';
            break;
          case 'ArrowUp':
          case 'Up':
            direction = 'up';
            break;
          case 'ArrowRight':
          case 'Right':
            direction = 'right';
            break;
          case 'ArrowDown':
          case 'Down':
            direction = 'down';
            break;
        }
        self.moveCanvas({
          speed: speed,
          direction: direction
        });
        return true;
      }
    }
    this.moveCanvas = function (options) {
      var dx = 0,
        dy = 0,
        speed = options.speed;
      var actualSpeed = speed / Math.min(Math.sqrt(canvas.viewbox().scale), 1);
      switch (options.direction) {
        case 'left':
          dx = actualSpeed;
          break;
        case 'up':
          dy = actualSpeed;
          break;
        case 'right':
          dx = -actualSpeed;
          break;
        case 'down':
          dy = -actualSpeed;
          break;
      }
      canvas.scroll({
        dx: dx,
        dy: dy
      });
    };
  }
  KeyboardMove.$inject = ['config.keyboardMove', 'keyboard', 'canvas'];
  var KeyboardMoveModule = {
    __depends__: [KeyboardModule$1],
    __init__: ['keyboardMove'],
    keyboardMove: ['type', KeyboardMove]
  };
  var CURSOR_CLS_PATTERN = /^djs-cursor-.*$/;
  function set(mode) {
    var classes = classes$1(document.body);
    classes.removeMatching(CURSOR_CLS_PATTERN);
    if (mode) {
      classes.add('djs-cursor-' + mode);
    }
  }
  function unset() {
    set(null);
  }
  var TRAP_PRIORITY = 5000;
  function install(eventBus, eventName) {
    eventName = eventName || 'element.click';
    function trap() {
      return false;
    }
    eventBus.once(eventName, TRAP_PRIORITY, trap);
    return function () {
      eventBus.off(eventName, trap);
    };
  }
  function center(bounds) {
    return {
      x: bounds.x + bounds.width / 2,
      y: bounds.y + bounds.height / 2
    };
  }
  function delta(a, b) {
    return {
      x: a.x - b.x,
      y: a.y - b.y
    };
  }
  var THRESHOLD$1 = 15;
  function MoveCanvas(eventBus, canvas) {
    var context;
    function handleMousedown(event) {
      return handleStart(event.originalEvent);
    }
    eventBus.on('canvas.focus.changed', function (event) {
      if (event.focused) {
        eventBus.on('element.mousedown', 500, handleMousedown);
      } else {
        eventBus.off('element.mousedown', handleMousedown);
      }
    });
    function handleMove(event) {
      var start = context.start,
        button = context.button,
        position = toPoint(event),
        delta$1 = delta(position, start);
      if (!context.dragging && length(delta$1) > THRESHOLD$1) {
        context.dragging = true;
        if (button === 0) {
          install(eventBus);
        }
        set('grab');
      }
      if (context.dragging) {
        var lastPosition = context.last || context.start;
        delta$1 = delta(position, lastPosition);
        canvas.scroll({
          dx: delta$1.x,
          dy: delta$1.y
        });
        context.last = position;
      }
      event.preventDefault();
    }
    function handleEnd(event$1) {
      event.unbind(document, 'mousemove', handleMove);
      event.unbind(document, 'mouseup', handleEnd);
      context = null;
      unset();
    }
    function handleStart(event$1) {
      if (closest(event$1.target, '.djs-draggable')) {
        return;
      }
      var button = event$1.button;
      if (button >= 2 || event$1.ctrlKey || event$1.shiftKey || event$1.altKey) {
        return;
      }
      context = {
        button: button,
        start: toPoint(event$1)
      };
      event.bind(document, 'mousemove', handleMove);
      event.bind(document, 'mouseup', handleEnd);
      return true;
    }
    this.isActive = function () {
      return !!context;
    };
  }
  MoveCanvas.$inject = ['eventBus', 'canvas'];
  function length(point) {
    return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));
  }
  var MoveCanvasModule = {
    __init__: ['moveCanvas'],
    moveCanvas: ['type', MoveCanvas]
  };
  function log10(x) {
    return Math.log(x) / Math.log(10);
  }
  function getStepSize(range, steps) {
    var minLinearRange = log10(range.min),
      maxLinearRange = log10(range.max);
    var absoluteLinearRange = Math.abs(minLinearRange) + Math.abs(maxLinearRange);
    return absoluteLinearRange / steps;
  }
  function cap(range, scale) {
    return Math.max(range.min, Math.min(range.max, scale));
  }
  var sign = Math.sign || function (n) {
    return n >= 0 ? 1 : -1;
  };
  var RANGE = {
      min: 0.2,
      max: 4
    },
    NUM_STEPS = 10;
  var DELTA_THRESHOLD = 0.1;
  var DEFAULT_SCALE = 0.75;
  function ZoomScroll(config, eventBus, canvas) {
    config = config || {};
    this._enabled = false;
    this._canvas = canvas;
    this._container = canvas._container;
    this._handleWheel = bind$2(this._handleWheel, this);
    this._totalDelta = 0;
    this._scale = config.scale || DEFAULT_SCALE;
    var self = this;
    eventBus.on('canvas.focus.changed', function (event) {
      self._init(event.focused && config.enabled !== false);
    });
  }
  ZoomScroll.$inject = ['config.zoomScroll', 'eventBus', 'canvas'];
  ZoomScroll.prototype.scroll = function scroll(delta) {
    this._canvas.scroll(delta);
  };
  ZoomScroll.prototype.reset = function reset() {
    this._canvas.zoom('fit-viewport');
  };
  ZoomScroll.prototype.zoom = function zoom(delta, position) {
    var stepSize = getStepSize(RANGE, NUM_STEPS * 2);
    this._totalDelta += delta;
    if (Math.abs(this._totalDelta) > DELTA_THRESHOLD) {
      this._zoom(delta, position, stepSize);
      this._totalDelta = 0;
    }
  };
  ZoomScroll.prototype._handleWheel = function handleWheel(event) {
    if (!this._canvas.isFocused()) {
      return;
    }
    var element = this._container;
    event.preventDefault();
    var isZoom = event.ctrlKey || isMac() && event.metaKey;
    var isHorizontalScroll = event.shiftKey;
    var factor = -1 * this._scale,
      delta;
    if (isZoom) {
      factor *= event.deltaMode === 0 ? 0.020 : 0.32;
    } else {
      factor *= event.deltaMode === 0 ? 1.0 : 16.0;
    }
    if (isZoom) {
      var elementRect = element.getBoundingClientRect();
      var offset = {
        x: event.clientX - elementRect.left,
        y: event.clientY - elementRect.top
      };
      delta = Math.sqrt(Math.pow(event.deltaY, 2) + Math.pow(event.deltaX, 2)) * sign(event.deltaY) * factor;
      this.zoom(delta, offset);
    } else {
      if (isHorizontalScroll) {
        delta = {
          dx: factor * event.deltaY,
          dy: 0
        };
      } else {
        delta = {
          dx: factor * event.deltaX,
          dy: factor * event.deltaY
        };
      }
      this.scroll(delta);
    }
  };
  ZoomScroll.prototype.stepZoom = function stepZoom(delta, position) {
    var stepSize = getStepSize(RANGE, NUM_STEPS);
    this._zoom(delta, position, stepSize);
  };
  ZoomScroll.prototype._zoom = function (delta, position, stepSize) {
    var canvas = this._canvas;
    var direction = delta > 0 ? 1 : -1;
    var currentLinearZoomLevel = log10(canvas.zoom());
    var newLinearZoomLevel = Math.round(currentLinearZoomLevel / stepSize) * stepSize;
    newLinearZoomLevel += stepSize * direction;
    var newLogZoomLevel = Math.pow(10, newLinearZoomLevel);
    canvas.zoom(cap(RANGE, newLogZoomLevel), position);
  };
  ZoomScroll.prototype.toggle = function toggle(newEnabled) {
    var element = this._container;
    var handleWheel = this._handleWheel;
    var oldEnabled = this._enabled;
    if (typeof newEnabled === 'undefined') {
      newEnabled = !oldEnabled;
    }
    if (oldEnabled !== newEnabled) {
      event[newEnabled ? 'bind' : 'unbind'](element, 'wheel', handleWheel, false);
    }
    this._enabled = newEnabled;
    return newEnabled;
  };
  ZoomScroll.prototype._init = function (newEnabled) {
    this.toggle(newEnabled);
  };
  var ZoomScrollModule = {
    __init__: ['zoomScroll'],
    zoomScroll: ['type', ZoomScroll]
  };
  function NavigatedViewer(options) {
    Viewer.call(this, options);
  }
  e$2(NavigatedViewer, Viewer);
  NavigatedViewer.prototype._navigationModules = [KeyboardMoveModule, MoveCanvasModule, ZoomScrollModule];
  NavigatedViewer.prototype._modules = [].concat(Viewer.prototype._modules, NavigatedViewer.prototype._navigationModules);
  function last(arr) {
    return arr && arr[arr.length - 1];
  }
  function sortTopOrMiddle(element) {
    return element.y;
  }
  function sortLeftOrCenter(element) {
    return element.x;
  }
  var ALIGNMENT_SORTING = {
    left: sortLeftOrCenter,
    center: sortLeftOrCenter,
    right: function right(element) {
      return element.x + element.width;
    },
    top: sortTopOrMiddle,
    middle: sortTopOrMiddle,
    bottom: function bottom(element) {
      return element.y + element.height;
    }
  };
  function AlignElements$1(modeling, rules) {
    this._modeling = modeling;
    this._rules = rules;
  }
  AlignElements$1.$inject = ['modeling', 'rules'];
  AlignElements$1.prototype._getOrientationDetails = function (type) {
    var vertical = ['top', 'bottom', 'middle'],
      axis = 'x',
      dimension = 'width';
    if (vertical.indexOf(type) !== -1) {
      axis = 'y';
      dimension = 'height';
    }
    return {
      axis: axis,
      dimension: dimension
    };
  };
  AlignElements$1.prototype._isType = function (type, types) {
    return types.indexOf(type) !== -1;
  };
  AlignElements$1.prototype._alignmentPosition = function (type, sortedElements) {
    var orientation = this._getOrientationDetails(type),
      axis = orientation.axis,
      dimension = orientation.dimension,
      alignment = {},
      centers = {},
      hasSharedCenters = false,
      centeredElements,
      firstElement,
      lastElement;
    function getMiddleOrTop(first, last) {
      return Math.round((first[axis] + last[axis] + last[dimension]) / 2);
    }
    if (this._isType(type, ['left', 'top'])) {
      alignment[type] = sortedElements[0][axis];
    } else if (this._isType(type, ['right', 'bottom'])) {
      lastElement = last(sortedElements);
      alignment[type] = lastElement[axis] + lastElement[dimension];
    } else if (this._isType(type, ['center', 'middle'])) {
      forEach$1(sortedElements, function (element) {
        var center = element[axis] + Math.round(element[dimension] / 2);
        if (centers[center]) {
          centers[center].elements.push(element);
        } else {
          centers[center] = {
            elements: [element],
            center: center
          };
        }
      });
      centeredElements = sortBy(centers, function (center) {
        if (center.elements.length > 1) {
          hasSharedCenters = true;
        }
        return center.elements.length;
      });
      if (hasSharedCenters) {
        alignment[type] = last(centeredElements).center;
        return alignment;
      }
      firstElement = sortedElements[0];
      sortedElements = sortBy(sortedElements, function (element) {
        return element[axis] + element[dimension];
      });
      lastElement = last(sortedElements);
      alignment[type] = getMiddleOrTop(firstElement, lastElement);
    }
    return alignment;
  };
  AlignElements$1.prototype.trigger = function (elements, type) {
    var modeling = this._modeling,
      allowed;
    var filteredElements = filter(elements, function (element) {
      return !(element.waypoints || element.host || element.labelTarget);
    });
    allowed = this._rules.allowed('elements.align', {
      elements: filteredElements
    });
    if (isArray$3(allowed)) {
      filteredElements = allowed;
    }
    if (filteredElements.length < 2 || !allowed) {
      return;
    }
    var sortFn = ALIGNMENT_SORTING[type];
    var sortedElements = sortBy(filteredElements, sortFn);
    var alignment = this._alignmentPosition(type, sortedElements);
    modeling.alignElements(sortedElements, alignment);
  };
  var AlignElementsModule$1 = {
    __init__: ['alignElements'],
    alignElements: ['type', AlignElements$1]
  };
  var Ids = new IdGenerator();
  function Scheduler(eventBus) {
    var _this7 = this;
    this._scheduled = {};
    eventBus.on('diagram.destroy', function () {
      Object.keys(_this7._scheduled).forEach(function (id) {
        _this7.cancel(id);
      });
    });
  }
  Scheduler.$inject = ['eventBus'];
  Scheduler.prototype.schedule = function (taskFn) {
    var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Ids.next();
    this.cancel(id);
    var newScheduled = this._schedule(taskFn, id);
    this._scheduled[id] = newScheduled;
    return newScheduled.promise;
  };
  Scheduler.prototype._schedule = function (taskFn, id) {
    var _this8 = this;
    var deferred = defer();
    var executionId = setTimeout(function () {
      try {
        _this8._scheduled[id] = null;
        try {
          deferred.resolve(taskFn());
        } catch (error) {
          deferred.reject(error);
        }
      } catch (error) {
        console.error('Scheduler#_schedule execution failed', error);
      }
    });
    return {
      executionId,
      promise: deferred.promise
    };
  };
  Scheduler.prototype.cancel = function (id) {
    var scheduled = this._scheduled[id];
    if (scheduled) {
      this._cancel(scheduled);
      this._scheduled[id] = null;
    }
  };
  Scheduler.prototype._cancel = function (scheduled) {
    clearTimeout(scheduled.executionId);
  };
  function defer() {
    var deferred = {};
    deferred.promise = new Promise(function (resolve, reject) {
      deferred.resolve = resolve;
      deferred.reject = reject;
    });
    return deferred;
  }
  var SchedulerModule = {
    scheduler: ['type', Scheduler]
  };
  var MARKER_HIDDEN$1 = 'djs-element-hidden';
  var entrySelector = '.entry';
  var DEFAULT_PRIORITY$3 = 1000;
  var CONTEXT_PAD_MARGIN = 8;
  var HOVER_DELAY = 300;
  function ContextPad(canvas, elementRegistry, eventBus, scheduler) {
    this._canvas = canvas;
    this._elementRegistry = elementRegistry;
    this._eventBus = eventBus;
    this._scheduler = scheduler;
    this._current = null;
    this._init();
  }
  ContextPad.$inject = ['canvas', 'elementRegistry', 'eventBus', 'scheduler'];
  ContextPad.prototype._init = function () {
    var self = this;
    this._eventBus.on('selection.changed', function (event) {
      var selection = event.newSelection;
      var target = selection.length ? selection.length === 1 ? selection[0] : selection : null;
      if (target) {
        self.open(target, true);
      } else {
        self.close();
      }
    });
    this._eventBus.on('elements.changed', function (event) {
      var elements = event.elements,
        current = self._current;
      if (!current) {
        return;
      }
      var target = current.target;
      var targets = isArray$3(target) ? target : [target];
      var targetsChanged = targets.filter(function (element) {
        return elements.includes(element);
      });
      if (targetsChanged.length) {
        self.close();
        var targetsNew = targets.filter(function (element) {
          return self._elementRegistry.get(element.id);
        });
        if (targetsNew.length) {
          self._updateAndOpen(targetsNew.length > 1 ? targetsNew : targetsNew[0]);
        }
      }
    });
    this._eventBus.on('canvas.viewbox.changed', function () {
      self._updatePosition();
    });
    this._eventBus.on('element.marker.update', function (event) {
      if (!self.isOpen()) {
        return;
      }
      var element = event.element;
      var current = self._current;
      var targets = isArray$3(current.target) ? current.target : [current.target];
      if (!targets.includes(element)) {
        return;
      }
      self._updateVisibility();
    });
    this._container = this._createContainer();
  };
  ContextPad.prototype._createContainer = function () {
    var container = domify$1('<div class="djs-context-pad-parent"></div>');
    this._canvas.getContainer().appendChild(container);
    return container;
  };
  ContextPad.prototype.registerProvider = function (priority, provider) {
    if (!provider) {
      provider = priority;
      priority = DEFAULT_PRIORITY$3;
    }
    this._eventBus.on('contextPad.getProviders', priority, function (event) {
      event.providers.push(provider);
    });
  };
  ContextPad.prototype.getEntries = function (target) {
    var providers = this._getProviders();
    var provideFn = isArray$3(target) ? 'getMultiElementContextPadEntries' : 'getContextPadEntries';
    var entries = {};
    forEach$1(providers, function (provider) {
      if (!isFunction(provider[provideFn])) {
        return;
      }
      var entriesOrUpdater = provider[provideFn](target);
      if (isFunction(entriesOrUpdater)) {
        entries = entriesOrUpdater(entries);
      } else {
        forEach$1(entriesOrUpdater, function (entry, id) {
          entries[id] = entry;
        });
      }
    });
    return entries;
  };
  ContextPad.prototype.trigger = function (action, event, autoActivate) {
    var self = this;
    var entry,
      originalEvent,
      button = event.delegateTarget || event.target;
    if (!button) {
      return event.preventDefault();
    }
    entry = attr$1(button, 'data-action');
    originalEvent = event.originalEvent || event;
    if (action === 'mouseover') {
      this._timeout = setTimeout(function () {
        self._mouseout = self.triggerEntry(entry, 'hover', originalEvent, autoActivate);
      }, HOVER_DELAY);
      return;
    } else if (action === 'mouseout') {
      clearTimeout(this._timeout);
      if (this._mouseout) {
        this._mouseout();
        this._mouseout = null;
      }
      return;
    }
    return this.triggerEntry(entry, action, originalEvent, autoActivate);
  };
  ContextPad.prototype.triggerEntry = function (entryId, action, event, autoActivate) {
    if (!this.isShown()) {
      return;
    }
    var target = this._current.target,
      entries = this._current.entries;
    var entry = entries[entryId];
    if (!entry) {
      return;
    }
    var handler = entry.action;
    if (this._eventBus.fire('contextPad.trigger', {
      entry,
      event
    }) === false) {
      return;
    }
    if (isFunction(handler)) {
      if (action === 'click') {
        return handler(event, target, autoActivate);
      }
    } else {
      if (handler[action]) {
        return handler[action](event, target, autoActivate);
      }
    }
    event.preventDefault();
  };
  ContextPad.prototype.open = function (target, force) {
    if (!force && this.isOpen(target)) {
      return;
    }
    this.close();
    this._updateAndOpen(target);
  };
  ContextPad.prototype._getProviders = function () {
    var event = this._eventBus.createEvent({
      type: 'contextPad.getProviders',
      providers: []
    });
    this._eventBus.fire(event);
    return event.providers;
  };
  ContextPad.prototype._updateAndOpen = function (target) {
    var entries = this.getEntries(target),
      html = this._createHtml(target),
      image;
    forEach$1(entries, function (entry, id) {
      var grouping = entry.group || 'default',
        control = domify$1(entry.html || '<div class="entry" draggable="true"></div>'),
        container;
      attr$1(control, 'data-action', id);
      container = query('[data-group=' + escapeCSS(grouping) + ']', html);
      if (!container) {
        container = domify$1('<div class="group"></div>');
        attr$1(container, 'data-group', grouping);
        html.appendChild(container);
      }
      container.appendChild(control);
      if (entry.className) {
        addClasses$1(control, entry.className);
      }
      if (entry.title) {
        attr$1(control, 'title', entry.title);
      }
      if (entry.imageUrl) {
        image = domify$1('<img>');
        attr$1(image, 'src', entry.imageUrl);
        image.style.width = '100%';
        image.style.height = '100%';
        control.appendChild(image);
      }
    });
    classes$1(html).add('open');
    this._current = {
      entries,
      html,
      target
    };
    this._updatePosition();
    this._updateVisibility();
    this._eventBus.fire('contextPad.open', {
      current: this._current
    });
  };
  ContextPad.prototype._createHtml = function (target) {
    var self = this;
    var html = domify$1('<div class="djs-context-pad"></div>');
    delegate.bind(html, entrySelector, 'click', function (event) {
      self.trigger('click', event);
    });
    delegate.bind(html, entrySelector, 'dragstart', function (event) {
      self.trigger('dragstart', event);
    });
    delegate.bind(html, entrySelector, 'mouseover', function (event) {
      self.trigger('mouseover', event);
    });
    delegate.bind(html, entrySelector, 'mouseout', function (event) {
      self.trigger('mouseout', event);
    });
    event.bind(html, 'mousedown', function (event) {
      event.stopPropagation();
    });
    this._container.appendChild(html);
    this._eventBus.fire('contextPad.create', {
      target: target,
      pad: html
    });
    return html;
  };
  ContextPad.prototype.getPad = function (target) {
    console.warn(new Error('ContextPad#getPad is deprecated and will be removed in future library versions, cf. https://github.com/bpmn-io/diagram-js/pull/888'));
    var html;
    if (this.isOpen() && targetsEqual(this._current.target, target)) {
      html = this._current.html;
    } else {
      html = this._createHtml(target);
    }
    return {
      html
    };
  };
  ContextPad.prototype.close = function () {
    if (!this.isOpen()) {
      return;
    }
    clearTimeout(this._timeout);
    this._container.innerHTML = '';
    this._eventBus.fire('contextPad.close', {
      current: this._current
    });
    this._current = null;
  };
  ContextPad.prototype.isOpen = function (target) {
    var current = this._current;
    if (!current) {
      return false;
    }
    if (!target) {
      return true;
    }
    var currentTarget = current.target;
    if (isArray$3(target) !== isArray$3(currentTarget)) {
      return false;
    }
    if (isArray$3(target)) {
      return target.length === currentTarget.length && every(target, function (element) {
        return currentTarget.includes(element);
      });
    } else {
      return currentTarget === target;
    }
  };
  ContextPad.prototype.isShown = function () {
    return this.isOpen() && classes$1(this._current.html).has('open');
  };
  ContextPad.prototype.show = function () {
    if (!this.isOpen()) {
      return;
    }
    classes$1(this._current.html).add('open');
    this._updatePosition();
    this._eventBus.fire('contextPad.show', {
      current: this._current
    });
  };
  ContextPad.prototype.hide = function () {
    if (!this.isOpen()) {
      return;
    }
    classes$1(this._current.html).remove('open');
    this._eventBus.fire('contextPad.hide', {
      current: this._current
    });
  };
  ContextPad.prototype._getPosition = function (target) {
    if (!isArray$3(target) && isConnection(target)) {
      var viewbox = this._canvas.viewbox();
      var lastWaypoint = getLastWaypoint(target);
      var x = lastWaypoint.x * viewbox.scale - viewbox.x * viewbox.scale,
        y = lastWaypoint.y * viewbox.scale - viewbox.y * viewbox.scale;
      return {
        left: x + CONTEXT_PAD_MARGIN * this._canvas.zoom(),
        top: y
      };
    }
    var container = this._canvas.getContainer();
    var containerBounds = container.getBoundingClientRect();
    var targetBounds = this._getTargetBounds(target);
    return {
      left: targetBounds.right - containerBounds.left + CONTEXT_PAD_MARGIN * this._canvas.zoom(),
      top: targetBounds.top - containerBounds.top
    };
  };
  ContextPad.prototype._updatePosition = function () {
    var _this9 = this;
    var updateFn = function updateFn() {
      if (!_this9.isOpen()) {
        return;
      }
      var html = _this9._current.html;
      var position = _this9._getPosition(_this9._current.target);
      if ('x' in position && 'y' in position) {
        html.style.left = position.x + 'px';
        html.style.top = position.y + 'px';
      } else {
        ['top', 'right', 'bottom', 'left'].forEach(function (key) {
          if (key in position) {
            html.style[key] = position[key] + 'px';
          }
        });
      }
    };
    this._scheduler.schedule(updateFn, 'ContextPad#_updatePosition');
  };
  ContextPad.prototype._updateVisibility = function () {
    var _this0 = this;
    var updateFn = function updateFn() {
      if (!_this0.isOpen()) {
        return;
      }
      var self = _this0;
      var target = _this0._current.target;
      var targets = isArray$3(target) ? target : [target];
      var isHidden = targets.some(function (target) {
        return self._canvas.hasMarker(target, MARKER_HIDDEN$1);
      });
      if (isHidden) {
        self.hide();
      } else {
        self.show();
      }
    };
    this._scheduler.schedule(updateFn, 'ContextPad#_updateVisibility');
  };
  ContextPad.prototype._getTargetBounds = function (target) {
    var self = this;
    var elements = isArray$3(target) ? target : [target];
    var elementsGfx = elements.map(function (element) {
      return self._canvas.getGraphics(element);
    });
    return elementsGfx.reduce(function (bounds, elementGfx) {
      var elementBounds = elementGfx.getBoundingClientRect();
      bounds.top = Math.min(bounds.top, elementBounds.top);
      bounds.right = Math.max(bounds.right, elementBounds.right);
      bounds.bottom = Math.max(bounds.bottom, elementBounds.bottom);
      bounds.left = Math.min(bounds.left, elementBounds.left);
      bounds.x = bounds.left;
      bounds.y = bounds.top;
      bounds.width = bounds.right - bounds.left;
      bounds.height = bounds.bottom - bounds.top;
      return bounds;
    }, {
      top: Infinity,
      right: -Infinity,
      bottom: -Infinity,
      left: Infinity
    });
  };
  function addClasses$1(element, classNames) {
    var classes = classes$1(element);
    classNames = isArray$3(classNames) ? classNames : classNames.split(/\s+/g);
    classNames.forEach(function (cls) {
      classes.add(cls);
    });
  }
  function getLastWaypoint(connection) {
    return connection.waypoints[connection.waypoints.length - 1];
  }
  function targetsEqual(target, otherTarget) {
    target = isArray$3(target) ? target : [target];
    otherTarget = isArray$3(otherTarget) ? otherTarget : [otherTarget];
    return target.length === otherTarget.length && every(target, function (element) {
      return otherTarget.includes(element);
    });
  }
  var ContextPadModule$1 = {
    __depends__: [InteractionEventsModule$1, SchedulerModule, OverlaysModule],
    contextPad: ['type', ContextPad]
  };
  var n$1,
    l$1,
    u$1,
    i$1,
    o$1,
    r$2,
    f$1,
    c$1 = {},
    s$1 = [],
    a$1 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i,
    h$1 = Array.isArray;
  function v$1(n, l) {
    for (var u in l) n[u] = l[u];
    return n;
  }
  function p$1(n) {
    var l = n.parentNode;
    l && l.removeChild(n);
  }
  function y$1(l, u, t) {
    var i,
      o,
      r,
      f = {};
    for (r in u) "key" == r ? i = u[r] : "ref" == r ? o = u[r] : f[r] = u[r];
    if (arguments.length > 2 && (f.children = arguments.length > 3 ? n$1.call(arguments, 2) : t), "function" == typeof l && null != l.defaultProps) for (r in l.defaultProps) void 0 === f[r] && (f[r] = l.defaultProps[r]);
    return d$1(l, f, i, o, null);
  }
  function d$1(n, t, i, o, r) {
    var f = {
      type: n,
      props: t,
      key: i,
      ref: o,
      __k: null,
      __: null,
      __b: 0,
      __e: null,
      __d: void 0,
      __c: null,
      constructor: void 0,
      __v: null == r ? ++u$1 : r,
      __i: -1,
      __u: 0
    };
    return null == r && null != l$1.vnode && l$1.vnode(f), f;
  }
  function g(n) {
    return n.children;
  }
  function b(n, l) {
    this.props = n, this.context = l;
  }
  function m$2(n, l) {
    if (null == l) return n.__ ? m$2(n.__, n.__i + 1) : null;
    for (var u; l < n.__k.length; l++) if (null != (u = n.__k[l]) && null != u.__e) return u.__e;
    return "function" == typeof n.type ? m$2(n) : null;
  }
  function w$1(n) {
    var l, u;
    if (null != (n = n.__) && null != n.__c) {
      for (n.__e = n.__c.base = null, l = 0; l < n.__k.length; l++) if (null != (u = n.__k[l]) && null != u.__e) {
        n.__e = n.__c.base = u.__e;
        break;
      }
      return w$1(n);
    }
  }
  function k$1(n) {
    (!n.__d && (n.__d = true) && i$1.push(n) && !x$1.__r++ || o$1 !== l$1.debounceRendering) && ((o$1 = l$1.debounceRendering) || r$2)(x$1);
  }
  function x$1() {
    var n, u, t, o, r, e, c, s, a;
    for (i$1.sort(f$1); n = i$1.shift();) n.__d && (u = i$1.length, o = void 0, e = (r = (t = n).__v).__e, s = [], a = [], (c = t.__P) && ((o = v$1({}, r)).__v = r.__v + 1, l$1.vnode && l$1.vnode(o), L(c, o, r, t.__n, void 0 !== c.ownerSVGElement, 32 & r.__u ? [e] : null, s, null == e ? m$2(r) : e, !!(32 & r.__u), a), o.__v = r.__v, o.__.__k[o.__i] = o, M(s, o, a), o.__e != e && w$1(o)), i$1.length > u && i$1.sort(f$1));
    x$1.__r = 0;
  }
  function C$1(n, l, u, t, i, o, r, f, e, a, h) {
    var v,
      p,
      y,
      d,
      _,
      g = t && t.__k || s$1,
      b = l.length;
    for (u.__d = e, P(u, l, g), e = u.__d, v = 0; v < b; v++) null != (y = u.__k[v]) && "boolean" != typeof y && "function" != typeof y && (p = -1 === y.__i ? c$1 : g[y.__i] || c$1, y.__i = v, L(n, y, p, i, o, r, f, e, a, h), d = y.__e, y.ref && p.ref != y.ref && (p.ref && z$1(p.ref, null, y), h.push(y.ref, y.__c || d, y)), null == _ && null != d && (_ = d), 65536 & y.__u || p.__k === y.__k ? e = S(y, e, n) : "function" == typeof y.type && void 0 !== y.__d ? e = y.__d : d && (e = d.nextSibling), y.__d = void 0, y.__u &= -196609);
    u.__d = e, u.__e = _;
  }
  function P(n, l, u) {
    var t,
      i,
      o,
      r,
      f,
      e = l.length,
      c = u.length,
      s = c,
      a = 0;
    for (n.__k = [], t = 0; t < e; t++) r = t + a, null != (i = n.__k[t] = null == (i = l[t]) || "boolean" == typeof i || "function" == typeof i ? null : "string" == typeof i || "number" == typeof i || "bigint" == typeof i || i.constructor == String ? d$1(null, i, null, null, null) : h$1(i) ? d$1(g, {
      children: i
    }, null, null, null) : void 0 === i.constructor && i.__b > 0 ? d$1(i.type, i.props, i.key, i.ref ? i.ref : null, i.__v) : i) ? (i.__ = n, i.__b = n.__b + 1, f = H(i, u, r, s), i.__i = f, o = null, -1 !== f && (s--, (o = u[f]) && (o.__u |= 131072)), null == o || null === o.__v ? (-1 == f && a--, "function" != typeof i.type && (i.__u |= 65536)) : f !== r && (f === r + 1 ? a++ : f > r ? s > e - r ? a += f - r : a-- : f < r ? f == r - 1 && (a = f - r) : a = 0, f !== t + a && (i.__u |= 65536))) : (o = u[r]) && null == o.key && o.__e && 0 == (131072 & o.__u) && (o.__e == n.__d && (n.__d = m$2(o)), N(o, o, false), u[r] = null, s--);
    if (s) for (t = 0; t < c; t++) null != (o = u[t]) && 0 == (131072 & o.__u) && (o.__e == n.__d && (n.__d = m$2(o)), N(o, o));
  }
  function S(n, l, u) {
    var t, i;
    if ("function" == typeof n.type) {
      for (t = n.__k, i = 0; t && i < t.length; i++) t[i] && (t[i].__ = n, l = S(t[i], l, u));
      return l;
    }
    n.__e != l && (u.insertBefore(n.__e, l || null), l = n.__e);
    do {
      l = l && l.nextSibling;
    } while (null != l && 8 === l.nodeType);
    return l;
  }
  function H(n, l, u, t) {
    var i = n.key,
      o = n.type,
      r = u - 1,
      f = u + 1,
      e = l[u];
    if (null === e || e && i == e.key && o === e.type && 0 == (131072 & e.__u)) return u;
    if (t > (null != e && 0 == (131072 & e.__u) ? 1 : 0)) for (; r >= 0 || f < l.length;) {
      if (r >= 0) {
        if ((e = l[r]) && 0 == (131072 & e.__u) && i == e.key && o === e.type) return r;
        r--;
      }
      if (f < l.length) {
        if ((e = l[f]) && 0 == (131072 & e.__u) && i == e.key && o === e.type) return f;
        f++;
      }
    }
    return -1;
  }
  function I(n, l, u) {
    "-" === l[0] ? n.setProperty(l, null == u ? "" : u) : n[l] = null == u ? "" : "number" != typeof u || a$1.test(l) ? u : u + "px";
  }
  function T(n, l, u, t, i) {
    var o;
    n: if ("style" === l) {
      if ("string" == typeof u) n.style.cssText = u;else {
        if ("string" == typeof t && (n.style.cssText = t = ""), t) for (l in t) u && l in u || I(n.style, l, "");
        if (u) for (l in u) t && u[l] === t[l] || I(n.style, l, u[l]);
      }
    } else if ("o" === l[0] && "n" === l[1]) o = l !== (l = l.replace(/(PointerCapture)$|Capture$/i, "$1")), l = l.toLowerCase() in n ? l.toLowerCase().slice(2) : l.slice(2), n.l || (n.l = {}), n.l[l + o] = u, u ? t ? u.u = t.u : (u.u = Date.now(), n.addEventListener(l, o ? D$1 : A$1, o)) : n.removeEventListener(l, o ? D$1 : A$1, o);else {
      if (i) l = l.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");else if ("width" !== l && "height" !== l && "href" !== l && "list" !== l && "form" !== l && "tabIndex" !== l && "download" !== l && "rowSpan" !== l && "colSpan" !== l && "role" !== l && l in n) try {
        n[l] = null == u ? "" : u;
        break n;
      } catch (n) {}
      "function" == typeof u || (null == u || false === u && "-" !== l[4] ? n.removeAttribute(l) : n.setAttribute(l, u));
    }
  }
  function A$1(n) {
    if (this.l) {
      var u = this.l[n.type + false];
      if (n.t) {
        if (n.t <= u.u) return;
      } else n.t = Date.now();
      return u(l$1.event ? l$1.event(n) : n);
    }
  }
  function D$1(n) {
    if (this.l) return this.l[n.type + true](l$1.event ? l$1.event(n) : n);
  }
  function L(n, u, t, i, o, r, f, e, c, s) {
    var a,
      p,
      y,
      d,
      _,
      m,
      w,
      k,
      x,
      P,
      S,
      $,
      H,
      I,
      T,
      A = u.type;
    if (void 0 !== u.constructor) return null;
    128 & t.__u && (c = !!(32 & t.__u), r = [e = u.__e = t.__e]), (a = l$1.__b) && a(u);
    n: if ("function" == typeof A) try {
      if (k = u.props, x = (a = A.contextType) && i[a.__c], P = a ? x ? x.props.value : a.__ : i, t.__c ? w = (p = u.__c = t.__c).__ = p.__E : ("prototype" in A && A.prototype.render ? u.__c = p = new A(k, P) : (u.__c = p = new b(k, P), p.constructor = A, p.render = O), x && x.sub(p), p.props = k, p.state || (p.state = {}), p.context = P, p.__n = i, y = p.__d = !0, p.__h = [], p._sb = []), null == p.__s && (p.__s = p.state), null != A.getDerivedStateFromProps && (p.__s == p.state && (p.__s = v$1({}, p.__s)), v$1(p.__s, A.getDerivedStateFromProps(k, p.__s))), d = p.props, _ = p.state, p.__v = u, y) null == A.getDerivedStateFromProps && null != p.componentWillMount && p.componentWillMount(), null != p.componentDidMount && p.__h.push(p.componentDidMount);else {
        if (null == A.getDerivedStateFromProps && k !== d && null != p.componentWillReceiveProps && p.componentWillReceiveProps(k, P), !p.__e && (null != p.shouldComponentUpdate && !1 === p.shouldComponentUpdate(k, p.__s, P) || u.__v === t.__v)) {
          for (u.__v !== t.__v && (p.props = k, p.state = p.__s, p.__d = !1), u.__e = t.__e, u.__k = t.__k, u.__k.forEach(function (n) {
            n && (n.__ = u);
          }), S = 0; S < p._sb.length; S++) p.__h.push(p._sb[S]);
          p._sb = [], p.__h.length && f.push(p);
          break n;
        }
        null != p.componentWillUpdate && p.componentWillUpdate(k, p.__s, P), null != p.componentDidUpdate && p.__h.push(function () {
          p.componentDidUpdate(d, _, m);
        });
      }
      if (p.context = P, p.props = k, p.__P = n, p.__e = !1, $ = l$1.__r, H = 0, "prototype" in A && A.prototype.render) {
        for (p.state = p.__s, p.__d = !1, $ && $(u), a = p.render(p.props, p.state, p.context), I = 0; I < p._sb.length; I++) p.__h.push(p._sb[I]);
        p._sb = [];
      } else do {
        p.__d = !1, $ && $(u), a = p.render(p.props, p.state, p.context), p.state = p.__s;
      } while (p.__d && ++H < 25);
      p.state = p.__s, null != p.getChildContext && (i = v$1(v$1({}, i), p.getChildContext())), y || null == p.getSnapshotBeforeUpdate || (m = p.getSnapshotBeforeUpdate(d, _)), C$1(n, h$1(T = null != a && a.type === g && null == a.key ? a.props.children : a) ? T : [T], u, t, i, o, r, f, e, c, s), p.base = u.__e, u.__u &= -161, p.__h.length && f.push(p), w && (p.__E = p.__ = null);
    } catch (n) {
      u.__v = null, c || null != r ? (u.__e = e, u.__u |= c ? 160 : 32, r[r.indexOf(e)] = null) : (u.__e = t.__e, u.__k = t.__k), l$1.__e(n, u, t);
    } else null == r && u.__v === t.__v ? (u.__k = t.__k, u.__e = t.__e) : u.__e = j$1(t.__e, u, t, i, o, r, f, c, s);
    (a = l$1.diffed) && a(u);
  }
  function M(n, u, t) {
    u.__d = void 0;
    for (var i = 0; i < t.length; i++) z$1(t[i], t[++i], t[++i]);
    l$1.__c && l$1.__c(u, n), n.some(function (u) {
      try {
        n = u.__h, u.__h = [], n.some(function (n) {
          n.call(u);
        });
      } catch (n) {
        l$1.__e(n, u.__v);
      }
    });
  }
  function j$1(l, u, t, i, o, r, f, e, s) {
    var a,
      v,
      y,
      d,
      _,
      g,
      b,
      w = t.props,
      k = u.props,
      x = u.type;
    if ("svg" === x && (o = true), null != r) for (a = 0; a < r.length; a++) if ((_ = r[a]) && "setAttribute" in _ == !!x && (x ? _.localName === x : 3 === _.nodeType)) {
      l = _, r[a] = null;
      break;
    }
    if (null == l) {
      if (null === x) return document.createTextNode(k);
      l = o ? document.createElementNS("http://www.w3.org/2000/svg", x) : document.createElement(x, k.is && k), r = null, e = false;
    }
    if (null === x) w === k || e && l.data === k || (l.data = k);else {
      if (r = r && n$1.call(l.childNodes), w = t.props || c$1, !e && null != r) for (w = {}, a = 0; a < l.attributes.length; a++) w[(_ = l.attributes[a]).name] = _.value;
      for (a in w) _ = w[a], "children" == a || ("dangerouslySetInnerHTML" == a ? y = _ : "key" === a || a in k || T(l, a, null, _, o));
      for (a in k) _ = k[a], "children" == a ? d = _ : "dangerouslySetInnerHTML" == a ? v = _ : "value" == a ? g = _ : "checked" == a ? b = _ : "key" === a || e && "function" != typeof _ || w[a] === _ || T(l, a, _, w[a], o);
      if (v) e || y && (v.__html === y.__html || v.__html === l.innerHTML) || (l.innerHTML = v.__html), u.__k = [];else if (y && (l.innerHTML = ""), C$1(l, h$1(d) ? d : [d], u, t, i, o && "foreignObject" !== x, r, f, r ? r[0] : t.__k && m$2(t, 0), e, s), null != r) for (a = r.length; a--;) null != r[a] && p$1(r[a]);
      e || (a = "value", void 0 !== g && (g !== l[a] || "progress" === x && !g || "option" === x && g !== w[a]) && T(l, a, g, w[a], false), a = "checked", void 0 !== b && b !== l[a] && T(l, a, b, w[a], false));
    }
    return l;
  }
  function z$1(n, u, t) {
    try {
      "function" == typeof n ? n(u) : n.current = u;
    } catch (n) {
      l$1.__e(n, t);
    }
  }
  function N(n, u, t) {
    var i, o;
    if (l$1.unmount && l$1.unmount(n), (i = n.ref) && (i.current && i.current !== n.__e || z$1(i, null, u)), null != (i = n.__c)) {
      if (i.componentWillUnmount) try {
        i.componentWillUnmount();
      } catch (n) {
        l$1.__e(n, u);
      }
      i.base = i.__P = null, n.__c = void 0;
    }
    if (i = n.__k) for (o = 0; o < i.length; o++) i[o] && N(i[o], u, t || "function" != typeof n.type);
    t || null == n.__e || p$1(n.__e), n.__ = n.__e = n.__d = void 0;
  }
  function O(n, l, u) {
    return this.constructor(n, u);
  }
  function q$1(u, t, i) {
    var o, r, f, e;
    l$1.__ && l$1.__(u, t), r = (o = "function" == "undefined") ? null : t.__k, f = [], e = [], L(t, u = t.__k = y$1(g, null, [u]), r || c$1, c$1, void 0 !== t.ownerSVGElement, r ? null : t.firstChild ? n$1.call(t.childNodes) : null, f, r ? r.__e : t.firstChild, o, e), M(f, u, e);
  }
  n$1 = s$1.slice, l$1 = {
    __e: function __e(n, l, u, t) {
      for (var i, o, r; l = l.__;) if ((i = l.__c) && !i.__) try {
        if ((o = i.constructor) && null != o.getDerivedStateFromError && (i.setState(o.getDerivedStateFromError(n)), r = i.__d), null != i.componentDidCatch && (i.componentDidCatch(n, t || {}), r = i.__d), r) return i.__E = i;
      } catch (l) {
        n = l;
      }
      throw n;
    }
  }, u$1 = 0, b.prototype.setState = function (n, l) {
    var u;
    u = null != this.__s && this.__s !== this.state ? this.__s : this.__s = v$1({}, this.state), "function" == typeof n && (n = n(v$1({}, u), this.props)), n && v$1(u, n), null != n && this.__v && (l && this._sb.push(l), k$1(this));
  }, b.prototype.forceUpdate = function (n) {
    this.__v && (this.__e = true, n && this.__h.push(n), k$1(this));
  }, b.prototype.render = g, i$1 = [], r$2 = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, f$1 = function f$1(n, l) {
    return n.__v.__b - l.__v.__b;
  }, x$1.__r = 0;
  var _n = function n(t, s, r, e) {
      var u;
      s[0] = 0;
      for (var h = 1; h < s.length; h++) {
        var p = s[h++],
          a = s[h] ? (s[0] |= p ? 1 : 2, r[s[h++]]) : s[++h];
        3 === p ? e[0] = a : 4 === p ? e[1] = Object.assign(e[1] || {}, a) : 5 === p ? (e[1] = e[1] || {})[s[++h]] = a : 6 === p ? e[1][s[++h]] += a + "" : p ? (u = t.apply(a, _n(t, a, r, ["", null])), e.push(u), a[0] ? s[0] |= 2 : (s[h - 2] = 0, s[h] = u)) : e.push(a);
      }
      return e;
    },
    t$1 = new Map();
  function e$1(s) {
    var r = t$1.get(this);
    return r || (r = new Map(), t$1.set(this, r)), (r = _n(this, r.get(s) || (r.set(s, r = function (n) {
      for (var t, s, r = 1, e = "", u = "", h = [0], p = function p(n) {
          1 === r && (n || (e = e.replace(/^\s*\n\s*|\s*\n\s*$/g, ""))) ? h.push(0, n, e) : 3 === r && (n || e) ? (h.push(3, n, e), r = 2) : 2 === r && "..." === e && n ? h.push(4, n, 0) : 2 === r && e && !n ? h.push(5, 0, true, e) : r >= 5 && ((e || !n && 5 === r) && (h.push(r, 0, e, s), r = 6), n && (h.push(r, n, 0, s), r = 6)), e = "";
        }, a = 0; a < n.length; a++) {
        a && (1 === r && p(), p(a));
        for (var l = 0; l < n[a].length; l++) t = n[a][l], 1 === r ? "<" === t ? (p(), h = [h], r = 3) : e += t : 4 === r ? "--" === e && ">" === t ? (r = 1, e = "") : e = t + e[0] : u ? t === u ? u = "" : e += t : '"' === t || "'" === t ? u = t : ">" === t ? (p(), r = 1) : r && ("=" === t ? (r = 5, s = e, e = "") : "/" === t && (r < 5 || ">" === n[a][l + 1]) ? (p(), 3 === r && (h = h[0]), r = h, (h = h[0]).push(2, 0, r), r = 0) : " " === t || "\t" === t || "\n" === t || "\r" === t ? (p(), r = 2) : e += t), 3 === r && "!--" === e && (r = 4, h = h[0]);
      }
      return p(), h;
    }(s)), r), arguments, [])).length > 1 ? r : r[0];
  }
  var m$1 = e$1.bind(y$1);
  var t,
    r$1,
    u,
    i,
    o = 0,
    f = [],
    c = [],
    e = l$1,
    a = e.__b,
    v = e.__r,
    l = e.diffed,
    m = e.__c,
    s = e.unmount,
    d = e.__;
  function h(n, t) {
    e.__h && e.__h(r$1, n, o || t), o = 0;
    var u = r$1.__H || (r$1.__H = {
      __: [],
      __h: []
    });
    return n >= u.__.length && u.__.push({
      __V: c
    }), u.__[n];
  }
  function p(n) {
    return o = 1, y(D, n);
  }
  function y(n, u, i) {
    var o = h(t++, 2);
    if (o.t = n, !o.__c && (o.__ = [D(void 0, u), function (n) {
      var t = o.__N ? o.__N[0] : o.__[0],
        r = o.t(t, n);
      t !== r && (o.__N = [r, o.__[1]], o.__c.setState({}));
    }], o.__c = r$1, !r$1.u)) {
      var f = function f(n, t, r) {
        if (!o.__c.__H) return true;
        var u = o.__c.__H.__.filter(function (n) {
          return !!n.__c;
        });
        if (u.every(function (n) {
          return !n.__N;
        })) return !c || c.call(this, n, t, r);
        var i = false;
        return u.forEach(function (n) {
          if (n.__N) {
            var t = n.__[0];
            n.__ = n.__N, n.__N = void 0, t !== n.__[0] && (i = true);
          }
        }), !(!i && o.__c.props === n) && (!c || c.call(this, n, t, r));
      };
      r$1.u = true;
      var c = r$1.shouldComponentUpdate,
        e = r$1.componentWillUpdate;
      r$1.componentWillUpdate = function (n, t, r) {
        if (this.__e) {
          var u = c;
          c = void 0, f(n, t, r), c = u;
        }
        e && e.call(this, n, t, r);
      }, r$1.shouldComponentUpdate = f;
    }
    return o.__N || o.__;
  }
  function _(n, u) {
    var i = h(t++, 3);
    !e.__s && C(i.__H, u) && (i.__ = n, i.i = u, r$1.__H.__h.push(i));
  }
  function A(n, u) {
    var i = h(t++, 4);
    !e.__s && C(i.__H, u) && (i.__ = n, i.i = u, r$1.__h.push(i));
  }
  function F(n) {
    return o = 5, q(function () {
      return {
        current: n
      };
    }, []);
  }
  function q(n, r) {
    var u = h(t++, 7);
    return C(u.__H, r) ? (u.__V = n(), u.i = r, u.__h = n, u.__V) : u.__;
  }
  function x(n, t) {
    return o = 8, q(function () {
      return n;
    }, t);
  }
  function j() {
    for (var n; n = f.shift();) if (n.__P && n.__H) try {
      n.__H.__h.forEach(z), n.__H.__h.forEach(B), n.__H.__h = [];
    } catch (t) {
      n.__H.__h = [], e.__e(t, n.__v);
    }
  }
  e.__b = function (n) {
    r$1 = null, a && a(n);
  }, e.__ = function (n, t) {
    n && t.__k && t.__k.__m && (n.__m = t.__k.__m), d && d(n, t);
  }, e.__r = function (n) {
    v && v(n), t = 0;
    var i = (r$1 = n.__c).__H;
    i && (u === r$1 ? (i.__h = [], r$1.__h = [], i.__.forEach(function (n) {
      n.__N && (n.__ = n.__N), n.__V = c, n.__N = n.i = void 0;
    })) : (i.__h.forEach(z), i.__h.forEach(B), i.__h = [], t = 0)), u = r$1;
  }, e.diffed = function (n) {
    l && l(n);
    var t = n.__c;
    t && t.__H && (t.__H.__h.length && (1 !== f.push(t) && i === e.requestAnimationFrame || ((i = e.requestAnimationFrame) || w)(j)), t.__H.__.forEach(function (n) {
      n.i && (n.__H = n.i), n.__V !== c && (n.__ = n.__V), n.i = void 0, n.__V = c;
    })), u = r$1 = null;
  }, e.__c = function (n, t) {
    t.some(function (n) {
      try {
        n.__h.forEach(z), n.__h = n.__h.filter(function (n) {
          return !n.__ || B(n);
        });
      } catch (r) {
        t.some(function (n) {
          n.__h && (n.__h = []);
        }), t = [], e.__e(r, n.__v);
      }
    }), m && m(n, t);
  }, e.unmount = function (n) {
    s && s(n);
    var t,
      r = n.__c;
    r && r.__H && (r.__H.__.forEach(function (n) {
      try {
        z(n);
      } catch (n) {
        t = n;
      }
    }), r.__H = void 0, t && e.__e(t, r.__v));
  };
  var k = "function" == typeof requestAnimationFrame;
  function w(n) {
    var t,
      r = function r() {
        clearTimeout(u), k && cancelAnimationFrame(t), setTimeout(n);
      },
      u = setTimeout(r, 100);
    k && (t = requestAnimationFrame(r));
  }
  function z(n) {
    var t = r$1,
      u = n.__c;
    "function" == typeof u && (n.__c = void 0, u()), r$1 = t;
  }
  function B(n) {
    var t = r$1;
    n.__c = n.__(), r$1 = t;
  }
  function C(n, t) {
    return !n || n.length !== t.length || t.some(function (t, r) {
      return t !== n[r];
    });
  }
  function D(n, t) {
    return "function" == typeof t ? t(n) : t;
  }
  function r(e) {
    var t,
      f,
      n = "";
    if ("string" == typeof e || "number" == typeof e) n += e;else if ("object" == typeof e) if (Array.isArray(e)) {
      var o = e.length;
      for (t = 0; t < o; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
    } else for (f in e) e[f] && (n && (n += " "), n += f);
    return n;
  }
  function clsx() {
    for (var e, t, f = 0, n = "", o = arguments.length; f < o; f++) (e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
    return n;
  }
  function PopupMenuHeader(props) {
    var headerEntries = props.headerEntries,
      onSelect = props.onSelect,
      selectedEntry = props.selectedEntry,
      setSelectedEntry = props.setSelectedEntry,
      title = props.title;
    var groups = q(function () {
      return groupEntries$1(headerEntries);
    }, [headerEntries]);
    var isActionable = function isActionable(entry) {
      return entry.action && !entry.disabled;
    };
    var handleClick = function handleClick(event, entry) {
      if (!isActionable(entry)) {
        return;
      }
      return onSelect(event, entry);
    };
    return m$1(_t7 || (_t7 = _2`
    <div class="djs-popup-header">
      <h3 class="djs-popup-title" title=${0}>${0}</h3>
      ${0}
    </div>
  `), title, title, groups.map(function (group) {
      return m$1(_t8 || (_t8 = _2`
        <ul key=${0} class="djs-popup-header-group" data-header-group=${0}>

          ${0}
        </ul>
      `), group.id, group.id, group.entries.map(function (entry) {
        return m$1(_t9 || (_t9 = _2`
            <li key=${0}>
              <${0}
                class=${0}
                onClick=${0}
                title=${0}
                data-id=${0}
                aria-disabled=${0}
                onMouseEnter=${0}
                onMouseLeave=${0}
                onFocus=${0}
                onBlur=${0}
              >
                ${0}
                ${0}
              </${0}>
            </li>
          `), entry.id, isActionable(entry) ? 'button' : 'span', getHeaderClasses(entry, entry === selectedEntry), function (event) {
          return handleClick(event, entry);
        }, entry.title || entry.label, entry.id, entry.disabled || undefined, function () {
          return isActionable(entry) && setSelectedEntry(entry);
        }, function () {
          return isActionable(entry) && setSelectedEntry(null);
        }, function () {
          return isActionable(entry) && setSelectedEntry(entry);
        }, function () {
          return isActionable(entry) && setSelectedEntry(null);
        }, entry.imageUrl && m$1(_t0 || (_t0 = _2`<img class="djs-popup-entry-icon" src=${0} alt="" />`), entry.imageUrl) || entry.imageHtml && m$1(_t1 || (_t1 = _2`<div class="djs-popup-entry-icon" dangerouslySetInnerHTML=${0} />`), {
          __html: entry.imageHtml
        }), entry.label ? m$1(_t10 || (_t10 = _2`
                  <span class="djs-popup-label">${0}</span>
                `), entry.label) : null, entry.action ? 'button' : 'span');
      }));
    }));
  }
  function groupEntries$1(entries) {
    return entries.reduce(function (groups, entry) {
      var groupId = entry.group || 'default';
      var group = groups.find(function (group) {
        return group.id === groupId;
      });
      if (group) {
        group.entries.push(entry);
      } else {
        groups.push({
          id: groupId,
          entries: [entry]
        });
      }
      return groups;
    }, []);
  }
  function getHeaderClasses(entry, selected) {
    return clsx('entry', entry.className, entry.active ? 'active' : '', entry.disabled ? 'disabled' : '', selected ? 'selected' : '');
  }
  function PopupMenuItem(props) {
    var entry = props.entry,
      selected = props.selected,
      onMouseEnter = props.onMouseEnter,
      onMouseLeave = props.onMouseLeave,
      onAction = props.onAction;
    var handleClick = function handleClick(event, action) {
      if (entry.disabled) {
        return;
      }
      return onAction(event, entry, action);
    };
    return m$1(_t11 || (_t11 = _2`
    <li
      class=${0}
      data-id=${0}
      title=${0}
      aria-disabled=${0}
      tabIndex="0"
      onClick=${0}
      onFocus=${0}
      onBlur=${0}
      onMouseEnter=${0}
      onMouseLeave=${0}
      onDragStart=${0}
      draggable=${0}
    >
      <div class="djs-popup-entry-content">
        <span
          class=${0}
        >
          ${0}

          ${0}
        </span>
        ${0}
      </div>
      ${0}
    </li>
  `), clsx('entry', {
      selected,
      disabled: entry.disabled
    }), entry.id, entry.title || entry.label, entry.disabled || undefined, handleClick, onMouseEnter, onMouseLeave, onMouseEnter, onMouseLeave, function (event) {
      return handleClick(event, 'dragstart');
    }, true, clsx('djs-popup-entry-name', entry.className), entry.imageUrl && m$1(_t12 || (_t12 = _2`<img class="djs-popup-entry-icon" src=${0} alt="" />`), entry.imageUrl) || entry.imageHtml && m$1(_t13 || (_t13 = _2`<div class="djs-popup-entry-icon" dangerouslySetInnerHTML=${0} />`), {
      __html: entry.imageHtml
    }), entry.label ? m$1(_t14 || (_t14 = _2`
            <span class="djs-popup-label">
              ${0}
            </span>
          `), entry.label) : null, entry.description && m$1(_t15 || (_t15 = _2`
          <span
            class="djs-popup-entry-description"
            title=${0}
          >
            ${0}
          </span>
        `), entry.description, entry.description), entry.documentationRef && m$1(_t16 || (_t16 = _2`
        <div class="djs-popup-entry-docs">
          <a
            href="${0}"
            onClick=${0}
            title="Open element documentation"
            target="_blank"
            rel="noopener"
          >
            <svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path fill-rule="evenodd" clip-rule="evenodd" d="M10.6368 10.6375V5.91761H11.9995V10.6382C11.9995 10.9973 11.8623 11.3141 11.5878 11.5885C11.3134 11.863 10.9966 12.0002 10.6375 12.0002H1.36266C0.982345 12.0002 0.660159 11.8681 0.396102 11.6041C0.132044 11.34 1.52588e-05 11.0178 1.52588e-05 10.6375V1.36267C1.52588e-05 0.98236 0.132044 0.660173 0.396102 0.396116C0.660159 0.132058 0.982345 2.95639e-05 1.36266 2.95639e-05H5.91624V1.36267H1.36266V10.6375H10.6368ZM12 0H7.2794L7.27873 1.36197H9.68701L3.06507 7.98391L4.01541 8.93425L10.6373 2.31231V4.72059H12V0Z" fill="#818798"/>
            </svg>
          </a>
        </div>
      `), entry.documentationRef, function (event) {
      return event.stopPropagation();
    }));
  }
  function PopupMenuList(props) {
    var selectedEntry = props.selectedEntry,
      setSelectedEntry = props.setSelectedEntry,
      groupedEntries = props.groupedEntries,
      restProps = _objectWithoutProperties(props, _excluded);
    var resultsRef = F();
    A(function () {
      var containerEl = resultsRef.current;
      if (!containerEl) return;
      var selectedEl = containerEl.querySelector('.selected');
      if (selectedEl) {
        scrollIntoView(selectedEl);
      }
    }, [selectedEntry]);
    return m$1(_t17 || (_t17 = _2`
    <div class="djs-popup-results" ref=${0}>
      ${0}
    </div>
  `), resultsRef, groupedEntries.map(function (group) {
      return m$1(_t18 || (_t18 = _2`
        ${0}
        <ul class="djs-popup-group" data-group=${0}>
          ${0}
        </ul>
      `), group.name && m$1(_t19 || (_t19 = _2`
          <div key=${0} class="entry-header" title=${0}>
            ${0}
          </div>
        `), group.id, group.name, group.name), group.id, group.entries.map(function (entry) {
        return m$1(_t20 || (_t20 = _2`
            <${0}
              key=${0}
              entry=${0}
              selected=${0}
              onMouseEnter=${0}
              onMouseLeave=${0}
              ...${0}
            />
          `), PopupMenuItem, entry.id, entry, entry === selectedEntry, function () {
          return setSelectedEntry(entry);
        }, function () {
          return setSelectedEntry(null);
        }, restProps);
      }));
    }));
  }
  function scrollIntoView(el) {
    if (typeof el.scrollIntoViewIfNeeded === 'function') {
      el.scrollIntoViewIfNeeded();
    } else {
      el.scrollIntoView({
        scrollMode: 'if-needed',
        block: 'nearest'
      });
    }
  }
  function PopupMenuComponent(props) {
    var onClose = props.onClose,
      onSelect = props.onSelect,
      className = props.className,
      headerEntries = props.headerEntries,
      position = props.position,
      title = props.title,
      width = props.width,
      scale = props.scale,
      search = props.search,
      emptyPlaceholder = props.emptyPlaceholder,
      searchFn = props.searchFn,
      originalEntries = props.entries,
      onOpened = props.onOpened,
      onClosed = props.onClosed;
    var searchable = q(function () {
      if (!isDefined(search)) {
        return false;
      }
      return originalEntries.length > 5;
    }, [search, originalEntries]);
    var _p = p(''),
      _p2 = _slicedToArray(_p, 2),
      searchValue = _p2[0],
      setSearchValue = _p2[1];
    var filterEntries = x(function (originalEntries, searchValue) {
      if (!searchable) {
        return originalEntries;
      }
      if (!searchValue.trim()) {
        return originalEntries.filter(function (_ref7) {
          var _ref7$rank = _ref7.rank,
            rank = _ref7$rank === void 0 ? 0 : _ref7$rank;
          return rank >= 0;
        });
      }
      var searchableEntries = originalEntries.filter(function (_ref8) {
        var searchable = _ref8.searchable;
        return searchable !== false;
      });
      return searchFn(searchableEntries, searchValue, {
        keys: ['label', 'search', 'description']
      }).map(function (_ref9) {
        var item = _ref9.item;
        return item;
      });
    }, [searchable]);
    var _p3 = p(filterEntries(originalEntries, searchValue)),
      _p4 = _slicedToArray(_p3, 2),
      entries = _p4[0],
      setEntries = _p4[1];
    var _p5 = p(entries[0]),
      _p6 = _slicedToArray(_p5, 2),
      selectedEntry = _p6[0],
      setSelectedEntry = _p6[1];
    var groupedEntries = q(function () {
      return groupEntries(entries);
    }, [entries]);
    var updateEntries = x(function (newEntries) {
      setSelectedEntry(newEntries[0]);
      setEntries(newEntries);
    }, [setEntries, setSelectedEntry]);
    _(function () {
      updateEntries(filterEntries(originalEntries, searchValue));
    }, [searchValue, originalEntries]);
    var keyboardSelect = x(function (direction) {
      var entries = getOrderedEntries(groupedEntries);
      var idx = entries.indexOf(selectedEntry);
      var nextIdx = idx + direction;
      if (nextIdx < 0) {
        nextIdx = entries.length - 1;
      }
      if (nextIdx >= entries.length) {
        nextIdx = 0;
      }
      setSelectedEntry(entries[nextIdx]);
    }, [groupedEntries, selectedEntry, setSelectedEntry]);
    var handleKeyDown = x(function (event) {
      if (event.key === 'Enter' && selectedEntry) {
        if (selectedEntry.disabled) {
          return;
        }
        return onSelect(event, selectedEntry);
      }
      if (event.key === 'ArrowUp') {
        keyboardSelect(-1);
        return event.preventDefault();
      }
      if (event.key === 'ArrowDown') {
        keyboardSelect(1);
        return event.preventDefault();
      }
    }, [onSelect, selectedEntry, keyboardSelect]);
    var handleKey = x(function (event) {
      if (matches(event.target, 'input')) {
        setSearchValue(function () {
          return event.target.value;
        });
      }
    }, [setSearchValue]);
    _(function () {
      onOpened();
      return function () {
        onClosed();
      };
    }, []);
    var displayHeader = q(function () {
      return title || headerEntries.length > 0;
    }, [title, headerEntries]);
    return m$1(_t21 || (_t21 = _2`
    <${0}
      onClose=${0}
      onKeyup=${0}
      onKeydown=${0}
      className=${0}
      position=${0}
      width=${0}
      scale=${0}
    >
      ${0}
      ${0}
    ${0}
    </${0}>
  `), PopupMenuWrapper, onClose, handleKey, handleKeyDown, className, position, width, scale, displayHeader && m$1(_t22 || (_t22 = _2`
        <${0}
          headerEntries=${0}
          onSelect=${0}
          selectedEntry=${0}
          setSelectedEntry=${0}
          title=${0}
        />
      `), PopupMenuHeader, headerEntries, onSelect, selectedEntry, setSelectedEntry, title), originalEntries.length > 0 && m$1(_t23 || (_t23 = _2`
        <div class="djs-popup-body">

          ${0}

          <${0}
            groupedEntries=${0}
            selectedEntry=${0}
            setSelectedEntry=${0}
            onAction=${0}
          />
        </div>
      `), searchable && m$1(_t24 || (_t24 = _2`
          <div class="djs-popup-search">
            <svg class="djs-popup-search-icon" width="14" height="14" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path fill-rule="evenodd" clip-rule="evenodd" d="M9.0325 8.5H9.625L13.3675 12.25L12.25 13.3675L8.5 9.625V9.0325L8.2975 8.8225C7.4425 9.5575 6.3325 10 5.125 10C2.4325 10 0.25 7.8175 0.25 5.125C0.25 2.4325 2.4325 0.25 5.125 0.25C7.8175 0.25 10 2.4325 10 5.125C10 6.3325 9.5575 7.4425 8.8225 8.2975L9.0325 8.5ZM1.75 5.125C1.75 6.9925 3.2575 8.5 5.125 8.5C6.9925 8.5 8.5 6.9925 8.5 5.125C8.5 3.2575 6.9925 1.75 5.125 1.75C3.2575 1.75 1.75 3.2575 1.75 5.125Z" fill="#22242A"/>
            </svg>
            <input type="text" spellcheck=${0} aria-label="${0}" />
          </div>
          `), false, title), PopupMenuList, groupedEntries, selectedEntry, setSelectedEntry, onSelect), emptyPlaceholder && entries.length === 0 && m$1(_t25 || (_t25 = _2`
      <div class="djs-popup-no-results">${0}</div>
    `), isFunction(emptyPlaceholder) ? emptyPlaceholder(searchValue) : emptyPlaceholder), PopupMenuWrapper);
  }
  function PopupMenuWrapper(props) {
    var onClose = props.onClose,
      onKeydown = props.onKeydown,
      onKeyup = props.onKeyup,
      className = props.className,
      children = props.children,
      positionGetter = props.position;
    var popupRef = F();
    A(function () {
      if (typeof positionGetter !== 'function') {
        return;
      }
      var popupEl = popupRef.current;
      var position = positionGetter(popupEl);
      popupEl.style.left = `${position.x}px`;
      popupEl.style.top = `${position.y}px`;
    }, [popupRef.current, positionGetter]);
    A(function () {
      var popupEl = popupRef.current;
      if (!popupEl) {
        return;
      }
      var inputEl = popupEl.querySelector('input');
      (inputEl || popupEl).focus();
    }, []);
    _(function () {
      var handleKeyDown = function handleKeyDown(event) {
        if (event.key === 'Escape') {
          event.preventDefault();
          return onClose();
        }
      };
      var handleClick = function handleClick(event) {
        var popup = closest(event.target, '.djs-popup', true);
        if (popup) {
          return;
        }
        return onClose();
      };
      document.documentElement.addEventListener('keydown', handleKeyDown);
      document.body.addEventListener('click', handleClick);
      return function () {
        document.documentElement.removeEventListener('keydown', handleKeyDown);
        document.body.removeEventListener('click', handleClick);
      };
    }, []);
    return m$1(_t26 || (_t26 = _2`
    <div
      class=${0}
      style=${0}
      onKeydown=${0}
      onKeyup=${0}
      ref=${0}
      tabIndex="-1"
    >
      ${0}
    </div>
  `), clsx('djs-popup', className), getPopupStyle(props), onKeydown, onKeyup, popupRef, children);
  }
  function getPopupStyle(props) {
    return {
      transform: `scale(${props.scale})`,
      width: `${props.width}px`,
      'transform-origin': 'top left'
    };
  }
  function getOrderedEntries(groupedEntries) {
    var entries = [];
    groupedEntries.forEach(function (group) {
      group.entries.forEach(function (entry) {
        entries.push(entry);
      });
    });
    return entries;
  }
  function groupEntries(entries) {
    var groups = [];
    var getGroup = function getGroup(group) {
      return groups.find(function (elem) {
        return group.id === elem.id;
      });
    };
    var containsGroup = function containsGroup(group) {
      return !!getGroup(group);
    };
    var formatGroup = function formatGroup(group) {
      return typeof group === 'string' ? {
        id: group
      } : group;
    };
    entries.forEach(function (entry) {
      var group = entry.group ? formatGroup(entry.group) : {
        id: 'default'
      };
      if (!containsGroup(group)) {
        groups.push(_objectSpread(_objectSpread({}, group), {}, {
          entries: [entry]
        }));
      } else {
        getGroup(group).entries.push(entry);
      }
    });
    return groups;
  }
  var DATA_REF = 'data-id';
  var CLOSE_EVENTS = ['contextPad.close', 'canvas.viewbox.changing', 'commandStack.changed'];
  var DEFAULT_PRIORITY$2 = 1000;
  function PopupMenu(config, eventBus, canvas, search) {
    var _this1 = this;
    this._eventBus = eventBus;
    this._canvas = canvas;
    this._search = search;
    this._current = null;
    var scale = isDefined(config && config.scale) ? config.scale : {
      min: 1,
      max: 1
    };
    this._config = {
      scale: scale
    };
    eventBus.on('diagram.destroy', function () {
      _this1.close();
    });
    eventBus.on('element.changed', function (event) {
      var element = _this1.isOpen() && _this1._current.target;
      if (event.element === element) {
        _this1.refresh();
      }
    });
  }
  PopupMenu.$inject = ['config.popupMenu', 'eventBus', 'canvas', 'search'];
  PopupMenu.prototype._render = function () {
    var _this10 = this;
    var _this$_current = this._current,
      _position = _this$_current.position,
      className = _this$_current.providerId,
      entries = _this$_current.entries,
      headerEntries = _this$_current.headerEntries,
      emptyPlaceholder = _this$_current.emptyPlaceholder,
      options = _this$_current.options;
    var entriesArray = Object.entries(entries).map(function (_ref0) {
      var _ref1 = _slicedToArray(_ref0, 2),
        key = _ref1[0],
        value = _ref1[1];
      return _objectSpread({
        id: key
      }, value);
    });
    var headerEntriesArray = Object.entries(headerEntries).map(function (_ref10) {
      var _ref11 = _slicedToArray(_ref10, 2),
        key = _ref11[0],
        value = _ref11[1];
      return _objectSpread({
        id: key
      }, value);
    });
    var position = _position && function (container) {
      return _this10._ensureVisible(container, _position);
    };
    var scale = this._updateScale(this._current.container);
    var onClose = function onClose(result) {
      return _this10.close(result);
    };
    var onSelect = function onSelect(event, entry, action) {
      return _this10.trigger(event, entry, action);
    };
    q$1(m$1(_t27 || (_t27 = _2`
      <${0}
        onClose=${0}
        onSelect=${0}
        position=${0}
        className=${0}
        entries=${0}
        headerEntries=${0}
        emptyPlaceholder=${0}
        scale=${0}
        onOpened=${0}
        onClosed=${0}
        searchFn=${0}
        ...${0}
      />
    `), PopupMenuComponent, onClose, onSelect, position, className, entriesArray, headerEntriesArray, emptyPlaceholder, scale, this._onOpened.bind(this), this._onClosed.bind(this), this._search, _objectSpread({}, options)), this._current.container);
  };
  PopupMenu.prototype.open = function (target, providerId, position, options) {
    if (!target) {
      throw new Error('target is missing');
    }
    if (!providerId) {
      throw new Error('providers for <' + providerId + '> not found');
    }
    if (!position) {
      throw new Error('position is missing');
    }
    if (this.isOpen()) {
      this.close();
    }
    var _this$_getContext = this._getContext(target, providerId),
      entries = _this$_getContext.entries,
      headerEntries = _this$_getContext.headerEntries,
      emptyPlaceholder = _this$_getContext.emptyPlaceholder;
    this._current = {
      position,
      providerId,
      target,
      entries,
      headerEntries,
      emptyPlaceholder,
      container: this._createContainer({
        provider: providerId
      }),
      options
    };
    this._emit('open');
    this._bindAutoClose();
    this._render();
  };
  PopupMenu.prototype.refresh = function () {
    if (!this.isOpen()) {
      return;
    }
    var _this$_current2 = this._current,
      target = _this$_current2.target,
      providerId = _this$_current2.providerId;
    var _this$_getContext2 = this._getContext(target, providerId),
      entries = _this$_getContext2.entries,
      headerEntries = _this$_getContext2.headerEntries,
      emptyPlaceholder = _this$_getContext2.emptyPlaceholder;
    this._current = _objectSpread(_objectSpread({}, this._current), {}, {
      entries,
      headerEntries,
      emptyPlaceholder
    });
    this._emit('refresh');
    this._render();
  };
  PopupMenu.prototype._getContext = function (target, provider) {
    var providers = this._getProviders(provider);
    if (!providers || !providers.length) {
      throw new Error('provider for <' + provider + '> not found');
    }
    var entries = this._getEntries(target, providers);
    var headerEntries = this._getHeaderEntries(target, providers);
    var emptyPlaceholder = this._getEmptyPlaceholder(providers);
    return {
      entries,
      headerEntries,
      emptyPlaceholder,
      empty: !(Object.keys(entries).length || Object.keys(headerEntries).length)
    };
  };
  PopupMenu.prototype.close = function () {
    if (!this.isOpen()) {
      return;
    }
    this._emit('close');
    this.reset();
    this._canvas.restoreFocus();
    this._current = null;
  };
  PopupMenu.prototype.reset = function () {
    var container = this._current.container;
    q$1(null, container);
    remove$2(container);
  };
  PopupMenu.prototype._emit = function (event, payload) {
    this._eventBus.fire(`popupMenu.${event}`, payload);
  };
  PopupMenu.prototype._onOpened = function () {
    this._emit('opened');
  };
  PopupMenu.prototype._onClosed = function () {
    this._emit('closed');
  };
  PopupMenu.prototype._createContainer = function (config) {
    var canvas = this._canvas,
      parent = canvas.getContainer();
    var container = domify$1(`<div class="djs-popup-parent djs-scrollable" data-popup=${config.provider}></div>`);
    parent.appendChild(container);
    return container;
  };
  PopupMenu.prototype._bindAutoClose = function () {
    this._eventBus.once(CLOSE_EVENTS, this.close, this);
  };
  PopupMenu.prototype._unbindAutoClose = function () {
    this._eventBus.off(CLOSE_EVENTS, this.close, this);
  };
  PopupMenu.prototype._updateScale = function () {
    var zoom = this._canvas.zoom();
    var scaleConfig = this._config.scale,
      minScale,
      maxScale,
      scale = zoom;
    if (scaleConfig !== true) {
      if (scaleConfig === false) {
        minScale = 1;
        maxScale = 1;
      } else {
        minScale = scaleConfig.min;
        maxScale = scaleConfig.max;
      }
      if (isDefined(minScale) && zoom < minScale) {
        scale = minScale;
      }
      if (isDefined(maxScale) && zoom > maxScale) {
        scale = maxScale;
      }
    }
    return scale;
  };
  PopupMenu.prototype._ensureVisible = function (container, position) {
    var documentBounds = document.documentElement.getBoundingClientRect();
    var containerBounds = container.getBoundingClientRect();
    var overAxis = {},
      left = position.x,
      top = position.y;
    if (position.x + containerBounds.width > documentBounds.width) {
      overAxis.x = true;
    }
    if (position.y + containerBounds.height > documentBounds.height) {
      overAxis.y = true;
    }
    if (overAxis.x && overAxis.y) {
      left = position.x - containerBounds.width;
      top = position.y - containerBounds.height;
    } else if (overAxis.x) {
      left = position.x - containerBounds.width;
      top = position.y;
    } else if (overAxis.y && position.y < containerBounds.height) {
      left = position.x;
      top = 10;
    } else if (overAxis.y) {
      left = position.x;
      top = position.y - containerBounds.height;
    }
    if (position.y < documentBounds.top) {
      top = position.y + containerBounds.height;
    }
    return {
      x: left,
      y: top
    };
  };
  PopupMenu.prototype.isEmpty = function (target, providerId) {
    if (!target) {
      throw new Error('target is missing');
    }
    if (!providerId) {
      throw new Error('provider ID is missing');
    }
    var providers = this._getProviders(providerId);
    if (!providers || !providers.length) {
      return true;
    }
    return this._getContext(target, providerId).empty;
  };
  PopupMenu.prototype.registerProvider = function (id, priority, provider) {
    if (!provider) {
      provider = priority;
      priority = DEFAULT_PRIORITY$2;
    }
    this._eventBus.on('popupMenu.getProviders.' + id, priority, function (event) {
      event.providers.push(provider);
    });
  };
  PopupMenu.prototype._getProviders = function (id) {
    var event = this._eventBus.createEvent({
      type: 'popupMenu.getProviders.' + id,
      providers: []
    });
    this._eventBus.fire(event);
    return event.providers;
  };
  PopupMenu.prototype._getEntries = function (target, providers) {
    var entries = {};
    forEach$1(providers, function (provider) {
      if (!provider.getPopupMenuEntries) {
        forEach$1(provider.getEntries(target), function (entry) {
          var id = entry.id;
          if (!id) {
            throw new Error('entry ID is missing');
          }
          entries[id] = omit(entry, ['id']);
        });
        return;
      }
      var entriesOrUpdater = provider.getPopupMenuEntries(target);
      if (isFunction(entriesOrUpdater)) {
        entries = entriesOrUpdater(entries);
      } else {
        forEach$1(entriesOrUpdater, function (entry, id) {
          entries[id] = entry;
        });
      }
    });
    return entries;
  };
  PopupMenu.prototype._getHeaderEntries = function (target, providers) {
    var entries = {};
    forEach$1(providers, function (provider) {
      if (!provider.getPopupMenuHeaderEntries) {
        if (!provider.getHeaderEntries) {
          return;
        }
        forEach$1(provider.getHeaderEntries(target), function (entry) {
          var id = entry.id;
          if (!id) {
            throw new Error('entry ID is missing');
          }
          entries[id] = omit(entry, ['id']);
        });
        return;
      }
      var entriesOrUpdater = provider.getPopupMenuHeaderEntries(target);
      if (isFunction(entriesOrUpdater)) {
        entries = entriesOrUpdater(entries);
      } else {
        forEach$1(entriesOrUpdater, function (entry, id) {
          entries[id] = entry;
        });
      }
    });
    return entries;
  };
  PopupMenu.prototype._getEmptyPlaceholder = function (providers) {
    var provider = providers.find(function (provider) {
      return isFunction(provider.getEmptyPlaceholder);
    });
    return provider && provider.getEmptyPlaceholder();
  };
  PopupMenu.prototype.isOpen = function () {
    return !!this._current;
  };
  PopupMenu.prototype.trigger = function (event, entry) {
    var action = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'click';
    event.preventDefault();
    if (!entry) {
      var element = closest(event.delegateTarget || event.target, '.entry', true);
      var entryId = attr$1(element, DATA_REF);
      entry = _objectSpread({
        id: entryId
      }, this._getEntry(entryId));
    }
    var handler = entry.action;
    if (this._emit('trigger', {
      entry,
      event
    }) === false) {
      return;
    }
    if (isFunction(handler)) {
      if (action === 'click') {
        return handler(event, entry);
      }
    } else {
      if (handler[action]) {
        return handler[action](event, entry);
      }
    }
  };
  PopupMenu.prototype._getEntry = function (entryId) {
    var entry = this._current.entries[entryId] || this._current.headerEntries[entryId];
    if (!entry) {
      throw new Error('entry not found');
    }
    return entry;
  };
  function search(items, pattern, options) {
    var keys = options.keys;
    pattern = pattern.trim().toLowerCase();
    if (!pattern) {
      throw new Error('<pattern> must not be empty');
    }
    var words = pattern.trim().toLowerCase().split(/\s+/);
    return items.flatMap(function (item) {
      var tokens = matchItem(item, words, keys);
      if (!tokens) {
        return [];
      }
      return {
        item,
        tokens
      };
    }).sort(createResultSorter(keys));
  }
  function matchItem(item, words, keys) {
    var _keys$reduce = keys.reduce(function (result, key) {
        var itemValue = item[key];
        var _ref12 = isArray$3(itemValue) ? itemValue.reduce(function (result, itemString) {
            var _matchString = matchString(itemString, words),
              tokens = _matchString.tokens,
              matchedWords = _matchString.matchedWords;
            return {
              tokens: [].concat(_toConsumableArray(result.tokens), [tokens]),
              matchedWords: _objectSpread(_objectSpread({}, result.matchedWords), matchedWords)
            };
          }, {
            matchedWords: {},
            tokens: []
          }) : matchString(itemValue, words),
          tokens = _ref12.tokens,
          matchedWords = _ref12.matchedWords;
        return {
          tokens: _objectSpread(_objectSpread({}, result.tokens), {}, {
            [key]: tokens
          }),
          matchedWords: _objectSpread(_objectSpread({}, result.matchedWords), matchedWords)
        };
      }, {
        matchedWords: {},
        tokens: {}
      }),
      matchedWords = _keys$reduce.matchedWords,
      tokens = _keys$reduce.tokens;
    if (Object.keys(matchedWords).length !== words.length) {
      return null;
    }
    return tokens;
  }
  function createResultSorter(keys) {
    return function (resultA, resultB) {
      var comparison = 0;
      var modifier = 1;
      var _iterator2 = _createForOfIteratorHelper(keys),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var key = _step2.value;
          var tokenComparison = compareTokens(resultA.tokens[key], resultB.tokens[key]);
          if (tokenComparison !== 0) {
            comparison += tokenComparison * modifier;
            modifier *= 0.9;
            continue;
          }
          var stringComparison = compareStrings(resultA.item[key], resultB.item[key]);
          if (stringComparison !== 0) {
            comparison += stringComparison * modifier;
            modifier *= 0.9;
            continue;
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return comparison;
    };
  }
  function compareTokens(tokensA, tokensB) {
    return scoreTokens(tokensB) - scoreTokens(tokensA);
  }
  function scoreTokens(tokens) {
    return tokens.reduce(function (sum, token) {
      return sum + scoreToken(token);
    }, 0);
  }
  function scoreToken(token) {
    if (isArray$3(token)) {
      return Math.max.apply(Math, _toConsumableArray(token.map(scoreToken)));
    }
    var modifier = Math.log(token.value.length);
    if (!token.match) {
      return -0.07 * modifier;
    }
    return (token.start ? token.end ? 131.9 : 7.87 : token.wordStart ? 2.19 : 1) * modifier;
  }
  function stringJoin() {
    var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    return isArray$3(str) ? str.join(', ') : str;
  }
  function compareStrings(a, b) {
    return stringJoin(a).localeCompare(stringJoin(b));
  }
  function matchString(string, words) {
    if (!string) {
      return {
        tokens: [],
        matchedWords: {}
      };
    }
    var tokens = [];
    var matchedWords = {};
    var wordsEscaped = words.map(escapeRegexp);
    var regexpString = [`(?<all>${wordsEscaped.join('\\s+')})`].concat(_toConsumableArray(wordsEscaped)).join('|');
    var regexp = new RegExp(regexpString, 'ig');
    var match;
    var lastIndex = 0;
    while (match = regexp.exec(string)) {
      var _match = match,
        _match2 = _slicedToArray(_match, 1),
        value = _match2[0];
      var startIndex = match.index;
      var endIndex = match.index + value.length;
      var start = startIndex === 0;
      var end = endIndex === string.length;
      var _all = !!match.groups.all;
      var wordStart = start || /\s/.test(string.charAt(startIndex - 1));
      var wordEnd = end || /\s/.test(string.charAt(endIndex));
      if (match.index > lastIndex) {
        tokens.push({
          value: string.slice(lastIndex, match.index),
          index: lastIndex
        });
      }
      tokens.push({
        value,
        index: match.index,
        match: true,
        wordStart,
        wordEnd,
        start,
        end,
        all: _all
      });
      var newMatchedWords = _all ? words : [value];
      var _iterator3 = _createForOfIteratorHelper(newMatchedWords),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var word = _step3.value;
          matchedWords[word.toLowerCase()] = true;
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      lastIndex = match.index + value.length;
    }
    if (lastIndex < string.length) {
      tokens.push({
        value: string.slice(lastIndex),
        index: lastIndex
      });
    }
    return {
      tokens,
      matchedWords
    };
  }
  function escapeRegexp(string) {
    return string.replace(/[/\-\\^$*+?.()|[\]{}]/g, '\\$&');
  }
  var SearchModule$1 = {
    search: ['value', search]
  };
  var PopupMenuModule$1 = {
    __depends__: [SearchModule$1],
    __init__: ['popupMenu'],
    popupMenu: ['type', PopupMenu]
  };
  var icons$1 = {
    align: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2000 2000">
              <line x1="200" y1="150" x2="200" y2="1850" style="stroke:currentColor;stroke-width:100;stroke-linecap:round;"/>
              <rect x="500" y="150" width="1300" height="700" rx="1" style="fill:none;stroke:currentColor;stroke-width:100;"></rect>
              <rect x="500" y="1150" width="700" height="700" rx="1" style="fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;"></rect>
          </svg>`,
    bottom: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1800 1800">
            <line x1="150" y1="1650" x2="1650" y2="1650" style="stroke:currentColor;stroke-width:100;stroke-linecap:round;"/>
            <rect x="150" y="350" width="600" height="1300" rx="1" style="fill:none;stroke:currentColor;stroke-width:100;"></rect>
            <rect x="1050" y="850" width="600" height="800" rx="1" style="fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;"></rect>
          </svg>`,
    center: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1800 1800">
            <line x1="900" y1="150" x2="900" y2="1650" style="stroke:currentColor;stroke-width:100;stroke-linecap:round;"/>
            <rect x="250" y="150" width="1300" height="600" rx="1" style="fill:none;stroke:currentColor;stroke-width:100;"></rect>
            <rect x="500" y="1050" width="800" height="600" rx="1" style="fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;"></rect>
          </svg>`,
    left: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1800 1800">
            <line x1="100" y1="150" x2="100" y2="1650" style="stroke:currentColor;stroke-width:100;stroke-linecap:round;"/>
            <rect x="100" y="150" width="1300" height="600" rx="1" style="fill:none;stroke:currentColor;stroke-width:100;"></rect>
            <rect x="100" y="1050" width="800" height="600" rx="1" style="fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;"></rect>
          </svg>`,
    right: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1800 1800">
            <line x1="1650" y1="150" x2="1650" y2="1650" style="stroke:currentColor;stroke-width:100;stroke-linecap:round;"/>
            <rect x="350" y="150" width="1300" height="600" rx="1" style="fill:none;stroke:currentColor;stroke-width:100;"></rect>
            <rect x="850" y="1050" width="800" height="600" rx="1" style="fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;"></rect>
          </svg>`,
    top: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1800 1800">
            <line x1="150" y1="150" x2="1650" y2="150" style="stroke:currentColor;stroke-width:100;stroke-linecap:round;"/>
            <rect x="150" y="150" width="600" height="1300" rx="1" style="fill:none;stroke:currentColor;stroke-width:100;"></rect>
            <rect x="1050" y="150" width="600" height="800" rx="1" style="fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;"></rect>
          </svg>`,
    middle: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1800 1800">
            <line x1="150" y1="900" x2="1650" y2="900" style="stroke:currentColor;stroke-width:100;stroke-linecap:round;"/>
            <rect x="150" y="250" width="600" height="1300" rx="1" style="fill:none;stroke:currentColor;stroke-width:100;"></rect>
            <rect x="1050" y="500" width="600" height="800" rx="1" style="fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;"></rect>
          </svg>`
  };
  var LOW_PRIORITY$m = 900;
  function AlignElementsContextPadProvider(contextPad, popupMenu, translate, canvas) {
    contextPad.registerProvider(LOW_PRIORITY$m, this);
    this._contextPad = contextPad;
    this._popupMenu = popupMenu;
    this._translate = translate;
    this._canvas = canvas;
  }
  AlignElementsContextPadProvider.$inject = ['contextPad', 'popupMenu', 'translate', 'canvas'];
  AlignElementsContextPadProvider.prototype.getMultiElementContextPadEntries = function (elements) {
    var actions = {};
    if (this._isAllowed(elements)) {
      assign$1(actions, this._getEntries(elements));
    }
    return actions;
  };
  AlignElementsContextPadProvider.prototype._isAllowed = function (elements) {
    return !this._popupMenu.isEmpty(elements, 'align-elements');
  };
  AlignElementsContextPadProvider.prototype._getEntries = function () {
    var self = this;
    return {
      'align-elements': {
        group: 'align-elements',
        title: self._translate('Align elements'),
        html: `<div class="entry">${icons$1['align']}</div>`,
        action: {
          click: function click(event, target) {
            var position = self._getMenuPosition(target);
            assign$1(position, {
              cursor: {
                x: event.x,
                y: event.y
              }
            });
            self._popupMenu.open(target, 'align-elements', position);
          }
        }
      }
    };
  };
  AlignElementsContextPadProvider.prototype._getMenuPosition = function (elements) {
    var Y_OFFSET = 5;
    var pad = this._contextPad.getPad(elements).html;
    var padRect = pad.getBoundingClientRect();
    var pos = {
      x: padRect.left,
      y: padRect.bottom + Y_OFFSET
    };
    return pos;
  };
  var ALIGNMENT_OPTIONS = ['left', 'center', 'right', 'top', 'middle', 'bottom'];
  function AlignElementsMenuProvider(popupMenu, alignElements, translate, rules) {
    this._alignElements = alignElements;
    this._translate = translate;
    this._popupMenu = popupMenu;
    this._rules = rules;
    popupMenu.registerProvider('align-elements', this);
  }
  AlignElementsMenuProvider.$inject = ['popupMenu', 'alignElements', 'translate', 'rules'];
  AlignElementsMenuProvider.prototype.getPopupMenuEntries = function (target) {
    var entries = {};
    if (this._isAllowed(target)) {
      assign$1(entries, this._getEntries(target));
    }
    return entries;
  };
  AlignElementsMenuProvider.prototype._isAllowed = function (target) {
    return this._rules.allowed('elements.align', {
      elements: target
    });
  };
  AlignElementsMenuProvider.prototype._getEntries = function (target) {
    var alignElements = this._alignElements,
      translate = this._translate,
      popupMenu = this._popupMenu;
    var entries = {};
    forEach$1(ALIGNMENT_OPTIONS, function (alignment) {
      entries['align-elements-' + alignment] = {
        group: 'align',
        title: translate('Align elements ' + alignment),
        className: 'bjs-align-elements-menu-entry',
        imageHtml: icons$1[alignment],
        action: function action() {
          alignElements.trigger(target, alignment);
          popupMenu.close();
        }
      };
    });
    return entries;
  };
  function RuleProvider(eventBus) {
    CommandInterceptor.call(this, eventBus);
    this.init();
  }
  RuleProvider.$inject = ['eventBus'];
  e$2(RuleProvider, CommandInterceptor);
  RuleProvider.prototype.addRule = function (actions, priority, fn) {
    var self = this;
    if (typeof actions === 'string') {
      actions = [actions];
    }
    actions.forEach(function (action) {
      self.canExecute(action, priority, function (context, action, event) {
        return fn(context);
      }, true);
    });
  };
  RuleProvider.prototype.init = function () {};
  function BpmnAlignElements(eventBus) {
    RuleProvider.call(this, eventBus);
  }
  BpmnAlignElements.$inject = ['eventBus'];
  e$2(BpmnAlignElements, RuleProvider);
  BpmnAlignElements.prototype.init = function () {
    this.addRule('elements.align', function (context) {
      var elements = context.elements;
      var filteredElements = filter(elements, function (element) {
        return !(element.waypoints || element.host || element.labelTarget);
      });
      filteredElements = getParents$1(filteredElements);
      if (filteredElements.length < 2) {
        return false;
      }
      return filteredElements;
    });
  };
  var AlignElementsModule = {
    __depends__: [AlignElementsModule$1, ContextPadModule$1, PopupMenuModule$1],
    __init__: ['alignElementsContextPadProvider', 'alignElementsMenuProvider', 'bpmnAlignElements'],
    alignElementsContextPadProvider: ['type', AlignElementsContextPadProvider],
    alignElementsMenuProvider: ['type', AlignElementsMenuProvider],
    bpmnAlignElements: ['type', BpmnAlignElements]
  };
  var PLACEMENT_DETECTION_PAD = 10;
  var DEFAULT_DISTANCE = 50;
  var DEFAULT_MAX_DISTANCE = 250;
  function findFreePosition(source, element, position, getNextPosition) {
    var connectedAtPosition;
    while (connectedAtPosition = getConnectedAtPosition(source, position, element)) {
      position = getNextPosition(element, position, connectedAtPosition);
    }
    return position;
  }
  function generateGetNextPosition(nextPositionDirection) {
    return function (element, previousPosition, connectedAtPosition) {
      var nextPosition = {
        x: previousPosition.x,
        y: previousPosition.y
      };
      ['x', 'y'].forEach(function (axis) {
        var nextPositionDirectionForAxis = nextPositionDirection[axis];
        if (!nextPositionDirectionForAxis) {
          return;
        }
        var dimension = axis === 'x' ? 'width' : 'height';
        var margin = nextPositionDirectionForAxis.margin,
          minDistance = nextPositionDirectionForAxis.minDistance;
        if (margin < 0) {
          nextPosition[axis] = Math.min(connectedAtPosition[axis] + margin - element[dimension] / 2, previousPosition[axis] - minDistance + margin);
        } else {
          nextPosition[axis] = Math.max(connectedAtPosition[axis] + connectedAtPosition[dimension] + margin + element[dimension] / 2, previousPosition[axis] + minDistance + margin);
        }
      });
      return nextPosition;
    };
  }
  function getConnectedAtPosition(source, position, element) {
    var bounds = {
      x: position.x - element.width / 2,
      y: position.y - element.height / 2,
      width: element.width,
      height: element.height
    };
    var closure = getAutoPlaceClosure(source);
    return find(closure, function (target) {
      if (target === element) {
        return false;
      }
      var orientation = getOrientation(target, bounds, PLACEMENT_DETECTION_PAD);
      return orientation === 'intersect';
    });
  }
  function getConnectedDistance(source, hints) {
    if (!hints) {
      hints = {};
    }
    function getDefaultWeight(connection) {
      return connection.source === source ? 1 : -1;
    }
    var defaultDistance = hints.defaultDistance || DEFAULT_DISTANCE,
      direction = hints.direction || 'e',
      filter = hints.filter,
      getWeight = hints.getWeight || getDefaultWeight,
      maxDistance = hints.maxDistance || DEFAULT_MAX_DISTANCE,
      reference = hints.reference || 'start';
    if (!filter) {
      filter = noneFilter;
    }
    function getDistance(a, b) {
      if (direction === 'n') {
        if (reference === 'start') {
          return asTRBL(a).top - asTRBL(b).bottom;
        } else if (reference === 'center') {
          return asTRBL(a).top - getMid(b).y;
        } else {
          return asTRBL(a).top - asTRBL(b).top;
        }
      } else if (direction === 'w') {
        if (reference === 'start') {
          return asTRBL(a).left - asTRBL(b).right;
        } else if (reference === 'center') {
          return asTRBL(a).left - getMid(b).x;
        } else {
          return asTRBL(a).left - asTRBL(b).left;
        }
      } else if (direction === 's') {
        if (reference === 'start') {
          return asTRBL(b).top - asTRBL(a).bottom;
        } else if (reference === 'center') {
          return getMid(b).y - asTRBL(a).bottom;
        } else {
          return asTRBL(b).bottom - asTRBL(a).bottom;
        }
      } else {
        if (reference === 'start') {
          return asTRBL(b).left - asTRBL(a).right;
        } else if (reference === 'center') {
          return getMid(b).x - asTRBL(a).right;
        } else {
          return asTRBL(b).right - asTRBL(a).right;
        }
      }
    }
    var sourcesDistances = source.incoming.filter(filter).map(function (connection) {
      var weight = getWeight(connection);
      var distance = weight < 0 ? getDistance(connection.source, source) : getDistance(source, connection.source);
      return {
        id: connection.source.id,
        distance: distance,
        weight: weight
      };
    });
    var targetsDistances = source.outgoing.filter(filter).map(function (connection) {
      var weight = getWeight(connection);
      var distance = weight > 0 ? getDistance(source, connection.target) : getDistance(connection.target, source);
      return {
        id: connection.target.id,
        distance: distance,
        weight: weight
      };
    });
    var distances = sourcesDistances.concat(targetsDistances).reduce(function (accumulator, currentValue) {
      accumulator[currentValue.id + '__weight_' + currentValue.weight] = currentValue;
      return accumulator;
    }, {});
    var distancesGrouped = reduce(distances, function (accumulator, currentValue) {
      var distance = currentValue.distance,
        weight = currentValue.weight;
      if (distance < 0 || distance > maxDistance) {
        return accumulator;
      }
      if (!accumulator[String(distance)]) {
        accumulator[String(distance)] = 0;
      }
      accumulator[String(distance)] += 1 * weight;
      if (!accumulator.distance || accumulator[accumulator.distance] < accumulator[String(distance)]) {
        accumulator.distance = distance;
      }
      return accumulator;
    }, {});
    return distancesGrouped.distance || defaultDistance;
  }
  function getAutoPlaceClosure(source) {
    var allConnected = getConnected(source);
    if (source.host) {
      allConnected = allConnected.concat(getConnected(source.host));
    }
    if (source.attachers) {
      allConnected = allConnected.concat(source.attachers.reduce(function (shapes, attacher) {
        return shapes.concat(getConnected(attacher));
      }, []));
    }
    return allConnected;
  }
  function getConnected(element) {
    return getTargets(element).concat(getSources(element));
  }
  function getSources(shape) {
    return shape.incoming.map(function (connection) {
      return connection.source;
    });
  }
  function getTargets(shape) {
    return shape.outgoing.map(function (connection) {
      return connection.target;
    });
  }
  function noneFilter() {
    return true;
  }
  var LOW_PRIORITY$l = 100;
  function AutoPlace$1(eventBus, modeling, canvas) {
    eventBus.on('autoPlace', LOW_PRIORITY$l, function (context) {
      var shape = context.shape,
        source = context.source;
      return getNewShapePosition$1(source, shape);
    });
    eventBus.on('autoPlace.end', function (event) {
      canvas.scrollToElement(event.shape);
    });
    this.append = function (source, shape, hints) {
      eventBus.fire('autoPlace.start', {
        source: source,
        shape: shape
      });
      var position = eventBus.fire('autoPlace', {
        source: source,
        shape: shape
      });
      var newShape = modeling.appendShape(source, shape, position, source.parent, hints);
      eventBus.fire('autoPlace.end', {
        source: source,
        shape: newShape
      });
      return newShape;
    };
  }
  AutoPlace$1.$inject = ['eventBus', 'modeling', 'canvas'];
  function getNewShapePosition$1(source, element, hints) {
    if (!hints) {
      hints = {};
    }
    var distance = hints.defaultDistance || DEFAULT_DISTANCE;
    var sourceMid = getMid(source),
      sourceTrbl = asTRBL(source);
    return {
      x: sourceTrbl.right + distance + element.width / 2,
      y: sourceMid.y
    };
  }
  function AutoPlaceSelectionBehavior(eventBus, selection) {
    eventBus.on('autoPlace.end', 500, function (e) {
      selection.select(e.shape);
    });
  }
  AutoPlaceSelectionBehavior.$inject = ['eventBus', 'selection'];
  var AutoPlaceModule$1 = {
    __init__: ['autoPlaceSelectionBehavior'],
    autoPlace: ['type', AutoPlace$1],
    autoPlaceSelectionBehavior: ['type', AutoPlaceSelectionBehavior]
  };
  function getParent(element, anyType) {
    if (isString(anyType)) {
      anyType = [anyType];
    }
    while (element = element.parent) {
      if (isAny(element, anyType)) {
        return element;
      }
    }
    return null;
  }
  function isDirectionHorizontal(element, elementRegistry) {
    var parent = getParent(element, 'bpmn:Process');
    if (parent) {
      return true;
    }
    var types = ['bpmn:Participant', 'bpmn:Lane'];
    parent = getParent(element, types);
    if (parent) {
      return isHorizontal$3(parent);
    } else if (isAny(element, types)) {
      return isHorizontal$3(element);
    }
    var process;
    for (process = getBusinessObject(element); process; process = process.$parent) {
      if (is(process, 'bpmn:Process')) {
        break;
      }
    }
    if (!elementRegistry) {
      return true;
    }
    var pool = elementRegistry.find(function (shape) {
      var businessObject = getBusinessObject(shape);
      return businessObject && businessObject.get('processRef') === process;
    });
    if (!pool) {
      return true;
    }
    return isHorizontal$3(pool);
  }
  function getNewShapePosition(source, element, elementRegistry) {
    var placeHorizontally = isDirectionHorizontal(source, elementRegistry);
    if (is(element, 'bpmn:TextAnnotation')) {
      return getTextAnnotationPosition(source, element, placeHorizontally);
    }
    if (isAny(element, ['bpmn:DataObjectReference', 'bpmn:DataStoreReference'])) {
      return getDataElementPosition(source, element, placeHorizontally);
    }
    if (is(element, 'bpmn:FlowNode')) {
      return getFlowNodePosition(source, element, placeHorizontally);
    }
  }
  function getFlowNodePosition(source, element, placeHorizontally) {
    var sourceTrbl = asTRBL(source);
    var sourceMid = getMid(source);
    var placement = placeHorizontally ? {
      directionHint: 'e',
      minDistance: 80,
      baseOrientation: 'left',
      boundaryOrientation: 'top',
      start: 'top',
      end: 'bottom'
    } : {
      directionHint: 's',
      minDistance: 90,
      baseOrientation: 'top',
      boundaryOrientation: 'left',
      start: 'left',
      end: 'right'
    };
    var connectedDistance = getConnectedDistance(source, {
      filter: function filter(connection) {
        return is(connection, 'bpmn:SequenceFlow');
      },
      direction: placement.directionHint
    });
    var margin = 30,
      minDistance = placement.minDistance,
      orientation = placement.baseOrientation;
    if (is(source, 'bpmn:BoundaryEvent')) {
      orientation = getOrientation(source, source.host, -25);
      if (orientation.indexOf(placement.boundaryOrientation) !== -1) {
        margin *= -1;
      }
    }
    var position = placeHorizontally ? {
      x: sourceTrbl.right + connectedDistance + element.width / 2,
      y: sourceMid.y + getDistance$2(orientation, minDistance, placement)
    } : {
      x: sourceMid.x + getDistance$2(orientation, minDistance, placement),
      y: sourceTrbl.bottom + connectedDistance + element.height / 2
    };
    var nextPosition = {
      margin: margin,
      minDistance: minDistance
    };
    var nextPositionDirection = placeHorizontally ? {
      y: nextPosition
    } : {
      x: nextPosition
    };
    return findFreePosition(source, element, position, generateGetNextPosition(nextPositionDirection));
  }
  function getDistance$2(orientation, minDistance, placement) {
    if (orientation.includes(placement.start)) {
      return -1 * minDistance;
    } else if (orientation.includes(placement.end)) {
      return minDistance;
    } else {
      return 0;
    }
  }
  function getTextAnnotationPosition(source, element, placeHorizontally) {
    var sourceTrbl = asTRBL(source);
    var position = placeHorizontally ? {
      x: sourceTrbl.right + element.width / 2,
      y: sourceTrbl.top - 50 - element.height / 2
    } : {
      x: sourceTrbl.right + 50 + element.width / 2,
      y: sourceTrbl.bottom + element.height / 2
    };
    if (isConnection(source)) {
      position = getMid(source);
      if (placeHorizontally) {
        position.x += 100;
        position.y -= 50;
      } else {
        position.x += 100;
        position.y += 50;
      }
    }
    var nextPosition = {
      margin: placeHorizontally ? -30 : 30,
      minDistance: 20
    };
    var nextPositionDirection = placeHorizontally ? {
      y: nextPosition
    } : {
      x: nextPosition
    };
    return findFreePosition(source, element, position, generateGetNextPosition(nextPositionDirection));
  }
  function getDataElementPosition(source, element, placeHorizontally) {
    var sourceTrbl = asTRBL(source);
    var position = placeHorizontally ? {
      x: sourceTrbl.right - 10 + element.width / 2,
      y: sourceTrbl.bottom + 40 + element.width / 2
    } : {
      x: sourceTrbl.left - 40 - element.width / 2,
      y: sourceTrbl.bottom - 10 + element.height / 2
    };
    var nextPosition = {
      margin: 30,
      minDistance: 30
    };
    var nextPositionDirection = placeHorizontally ? {
      x: nextPosition
    } : {
      y: nextPosition
    };
    return findFreePosition(source, element, position, generateGetNextPosition(nextPositionDirection));
  }
  function AutoPlace(eventBus, elementRegistry) {
    eventBus.on('autoPlace', function (context) {
      var shape = context.shape,
        source = context.source;
      return getNewShapePosition(source, shape, elementRegistry);
    });
  }
  AutoPlace.$inject = ['eventBus', 'elementRegistry'];
  var AutoPlaceModule = {
    __depends__: [AutoPlaceModule$1],
    __init__: ['bpmnAutoPlace'],
    bpmnAutoPlace: ['type', AutoPlace]
  };
  function AutoResize(eventBus, elementRegistry, modeling, rules) {
    CommandInterceptor.call(this, eventBus);
    this._elementRegistry = elementRegistry;
    this._modeling = modeling;
    this._rules = rules;
    var self = this;
    this.postExecuted(['shape.create'], function (event) {
      var context = event.context,
        hints = context.hints || {},
        shape = context.shape,
        parent = context.parent || context.newParent;
      if (hints.autoResize === false) {
        return;
      }
      self._expand([shape], parent);
    });
    this.postExecuted(['elements.move'], function (event) {
      var context = event.context,
        elements = flatten(values(context.closure.topLevel)),
        hints = context.hints;
      var autoResize = hints ? hints.autoResize : true;
      if (autoResize === false) {
        return;
      }
      var expandings = groupBy(elements, function (element) {
        return element.parent.id;
      });
      forEach$1(expandings, function (elements, parentId) {
        if (isArray$3(autoResize)) {
          elements = elements.filter(function (element) {
            return find(autoResize, matchPattern({
              id: element.id
            }));
          });
        }
        self._expand(elements, parentId);
      });
    });
    this.postExecuted(['shape.toggleCollapse'], function (event) {
      var context = event.context,
        hints = context.hints,
        shape = context.shape;
      if (hints && hints.autoResize === false) {
        return;
      }
      if (shape.collapsed) {
        return;
      }
      self._expand(shape.children || [], shape);
    });
    this.postExecuted(['shape.resize'], function (event) {
      var context = event.context,
        hints = context.hints,
        shape = context.shape,
        parent = shape.parent;
      if (hints && hints.autoResize === false) {
        return;
      }
      if (parent) {
        self._expand([shape], parent);
      }
    });
  }
  AutoResize.$inject = ['eventBus', 'elementRegistry', 'modeling', 'rules'];
  e$2(AutoResize, CommandInterceptor);
  AutoResize.prototype._getOptimalBounds = function (elements, target) {
    var offset = this.getOffset(target),
      padding = this.getPadding(target);
    var elementsTrbl = asTRBL(getBBox(elements)),
      targetTrbl = asTRBL(target);
    var newTrbl = {};
    if (elementsTrbl.top - targetTrbl.top < padding.top) {
      newTrbl.top = elementsTrbl.top - offset.top;
    }
    if (elementsTrbl.left - targetTrbl.left < padding.left) {
      newTrbl.left = elementsTrbl.left - offset.left;
    }
    if (targetTrbl.right - elementsTrbl.right < padding.right) {
      newTrbl.right = elementsTrbl.right + offset.right;
    }
    if (targetTrbl.bottom - elementsTrbl.bottom < padding.bottom) {
      newTrbl.bottom = elementsTrbl.bottom + offset.bottom;
    }
    return asBounds(assign$1({}, targetTrbl, newTrbl));
  };
  AutoResize.prototype._expand = function (elements, target) {
    if (typeof target === 'string') {
      target = this._elementRegistry.get(target);
    }
    var allowed = this._rules.allowed('element.autoResize', {
      elements: elements,
      target: target
    });
    if (!allowed) {
      return;
    }
    var newBounds = this._getOptimalBounds(elements, target);
    if (!boundsChanged$1(newBounds, target)) {
      return;
    }
    var resizeDirections = getResizeDirections(pick(target, ['x', 'y', 'width', 'height']), newBounds);
    this.resize(target, newBounds, {
      autoResize: resizeDirections
    });
    var parent = target.parent;
    if (parent) {
      this._expand([target], parent);
    }
  };
  AutoResize.prototype.getOffset = function (shape) {
    return {
      top: 60,
      bottom: 60,
      left: 100,
      right: 100
    };
  };
  AutoResize.prototype.getPadding = function (shape) {
    return {
      top: 2,
      bottom: 2,
      left: 15,
      right: 15
    };
  };
  AutoResize.prototype.resize = function (shape, newBounds, hints) {
    this._modeling.resizeShape(shape, newBounds, null, hints);
  };
  function boundsChanged$1(newBounds, oldBounds) {
    return newBounds.x !== oldBounds.x || newBounds.y !== oldBounds.y || newBounds.width !== oldBounds.width || newBounds.height !== oldBounds.height;
  }
  function getResizeDirections(oldBounds, newBounds) {
    var directions = '';
    oldBounds = asTRBL(oldBounds);
    newBounds = asTRBL(newBounds);
    if (oldBounds.top > newBounds.top) {
      directions = directions.concat('n');
    }
    if (oldBounds.right < newBounds.right) {
      directions = directions.concat('w');
    }
    if (oldBounds.bottom < newBounds.bottom) {
      directions = directions.concat('s');
    }
    if (oldBounds.left > newBounds.left) {
      directions = directions.concat('e');
    }
    return directions;
  }
  function BpmnAutoResize(injector) {
    injector.invoke(AutoResize, this);
  }
  BpmnAutoResize.$inject = ['injector'];
  e$2(BpmnAutoResize, AutoResize);
  BpmnAutoResize.prototype.resize = function (target, newBounds, hints) {
    if (is(target, 'bpmn:Participant')) {
      this._modeling.resizeLane(target, newBounds, null, hints);
    } else {
      this._modeling.resizeShape(target, newBounds, null, hints);
    }
  };
  function AutoResizeProvider(eventBus) {
    RuleProvider.call(this, eventBus);
    var self = this;
    this.addRule('element.autoResize', function (context) {
      return self.canResize(context.elements, context.target);
    });
  }
  AutoResizeProvider.$inject = ['eventBus'];
  e$2(AutoResizeProvider, RuleProvider);
  AutoResizeProvider.prototype.canResize = function (elements, target) {
    return false;
  };
  function BpmnAutoResizeProvider(eventBus, modeling) {
    AutoResizeProvider.call(this, eventBus);
    this._modeling = modeling;
  }
  e$2(BpmnAutoResizeProvider, AutoResizeProvider);
  BpmnAutoResizeProvider.$inject = ['eventBus', 'modeling'];
  BpmnAutoResizeProvider.prototype.canResize = function (elements, target) {
    if (is(target.di, 'bpmndi:BPMNPlane')) {
      return false;
    }
    if (!is(target, 'bpmn:Participant') && !is(target, 'bpmn:Lane') && !is(target, 'bpmn:SubProcess')) {
      return false;
    }
    var canResize = true;
    forEach$1(elements, function (element) {
      if (is(element, 'bpmn:Lane') || isLabel(element)) {
        canResize = false;
        return;
      }
    });
    return canResize;
  };
  var AutoResizeModule = {
    __init__: ['bpmnAutoResize', 'bpmnAutoResizeProvider'],
    bpmnAutoResize: ['type', BpmnAutoResize],
    bpmnAutoResizeProvider: ['type', BpmnAutoResizeProvider]
  };
  var HIGH_PRIORITY$j = 1500;
  function HoverFix(elementRegistry, eventBus, injector) {
    var self = this;
    var dragging = injector.get('dragging', false);
    function ensureHover(event) {
      if (event.hover) {
        return;
      }
      var originalEvent = event.originalEvent;
      var gfx = self._findTargetGfx(originalEvent);
      var element = gfx && elementRegistry.get(gfx);
      if (gfx && element) {
        event.stopPropagation();
        dragging.hover({
          element: element,
          gfx: gfx
        });
        dragging.move(originalEvent);
      }
    }
    if (dragging) {
      eventBus.on('drag.start', function (event) {
        eventBus.once('drag.move', HIGH_PRIORITY$j, function (event) {
          ensureHover(event);
        });
      });
    }
    (function () {
      var hoverGfx;
      var hover;
      eventBus.on('element.hover', function (event) {
        hoverGfx = event.gfx;
        hover = event.element;
      });
      eventBus.on('element.hover', HIGH_PRIORITY$j, function (event) {
        if (hover) {
          eventBus.fire('element.out', {
            element: hover,
            gfx: hoverGfx
          });
        }
      });
      eventBus.on('element.out', function () {
        hoverGfx = null;
        hover = null;
      });
    })();
    this._findTargetGfx = function (event) {
      var position, target;
      if (!(event instanceof MouseEvent)) {
        return;
      }
      position = toPoint(event);
      target = document.elementFromPoint(position.x, position.y);
      return getGfx(target);
    };
  }
  HoverFix.$inject = ['elementRegistry', 'eventBus', 'injector'];
  function getGfx(target) {
    return closest(target, 'svg, .djs-element', true);
  }
  var HoverFixModule = {
    __init__: ['hoverFix'],
    hoverFix: ['type', HoverFix]
  };
  var round$b = Math.round;
  var DRAG_ACTIVE_CLS = 'djs-drag-active';
  function preventDefault$1(event) {
    event.preventDefault();
  }
  function isTouchEvent(event) {
    return typeof TouchEvent !== 'undefined' && event instanceof TouchEvent;
  }
  function getLength(point) {
    return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));
  }
  function Dragging(eventBus, canvas, selection, elementRegistry) {
    var defaultOptions = {
      threshold: 5,
      trapClick: true
    };
    var context;
    function toLocalPoint(globalPosition) {
      var viewbox = canvas.viewbox();
      var clientRect = canvas._container.getBoundingClientRect();
      return {
        x: viewbox.x + (globalPosition.x - clientRect.left) / viewbox.scale,
        y: viewbox.y + (globalPosition.y - clientRect.top) / viewbox.scale
      };
    }
    function fire(type, dragContext) {
      dragContext = dragContext || context;
      var event = eventBus.createEvent(assign$1({}, dragContext.payload, dragContext.data, {
        isTouch: dragContext.isTouch
      }));
      if (eventBus.fire('drag.' + type, event) === false) {
        return false;
      }
      return eventBus.fire(dragContext.prefix + '.' + type, event);
    }
    function restoreSelection(previousSelection) {
      var existingSelection = previousSelection.filter(function (element) {
        return elementRegistry.get(element.id);
      });
      existingSelection.length && selection.select(existingSelection);
    }
    function move(event, activate) {
      var payload = context.payload,
        displacement = context.displacement;
      var globalStart = context.globalStart,
        globalCurrent = toPoint(event),
        globalDelta = delta(globalCurrent, globalStart);
      var localStart = context.localStart,
        localCurrent = toLocalPoint(globalCurrent),
        localDelta = delta(localCurrent, localStart);
      if (!context.active && (activate || getLength(globalDelta) > context.threshold)) {
        assign$1(payload, {
          x: round$b(localStart.x + displacement.x),
          y: round$b(localStart.y + displacement.y),
          dx: 0,
          dy: 0
        }, {
          originalEvent: event
        });
        if (false === fire('start')) {
          return cancel();
        }
        context.active = true;
        if (!context.keepSelection) {
          payload.previousSelection = selection.get();
          selection.select(null);
        }
        if (context.cursor) {
          set(context.cursor);
        }
        canvas.addMarker(canvas.getRootElement(), DRAG_ACTIVE_CLS);
      }
      stopPropagation$1(event);
      if (context.active) {
        assign$1(payload, {
          x: round$b(localCurrent.x + displacement.x),
          y: round$b(localCurrent.y + displacement.y),
          dx: round$b(localDelta.x),
          dy: round$b(localDelta.y)
        }, {
          originalEvent: event
        });
        fire('move');
      }
    }
    function end(event) {
      var previousContext,
        returnValue = true;
      if (context.active) {
        if (event) {
          context.payload.originalEvent = event;
          stopPropagation$1(event);
        }
        returnValue = fire('end');
      }
      if (returnValue === false) {
        fire('rejected');
      }
      previousContext = cleanup(returnValue !== true);
      fire('ended', previousContext);
    }
    function checkCancel(event) {
      if (isKey('Escape', event)) {
        preventDefault$1(event);
        cancel();
      }
    }
    function trapClickAndEnd(event) {
      var untrap;
      if (context.active) {
        untrap = install(eventBus);
        setTimeout(untrap, 400);
        preventDefault$1(event);
      }
      end(event);
    }
    function trapTouch(event) {
      move(event);
    }
    function hover(event) {
      var payload = context.payload;
      payload.hoverGfx = event.gfx;
      payload.hover = event.element;
      fire('hover');
    }
    function out(event) {
      fire('out');
      var payload = context.payload;
      payload.hoverGfx = null;
      payload.hover = null;
    }
    function cancel(restore) {
      var previousContext;
      if (!context) {
        return;
      }
      var wasActive = context.active;
      if (wasActive) {
        fire('cancel');
      }
      previousContext = cleanup(restore);
      if (wasActive) {
        fire('canceled', previousContext);
      }
    }
    function cleanup(restore) {
      var previousContext, endDrag;
      fire('cleanup');
      unset();
      if (context.trapClick) {
        endDrag = trapClickAndEnd;
      } else {
        endDrag = end;
      }
      event.unbind(document, 'mousemove', move);
      event.unbind(document, 'dragstart', preventDefault$1);
      event.unbind(document, 'selectstart', preventDefault$1);
      event.unbind(document, 'mousedown', endDrag, true);
      event.unbind(document, 'mouseup', endDrag, true);
      event.unbind(document, 'keyup', checkCancel);
      event.unbind(document, 'touchstart', trapTouch, true);
      event.unbind(document, 'touchcancel', cancel, true);
      event.unbind(document, 'touchmove', move, true);
      event.unbind(document, 'touchend', end, true);
      eventBus.off('element.hover', hover);
      eventBus.off('element.out', out);
      canvas.removeMarker(canvas.getRootElement(), DRAG_ACTIVE_CLS);
      var previousSelection = context.payload.previousSelection;
      if (restore !== false && previousSelection && !selection.get().length) {
        restoreSelection(previousSelection);
      }
      previousContext = context;
      context = null;
      return previousContext;
    }
    function init(event$1, relativeTo, prefix, options) {
      if (context) {
        cancel(false);
      }
      if (typeof relativeTo === 'string') {
        options = prefix;
        prefix = relativeTo;
        relativeTo = null;
      }
      options = assign$1({}, defaultOptions, options || {});
      var data = options.data || {},
        originalEvent,
        globalStart,
        localStart,
        endDrag,
        isTouch;
      if (options.trapClick) {
        endDrag = trapClickAndEnd;
      } else {
        endDrag = end;
      }
      if (event$1) {
        originalEvent = getOriginal$1(event$1) || event$1;
        globalStart = toPoint(event$1);
        stopPropagation$1(event$1);
        if (originalEvent.type === 'dragstart') {
          preventDefault$1(originalEvent);
        }
      } else {
        originalEvent = null;
        globalStart = {
          x: 0,
          y: 0
        };
      }
      localStart = toLocalPoint(globalStart);
      if (!relativeTo) {
        relativeTo = localStart;
      }
      isTouch = isTouchEvent(originalEvent);
      context = assign$1({
        prefix: prefix,
        data: data,
        payload: {},
        globalStart: globalStart,
        displacement: delta(relativeTo, localStart),
        localStart: localStart,
        isTouch: isTouch
      }, options);
      if (!options.manual) {
        if (isTouch) {
          event.bind(document, 'touchstart', trapTouch, true);
          event.bind(document, 'touchcancel', cancel, true);
          event.bind(document, 'touchmove', move, true);
          event.bind(document, 'touchend', end, true);
        } else {
          event.bind(document, 'mousemove', move);
          event.bind(document, 'dragstart', preventDefault$1);
          event.bind(document, 'selectstart', preventDefault$1);
          event.bind(document, 'mousedown', endDrag, true);
          event.bind(document, 'mouseup', endDrag, true);
        }
        event.bind(document, 'keyup', checkCancel);
        eventBus.on('element.hover', hover);
        eventBus.on('element.out', out);
      }
      fire('init');
      if (options.autoActivate) {
        move(event$1, true);
      }
    }
    eventBus.on('diagram.destroy', cancel);
    this.init = init;
    this.move = move;
    this.hover = hover;
    this.out = out;
    this.end = end;
    this.cancel = cancel;
    this.context = function () {
      return context;
    };
    this.setOptions = function (options) {
      assign$1(defaultOptions, options);
    };
  }
  Dragging.$inject = ['eventBus', 'canvas', 'selection', 'elementRegistry'];
  var DraggingModule = {
    __depends__: [HoverFixModule, SelectionModule],
    dragging: ['type', Dragging]
  };
  function AutoScroll(config, eventBus, canvas) {
    this._canvas = canvas;
    this._opts = assign$1({
      scrollThresholdIn: [20, 20, 20, 20],
      scrollThresholdOut: [0, 0, 0, 0],
      scrollRepeatTimeout: 15,
      scrollStep: 10
    }, config);
    var self = this;
    eventBus.on('drag.move', function (e) {
      var point = self._toBorderPoint(e);
      self.startScroll(point);
    });
    eventBus.on(['drag.cleanup'], function () {
      self.stopScroll();
    });
  }
  AutoScroll.$inject = ['config.autoScroll', 'eventBus', 'canvas'];
  AutoScroll.prototype.startScroll = function (point) {
    var canvas = this._canvas;
    var opts = this._opts;
    var self = this;
    var clientRect = canvas.getContainer().getBoundingClientRect();
    var diff = [point.x, point.y, clientRect.width - point.x, clientRect.height - point.y];
    this.stopScroll();
    var dx = 0,
      dy = 0;
    for (var i = 0; i < 4; i++) {
      if (between(diff[i], opts.scrollThresholdOut[i], opts.scrollThresholdIn[i])) {
        if (i === 0) {
          dx = opts.scrollStep;
        } else if (i == 1) {
          dy = opts.scrollStep;
        } else if (i == 2) {
          dx = -opts.scrollStep;
        } else if (i == 3) {
          dy = -opts.scrollStep;
        }
      }
    }
    if (dx !== 0 || dy !== 0) {
      canvas.scroll({
        dx: dx,
        dy: dy
      });
      this._scrolling = setTimeout(function () {
        self.startScroll(point);
      }, opts.scrollRepeatTimeout);
    }
  };
  function between(val, start, end) {
    if (start < val && val < end) {
      return true;
    }
    return false;
  }
  AutoScroll.prototype.stopScroll = function () {
    clearTimeout(this._scrolling);
  };
  AutoScroll.prototype.setOptions = function (options) {
    this._opts = assign$1({}, this._opts, options);
  };
  AutoScroll.prototype._toBorderPoint = function (event) {
    var clientRect = this._canvas._container.getBoundingClientRect();
    var globalPosition = toPoint(event.originalEvent);
    return {
      x: globalPosition.x - clientRect.left,
      y: globalPosition.y - clientRect.top
    };
  };
  var AutoScrollModule = {
    __depends__: [DraggingModule],
    __init__: ['autoScroll'],
    autoScroll: ['type', AutoScroll]
  };
  function Rules(injector) {
    this._commandStack = injector.get('commandStack', false);
  }
  Rules.$inject = ['injector'];
  Rules.prototype.allowed = function (action, context) {
    var allowed = true;
    var commandStack = this._commandStack;
    if (commandStack) {
      allowed = commandStack.canExecute(action, context);
    }
    return allowed === undefined ? true : allowed;
  };
  var RulesModule$1 = {
    __init__: ['rules'],
    rules: ['type', Rules]
  };
  var round$a = Math.round,
    max$6 = Math.max;
  function circlePath(center, r) {
    var x = center.x,
      y = center.y;
    return [['M', x, y], ['m', 0, -10], ['a', r, r, 0, 1, 1, 0, 2 * r], ['a', r, r, 0, 1, 1, 0, -2 * r], ['z']];
  }
  function linePath(points) {
    var segments = [];
    points.forEach(function (p, idx) {
      segments.push([idx === 0 ? 'M' : 'L', p.x, p.y]);
    });
    return segments;
  }
  var INTERSECTION_THRESHOLD$1 = 10;
  function getBendpointIntersection(waypoints, reference) {
    var i, w;
    for (i = 0; w = waypoints[i]; i++) {
      if (pointDistance(w, reference) <= INTERSECTION_THRESHOLD$1) {
        return {
          point: waypoints[i],
          bendpoint: true,
          index: i
        };
      }
    }
    return null;
  }
  function getPathIntersection(waypoints, reference) {
    var intersections = findPathIntersections(circlePath(reference, INTERSECTION_THRESHOLD$1), linePath(waypoints));
    var a = intersections[0],
      b = intersections[intersections.length - 1],
      idx;
    if (!a) {
      return null;
    }
    if (a !== b) {
      if (a.segment2 !== b.segment2) {
        idx = max$6(a.segment2, b.segment2) - 1;
        return {
          point: waypoints[idx],
          bendpoint: true,
          index: idx
        };
      }
      return {
        point: {
          x: round$a(a.x + b.x) / 2,
          y: round$a(a.y + b.y) / 2
        },
        index: a.segment2
      };
    }
    return {
      point: {
        x: round$a(a.x),
        y: round$a(a.y)
      },
      index: a.segment2
    };
  }
  function getApproxIntersection(waypoints, reference) {
    return getBendpointIntersection(waypoints, reference) || getPathIntersection(waypoints, reference);
  }
  function vectorLength(vector) {
    return Math.sqrt(Math.pow(vector.x, 2) + Math.pow(vector.y, 2));
  }
  function getAngle(line) {
    return Math.atan((line[1].y - line[0].y) / (line[1].x - line[0].x));
  }
  function rotateVector(vector, angle) {
    return !angle ? vector : {
      x: Math.cos(angle) * vector.x - Math.sin(angle) * vector.y,
      y: Math.sin(angle) * vector.x + Math.cos(angle) * vector.y
    };
  }
  function solveLambaSystem(a, b, c) {
    var system = [{
      n: a[0] - c[0],
      lambda: b[0]
    }, {
      n: a[1] - c[1],
      lambda: b[1]
    }];
    var n = system[0].n * b[0] + system[1].n * b[1],
      l = system[0].lambda * b[0] + system[1].lambda * b[1];
    return -n / l;
  }
  function perpendicularFoot(point, line) {
    var a = line[0],
      b = line[1];
    var bd = {
      x: b.x - a.x,
      y: b.y - a.y
    };
    var r = solveLambaSystem([a.x, a.y], [bd.x, bd.y], [point.x, point.y]);
    return {
      x: a.x + r * bd.x,
      y: a.y + r * bd.y
    };
  }
  function getDistancePointLine(point, line) {
    var pfPoint = perpendicularFoot(point, line);
    var connectionVector = {
      x: pfPoint.x - point.x,
      y: pfPoint.y - point.y
    };
    return vectorLength(connectionVector);
  }
  function getDistancePointPoint(point1, point2) {
    return vectorLength({
      x: point1.x - point2.x,
      y: point1.y - point2.y
    });
  }
  var BENDPOINT_CLS = 'djs-bendpoint';
  var SEGMENT_DRAGGER_CLS = 'djs-segment-dragger';
  function toCanvasCoordinates(canvas, event) {
    var position = toPoint(event),
      clientRect = canvas._container.getBoundingClientRect(),
      offset;
    offset = {
      x: clientRect.left,
      y: clientRect.top
    };
    var viewbox = canvas.viewbox();
    return {
      x: viewbox.x + (position.x - offset.x) / viewbox.scale,
      y: viewbox.y + (position.y - offset.y) / viewbox.scale
    };
  }
  function getConnectionIntersection(canvas, waypoints, event) {
    var localPosition = toCanvasCoordinates(canvas, event),
      intersection = getApproxIntersection(waypoints, localPosition);
    return intersection;
  }
  function addBendpoint(parentGfx, cls) {
    var groupGfx = create$1('g');
    classes(groupGfx).add(BENDPOINT_CLS);
    append(parentGfx, groupGfx);
    var visual = create$1('circle');
    attr(visual, {
      cx: 0,
      cy: 0,
      r: 4
    });
    classes(visual).add('djs-visual');
    append(groupGfx, visual);
    var hit = create$1('circle');
    attr(hit, {
      cx: 0,
      cy: 0,
      r: 10
    });
    classes(hit).add('djs-hit');
    append(groupGfx, hit);
    if (cls) {
      classes(groupGfx).add(cls);
    }
    return groupGfx;
  }
  function createParallelDragger(parentGfx, segmentStart, segmentEnd, alignment) {
    var draggerGfx = create$1('g');
    append(parentGfx, draggerGfx);
    var width = 18,
      height = 6,
      padding = 11,
      hitWidth = calculateHitWidth(segmentStart, segmentEnd, alignment),
      hitHeight = height + padding;
    var visual = create$1('rect');
    attr(visual, {
      x: -18 / 2,
      y: -6 / 2,
      width: width,
      height: height
    });
    classes(visual).add('djs-visual');
    append(draggerGfx, visual);
    var hit = create$1('rect');
    attr(hit, {
      x: -hitWidth / 2,
      y: -17 / 2,
      width: hitWidth,
      height: hitHeight
    });
    classes(hit).add('djs-hit');
    append(draggerGfx, hit);
    rotate(draggerGfx, alignment === 'v' ? 90 : 0);
    return draggerGfx;
  }
  function addSegmentDragger(parentGfx, segmentStart, segmentEnd) {
    var groupGfx = create$1('g'),
      mid = getMidPoint(segmentStart, segmentEnd),
      alignment = pointsAligned(segmentStart, segmentEnd);
    append(parentGfx, groupGfx);
    createParallelDragger(groupGfx, segmentStart, segmentEnd, alignment);
    classes(groupGfx).add(SEGMENT_DRAGGER_CLS);
    classes(groupGfx).add(alignment === 'h' ? 'horizontal' : 'vertical');
    translate$1(groupGfx, mid.x, mid.y);
    return groupGfx;
  }
  function calculateSegmentMoveRegion(segmentLength) {
    return Math.abs(Math.round(segmentLength * 2 / 3));
  }
  function getClosestPointOnConnection(position, connection) {
    var segment = getClosestSegment(position, connection);
    return perpendicularFoot(position, segment);
  }
  function calculateHitWidth(segmentStart, segmentEnd, alignment) {
    var segmentLengthXAxis = segmentEnd.x - segmentStart.x,
      segmentLengthYAxis = segmentEnd.y - segmentStart.y;
    return alignment === 'h' ? calculateSegmentMoveRegion(segmentLengthXAxis) : calculateSegmentMoveRegion(segmentLengthYAxis);
  }
  function getClosestSegment(position, connection) {
    var waypoints = connection.waypoints;
    var minDistance = Infinity,
      segmentIndex;
    for (var i = 0; i < waypoints.length - 1; i++) {
      var start = waypoints[i],
        end = waypoints[i + 1],
        distance = getDistancePointLine(position, [start, end]);
      if (distance < minDistance) {
        minDistance = distance;
        segmentIndex = i;
      }
    }
    return [waypoints[segmentIndex], waypoints[segmentIndex + 1]];
  }
  function Bendpoints(eventBus, canvas, interactionEvents, bendpointMove, connectionSegmentMove) {
    function isIntersectionMiddle(intersection, waypoints, treshold) {
      var idx = intersection.index,
        p = intersection.point,
        p0,
        p1,
        mid,
        aligned,
        xDelta,
        yDelta;
      if (idx <= 0 || intersection.bendpoint) {
        return false;
      }
      p0 = waypoints[idx - 1];
      p1 = waypoints[idx];
      mid = getMidPoint(p0, p1), aligned = pointsAligned(p0, p1);
      xDelta = Math.abs(p.x - mid.x);
      yDelta = Math.abs(p.y - mid.y);
      return aligned && xDelta <= treshold && yDelta <= treshold;
    }
    function calculateIntersectionThreshold(connection, intersection) {
      var waypoints = connection.waypoints,
        relevantSegment,
        alignment,
        segmentLength,
        threshold;
      if (intersection.index <= 0 || intersection.bendpoint) {
        return null;
      }
      relevantSegment = {
        start: waypoints[intersection.index - 1],
        end: waypoints[intersection.index]
      };
      alignment = pointsAligned(relevantSegment.start, relevantSegment.end);
      if (!alignment) {
        return null;
      }
      if (alignment === 'h') {
        segmentLength = relevantSegment.end.x - relevantSegment.start.x;
      } else {
        segmentLength = relevantSegment.end.y - relevantSegment.start.y;
      }
      threshold = calculateSegmentMoveRegion(segmentLength) / 2;
      return threshold;
    }
    function activateBendpointMove(event, connection) {
      var waypoints = connection.waypoints,
        intersection = getConnectionIntersection(canvas, waypoints, event),
        threshold;
      if (!intersection) {
        return;
      }
      threshold = calculateIntersectionThreshold(connection, intersection);
      if (isIntersectionMiddle(intersection, waypoints, threshold)) {
        connectionSegmentMove.start(event, connection, intersection.index);
      } else {
        bendpointMove.start(event, connection, intersection.index, !intersection.bendpoint);
      }
      return true;
    }
    function bindInteractionEvents(node, eventName, element) {
      event.bind(node, eventName, function (event) {
        interactionEvents.triggerMouseEvent(eventName, event, element);
        event.stopPropagation();
      });
    }
    function getBendpointsContainer(element, create) {
      var layer = canvas.getLayer('overlays'),
        gfx = query('.djs-bendpoints[data-element-id="' + escapeCSS(element.id) + '"]', layer);
      if (!gfx && create) {
        gfx = create$1('g');
        attr(gfx, {
          'data-element-id': element.id
        });
        classes(gfx).add('djs-bendpoints');
        append(layer, gfx);
        bindInteractionEvents(gfx, 'mousedown', element);
        bindInteractionEvents(gfx, 'click', element);
        bindInteractionEvents(gfx, 'dblclick', element);
      }
      return gfx;
    }
    function getSegmentDragger(idx, parentGfx) {
      return query('.djs-segment-dragger[data-segment-idx="' + idx + '"]', parentGfx);
    }
    function createBendpoints(gfx, connection) {
      connection.waypoints.forEach(function (p, idx) {
        var bendpoint = addBendpoint(gfx);
        append(gfx, bendpoint);
        translate$1(bendpoint, p.x, p.y);
      });
      addBendpoint(gfx, 'floating');
    }
    function createSegmentDraggers(gfx, connection) {
      var waypoints = connection.waypoints;
      var segmentStart, segmentEnd, segmentDraggerGfx;
      for (var i = 1; i < waypoints.length; i++) {
        segmentStart = waypoints[i - 1];
        segmentEnd = waypoints[i];
        if (pointsAligned(segmentStart, segmentEnd)) {
          segmentDraggerGfx = addSegmentDragger(gfx, segmentStart, segmentEnd);
          attr(segmentDraggerGfx, {
            'data-segment-idx': i
          });
          bindInteractionEvents(segmentDraggerGfx, 'mousemove', connection);
        }
      }
    }
    function clearBendpoints(gfx) {
      forEach$1(all('.' + BENDPOINT_CLS, gfx), function (node) {
        remove$1(node);
      });
    }
    function clearSegmentDraggers(gfx) {
      forEach$1(all('.' + SEGMENT_DRAGGER_CLS, gfx), function (node) {
        remove$1(node);
      });
    }
    function addHandles(connection) {
      var gfx = getBendpointsContainer(connection);
      if (!gfx) {
        gfx = getBendpointsContainer(connection, true);
        createBendpoints(gfx, connection);
        createSegmentDraggers(gfx, connection);
      }
      return gfx;
    }
    function updateHandles(connection) {
      var gfx = getBendpointsContainer(connection);
      if (gfx) {
        clearSegmentDraggers(gfx);
        clearBendpoints(gfx);
        createSegmentDraggers(gfx, connection);
        createBendpoints(gfx, connection);
      }
    }
    function updateFloatingBendpointPosition(parentGfx, intersection) {
      var floating = query('.floating', parentGfx),
        point = intersection.point;
      if (!floating) {
        return;
      }
      translate$1(floating, point.x, point.y);
    }
    function updateSegmentDraggerPosition(parentGfx, intersection, waypoints) {
      var draggerGfx = getSegmentDragger(intersection.index, parentGfx),
        segmentStart = waypoints[intersection.index - 1],
        segmentEnd = waypoints[intersection.index],
        point = intersection.point,
        mid = getMidPoint(segmentStart, segmentEnd),
        alignment = pointsAligned(segmentStart, segmentEnd),
        draggerVisual,
        relativePosition;
      if (!draggerGfx) {
        return;
      }
      draggerVisual = getDraggerVisual(draggerGfx);
      relativePosition = {
        x: point.x - mid.x,
        y: point.y - mid.y
      };
      if (alignment === 'v') {
        relativePosition = {
          x: relativePosition.y,
          y: relativePosition.x
        };
      }
      translate$1(draggerVisual, relativePosition.x, relativePosition.y);
    }
    eventBus.on('connection.changed', function (event) {
      updateHandles(event.element);
    });
    eventBus.on('connection.remove', function (event) {
      var gfx = getBendpointsContainer(event.element);
      if (gfx) {
        remove$1(gfx);
      }
    });
    eventBus.on('element.marker.update', function (event) {
      var element = event.element,
        bendpointsGfx;
      if (!element.waypoints) {
        return;
      }
      bendpointsGfx = addHandles(element);
      if (event.add) {
        classes(bendpointsGfx).add(event.marker);
      } else {
        classes(bendpointsGfx).remove(event.marker);
      }
    });
    eventBus.on('element.mousemove', function (event) {
      var element = event.element,
        waypoints = element.waypoints,
        bendpointsGfx,
        intersection;
      if (waypoints) {
        bendpointsGfx = getBendpointsContainer(element, true);
        intersection = getConnectionIntersection(canvas, waypoints, event.originalEvent);
        if (!intersection) {
          return;
        }
        updateFloatingBendpointPosition(bendpointsGfx, intersection);
        if (!intersection.bendpoint) {
          updateSegmentDraggerPosition(bendpointsGfx, intersection, waypoints);
        }
      }
    });
    eventBus.on('element.mousedown', function (event) {
      if (!isPrimaryButton(event)) {
        return;
      }
      var originalEvent = event.originalEvent,
        element = event.element;
      if (!element.waypoints) {
        return;
      }
      return activateBendpointMove(originalEvent, element);
    });
    eventBus.on('selection.changed', function (event) {
      var newSelection = event.newSelection,
        primary = newSelection[0];
      if (primary && primary.waypoints) {
        addHandles(primary);
      }
    });
    eventBus.on('element.hover', function (event) {
      var element = event.element;
      if (element.waypoints) {
        addHandles(element);
        interactionEvents.registerEvent(event.gfx, 'mousemove', 'element.mousemove');
      }
    });
    eventBus.on('element.out', function (event) {
      interactionEvents.unregisterEvent(event.gfx, 'mousemove', 'element.mousemove');
    });
    eventBus.on('element.updateId', function (context) {
      var element = context.element,
        newId = context.newId;
      if (element.waypoints) {
        var bendpointContainer = getBendpointsContainer(element);
        if (bendpointContainer) {
          attr(bendpointContainer, {
            'data-element-id': newId
          });
        }
      }
    });
    this.addHandles = addHandles;
    this.updateHandles = updateHandles;
    this.getBendpointsContainer = getBendpointsContainer;
    this.getSegmentDragger = getSegmentDragger;
  }
  Bendpoints.$inject = ['eventBus', 'canvas', 'interactionEvents', 'bendpointMove', 'connectionSegmentMove'];
  function getDraggerVisual(draggerGfx) {
    return query('.djs-visual', draggerGfx);
  }
  var round$9 = Math.round;
  var RECONNECT_START$1 = 'reconnectStart',
    RECONNECT_END$1 = 'reconnectEnd',
    UPDATE_WAYPOINTS$1 = 'updateWaypoints';
  function BendpointMove(injector, eventBus, canvas, dragging, rules, modeling) {
    this._injector = injector;
    this.start = function (event, connection, bendpointIndex, insert) {
      var gfx = canvas.getGraphics(connection),
        source = connection.source,
        target = connection.target,
        waypoints = connection.waypoints,
        type;
      if (!insert && bendpointIndex === 0) {
        type = RECONNECT_START$1;
      } else if (!insert && bendpointIndex === waypoints.length - 1) {
        type = RECONNECT_END$1;
      } else {
        type = UPDATE_WAYPOINTS$1;
      }
      var command = type === UPDATE_WAYPOINTS$1 ? 'connection.updateWaypoints' : 'connection.reconnect';
      var allowed = rules.allowed(command, {
        connection: connection,
        source: source,
        target: target
      });
      if (allowed === false) {
        allowed = rules.allowed(command, {
          connection: connection,
          source: target,
          target: source
        });
      }
      if (allowed === false) {
        return;
      }
      dragging.init(event, 'bendpoint.move', {
        data: {
          connection: connection,
          connectionGfx: gfx,
          context: {
            allowed: allowed,
            bendpointIndex: bendpointIndex,
            connection: connection,
            source: source,
            target: target,
            insert: insert,
            type: type
          }
        }
      });
    };
    eventBus.on('bendpoint.move.hover', function (event) {
      var context = event.context,
        connection = context.connection,
        source = connection.source,
        target = connection.target,
        hover = event.hover,
        type = context.type;
      context.hover = hover;
      var allowed;
      if (!hover) {
        return;
      }
      var command = type === UPDATE_WAYPOINTS$1 ? 'connection.updateWaypoints' : 'connection.reconnect';
      allowed = context.allowed = rules.allowed(command, {
        connection: connection,
        source: type === RECONNECT_START$1 ? hover : source,
        target: type === RECONNECT_END$1 ? hover : target
      });
      if (allowed) {
        context.source = type === RECONNECT_START$1 ? hover : source;
        context.target = type === RECONNECT_END$1 ? hover : target;
        return;
      }
      if (allowed === false) {
        allowed = context.allowed = rules.allowed(command, {
          connection: connection,
          source: type === RECONNECT_END$1 ? hover : target,
          target: type === RECONNECT_START$1 ? hover : source
        });
      }
      if (allowed) {
        context.source = type === RECONNECT_END$1 ? hover : target;
        context.target = type === RECONNECT_START$1 ? hover : source;
      }
    });
    eventBus.on(['bendpoint.move.out', 'bendpoint.move.cleanup'], function (event) {
      var context = event.context,
        type = context.type;
      context.hover = null;
      context.source = null;
      context.target = null;
      if (type !== UPDATE_WAYPOINTS$1) {
        context.allowed = false;
      }
    });
    eventBus.on('bendpoint.move.end', function (event) {
      var context = event.context,
        allowed = context.allowed,
        bendpointIndex = context.bendpointIndex,
        connection = context.connection,
        insert = context.insert,
        newWaypoints = connection.waypoints.slice(),
        source = context.source,
        target = context.target,
        type = context.type,
        hints = context.hints || {};
      var docking = {
        x: round$9(event.x),
        y: round$9(event.y)
      };
      if (!allowed) {
        return false;
      }
      if (type === UPDATE_WAYPOINTS$1) {
        if (insert) {
          newWaypoints.splice(bendpointIndex, 0, docking);
        } else {
          newWaypoints[bendpointIndex] = docking;
        }
        hints.bendpointMove = {
          insert: insert,
          bendpointIndex: bendpointIndex
        };
        newWaypoints = this.cropWaypoints(connection, newWaypoints);
        modeling.updateWaypoints(connection, filterRedundantWaypoints(newWaypoints), hints);
      } else {
        if (type === RECONNECT_START$1) {
          hints.docking = 'source';
          if (isReverse$2(context)) {
            hints.docking = 'target';
            hints.newWaypoints = newWaypoints.reverse();
          }
        } else if (type === RECONNECT_END$1) {
          hints.docking = 'target';
          if (isReverse$2(context)) {
            hints.docking = 'source';
            hints.newWaypoints = newWaypoints.reverse();
          }
        }
        modeling.reconnect(connection, source, target, docking, hints);
      }
    }, this);
  }
  BendpointMove.$inject = ['injector', 'eventBus', 'canvas', 'dragging', 'rules', 'modeling'];
  BendpointMove.prototype.cropWaypoints = function (connection, newWaypoints) {
    var connectionDocking = this._injector.get('connectionDocking', false);
    if (!connectionDocking) {
      return newWaypoints;
    }
    var waypoints = connection.waypoints;
    connection.waypoints = newWaypoints;
    connection.waypoints = connectionDocking.getCroppedWaypoints(connection);
    newWaypoints = connection.waypoints;
    connection.waypoints = waypoints;
    return newWaypoints;
  };
  function isReverse$2(context) {
    var hover = context.hover,
      source = context.source,
      target = context.target,
      type = context.type;
    if (type === RECONNECT_START$1) {
      return hover && target && hover === target && source !== target;
    }
    if (type === RECONNECT_END$1) {
      return hover && source && hover === source && source !== target;
    }
  }
  var RECONNECT_START = 'reconnectStart',
    RECONNECT_END = 'reconnectEnd',
    UPDATE_WAYPOINTS = 'updateWaypoints';
  var MARKER_OK$4 = 'connect-ok',
    MARKER_NOT_OK$4 = 'connect-not-ok',
    MARKER_CONNECT_HOVER$1 = 'connect-hover',
    MARKER_CONNECT_UPDATING$1 = 'djs-updating',
    MARKER_DRAGGER = 'djs-dragging';
  var HIGH_PRIORITY$i = 1100;
  function BendpointMovePreview(bendpointMove, injector, eventBus, canvas) {
    this._injector = injector;
    var connectionPreview = injector.get('connectionPreview', false);
    eventBus.on('bendpoint.move.start', function (event) {
      var context = event.context,
        bendpointIndex = context.bendpointIndex,
        connection = context.connection,
        insert = context.insert,
        waypoints = connection.waypoints,
        newWaypoints = waypoints.slice();
      context.waypoints = waypoints;
      if (insert) {
        newWaypoints.splice(bendpointIndex, 0, {
          x: event.x,
          y: event.y
        });
      }
      connection.waypoints = newWaypoints;
      var draggerGfx = context.draggerGfx = addBendpoint(canvas.getLayer('overlays'));
      classes(draggerGfx).add('djs-dragging');
      canvas.addMarker(connection, MARKER_DRAGGER);
      canvas.addMarker(connection, MARKER_CONNECT_UPDATING$1);
    });
    eventBus.on('bendpoint.move.hover', function (event) {
      var context = event.context,
        allowed = context.allowed,
        hover = context.hover,
        type = context.type;
      if (hover) {
        canvas.addMarker(hover, MARKER_CONNECT_HOVER$1);
        if (type === UPDATE_WAYPOINTS) {
          return;
        }
        if (allowed) {
          canvas.removeMarker(hover, MARKER_NOT_OK$4);
          canvas.addMarker(hover, MARKER_OK$4);
        } else if (allowed === false) {
          canvas.removeMarker(hover, MARKER_OK$4);
          canvas.addMarker(hover, MARKER_NOT_OK$4);
        }
      }
    });
    eventBus.on(['bendpoint.move.out', 'bendpoint.move.cleanup'], HIGH_PRIORITY$i, function (event) {
      var context = event.context,
        hover = context.hover,
        target = context.target;
      if (hover) {
        canvas.removeMarker(hover, MARKER_CONNECT_HOVER$1);
        canvas.removeMarker(hover, target ? MARKER_OK$4 : MARKER_NOT_OK$4);
      }
    });
    eventBus.on('bendpoint.move.move', function (event) {
      var context = event.context,
        allowed = context.allowed,
        bendpointIndex = context.bendpointIndex,
        draggerGfx = context.draggerGfx,
        hover = context.hover,
        type = context.type,
        connection = context.connection,
        source = connection.source,
        target = connection.target,
        newWaypoints = connection.waypoints.slice(),
        bendpoint = {
          x: event.x,
          y: event.y
        },
        hints = context.hints || {},
        drawPreviewHints = {};
      if (connectionPreview) {
        if (hints.connectionStart) {
          drawPreviewHints.connectionStart = hints.connectionStart;
        }
        if (hints.connectionEnd) {
          drawPreviewHints.connectionEnd = hints.connectionEnd;
        }
        if (type === RECONNECT_START) {
          if (isReverse$2(context)) {
            drawPreviewHints.connectionEnd = drawPreviewHints.connectionEnd || bendpoint;
            drawPreviewHints.source = target;
            drawPreviewHints.target = hover || source;
            newWaypoints = newWaypoints.reverse();
          } else {
            drawPreviewHints.connectionStart = drawPreviewHints.connectionStart || bendpoint;
            drawPreviewHints.source = hover || source;
            drawPreviewHints.target = target;
          }
        } else if (type === RECONNECT_END) {
          if (isReverse$2(context)) {
            drawPreviewHints.connectionStart = drawPreviewHints.connectionStart || bendpoint;
            drawPreviewHints.source = hover || target;
            drawPreviewHints.target = source;
            newWaypoints = newWaypoints.reverse();
          } else {
            drawPreviewHints.connectionEnd = drawPreviewHints.connectionEnd || bendpoint;
            drawPreviewHints.source = source;
            drawPreviewHints.target = hover || target;
          }
        } else {
          drawPreviewHints.noCropping = true;
          drawPreviewHints.noLayout = true;
          newWaypoints[bendpointIndex] = bendpoint;
        }
        if (type === UPDATE_WAYPOINTS) {
          newWaypoints = bendpointMove.cropWaypoints(connection, newWaypoints);
        }
        drawPreviewHints.waypoints = newWaypoints;
        connectionPreview.drawPreview(context, allowed, drawPreviewHints);
      }
      translate$1(draggerGfx, event.x, event.y);
    }, this);
    eventBus.on(['bendpoint.move.end', 'bendpoint.move.cancel'], HIGH_PRIORITY$i, function (event) {
      var context = event.context,
        connection = context.connection,
        draggerGfx = context.draggerGfx,
        hover = context.hover,
        target = context.target,
        waypoints = context.waypoints;
      connection.waypoints = waypoints;
      remove$1(draggerGfx);
      canvas.removeMarker(connection, MARKER_CONNECT_UPDATING$1);
      canvas.removeMarker(connection, MARKER_DRAGGER);
      if (hover) {
        canvas.removeMarker(hover, MARKER_OK$4);
        canvas.removeMarker(hover, target ? MARKER_OK$4 : MARKER_NOT_OK$4);
      }
      if (connectionPreview) {
        connectionPreview.cleanUp(context);
      }
    });
  }
  BendpointMovePreview.$inject = ['bendpointMove', 'injector', 'eventBus', 'canvas'];
  var MARKER_CONNECT_HOVER = 'connect-hover',
    MARKER_CONNECT_UPDATING = 'djs-updating';
  function axisAdd(point, axis, delta) {
    return axisSet(point, axis, point[axis] + delta);
  }
  function axisSet(point, axis, value) {
    return {
      x: axis === 'x' ? value : point.x,
      y: axis === 'y' ? value : point.y
    };
  }
  function axisFenced(position, segmentStart, segmentEnd, axis) {
    var maxValue = Math.max(segmentStart[axis], segmentEnd[axis]),
      minValue = Math.min(segmentStart[axis], segmentEnd[axis]);
    var padding = 20;
    var fencedValue = Math.min(Math.max(minValue + padding, position[axis]), maxValue - padding);
    return axisSet(segmentStart, axis, fencedValue);
  }
  function flipAxis(axis) {
    return axis === 'x' ? 'y' : 'x';
  }
  function getDocking$2(point, referenceElement, moveAxis) {
    var referenceMid, inverseAxis;
    if (point.original) {
      return point.original;
    } else {
      referenceMid = getMid(referenceElement);
      inverseAxis = flipAxis(moveAxis);
      return axisSet(point, inverseAxis, referenceMid[inverseAxis]);
    }
  }
  function ConnectionSegmentMove(injector, eventBus, canvas, dragging, graphicsFactory, modeling) {
    var connectionDocking = injector.get('connectionDocking', false);
    this.start = function (event, connection, idx) {
      var context,
        gfx = canvas.getGraphics(connection),
        segmentStartIndex = idx - 1,
        segmentEndIndex = idx,
        waypoints = connection.waypoints,
        segmentStart = waypoints[segmentStartIndex],
        segmentEnd = waypoints[segmentEndIndex],
        intersection = getConnectionIntersection(canvas, waypoints, event),
        direction,
        axis,
        dragPosition;
      direction = pointsAligned(segmentStart, segmentEnd);
      if (!direction) {
        return;
      }
      axis = direction === 'v' ? 'x' : 'y';
      if (segmentStartIndex === 0) {
        segmentStart = getDocking$2(segmentStart, connection.source, axis);
      }
      if (segmentEndIndex === waypoints.length - 1) {
        segmentEnd = getDocking$2(segmentEnd, connection.target, axis);
      }
      if (intersection) {
        dragPosition = intersection.point;
      } else {
        dragPosition = {
          x: (segmentStart.x + segmentEnd.x) / 2,
          y: (segmentStart.y + segmentEnd.y) / 2
        };
      }
      context = {
        connection: connection,
        segmentStartIndex: segmentStartIndex,
        segmentEndIndex: segmentEndIndex,
        segmentStart: segmentStart,
        segmentEnd: segmentEnd,
        axis: axis,
        dragPosition: dragPosition
      };
      dragging.init(event, dragPosition, 'connectionSegment.move', {
        cursor: axis === 'x' ? 'resize-ew' : 'resize-ns',
        data: {
          connection: connection,
          connectionGfx: gfx,
          context: context
        }
      });
    };
    function cropConnection(connection, newWaypoints) {
      if (!connectionDocking) {
        return newWaypoints;
      }
      var oldWaypoints = connection.waypoints,
        croppedWaypoints;
      connection.waypoints = newWaypoints;
      croppedWaypoints = connectionDocking.getCroppedWaypoints(connection);
      connection.waypoints = oldWaypoints;
      return croppedWaypoints;
    }
    function redrawConnection(data) {
      graphicsFactory.update('connection', data.connection, data.connectionGfx);
    }
    function updateDragger(context, segmentOffset, event) {
      var newWaypoints = context.newWaypoints,
        segmentStartIndex = context.segmentStartIndex + segmentOffset,
        segmentStart = newWaypoints[segmentStartIndex],
        segmentEndIndex = context.segmentEndIndex + segmentOffset,
        segmentEnd = newWaypoints[segmentEndIndex],
        axis = flipAxis(context.axis);
      var draggerPosition = axisFenced(event, segmentStart, segmentEnd, axis);
      translate$1(context.draggerGfx, draggerPosition.x, draggerPosition.y);
    }
    function filterRedundantWaypoints(waypoints, segmentStartIndex) {
      var segmentOffset = 0;
      var filteredWaypoints = waypoints.filter(function (r, idx) {
        if (pointsOnLine(waypoints[idx - 1], waypoints[idx + 1], r)) {
          segmentOffset = idx <= segmentStartIndex ? segmentOffset - 1 : segmentOffset;
          return false;
        }
        return true;
      });
      return {
        waypoints: filteredWaypoints,
        segmentOffset: segmentOffset
      };
    }
    eventBus.on('connectionSegment.move.start', function (event) {
      var context = event.context,
        connection = event.connection,
        layer = canvas.getLayer('overlays');
      context.originalWaypoints = connection.waypoints.slice();
      context.draggerGfx = addSegmentDragger(layer, context.segmentStart, context.segmentEnd);
      classes(context.draggerGfx).add('djs-dragging');
      canvas.addMarker(connection, MARKER_CONNECT_UPDATING);
    });
    eventBus.on('connectionSegment.move.move', function (event) {
      var context = event.context,
        connection = context.connection,
        segmentStartIndex = context.segmentStartIndex,
        segmentEndIndex = context.segmentEndIndex,
        segmentStart = context.segmentStart,
        segmentEnd = context.segmentEnd,
        axis = context.axis;
      var newWaypoints = context.originalWaypoints.slice(),
        newSegmentStart = axisAdd(segmentStart, axis, event['d' + axis]),
        newSegmentEnd = axisAdd(segmentEnd, axis, event['d' + axis]);
      var waypointCount = newWaypoints.length,
        segmentOffset = 0;
      newWaypoints[segmentStartIndex] = newSegmentStart;
      newWaypoints[segmentEndIndex] = newSegmentEnd;
      var sourceToSegmentOrientation, targetToSegmentOrientation;
      if (segmentStartIndex < 2) {
        sourceToSegmentOrientation = getOrientation(connection.source, newSegmentStart);
        if (segmentStartIndex === 1) {
          if (sourceToSegmentOrientation === 'intersect') {
            newWaypoints.shift();
            newWaypoints[0] = newSegmentStart;
            segmentOffset--;
          }
        } else {
          if (sourceToSegmentOrientation !== 'intersect') {
            newWaypoints.unshift(segmentStart);
            segmentOffset++;
          }
        }
      }
      if (segmentEndIndex > waypointCount - 3) {
        targetToSegmentOrientation = getOrientation(connection.target, newSegmentEnd);
        if (segmentEndIndex === waypointCount - 2) {
          if (targetToSegmentOrientation === 'intersect') {
            newWaypoints.pop();
            newWaypoints[newWaypoints.length - 1] = newSegmentEnd;
          }
        } else {
          if (targetToSegmentOrientation !== 'intersect') {
            newWaypoints.push(segmentEnd);
          }
        }
      }
      context.newWaypoints = connection.waypoints = cropConnection(connection, newWaypoints);
      updateDragger(context, segmentOffset, event);
      context.newSegmentStartIndex = segmentStartIndex + segmentOffset;
      redrawConnection(event);
    });
    eventBus.on('connectionSegment.move.hover', function (event) {
      event.context.hover = event.hover;
      canvas.addMarker(event.hover, MARKER_CONNECT_HOVER);
    });
    eventBus.on(['connectionSegment.move.out', 'connectionSegment.move.cleanup'], function (event) {
      var hover = event.context.hover;
      if (hover) {
        canvas.removeMarker(hover, MARKER_CONNECT_HOVER);
      }
    });
    eventBus.on('connectionSegment.move.cleanup', function (event) {
      var context = event.context,
        connection = context.connection;
      if (context.draggerGfx) {
        remove$1(context.draggerGfx);
      }
      canvas.removeMarker(connection, MARKER_CONNECT_UPDATING);
    });
    eventBus.on(['connectionSegment.move.cancel', 'connectionSegment.move.end'], function (event) {
      var context = event.context,
        connection = context.connection;
      connection.waypoints = context.originalWaypoints;
      redrawConnection(event);
    });
    eventBus.on('connectionSegment.move.end', function (event) {
      var context = event.context,
        connection = context.connection,
        newWaypoints = context.newWaypoints,
        newSegmentStartIndex = context.newSegmentStartIndex;
      newWaypoints = newWaypoints.map(function (p) {
        return {
          original: p.original,
          x: Math.round(p.x),
          y: Math.round(p.y)
        };
      });
      var filtered = filterRedundantWaypoints(newWaypoints, newSegmentStartIndex);
      var filteredWaypoints = filtered.waypoints,
        croppedWaypoints = cropConnection(connection, filteredWaypoints),
        segmentOffset = filtered.segmentOffset;
      var hints = {
        segmentMove: {
          segmentStartIndex: context.segmentStartIndex,
          newSegmentStartIndex: newSegmentStartIndex + segmentOffset
        }
      };
      modeling.updateWaypoints(connection, croppedWaypoints, hints);
    });
  }
  ConnectionSegmentMove.$inject = ['injector', 'eventBus', 'canvas', 'dragging', 'graphicsFactory', 'modeling'];
  var abs$6 = Math.abs,
    round$8 = Math.round;
  function snapTo(value, values, tolerance) {
    tolerance = tolerance === undefined ? 10 : tolerance;
    var idx, snapValue;
    for (idx = 0; idx < values.length; idx++) {
      snapValue = values[idx];
      if (abs$6(snapValue - value) <= tolerance) {
        return snapValue;
      }
    }
  }
  function topLeft(bounds) {
    return {
      x: bounds.x,
      y: bounds.y
    };
  }
  function bottomRight(bounds) {
    return {
      x: bounds.x + bounds.width,
      y: bounds.y + bounds.height
    };
  }
  function mid$2(bounds, defaultValue) {
    if (!bounds || isNaN(bounds.x) || isNaN(bounds.y)) {
      return defaultValue;
    }
    return {
      x: round$8(bounds.x + bounds.width / 2),
      y: round$8(bounds.y + bounds.height / 2)
    };
  }
  function isSnapped(event, axis) {
    var snapped = event.snapped;
    if (!snapped) {
      return false;
    }
    if (typeof axis === 'string') {
      return snapped[axis];
    }
    return snapped.x && snapped.y;
  }
  function setSnapped(event, axis, value) {
    if (typeof axis !== 'string') {
      throw new Error('axis must be in [x, y]');
    }
    if (typeof value !== 'number' && value !== false) {
      throw new Error('value must be Number or false');
    }
    var delta,
      previousValue = event[axis];
    var snapped = event.snapped = event.snapped || {};
    if (value === false) {
      snapped[axis] = false;
    } else {
      snapped[axis] = true;
      delta = value - previousValue;
      event[axis] += delta;
      event['d' + axis] += delta;
    }
    return previousValue;
  }
  function getChildren(parent) {
    return parent.children || [];
  }
  var abs$5 = Math.abs,
    round$7 = Math.round;
  var TOLERANCE = 10;
  function BendpointSnapping(eventBus) {
    function snapTo(values, value) {
      if (isArray$3(values)) {
        var i = values.length;
        while (i--) if (abs$5(values[i] - value) <= TOLERANCE) {
          return values[i];
        }
      } else {
        values = +values;
        var rem = value % values;
        if (rem < TOLERANCE) {
          return value - rem;
        }
        if (rem > values - TOLERANCE) {
          return value - rem + values;
        }
      }
      return value;
    }
    function getSnapPoint(element, event) {
      if (element.waypoints) {
        return getClosestPointOnConnection(event, element);
      }
      if (element.width) {
        return {
          x: round$7(element.width / 2 + element.x),
          y: round$7(element.height / 2 + element.y)
        };
      }
    }
    function getConnectionSegmentSnaps(event) {
      var context = event.context,
        snapPoints = context.snapPoints,
        connection = context.connection,
        waypoints = connection.waypoints,
        segmentStart = context.segmentStart,
        segmentStartIndex = context.segmentStartIndex,
        segmentEnd = context.segmentEnd,
        segmentEndIndex = context.segmentEndIndex,
        axis = context.axis;
      if (snapPoints) {
        return snapPoints;
      }
      var referenceWaypoints = [waypoints[segmentStartIndex - 1], segmentStart, segmentEnd, waypoints[segmentEndIndex + 1]];
      if (segmentStartIndex < 2) {
        referenceWaypoints.unshift(getSnapPoint(connection.source, event));
      }
      if (segmentEndIndex > waypoints.length - 3) {
        referenceWaypoints.unshift(getSnapPoint(connection.target, event));
      }
      context.snapPoints = snapPoints = {
        horizontal: [],
        vertical: []
      };
      forEach$1(referenceWaypoints, function (p) {
        if (p) {
          p = p.original || p;
          if (axis === 'y') {
            snapPoints.horizontal.push(p.y);
          }
          if (axis === 'x') {
            snapPoints.vertical.push(p.x);
          }
        }
      });
      return snapPoints;
    }
    eventBus.on('connectionSegment.move.move', 1500, function (event) {
      var snapPoints = getConnectionSegmentSnaps(event),
        x = event.x,
        y = event.y,
        sx,
        sy;
      if (!snapPoints) {
        return;
      }
      sx = snapTo(snapPoints.vertical, x);
      sy = snapTo(snapPoints.horizontal, y);
      var cx = x - sx,
        cy = y - sy;
      assign$1(event, {
        dx: event.dx - cx,
        dy: event.dy - cy,
        x: sx,
        y: sy
      });
      if (cx || snapPoints.vertical.indexOf(x) !== -1) {
        setSnapped(event, 'x', sx);
      }
      if (cy || snapPoints.horizontal.indexOf(y) !== -1) {
        setSnapped(event, 'y', sy);
      }
    });
    function getBendpointSnaps(context) {
      var snapPoints = context.snapPoints,
        waypoints = context.connection.waypoints,
        bendpointIndex = context.bendpointIndex;
      if (snapPoints) {
        return snapPoints;
      }
      var referenceWaypoints = [waypoints[bendpointIndex - 1], waypoints[bendpointIndex + 1]];
      context.snapPoints = snapPoints = {
        horizontal: [],
        vertical: []
      };
      forEach$1(referenceWaypoints, function (p) {
        if (p) {
          p = p.original || p;
          snapPoints.horizontal.push(p.y);
          snapPoints.vertical.push(p.x);
        }
      });
      return snapPoints;
    }
    eventBus.on(['connect.hover', 'connect.move', 'connect.end'], 1500, function (event) {
      var context = event.context,
        hover = context.hover,
        hoverMid = hover && getSnapPoint(hover, event);
      if (!isConnection(hover) || !hoverMid || !hoverMid.x || !hoverMid.y) {
        return;
      }
      setSnapped(event, 'x', hoverMid.x);
      setSnapped(event, 'y', hoverMid.y);
    });
    eventBus.on(['bendpoint.move.move', 'bendpoint.move.end'], 1500, function (event) {
      var context = event.context,
        snapPoints = getBendpointSnaps(context),
        hover = context.hover,
        hoverMid = hover && getSnapPoint(hover, event),
        x = event.x,
        y = event.y,
        sx,
        sy;
      if (!snapPoints) {
        return;
      }
      sx = snapTo(hoverMid ? snapPoints.vertical.concat([hoverMid.x]) : snapPoints.vertical, x);
      sy = snapTo(hoverMid ? snapPoints.horizontal.concat([hoverMid.y]) : snapPoints.horizontal, y);
      var cx = x - sx,
        cy = y - sy;
      assign$1(event, {
        dx: event.dx - cx,
        dy: event.dy - cy,
        x: event.x - cx,
        y: event.y - cy
      });
      if (cx || snapPoints.vertical.indexOf(x) !== -1) {
        setSnapped(event, 'x', sx);
      }
      if (cy || snapPoints.horizontal.indexOf(y) !== -1) {
        setSnapped(event, 'y', sy);
      }
    });
  }
  BendpointSnapping.$inject = ['eventBus'];
  var BendpointsModule = {
    __depends__: [DraggingModule, RulesModule$1],
    __init__: ['bendpoints', 'bendpointSnapping', 'bendpointMovePreview'],
    bendpoints: ['type', Bendpoints],
    bendpointMove: ['type', BendpointMove],
    bendpointMovePreview: ['type', BendpointMovePreview],
    connectionSegmentMove: ['type', ConnectionSegmentMove],
    bendpointSnapping: ['type', BendpointSnapping]
  };
  function Connect(eventBus, dragging, modeling, rules) {
    function canConnect(source, target) {
      return rules.allowed('connection.create', {
        source: source,
        target: target
      });
    }
    function canConnectReverse(source, target) {
      return canConnect(target, source);
    }
    eventBus.on('connect.hover', function (event) {
      var context = event.context,
        start = context.start,
        hover = event.hover,
        canExecute;
      context.hover = hover;
      canExecute = context.canExecute = canConnect(start, hover);
      if (isNil(canExecute)) {
        return;
      }
      if (canExecute !== false) {
        context.source = start;
        context.target = hover;
        return;
      }
      canExecute = context.canExecute = canConnectReverse(start, hover);
      if (isNil(canExecute)) {
        return;
      }
      if (canExecute !== false) {
        context.source = hover;
        context.target = start;
      }
    });
    eventBus.on(['connect.out', 'connect.cleanup'], function (event) {
      var context = event.context;
      context.hover = null;
      context.source = null;
      context.target = null;
      context.canExecute = false;
    });
    eventBus.on('connect.end', function (event) {
      var context = event.context,
        canExecute = context.canExecute,
        connectionStart = context.connectionStart,
        connectionEnd = {
          x: event.x,
          y: event.y
        },
        source = context.source,
        target = context.target;
      if (!canExecute) {
        return false;
      }
      var attrs = null,
        hints = {
          connectionStart: isReverse$1(context) ? connectionEnd : connectionStart,
          connectionEnd: isReverse$1(context) ? connectionStart : connectionEnd
        };
      if (isObject(canExecute)) {
        attrs = canExecute;
      }
      context.connection = modeling.connect(source, target, attrs, hints);
    });
    this.start = function (event, start, connectionStart, autoActivate) {
      if (!isObject(connectionStart)) {
        autoActivate = connectionStart;
        connectionStart = getMid(start);
      }
      dragging.init(event, 'connect', {
        autoActivate: autoActivate,
        data: {
          shape: start,
          context: {
            start: start,
            connectionStart: connectionStart
          }
        }
      });
    };
  }
  Connect.$inject = ['eventBus', 'dragging', 'modeling', 'rules'];
  function isReverse$1(context) {
    var hover = context.hover,
      source = context.source,
      target = context.target;
    return hover && source && hover === source && source !== target;
  }
  var HIGH_PRIORITY$h = 1100,
    LOW_PRIORITY$k = 900;
  var MARKER_OK$3 = 'connect-ok',
    MARKER_NOT_OK$3 = 'connect-not-ok';
  function ConnectPreview(injector, eventBus, canvas) {
    var connectionPreview = injector.get('connectionPreview', false);
    connectionPreview && eventBus.on('connect.move', function (event) {
      var context = event.context,
        canConnect = context.canExecute,
        hover = context.hover,
        source = context.source,
        start = context.start,
        startPosition = context.startPosition,
        target = context.target,
        connectionStart = context.connectionStart || startPosition,
        connectionEnd = context.connectionEnd || {
          x: event.x,
          y: event.y
        },
        previewStart = connectionStart,
        previewEnd = connectionEnd;
      if (isReverse$1(context)) {
        previewStart = connectionEnd;
        previewEnd = connectionStart;
      }
      connectionPreview.drawPreview(context, canConnect, {
        source: source || start,
        target: target || hover,
        connectionStart: previewStart,
        connectionEnd: previewEnd
      });
    });
    eventBus.on('connect.hover', LOW_PRIORITY$k, function (event) {
      var context = event.context,
        hover = event.hover,
        canExecute = context.canExecute;
      if (canExecute === null) {
        return;
      }
      canvas.addMarker(hover, canExecute ? MARKER_OK$3 : MARKER_NOT_OK$3);
    });
    eventBus.on(['connect.out', 'connect.cleanup'], HIGH_PRIORITY$h, function (event) {
      var hover = event.hover;
      if (hover) {
        canvas.removeMarker(hover, MARKER_OK$3);
        canvas.removeMarker(hover, MARKER_NOT_OK$3);
      }
    });
    connectionPreview && eventBus.on('connect.cleanup', function (event) {
      connectionPreview.cleanUp(event.context);
    });
  }
  ConnectPreview.$inject = ['injector', 'eventBus', 'canvas'];
  var ConnectModule = {
    __depends__: [SelectionModule, RulesModule$1, DraggingModule],
    __init__: ['connectPreview'],
    connect: ['type', Connect],
    connectPreview: ['type', ConnectPreview]
  };
  var MARKER_CONNECTION_PREVIEW = 'djs-dragger';
  function ConnectionPreview(injector, canvas, graphicsFactory, elementFactory) {
    this._canvas = canvas;
    this._graphicsFactory = graphicsFactory;
    this._elementFactory = elementFactory;
    this._connectionDocking = injector.get('connectionDocking', false);
    this._layouter = injector.get('layouter', false);
  }
  ConnectionPreview.$inject = ['injector', 'canvas', 'graphicsFactory', 'elementFactory'];
  ConnectionPreview.prototype.drawPreview = function (context, canConnect, hints) {
    hints = hints || {};
    var connectionPreviewGfx = context.connectionPreviewGfx,
      getConnection = context.getConnection,
      source = hints.source,
      target = hints.target,
      waypoints = hints.waypoints,
      connectionStart = hints.connectionStart,
      connectionEnd = hints.connectionEnd,
      noLayout = hints.noLayout,
      noCropping = hints.noCropping,
      noNoop = hints.noNoop,
      connection;
    var self = this;
    if (!connectionPreviewGfx) {
      connectionPreviewGfx = context.connectionPreviewGfx = this.createConnectionPreviewGfx();
    }
    clear(connectionPreviewGfx);
    if (!getConnection) {
      getConnection = context.getConnection = cacheReturnValues(function (canConnect, source, target) {
        return self.getConnection(canConnect, source, target);
      });
    }
    if (canConnect) {
      connection = getConnection(canConnect, source, target);
    }
    if (!connection) {
      !noNoop && this.drawNoopPreview(connectionPreviewGfx, hints);
      return;
    }
    connection.waypoints = waypoints || [];
    if (this._layouter && !noLayout) {
      connection.waypoints = this._layouter.layoutConnection(connection, {
        source: source,
        target: target,
        connectionStart: connectionStart,
        connectionEnd: connectionEnd,
        waypoints: hints.waypoints || connection.waypoints
      });
    }
    if (!connection.waypoints || !connection.waypoints.length) {
      connection.waypoints = [source ? getMid(source) : connectionStart, target ? getMid(target) : connectionEnd];
    }
    if (this._connectionDocking && (source || target) && !noCropping) {
      connection.waypoints = this._connectionDocking.getCroppedWaypoints(connection, source, target);
    }
    this._graphicsFactory.drawConnection(connectionPreviewGfx, connection, {
      stroke: 'var(--element-dragger-color)'
    });
  };
  ConnectionPreview.prototype.drawNoopPreview = function (connectionPreviewGfx, hints) {
    var source = hints.source,
      target = hints.target,
      start = hints.connectionStart || getMid(source),
      end = hints.connectionEnd || getMid(target);
    var waypoints = this.cropWaypoints(start, end, source, target);
    var connection = this.createNoopConnection(waypoints[0], waypoints[1]);
    append(connectionPreviewGfx, connection);
  };
  ConnectionPreview.prototype.cropWaypoints = function (start, end, source, target) {
    var graphicsFactory = this._graphicsFactory,
      sourcePath = source && graphicsFactory.getShapePath(source),
      targetPath = target && graphicsFactory.getShapePath(target),
      connectionPath = graphicsFactory.getConnectionPath({
        waypoints: [start, end]
      });
    start = source && getElementLineIntersection(sourcePath, connectionPath, true) || start;
    end = target && getElementLineIntersection(targetPath, connectionPath, false) || end;
    return [start, end];
  };
  ConnectionPreview.prototype.cleanUp = function (context) {
    if (context && context.connectionPreviewGfx) {
      remove$1(context.connectionPreviewGfx);
    }
  };
  ConnectionPreview.prototype.getConnection = function (canConnect) {
    var attrs = ensureConnectionAttrs(canConnect);
    return this._elementFactory.createConnection(attrs);
  };
  ConnectionPreview.prototype.createConnectionPreviewGfx = function () {
    var gfx = create$1('g');
    attr(gfx, {
      pointerEvents: 'none'
    });
    classes(gfx).add(MARKER_CONNECTION_PREVIEW);
    append(this._canvas.getActiveLayer(), gfx);
    return gfx;
  };
  ConnectionPreview.prototype.createNoopConnection = function (start, end) {
    return createLine([start, end], {
      'stroke': '#333',
      'strokeDasharray': [1],
      'strokeWidth': 2,
      'pointer-events': 'none'
    });
  };
  function cacheReturnValues(fn) {
    var returnValues = {};
    return function (firstArgument) {
      var key = JSON.stringify(firstArgument);
      var returnValue = returnValues[key];
      if (!returnValue) {
        returnValue = returnValues[key] = fn.apply(null, arguments);
      }
      return returnValue;
    };
  }
  function ensureConnectionAttrs(canConnect) {
    if (isObject(canConnect)) {
      return canConnect;
    } else {
      return {};
    }
  }
  var ConnectionPreviewModule = {
    __init__: ['connectionPreview'],
    connectionPreview: ['type', ConnectionPreview]
  };
  var cloneIds = new IdGenerator('ps');
  var MARKER_TYPES = ['marker-start', 'marker-mid', 'marker-end'];
  var NODES_CAN_HAVE_MARKER = ['circle', 'ellipse', 'line', 'path', 'polygon', 'polyline', 'path', 'rect'];
  function PreviewSupport(elementRegistry, eventBus, canvas, styles) {
    this._elementRegistry = elementRegistry;
    this._canvas = canvas;
    this._styles = styles;
  }
  PreviewSupport.$inject = ['elementRegistry', 'eventBus', 'canvas', 'styles'];
  PreviewSupport.prototype.cleanUp = function () {
    console.warn('PreviewSupport#cleanUp is deprecated and will be removed in future versions. You do not need to manually clean up previews anymore. cf. https://github.com/bpmn-io/diagram-js/pull/906');
  };
  PreviewSupport.prototype.getGfx = function (element) {
    return this._elementRegistry.getGraphics(element);
  };
  PreviewSupport.prototype.addDragger = function (element, group, gfx) {
    var className = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'djs-dragger';
    gfx = gfx || this.getGfx(element);
    var dragger = clone$1(gfx);
    var bbox = gfx.getBoundingClientRect();
    this._cloneMarkers(getVisual(dragger), className);
    attr(dragger, this._styles.cls(className, [], {
      x: bbox.top,
      y: bbox.left
    }));
    append(group, dragger);
    attr(dragger, 'data-preview-support-element-id', element.id);
    return dragger;
  };
  PreviewSupport.prototype.addFrame = function (shape, group) {
    var frame = create$1('rect', {
      class: 'djs-resize-overlay',
      width: shape.width,
      height: shape.height,
      x: shape.x,
      y: shape.y
    });
    append(group, frame);
    attr(frame, 'data-preview-support-element-id', shape.id);
    return frame;
  };
  PreviewSupport.prototype._cloneMarkers = function (gfx) {
    var className = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'djs-dragger';
    var rootGfx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : gfx;
    var self = this;
    if (gfx.childNodes) {
      gfx.childNodes.forEach(function (childNode) {
        self._cloneMarkers(childNode, className, rootGfx);
      });
    }
    if (!canHaveMarker(gfx)) {
      return;
    }
    MARKER_TYPES.forEach(function (markerType) {
      if (attr(gfx, markerType)) {
        var marker = getMarker(gfx, markerType, self._canvas.getContainer());
        marker && self._cloneMarker(rootGfx, gfx, marker, markerType, className);
      }
    });
  };
  PreviewSupport.prototype._cloneMarker = function (parentGfx, gfx, marker, markerType) {
    var className = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'djs-dragger';
    var clonedMarkerId = [marker.id, className, cloneIds.next()].join('-');
    var copiedMarker = query('marker#' + marker.id, parentGfx);
    parentGfx = parentGfx || this._canvas._svg;
    var clonedMarker = copiedMarker || clone$1(marker);
    clonedMarker.id = clonedMarkerId;
    classes(clonedMarker).add(className);
    var defs = query(':scope > defs', parentGfx);
    if (!defs) {
      defs = create$1('defs');
      append(parentGfx, defs);
    }
    append(defs, clonedMarker);
    var reference = idToReference(clonedMarker.id);
    attr(gfx, markerType, reference);
  };
  function getMarker(node, markerType, parentNode) {
    var id = referenceToId(attr(node, markerType));
    return query('marker#' + id, parentNode || document);
  }
  function referenceToId(reference) {
    return reference.match(/url\(['"]?#([^'"]*)['"]?\)/)[1];
  }
  function idToReference(id) {
    return 'url(#' + id + ')';
  }
  function canHaveMarker(node) {
    return NODES_CAN_HAVE_MARKER.indexOf(node.nodeName) !== -1;
  }
  var PreviewSupportModule = {
    __init__: ['previewSupport'],
    previewSupport: ['type', PreviewSupport]
  };
  var LAYER_NAME = 'complex-preview';
  var ComplexPreview = function () {
    function ComplexPreview(canvas, graphicsFactory, previewSupport) {
      _classCallCheck(this, ComplexPreview);
      this._canvas = canvas;
      this._graphicsFactory = graphicsFactory;
      this._previewSupport = previewSupport;
      this._markers = [];
    }
    return _createClass(ComplexPreview, [{
      key: "create",
      value: function create(options) {
        var _this11 = this;
        this.cleanUp();
        var _options$created = options.created,
          created = _options$created === void 0 ? [] : _options$created,
          _options$moved = options.moved,
          moved = _options$moved === void 0 ? [] : _options$moved,
          _options$removed = options.removed,
          removed = _options$removed === void 0 ? [] : _options$removed,
          _options$resized = options.resized,
          resized = _options$resized === void 0 ? [] : _options$resized;
        var layer = this._canvas.getLayer(LAYER_NAME);
        created.filter(function (element) {
          return !isHidden$2(element);
        }).forEach(function (element) {
          var gfx;
          if (isConnection(element)) {
            gfx = _this11._graphicsFactory._createContainer('connection', create$1('g'));
            _this11._graphicsFactory.drawConnection(getVisual(gfx), element);
          } else {
            gfx = _this11._graphicsFactory._createContainer('shape', create$1('g'));
            _this11._graphicsFactory.drawShape(getVisual(gfx), element);
            translate$1(gfx, element.x, element.y);
          }
          _this11._previewSupport.addDragger(element, layer, gfx);
        });
        moved.forEach(function (_ref13) {
          var element = _ref13.element,
            delta = _ref13.delta;
          _this11._previewSupport.addDragger(element, layer, undefined, 'djs-dragging');
          _this11._canvas.addMarker(element, 'djs-element-hidden');
          _this11._markers.push([element, 'djs-element-hidden']);
          var dragger = _this11._previewSupport.addDragger(element, layer);
          if (isConnection(element)) {
            translate$1(dragger, delta.x, delta.y);
          } else {
            translate$1(dragger, element.x + delta.x, element.y + delta.y);
          }
        });
        removed.forEach(function (element) {
          _this11._previewSupport.addDragger(element, layer, undefined, 'djs-dragging');
          _this11._canvas.addMarker(element, 'djs-element-hidden');
          _this11._markers.push([element, 'djs-element-hidden']);
        });
        resized.forEach(function (_ref14) {
          var shape = _ref14.shape,
            bounds = _ref14.bounds;
          _this11._canvas.addMarker(shape, 'djs-hidden');
          _this11._markers.push([shape, 'djs-hidden']);
          _this11._previewSupport.addDragger(shape, layer, undefined, 'djs-dragging');
          var gfx = _this11._graphicsFactory._createContainer('shape', create$1('g'));
          _this11._graphicsFactory.drawShape(getVisual(gfx), shape, {
            width: bounds.width,
            height: bounds.height
          });
          translate$1(gfx, bounds.x, bounds.y);
          _this11._previewSupport.addDragger(shape, layer, gfx);
        });
      }
    }, {
      key: "cleanUp",
      value: function cleanUp() {
        var _this12 = this;
        clear(this._canvas.getLayer(LAYER_NAME));
        this._markers.forEach(function (_ref15) {
          var _ref16 = _slicedToArray(_ref15, 2),
            element = _ref16[0],
            marker = _ref16[1];
          return _this12._canvas.removeMarker(element, marker);
        });
        this._markers = [];
      }
    }, {
      key: "show",
      value: function show() {
        this._canvas.showLayer(LAYER_NAME);
      }
    }, {
      key: "hide",
      value: function hide() {
        this._canvas.hideLayer(LAYER_NAME);
      }
    }]);
  }();
  ComplexPreview.$inject = ['canvas', 'graphicsFactory', 'previewSupport'];
  function isHidden$2(element) {
    return element.hidden;
  }
  var ComplexPreviewModule = {
    __depends__: [PreviewSupportModule],
    __init__: ['complexPreview'],
    complexPreview: ['type', ComplexPreview]
  };
  var ALIGNMENTS = ['top', 'bottom', 'left', 'right'];
  var ELEMENT_LABEL_DISTANCE = 10;
  function AdaptiveLabelPositioningBehavior(eventBus, modeling) {
    CommandInterceptor.call(this, eventBus);
    this.postExecuted(['connection.create', 'connection.layout', 'connection.updateWaypoints'], function (event) {
      var context = event.context,
        connection = context.connection,
        source = connection.source,
        target = connection.target,
        hints = context.hints || {};
      if (hints.createElementsBehavior !== false) {
        checkLabelAdjustment(source);
        checkLabelAdjustment(target);
      }
    });
    this.postExecuted(['label.create'], function (event) {
      var context = event.context,
        shape = context.shape,
        hints = context.hints || {};
      if (hints.createElementsBehavior !== false) {
        checkLabelAdjustment(shape.labelTarget);
      }
    });
    this.postExecuted(['elements.create'], function (event) {
      var context = event.context,
        elements = context.elements,
        hints = context.hints || {};
      if (hints.createElementsBehavior !== false) {
        elements.forEach(function (element) {
          checkLabelAdjustment(element);
        });
      }
    });
    function checkLabelAdjustment(element) {
      if (!hasExternalLabel(element)) {
        return;
      }
      if (isConnection(element)) {
        return;
      }
      var optimalPosition = getOptimalPosition(element);
      if (!optimalPosition) {
        return;
      }
      adjustLabelPosition(element, optimalPosition);
    }
    function adjustLabelPosition(element, orientation) {
      var elementMid = getMid(element),
        label = element.label,
        labelMid = getMid(label);
      if (!label.parent) {
        return;
      }
      var elementTrbl = asTRBL(element);
      var newLabelMid;
      switch (orientation) {
        case 'top':
          newLabelMid = {
            x: elementMid.x,
            y: elementTrbl.top - ELEMENT_LABEL_DISTANCE - label.height / 2
          };
          break;
        case 'left':
          newLabelMid = {
            x: elementTrbl.left - ELEMENT_LABEL_DISTANCE - label.width / 2,
            y: elementMid.y
          };
          break;
        case 'bottom':
          newLabelMid = {
            x: elementMid.x,
            y: elementTrbl.bottom + ELEMENT_LABEL_DISTANCE + label.height / 2
          };
          break;
        case 'right':
          newLabelMid = {
            x: elementTrbl.right + ELEMENT_LABEL_DISTANCE + label.width / 2,
            y: elementMid.y
          };
          break;
      }
      var delta$1 = delta(newLabelMid, labelMid);
      modeling.moveShape(label, delta$1);
    }
  }
  e$2(AdaptiveLabelPositioningBehavior, CommandInterceptor);
  AdaptiveLabelPositioningBehavior.$inject = ['eventBus', 'modeling'];
  function getTakenHostAlignments(element) {
    var hostElement = element.host,
      elementMid = getMid(element),
      hostOrientation = getOrientation(elementMid, hostElement);
    var freeAlignments;
    if (hostOrientation.indexOf('-') >= 0) {
      freeAlignments = hostOrientation.split('-');
    } else {
      freeAlignments = [hostOrientation];
    }
    var takenAlignments = ALIGNMENTS.filter(function (alignment) {
      return freeAlignments.indexOf(alignment) === -1;
    });
    return takenAlignments;
  }
  function getTakenConnectionAlignments(element) {
    var elementMid = getMid(element);
    var takenAlignments = [].concat(element.incoming.map(function (c) {
      return c.waypoints[c.waypoints.length - 2];
    }), element.outgoing.map(function (c) {
      return c.waypoints[1];
    })).map(function (point) {
      return getApproximateOrientation(elementMid, point);
    });
    return takenAlignments;
  }
  function getOptimalPosition(element) {
    var labelMid = getMid(element.label);
    var elementMid = getMid(element);
    var labelOrientation = getApproximateOrientation(elementMid, labelMid);
    if (!isAligned(labelOrientation)) {
      return;
    }
    var takenAlignments = getTakenConnectionAlignments(element);
    if (element.host) {
      var takenHostAlignments = getTakenHostAlignments(element);
      takenAlignments = takenAlignments.concat(takenHostAlignments);
    }
    var freeAlignments = ALIGNMENTS.filter(function (alignment) {
      return takenAlignments.indexOf(alignment) === -1;
    });
    if (freeAlignments.indexOf(labelOrientation) !== -1) {
      return;
    }
    return freeAlignments[0];
  }
  function getApproximateOrientation(p0, p1) {
    return getOrientation(p1, p0, 5);
  }
  function isAligned(orientation) {
    return ALIGNMENTS.indexOf(orientation) !== -1;
  }
  function AppendBehavior(eventBus) {
    CommandInterceptor.call(this, eventBus);
    this.preExecute('shape.append', function (context) {
      var source = context.source,
        shape = context.shape;
      if (!context.position) {
        if (is(shape, 'bpmn:TextAnnotation')) {
          context.position = {
            x: source.x + source.width / 2 + 75,
            y: source.y - 50 - shape.height / 2
          };
        } else {
          context.position = {
            x: source.x + source.width + 80 + shape.width / 2,
            y: source.y + source.height / 2
          };
        }
      }
    }, true);
  }
  e$2(AppendBehavior, CommandInterceptor);
  AppendBehavior.$inject = ['eventBus'];
  function AssociationBehavior(injector, modeling) {
    injector.invoke(CommandInterceptor, this);
    this.postExecute('shape.move', function (context) {
      var newParent = context.newParent,
        shape = context.shape;
      var associations = filter(shape.incoming.concat(shape.outgoing), function (connection) {
        return is(connection, 'bpmn:Association');
      });
      forEach$1(associations, function (association) {
        modeling.moveConnection(association, {
          x: 0,
          y: 0
        }, newParent);
      });
    }, true);
  }
  e$2(AssociationBehavior, CommandInterceptor);
  AssociationBehavior.$inject = ['injector', 'modeling'];
  var LOW_PRIORITY$j = 500;
  function AttachEventBehavior(bpmnReplace, injector) {
    injector.invoke(CommandInterceptor, this);
    this._bpmnReplace = bpmnReplace;
    var self = this;
    this.postExecuted('elements.create', LOW_PRIORITY$j, function (context) {
      var elements = context.elements;
      elements = elements.filter(function (shape) {
        var host = shape.host;
        return shouldReplace$1(shape, host);
      });
      if (elements.length !== 1) {
        return;
      }
      elements.map(function (element) {
        return elements.indexOf(element);
      }).forEach(function (index) {
        var host = elements[index];
        context.elements[index] = self._replaceShape(elements[index], host);
      });
    }, true);
    this.preExecute('elements.move', LOW_PRIORITY$j, function (context) {
      var shapes = context.shapes,
        host = context.newHost;
      if (shapes.length !== 1) {
        return;
      }
      var shape = shapes[0];
      if (shouldReplace$1(shape, host)) {
        context.shapes = [self._replaceShape(shape, host)];
      }
    }, true);
  }
  AttachEventBehavior.$inject = ['bpmnReplace', 'injector'];
  e$2(AttachEventBehavior, CommandInterceptor);
  AttachEventBehavior.prototype._replaceShape = function (shape, host) {
    var eventDefinition = getEventDefinition$1(shape);
    var boundaryEvent = {
      type: 'bpmn:BoundaryEvent',
      host: host
    };
    if (eventDefinition) {
      boundaryEvent.eventDefinitionType = eventDefinition.$type;
    }
    return this._bpmnReplace.replaceElement(shape, boundaryEvent, {
      layoutConnection: false
    });
  };
  function getEventDefinition$1(element) {
    var businessObject = getBusinessObject(element),
      eventDefinitions = businessObject.eventDefinitions;
    return eventDefinitions && eventDefinitions[0];
  }
  function shouldReplace$1(shape, host) {
    return !isLabel(shape) && isAny(shape, ['bpmn:IntermediateThrowEvent', 'bpmn:IntermediateCatchEvent']) && !!host;
  }
  function BoundaryEventBehavior(eventBus, modeling) {
    CommandInterceptor.call(this, eventBus);
    function getBoundaryEvents(element) {
      return filter(element.attachers, function (attacher) {
        return is(attacher, 'bpmn:BoundaryEvent');
      });
    }
    this.postExecute('connection.create', function (event) {
      var source = event.context.source,
        target = event.context.target,
        boundaryEvents = getBoundaryEvents(target);
      if (is(source, 'bpmn:EventBasedGateway') && is(target, 'bpmn:ReceiveTask') && boundaryEvents.length > 0) {
        modeling.removeElements(boundaryEvents);
      }
    });
    this.postExecute('connection.reconnect', function (event) {
      var oldSource = event.context.oldSource,
        newSource = event.context.newSource;
      if (is(oldSource, 'bpmn:Gateway') && is(newSource, 'bpmn:EventBasedGateway')) {
        forEach$1(newSource.outgoing, function (connection) {
          var target = connection.target,
            attachedboundaryEvents = getBoundaryEvents(target);
          if (is(target, 'bpmn:ReceiveTask') && attachedboundaryEvents.length > 0) {
            modeling.removeElements(attachedboundaryEvents);
          }
        });
      }
    });
  }
  BoundaryEventBehavior.$inject = ['eventBus', 'modeling'];
  e$2(BoundaryEventBehavior, CommandInterceptor);
  function CompensateBoundaryEventBehavior(eventBus, modeling, bpmnRules) {
    CommandInterceptor.call(this, eventBus);
    this.preExecute('shape.replace', handleReplacement, true);
    this.postExecuted('shape.replace', handleReplacementPostExecuted, true);
    this.preExecute('connection.create', handleNewConnection, true);
    this.postExecuted('connection.delete', handleConnectionRemoval, true);
    this.postExecuted('connection.reconnect', handleReconnection, true);
    this.postExecuted('element.updateProperties', handlePropertiesUpdate, true);
    function handleConnectionRemoval(context) {
      var source = context.source,
        target = context.target;
      if (isCompensationBoundaryEvent$1(source) && isForCompensation$2(target)) {
        removeIsForCompensationProperty(target);
      }
    }
    function handleNewConnection(context) {
      var connection = context.connection,
        source = context.source,
        target = context.target;
      if (isCompensationBoundaryEvent$1(source) && isForCompensationAllowed(target)) {
        addIsForCompensationProperty(target);
        removeExistingAssociations(source, [connection]);
      }
    }
    function handleReconnection(context) {
      var newTarget = context.newTarget,
        oldSource = context.oldSource,
        oldTarget = context.oldTarget;
      if (oldTarget !== newTarget) {
        var source = oldSource;
        if (isForCompensation$2(oldTarget)) {
          removeIsForCompensationProperty(oldTarget);
        }
        if (isCompensationBoundaryEvent$1(source) && isForCompensationAllowed(newTarget)) {
          addIsForCompensationProperty(newTarget);
        }
      }
    }
    function handlePropertiesUpdate(context) {
      var element = context.element;
      if (isForCompensation$2(element)) {
        removeDisallowedConnections(element);
        removeAttachments(element);
      } else if (isForCompensationAllowed(element)) {
        removeIncomingCompensationAssociations(element);
      }
    }
    function handleReplacement(context) {
      var newData = context.newData,
        oldShape = context.oldShape;
      if (isCompensationBoundaryEvent$1(context.oldShape) && newData.eventDefinitionType !== 'bpmn:CompensateEventDefinition' || newData.type !== 'bpmn:BoundaryEvent') {
        var targetConnection = oldShape.outgoing.find(function (_ref17) {
          var target = _ref17.target;
          return isForCompensation$2(target);
        });
        if (targetConnection && targetConnection.target) {
          context._connectionTarget = targetConnection.target;
        }
      } else if (!isCompensationBoundaryEvent$1(context.oldShape) && newData.eventDefinitionType === 'bpmn:CompensateEventDefinition' && newData.type === 'bpmn:BoundaryEvent') {
        var _targetConnection = oldShape.outgoing.find(function (_ref18) {
          var target = _ref18.target;
          return isForCompensationAllowed(target);
        });
        if (_targetConnection && _targetConnection.target) {
          context._connectionTarget = _targetConnection.target;
        }
        removeOutgoingSequenceFlows(oldShape);
      }
    }
    function handleReplacementPostExecuted(context) {
      var target = context._connectionTarget,
        newShape = context.newShape;
      if (target) {
        modeling.connect(newShape, target);
      }
    }
    function addIsForCompensationProperty(target) {
      modeling.updateProperties(target, {
        isForCompensation: true
      });
    }
    function removeIsForCompensationProperty(target) {
      modeling.updateProperties(target, {
        isForCompensation: undefined
      });
    }
    function removeDisallowedConnections(element) {
      var _iterator4 = _createForOfIteratorHelper(element.incoming),
        _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var connection = _step4.value;
          if (!bpmnRules.canConnect(connection.source, element)) {
            modeling.removeConnection(connection);
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
      var _iterator5 = _createForOfIteratorHelper(element.outgoing),
        _step5;
      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var _connection = _step5.value;
          if (!bpmnRules.canConnect(element, _connection.target)) {
            modeling.removeConnection(_connection);
          }
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
    }
    function removeExistingAssociations(boundaryEvent, ignoredAssociations) {
      var associations = boundaryEvent.outgoing.filter(function (connection) {
        return is(connection, 'bpmn:Association');
      });
      var associationsToRemove = associations.filter(function (association) {
        return isForCompensation$2(association.target) && !ignoredAssociations.includes(association);
      });
      associationsToRemove.forEach(function (association) {
        return modeling.removeConnection(association);
      });
    }
    function removeAttachments(element) {
      var attachments = element.attachers.slice();
      if (!attachments.length) {
        return;
      }
      modeling.removeElements(attachments);
    }
    function removeIncomingCompensationAssociations(element) {
      var compensationAssociations = element.incoming.filter(function (connection) {
        return isCompensationBoundaryEvent$1(connection.source);
      });
      modeling.removeElements(compensationAssociations);
    }
    function removeOutgoingSequenceFlows(element) {
      var sequenceFlows = element.outgoing.filter(function (connection) {
        return is(connection, 'bpmn:SequenceFlow');
      });
      modeling.removeElements(sequenceFlows);
    }
  }
  e$2(CompensateBoundaryEventBehavior, CommandInterceptor);
  CompensateBoundaryEventBehavior.$inject = ['eventBus', 'modeling', 'bpmnRules'];
  function isForCompensation$2(element) {
    var bo = getBusinessObject(element);
    return bo && bo.get('isForCompensation');
  }
  function isCompensationBoundaryEvent$1(element) {
    return element && is(element, 'bpmn:BoundaryEvent') && hasEventDefinition$2(element, 'bpmn:CompensateEventDefinition');
  }
  function isForCompensationAllowed(element) {
    return element && is(element, 'bpmn:Activity') && !isEventSubProcess(element);
  }
  function CreateBehavior(injector) {
    injector.invoke(CommandInterceptor, this);
    this.preExecute('shape.create', 1500, function (event) {
      var context = event.context,
        parent = context.parent,
        shape = context.shape;
      if (is(parent, 'bpmn:Lane') && !is(shape, 'bpmn:Lane')) {
        context.parent = getParent(parent, 'bpmn:Participant');
      }
    });
  }
  CreateBehavior.$inject = ['injector'];
  e$2(CreateBehavior, CommandInterceptor);
  function CreateDataObjectBehavior(eventBus, bpmnFactory) {
    CommandInterceptor.call(this, eventBus);
    this.preExecute('shape.create', function (event) {
      var context = event.context,
        shape = context.shape;
      if (is(shape, 'bpmn:DataObjectReference') && shape.type !== 'label') {
        var dataObject = bpmnFactory.create('bpmn:DataObject');
        shape.businessObject.dataObjectRef = dataObject;
      }
    });
  }
  CreateDataObjectBehavior.$inject = ['eventBus', 'bpmnFactory'];
  e$2(CreateDataObjectBehavior, CommandInterceptor);
  var HORIZONTAL_PARTICIPANT_PADDING = 20,
    VERTICAL_PARTICIPANT_PADDING = 20;
  var PARTICIPANT_BORDER_WIDTH = 30;
  var HIGH_PRIORITY$g = 2000;
  function CreateParticipantBehavior(canvas, eventBus, modeling) {
    CommandInterceptor.call(this, eventBus);
    eventBus.on(['create.start', 'shape.move.start'], HIGH_PRIORITY$g, function (event) {
      var context = event.context,
        shape = context.shape,
        rootElement = canvas.getRootElement();
      if (!is(shape, 'bpmn:Participant') || !is(rootElement, 'bpmn:Process') || !rootElement.children.length) {
        return;
      }
      var children = rootElement.children.filter(function (element) {
        return !is(element, 'bpmn:Group') && !isLabel(element) && !isConnection(element);
      });
      if (!children.length) {
        return;
      }
      var childrenBBox = getBBox(children);
      var participantBounds = getParticipantBounds(shape, childrenBBox);
      assign$1(shape, participantBounds);
      context.createConstraints = getParticipantCreateConstraints(shape, childrenBBox);
    });
    eventBus.on('create.start', HIGH_PRIORITY$g, function (event) {
      var context = event.context,
        shape = context.shape,
        rootElement = canvas.getRootElement(),
        rootElementGfx = canvas.getGraphics(rootElement);
      function ensureHoveringProcess(event) {
        event.element = rootElement;
        event.gfx = rootElementGfx;
      }
      if (is(shape, 'bpmn:Participant') && is(rootElement, 'bpmn:Process')) {
        eventBus.on('element.hover', HIGH_PRIORITY$g, ensureHoveringProcess);
        eventBus.once('create.cleanup', function () {
          eventBus.off('element.hover', ensureHoveringProcess);
        });
      }
    });
    function getOrCreateCollaboration() {
      var rootElement = canvas.getRootElement();
      if (is(rootElement, 'bpmn:Collaboration')) {
        return rootElement;
      }
      return modeling.makeCollaboration();
    }
    this.preExecute('elements.create', HIGH_PRIORITY$g, function (context) {
      var elements = context.elements,
        parent = context.parent,
        participant = findParticipant(elements),
        hints;
      if (participant && is(parent, 'bpmn:Process')) {
        context.parent = getOrCreateCollaboration();
        hints = context.hints = context.hints || {};
        hints.participant = participant;
        hints.process = parent;
        hints.processRef = getBusinessObject(participant).get('processRef');
      }
    }, true);
    this.preExecute('shape.create', function (context) {
      var parent = context.parent,
        shape = context.shape;
      if (is(shape, 'bpmn:Participant') && is(parent, 'bpmn:Process')) {
        context.parent = getOrCreateCollaboration();
        context.process = parent;
        context.processRef = getBusinessObject(shape).get('processRef');
      }
    }, true);
    this.execute('shape.create', function (context) {
      var hints = context.hints || {},
        process = context.process || hints.process,
        shape = context.shape,
        participant = hints.participant;
      if (process && (!participant || shape === participant)) {
        getBusinessObject(shape).set('processRef', getBusinessObject(process));
      }
    }, true);
    this.revert('shape.create', function (context) {
      var hints = context.hints || {},
        process = context.process || hints.process,
        processRef = context.processRef || hints.processRef,
        shape = context.shape,
        participant = hints.participant;
      if (process && (!participant || shape === participant)) {
        getBusinessObject(shape).set('processRef', processRef);
      }
    }, true);
    this.postExecute('shape.create', function (context) {
      var hints = context.hints || {},
        process = context.process || context.hints.process,
        shape = context.shape,
        participant = hints.participant;
      if (process) {
        var children = process.children.slice();
        if (!participant) {
          modeling.moveElements(children, {
            x: 0,
            y: 0
          }, shape);
        } else if (shape === participant) {
          modeling.moveElements(children, {
            x: 0,
            y: 0
          }, participant);
        }
      }
    }, true);
  }
  CreateParticipantBehavior.$inject = ['canvas', 'eventBus', 'modeling'];
  e$2(CreateParticipantBehavior, CommandInterceptor);
  function getParticipantBounds(shape, childrenBBox) {
    childrenBBox = {
      width: childrenBBox.width + HORIZONTAL_PARTICIPANT_PADDING * 2 + PARTICIPANT_BORDER_WIDTH,
      height: childrenBBox.height + VERTICAL_PARTICIPANT_PADDING * 2
    };
    var width = Math.max(shape.width, childrenBBox.width),
      height = Math.max(shape.height, childrenBBox.height);
    return {
      x: -width / 2,
      y: -height / 2,
      width: width,
      height: height
    };
  }
  function getParticipantCreateConstraints(shape, childrenBBox) {
    childrenBBox = asTRBL(childrenBBox);
    return {
      bottom: childrenBBox.top + shape.height / 2 - VERTICAL_PARTICIPANT_PADDING,
      left: childrenBBox.right - shape.width / 2 + HORIZONTAL_PARTICIPANT_PADDING,
      top: childrenBBox.bottom - shape.height / 2 + VERTICAL_PARTICIPANT_PADDING,
      right: childrenBBox.left + shape.width / 2 - HORIZONTAL_PARTICIPANT_PADDING - PARTICIPANT_BORDER_WIDTH
    };
  }
  function findParticipant(elements) {
    return find(elements, function (element) {
      return is(element, 'bpmn:Participant');
    });
  }
  var TARGET_REF_PLACEHOLDER_NAME = '__targetRef_placeholder';
  function DataInputAssociationBehavior(eventBus, bpmnFactory) {
    CommandInterceptor.call(this, eventBus);
    this.executed(['connection.create', 'connection.delete', 'connection.move', 'connection.reconnect'], ifDataInputAssociation(fixTargetRef));
    this.reverted(['connection.create', 'connection.delete', 'connection.move', 'connection.reconnect'], ifDataInputAssociation(fixTargetRef));
    function usesTargetRef(element, targetRef, removedConnection) {
      var inputAssociations = element.get('dataInputAssociations');
      return find(inputAssociations, function (association) {
        return association !== removedConnection && association.targetRef === targetRef;
      });
    }
    function getTargetRef(element, create) {
      var properties = element.get('properties');
      var targetRefProp = find(properties, function (p) {
        return p.name === TARGET_REF_PLACEHOLDER_NAME;
      });
      if (!targetRefProp && create) {
        targetRefProp = bpmnFactory.create('bpmn:Property', {
          name: TARGET_REF_PLACEHOLDER_NAME
        });
        add(properties, targetRefProp);
      }
      return targetRefProp;
    }
    function cleanupTargetRef(element, connection) {
      var targetRefProp = getTargetRef(element);
      if (!targetRefProp) {
        return;
      }
      if (!usesTargetRef(element, targetRefProp, connection)) {
        remove(element.get('properties'), targetRefProp);
      }
    }
    function fixTargetRef(event) {
      var context = event.context,
        connection = context.connection,
        connectionBo = connection.businessObject,
        target = connection.target,
        targetBo = target && target.businessObject,
        newTarget = context.newTarget,
        newTargetBo = newTarget && newTarget.businessObject,
        oldTarget = context.oldTarget || context.target,
        oldTargetBo = oldTarget && oldTarget.businessObject;
      var dataAssociation = connection.businessObject,
        targetRefProp;
      if (oldTargetBo && oldTargetBo !== targetBo) {
        cleanupTargetRef(oldTargetBo, connectionBo);
      }
      if (newTargetBo && newTargetBo !== targetBo) {
        cleanupTargetRef(newTargetBo, connectionBo);
      }
      if (targetBo) {
        targetRefProp = getTargetRef(targetBo, true);
        dataAssociation.targetRef = targetRefProp;
      } else {
        dataAssociation.targetRef = null;
      }
    }
  }
  DataInputAssociationBehavior.$inject = ['eventBus', 'bpmnFactory'];
  e$2(DataInputAssociationBehavior, CommandInterceptor);
  function ifDataInputAssociation(fn) {
    return function (event) {
      var context = event.context,
        connection = context.connection;
      if (is(connection, 'bpmn:DataInputAssociation')) {
        return fn(event);
      }
    };
  }
  function UpdateSemanticParentHandler(bpmnUpdater) {
    this._bpmnUpdater = bpmnUpdater;
  }
  UpdateSemanticParentHandler.$inject = ['bpmnUpdater'];
  UpdateSemanticParentHandler.prototype.execute = function (context) {
    var dataStoreBo = context.dataStoreBo,
      dataStoreDi = context.dataStoreDi,
      newSemanticParent = context.newSemanticParent,
      newDiParent = context.newDiParent;
    context.oldSemanticParent = dataStoreBo.$parent;
    context.oldDiParent = dataStoreDi.$parent;
    this._bpmnUpdater.updateSemanticParent(dataStoreBo, newSemanticParent);
    this._bpmnUpdater.updateDiParent(dataStoreDi, newDiParent);
    return [];
  };
  UpdateSemanticParentHandler.prototype.revert = function (context) {
    var dataStoreBo = context.dataStoreBo,
      dataStoreDi = context.dataStoreDi,
      oldSemanticParent = context.oldSemanticParent,
      oldDiParent = context.oldDiParent;
    this._bpmnUpdater.updateSemanticParent(dataStoreBo, oldSemanticParent);
    this._bpmnUpdater.updateDiParent(dataStoreDi, oldDiParent);
    return [];
  };
  function DataStoreBehavior(canvas, commandStack, elementRegistry, eventBus) {
    CommandInterceptor.call(this, eventBus);
    commandStack.registerHandler('dataStore.updateContainment', UpdateSemanticParentHandler);
    function getFirstParticipantWithProcessRef() {
      return elementRegistry.filter(function (element) {
        return is(element, 'bpmn:Participant') && getBusinessObject(element).processRef;
      })[0];
    }
    function getDataStores(element) {
      return element.children.filter(function (child) {
        return is(child, 'bpmn:DataStoreReference') && !child.labelTarget;
      });
    }
    function updateDataStoreParent(dataStore, newDataStoreParent) {
      var dataStoreBo = dataStore.businessObject || dataStore;
      newDataStoreParent = newDataStoreParent || getFirstParticipantWithProcessRef();
      if (newDataStoreParent) {
        var newDataStoreParentBo = newDataStoreParent.businessObject || newDataStoreParent;
        commandStack.execute('dataStore.updateContainment', {
          dataStoreBo: dataStoreBo,
          dataStoreDi: getDi(dataStore),
          newSemanticParent: newDataStoreParentBo.processRef || newDataStoreParentBo,
          newDiParent: getDi(newDataStoreParent)
        });
      }
    }
    this.preExecute('shape.create', function (event) {
      var context = event.context,
        shape = context.shape;
      if (is(shape, 'bpmn:DataStoreReference') && shape.type !== 'label') {
        if (!context.hints) {
          context.hints = {};
        }
        context.hints.autoResize = false;
      }
    });
    this.preExecute('elements.move', function (event) {
      var context = event.context,
        shapes = context.shapes;
      var dataStoreReferences = shapes.filter(function (shape) {
        return is(shape, 'bpmn:DataStoreReference');
      });
      if (dataStoreReferences.length) {
        if (!context.hints) {
          context.hints = {};
        }
        context.hints.autoResize = shapes.filter(function (shape) {
          return !is(shape, 'bpmn:DataStoreReference');
        });
      }
    });
    this.postExecute('shape.create', function (event) {
      var context = event.context,
        shape = context.shape,
        parent = shape.parent;
      if (is(shape, 'bpmn:DataStoreReference') && shape.type !== 'label' && is(parent, 'bpmn:Collaboration')) {
        updateDataStoreParent(shape);
      }
    });
    this.postExecute('shape.move', function (event) {
      var context = event.context,
        shape = context.shape,
        oldParent = context.oldParent,
        parent = shape.parent;
      if (is(oldParent, 'bpmn:Collaboration')) {
        return;
      }
      if (is(shape, 'bpmn:DataStoreReference') && shape.type !== 'label' && is(parent, 'bpmn:Collaboration')) {
        var participant = is(oldParent, 'bpmn:Participant') ? oldParent : getAncestor(oldParent, 'bpmn:Participant');
        updateDataStoreParent(shape, participant);
      }
    });
    this.postExecute('shape.delete', function (event) {
      var context = event.context,
        shape = context.shape,
        rootElement = canvas.getRootElement();
      if (isAny(shape, ['bpmn:Participant', 'bpmn:SubProcess']) && is(rootElement, 'bpmn:Collaboration')) {
        getDataStores(rootElement).filter(function (dataStore) {
          return isDescendant(dataStore, shape);
        }).forEach(function (dataStore) {
          updateDataStoreParent(dataStore);
        });
      }
    });
    this.postExecute('canvas.updateRoot', function (event) {
      var context = event.context,
        oldRoot = context.oldRoot,
        newRoot = context.newRoot;
      var dataStores = getDataStores(oldRoot);
      dataStores.forEach(function (dataStore) {
        if (is(newRoot, 'bpmn:Process')) {
          updateDataStoreParent(dataStore, newRoot);
        }
      });
    });
  }
  DataStoreBehavior.$inject = ['canvas', 'commandStack', 'elementRegistry', 'eventBus'];
  e$2(DataStoreBehavior, CommandInterceptor);
  function isDescendant(descendant, ancestor) {
    var descendantBo = descendant.businessObject || descendant,
      ancestorBo = ancestor.businessObject || ancestor;
    while (descendantBo.$parent) {
      if (descendantBo.$parent === ancestorBo.processRef || ancestorBo) {
        return true;
      }
      descendantBo = descendantBo.$parent;
    }
    return false;
  }
  function getAncestor(element, type) {
    while (element.parent) {
      if (is(element.parent, type)) {
        return element.parent;
      }
      element = element.parent;
    }
  }
  var max$5 = Math.max,
    min$3 = Math.min;
  var DEFAULT_CHILD_BOX_PADDING = 20;
  function substractTRBL(trblA, trblB) {
    return {
      top: trblA.top - trblB.top,
      right: trblA.right - trblB.right,
      bottom: trblA.bottom - trblB.bottom,
      left: trblA.left - trblB.left
    };
  }
  function resizeBounds$1(bounds, direction, delta) {
    var dx = delta.x,
      dy = delta.y;
    var newBounds = {
      x: bounds.x,
      y: bounds.y,
      width: bounds.width,
      height: bounds.height
    };
    if (direction.indexOf('n') !== -1) {
      newBounds.y = bounds.y + dy;
      newBounds.height = bounds.height - dy;
    } else if (direction.indexOf('s') !== -1) {
      newBounds.height = bounds.height + dy;
    }
    if (direction.indexOf('e') !== -1) {
      newBounds.width = bounds.width + dx;
    } else if (direction.indexOf('w') !== -1) {
      newBounds.x = bounds.x + dx;
      newBounds.width = bounds.width - dx;
    }
    return newBounds;
  }
  function resizeTRBL(bounds, resize) {
    return {
      x: bounds.x + (resize.left || 0),
      y: bounds.y + (resize.top || 0),
      width: bounds.width - (resize.left || 0) + (resize.right || 0),
      height: bounds.height - (resize.top || 0) + (resize.bottom || 0)
    };
  }
  function applyConstraints(attr, trbl, resizeConstraints) {
    var value = trbl[attr],
      minValue = resizeConstraints.min && resizeConstraints.min[attr],
      maxValue = resizeConstraints.max && resizeConstraints.max[attr];
    if (isNumber(minValue)) {
      value = (/top|left/.test(attr) ? min$3 : max$5)(value, minValue);
    }
    if (isNumber(maxValue)) {
      value = (/top|left/.test(attr) ? max$5 : min$3)(value, maxValue);
    }
    return value;
  }
  function ensureConstraints$2(currentBounds, resizeConstraints) {
    if (!resizeConstraints) {
      return currentBounds;
    }
    var currentTrbl = asTRBL(currentBounds);
    return asBounds({
      top: applyConstraints('top', currentTrbl, resizeConstraints),
      right: applyConstraints('right', currentTrbl, resizeConstraints),
      bottom: applyConstraints('bottom', currentTrbl, resizeConstraints),
      left: applyConstraints('left', currentTrbl, resizeConstraints)
    });
  }
  function getMinResizeBounds(direction, currentBounds, minDimensions, childrenBounds) {
    var currentBox = asTRBL(currentBounds);
    var minBox = {
      top: /n/.test(direction) ? currentBox.bottom - minDimensions.height : currentBox.top,
      left: /w/.test(direction) ? currentBox.right - minDimensions.width : currentBox.left,
      bottom: /s/.test(direction) ? currentBox.top + minDimensions.height : currentBox.bottom,
      right: /e/.test(direction) ? currentBox.left + minDimensions.width : currentBox.right
    };
    var childrenBox = childrenBounds ? asTRBL(childrenBounds) : minBox;
    var combinedBox = {
      top: min$3(minBox.top, childrenBox.top),
      left: min$3(minBox.left, childrenBox.left),
      bottom: max$5(minBox.bottom, childrenBox.bottom),
      right: max$5(minBox.right, childrenBox.right)
    };
    return asBounds(combinedBox);
  }
  function asPadding(mayBePadding, defaultValue) {
    if (typeof mayBePadding !== 'undefined') {
      return mayBePadding;
    } else {
      return DEFAULT_CHILD_BOX_PADDING;
    }
  }
  function addPadding$1(bbox, padding) {
    var left, right, top, bottom;
    if (typeof padding === 'object') {
      left = asPadding(padding.left);
      right = asPadding(padding.right);
      top = asPadding(padding.top);
      bottom = asPadding(padding.bottom);
    } else {
      left = right = top = bottom = asPadding(padding);
    }
    return {
      x: bbox.x - left,
      y: bbox.y - top,
      width: bbox.width + left + right,
      height: bbox.height + top + bottom
    };
  }
  function isBBoxChild(element) {
    if (element.waypoints) {
      return false;
    }
    if (element.type === 'label') {
      return false;
    }
    return true;
  }
  function computeChildrenBBox(shapeOrChildren, padding) {
    var elements;
    if (shapeOrChildren.length === undefined) {
      elements = filter(shapeOrChildren.children, isBBoxChild);
    } else {
      elements = shapeOrChildren;
    }
    if (elements.length) {
      return addPadding$1(getBBox(elements), padding);
    }
  }
  var abs$4 = Math.abs;
  function getTRBLResize(oldBounds, newBounds) {
    return substractTRBL(asTRBL(newBounds), asTRBL(oldBounds));
  }
  var LANE_PARENTS = ['bpmn:Participant', 'bpmn:Process', 'bpmn:SubProcess'];
  var LANE_INDENTATION = 30;
  function collectLanes(shape, collectedShapes) {
    collectedShapes = collectedShapes || [];
    shape.children.filter(function (s) {
      if (is(s, 'bpmn:Lane')) {
        collectLanes(s, collectedShapes);
        collectedShapes.push(s);
      }
    });
    return collectedShapes;
  }
  function getChildLanes(shape) {
    return shape.children.filter(function (c) {
      return is(c, 'bpmn:Lane');
    });
  }
  function getLanesRoot(shape) {
    return getParent(shape, LANE_PARENTS) || shape;
  }
  function computeLanesResize(shape, newBounds) {
    var rootElement = getLanesRoot(shape);
    var initialShapes = is(rootElement, 'bpmn:Process') ? [] : [rootElement];
    var allLanes = collectLanes(rootElement, initialShapes),
      shapeTrbl = asTRBL(shape),
      shapeNewTrbl = asTRBL(newBounds),
      trblResize = getTRBLResize(shape, newBounds),
      resizeNeeded = [];
    var isHorizontalLane = isHorizontal$3(shape);
    allLanes.forEach(function (other) {
      if (other === shape) {
        return;
      }
      var topResize = isHorizontalLane ? 0 : trblResize.top,
        rightResize = isHorizontalLane ? trblResize.right : 0,
        bottomResize = isHorizontalLane ? 0 : trblResize.bottom,
        leftResize = isHorizontalLane ? trblResize.left : 0;
      var otherTrbl = asTRBL(other);
      if (trblResize.top) {
        if (abs$4(otherTrbl.bottom - shapeTrbl.top) < 10) {
          bottomResize = shapeNewTrbl.top - otherTrbl.bottom;
        }
        if (abs$4(otherTrbl.top - shapeTrbl.top) < 5) {
          topResize = shapeNewTrbl.top - otherTrbl.top;
        }
      }
      if (trblResize.left) {
        if (abs$4(otherTrbl.right - shapeTrbl.left) < 10) {
          rightResize = shapeNewTrbl.left - otherTrbl.right;
        }
        if (abs$4(otherTrbl.left - shapeTrbl.left) < 5) {
          leftResize = shapeNewTrbl.left - otherTrbl.left;
        }
      }
      if (trblResize.bottom) {
        if (abs$4(otherTrbl.top - shapeTrbl.bottom) < 10) {
          topResize = shapeNewTrbl.bottom - otherTrbl.top;
        }
        if (abs$4(otherTrbl.bottom - shapeTrbl.bottom) < 5) {
          bottomResize = shapeNewTrbl.bottom - otherTrbl.bottom;
        }
      }
      if (trblResize.right) {
        if (abs$4(otherTrbl.left - shapeTrbl.right) < 10) {
          leftResize = shapeNewTrbl.right - otherTrbl.left;
        }
        if (abs$4(otherTrbl.right - shapeTrbl.right) < 5) {
          rightResize = shapeNewTrbl.right - otherTrbl.right;
        }
      }
      if (topResize || rightResize || bottomResize || leftResize) {
        resizeNeeded.push({
          shape: other,
          newBounds: resizeTRBL(other, {
            top: topResize,
            right: rightResize,
            bottom: bottomResize,
            left: leftResize
          })
        });
      }
    });
    return resizeNeeded;
  }
  var LOW_PRIORITY$i = 500;
  function DeleteLaneBehavior(eventBus, spaceTool) {
    CommandInterceptor.call(this, eventBus);
    function compensateLaneDelete(shape, oldParent) {
      var isHorizontalLane = isHorizontal$3(shape);
      var siblings = getChildLanes(oldParent);
      var topAffected = [];
      var bottomAffected = [];
      var leftAffected = [];
      var rightAffected = [];
      eachElement(siblings, function (element) {
        if (isHorizontalLane) {
          if (element.y > shape.y) {
            bottomAffected.push(element);
          } else {
            topAffected.push(element);
          }
        } else {
          if (element.x > shape.x) {
            rightAffected.push(element);
          } else {
            leftAffected.push(element);
          }
        }
        return element.children;
      });
      if (!siblings.length) {
        return;
      }
      var offset;
      if (isHorizontalLane) {
        if (bottomAffected.length && topAffected.length) {
          offset = shape.height / 2;
        } else {
          offset = shape.height;
        }
      } else {
        if (rightAffected.length && leftAffected.length) {
          offset = shape.width / 2;
        } else {
          offset = shape.width;
        }
      }
      var topAdjustments, bottomAdjustments, leftAdjustments, rightAdjustments;
      if (topAffected.length) {
        topAdjustments = spaceTool.calculateAdjustments(topAffected, 'y', offset, shape.y - 10);
        spaceTool.makeSpace(topAdjustments.movingShapes, topAdjustments.resizingShapes, {
          x: 0,
          y: offset
        }, 's');
      }
      if (bottomAffected.length) {
        bottomAdjustments = spaceTool.calculateAdjustments(bottomAffected, 'y', -offset, shape.y + shape.height + 10);
        spaceTool.makeSpace(bottomAdjustments.movingShapes, bottomAdjustments.resizingShapes, {
          x: 0,
          y: -offset
        }, 'n');
      }
      if (leftAffected.length) {
        leftAdjustments = spaceTool.calculateAdjustments(leftAffected, 'x', offset, shape.x - 10);
        spaceTool.makeSpace(leftAdjustments.movingShapes, leftAdjustments.resizingShapes, {
          x: offset,
          y: 0
        }, 'e');
      }
      if (rightAffected.length) {
        rightAdjustments = spaceTool.calculateAdjustments(rightAffected, 'x', -offset, shape.x + shape.width + 10);
        spaceTool.makeSpace(rightAdjustments.movingShapes, rightAdjustments.resizingShapes, {
          x: -offset,
          y: 0
        }, 'w');
      }
    }
    this.postExecuted('shape.delete', LOW_PRIORITY$i, function (event) {
      var context = event.context,
        hints = context.hints,
        shape = context.shape,
        oldParent = context.oldParent;
      if (!is(shape, 'bpmn:Lane')) {
        return;
      }
      if (hints && hints.nested) {
        return;
      }
      compensateLaneDelete(shape, oldParent);
    });
  }
  DeleteLaneBehavior.$inject = ['eventBus', 'spaceTool'];
  e$2(DeleteLaneBehavior, CommandInterceptor);
  var LOW_PRIORITY$h = 500;
  function DetachEventBehavior(bpmnReplace, injector) {
    injector.invoke(CommandInterceptor, this);
    this._bpmnReplace = bpmnReplace;
    var self = this;
    this.postExecuted('elements.create', LOW_PRIORITY$h, function (context) {
      var elements = context.elements;
      elements.filter(function (shape) {
        var host = shape.host;
        return shouldReplace(shape, host);
      }).map(function (shape) {
        return elements.indexOf(shape);
      }).forEach(function (index) {
        context.elements[index] = self._replaceShape(elements[index]);
      });
    }, true);
    this.preExecute('elements.move', LOW_PRIORITY$h, function (context) {
      var shapes = context.shapes,
        newHost = context.newHost;
      shapes.forEach(function (shape, index) {
        var host = shape.host;
        if (shouldReplace(shape, includes$6(shapes, host) ? host : newHost)) {
          shapes[index] = self._replaceShape(shape);
        }
      });
    }, true);
  }
  DetachEventBehavior.$inject = ['bpmnReplace', 'injector'];
  e$2(DetachEventBehavior, CommandInterceptor);
  DetachEventBehavior.prototype._replaceShape = function (shape) {
    var eventDefinition = getEventDefinition(shape),
      intermediateEvent;
    if (eventDefinition) {
      intermediateEvent = {
        type: 'bpmn:IntermediateCatchEvent',
        eventDefinitionType: eventDefinition.$type
      };
    } else {
      intermediateEvent = {
        type: 'bpmn:IntermediateThrowEvent'
      };
    }
    return this._bpmnReplace.replaceElement(shape, intermediateEvent, {
      layoutConnection: false
    });
  };
  function getEventDefinition(element) {
    var businessObject = getBusinessObject(element),
      eventDefinitions = businessObject.eventDefinitions;
    return eventDefinitions && eventDefinitions[0];
  }
  function shouldReplace(shape, host) {
    return !isLabel(shape) && is(shape, 'bpmn:BoundaryEvent') && !host;
  }
  function includes$6(array, item) {
    return array.indexOf(item) !== -1;
  }
  function DropOnFlowBehavior(eventBus, bpmnRules, modeling) {
    CommandInterceptor.call(this, eventBus);
    function insertShape(shape, targetFlow, positionOrBounds) {
      var waypoints = targetFlow.waypoints,
        waypointsBefore,
        waypointsAfter,
        dockingPoint,
        source,
        target,
        incomingConnection,
        outgoingConnection,
        oldOutgoing = shape.outgoing.slice(),
        oldIncoming = shape.incoming.slice();
      var mid;
      if (isNumber(positionOrBounds.width)) {
        mid = getMid(positionOrBounds);
      } else {
        mid = positionOrBounds;
      }
      var intersection = getApproxIntersection(waypoints, mid);
      if (intersection) {
        waypointsBefore = waypoints.slice(0, intersection.index);
        waypointsAfter = waypoints.slice(intersection.index + (intersection.bendpoint ? 1 : 0));
        if (!waypointsBefore.length || !waypointsAfter.length) {
          return;
        }
        dockingPoint = intersection.bendpoint ? waypoints[intersection.index] : mid;
        if (waypointsBefore.length === 1 || !isPointInsideBBox(shape, waypointsBefore[waypointsBefore.length - 1])) {
          waypointsBefore.push(copy(dockingPoint));
        }
        if (waypointsAfter.length === 1 || !isPointInsideBBox(shape, waypointsAfter[0])) {
          waypointsAfter.unshift(copy(dockingPoint));
        }
      }
      source = targetFlow.source;
      target = targetFlow.target;
      if (bpmnRules.canConnect(source, shape, targetFlow)) {
        modeling.reconnectEnd(targetFlow, shape, waypointsBefore || mid);
        incomingConnection = targetFlow;
      }
      if (bpmnRules.canConnect(shape, target, targetFlow)) {
        if (!incomingConnection) {
          modeling.reconnectStart(targetFlow, shape, waypointsAfter || mid);
          outgoingConnection = targetFlow;
        } else {
          outgoingConnection = modeling.connect(shape, target, {
            type: targetFlow.type,
            waypoints: waypointsAfter
          });
        }
      }
      var duplicateConnections = [].concat(incomingConnection && filter(oldIncoming, function (connection) {
        return connection.source === incomingConnection.source;
      }) || [], outgoingConnection && filter(oldOutgoing, function (connection) {
        return connection.target === outgoingConnection.target;
      }) || []);
      if (duplicateConnections.length) {
        modeling.removeElements(duplicateConnections);
      }
    }
    this.preExecute('elements.move', function (context) {
      var newParent = context.newParent,
        shapes = context.shapes,
        delta = context.delta,
        shape = shapes[0];
      if (!shape || !newParent) {
        return;
      }
      if (newParent && newParent.waypoints) {
        context.newParent = newParent = newParent.parent;
      }
      var shapeMid = getMid(shape);
      var newShapeMid = {
        x: shapeMid.x + delta.x,
        y: shapeMid.y + delta.y
      };
      var connection = find(newParent.children, function (element) {
        var canInsert = bpmnRules.canInsert(shapes, element);
        return canInsert && getApproxIntersection(element.waypoints, newShapeMid);
      });
      if (connection) {
        context.targetFlow = connection;
        context.position = newShapeMid;
      }
    }, true);
    this.postExecuted('elements.move', function (context) {
      var shapes = context.shapes,
        targetFlow = context.targetFlow,
        position = context.position;
      if (targetFlow) {
        insertShape(shapes[0], targetFlow, position);
      }
    }, true);
    this.preExecute('shape.create', function (context) {
      var parent = context.parent,
        shape = context.shape;
      if (bpmnRules.canInsert(shape, parent)) {
        context.targetFlow = parent;
        context.parent = parent.parent;
      }
    }, true);
    this.postExecuted('shape.create', function (context) {
      var shape = context.shape,
        targetFlow = context.targetFlow,
        positionOrBounds = context.position;
      if (targetFlow) {
        insertShape(shape, targetFlow, positionOrBounds);
      }
    }, true);
  }
  e$2(DropOnFlowBehavior, CommandInterceptor);
  DropOnFlowBehavior.$inject = ['eventBus', 'bpmnRules', 'modeling'];
  function isPointInsideBBox(bbox, point) {
    var x = point.x,
      y = point.y;
    return x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;
  }
  function copy(obj) {
    return assign$1({}, obj);
  }
  function EventBasedGatewayBehavior(eventBus, modeling) {
    CommandInterceptor.call(this, eventBus);
    this.preExecuted('connection.create', function (event) {
      var context = event.context,
        connection = context.connection,
        source = context.source,
        target = context.target,
        hints = context.hints;
      if (hints && hints.createElementsBehavior === false) {
        return;
      }
      if (!isSequenceFlow(connection)) {
        return;
      }
      var sequenceFlows = [];
      if (is(source, 'bpmn:EventBasedGateway')) {
        sequenceFlows = target.incoming.filter(function (flow) {
          return flow !== connection && isSequenceFlow(flow);
        });
      } else {
        sequenceFlows = target.incoming.filter(function (flow) {
          return flow !== connection && isSequenceFlow(flow) && is(flow.source, 'bpmn:EventBasedGateway');
        });
      }
      sequenceFlows.forEach(function (sequenceFlow) {
        modeling.removeConnection(sequenceFlow);
      });
    });
    this.preExecuted('shape.replace', function (event) {
      var context = event.context,
        newShape = context.newShape;
      if (!is(newShape, 'bpmn:EventBasedGateway')) {
        return;
      }
      var targets = newShape.outgoing.filter(isSequenceFlow).reduce(function (targets, sequenceFlow) {
        if (!targets.includes(sequenceFlow.target)) {
          return targets.concat(sequenceFlow.target);
        }
        return targets;
      }, []);
      targets.forEach(function (target) {
        target.incoming.filter(isSequenceFlow).forEach(function (sequenceFlow) {
          var sequenceFlowsFromNewShape = target.incoming.filter(isSequenceFlow).filter(function (sequenceFlow) {
            return sequenceFlow.source === newShape;
          });
          if (sequenceFlow.source !== newShape || sequenceFlowsFromNewShape.length > 1) {
            modeling.removeConnection(sequenceFlow);
          }
        });
      });
    });
  }
  EventBasedGatewayBehavior.$inject = ['eventBus', 'modeling'];
  e$2(EventBasedGatewayBehavior, CommandInterceptor);
  function isSequenceFlow(connection) {
    return is(connection, 'bpmn:SequenceFlow');
  }
  var HIGH_PRIORITY$f = 1500;
  var HIGHEST_PRIORITY = 2000;
  function FixHoverBehavior(elementRegistry, eventBus, canvas) {
    eventBus.on(['create.hover', 'create.move', 'create.out', 'create.end', 'shape.move.hover', 'shape.move.move', 'shape.move.out', 'shape.move.end'], HIGH_PRIORITY$f, function (event) {
      var context = event.context,
        shape = context.shape || event.shape,
        hover = event.hover;
      if (is(hover, 'bpmn:Lane') && !isAny(shape, ['bpmn:Lane', 'bpmn:Participant'])) {
        event.hover = getLanesRoot(hover);
        event.hoverGfx = elementRegistry.getGraphics(event.hover);
      }
      var rootElement = canvas.getRootElement();
      if (hover !== rootElement && (shape.labelTarget || isAny(shape, ['bpmn:Group', 'bpmn:TextAnnotation']))) {
        event.hover = rootElement;
        event.hoverGfx = elementRegistry.getGraphics(event.hover);
      }
    });
    eventBus.on(['connect.hover', 'connect.out', 'connect.end', 'connect.cleanup', 'global-connect.hover', 'global-connect.out', 'global-connect.end', 'global-connect.cleanup'], HIGH_PRIORITY$f, function (event) {
      var hover = event.hover;
      if (is(hover, 'bpmn:Lane')) {
        event.hover = getLanesRoot(hover) || hover;
        event.hoverGfx = elementRegistry.getGraphics(event.hover);
      }
    });
    eventBus.on(['bendpoint.move.hover'], HIGH_PRIORITY$f, function (event) {
      var context = event.context,
        hover = event.hover,
        type = context.type;
      if (is(hover, 'bpmn:Lane') && /reconnect/.test(type)) {
        event.hover = getLanesRoot(hover) || hover;
        event.hoverGfx = elementRegistry.getGraphics(event.hover);
      }
    });
    eventBus.on(['connect.start'], HIGH_PRIORITY$f, function (event) {
      var context = event.context,
        start = context.start;
      if (is(start, 'bpmn:Lane')) {
        context.start = getLanesRoot(start) || start;
      }
    });
    eventBus.on('shape.move.start', HIGHEST_PRIORITY, function (event) {
      var shape = event.shape;
      if (is(shape, 'bpmn:Lane')) {
        event.shape = getLanesRoot(shape) || shape;
      }
    });
    eventBus.on('spaceTool.move', HIGHEST_PRIORITY, function (event) {
      var hover = event.hover;
      if (hover && is(hover, 'bpmn:Lane')) {
        event.hover = getLanesRoot(hover);
      }
    });
  }
  FixHoverBehavior.$inject = ['elementRegistry', 'eventBus', 'canvas'];
  function createCategory(bpmnFactory) {
    return bpmnFactory.create('bpmn:Category');
  }
  function createCategoryValue(bpmnFactory) {
    return bpmnFactory.create('bpmn:CategoryValue');
  }
  function linkCategoryValue(categoryValue, category, definitions) {
    add(category.get('categoryValue'), categoryValue);
    categoryValue.$parent = category;
    add(definitions.get('rootElements'), category);
    category.$parent = definitions;
    return categoryValue;
  }
  function unlinkCategoryValue(categoryValue) {
    var category = categoryValue.$parent;
    if (category) {
      remove(category.get('categoryValue'), categoryValue);
      categoryValue.$parent = null;
    }
    return categoryValue;
  }
  function unlinkCategory(category) {
    var definitions = category.$parent;
    if (definitions) {
      remove(definitions.get('rootElements'), category);
      category.$parent = null;
    }
    return category;
  }
  var LOWER_PRIORITY$1 = 770;
  function GroupBehavior(bpmnFactory, bpmnjs, elementRegistry, eventBus, injector, moddleCopy) {
    injector.invoke(CommandInterceptor, this);
    function getGroupElements() {
      return elementRegistry.filter(function (e) {
        return is(e, 'bpmn:Group');
      });
    }
    function isReferencedCategory(elements, category) {
      return elements.some(function (element) {
        var businessObject = getBusinessObject(element);
        var _category = businessObject.categoryValueRef && businessObject.categoryValueRef.$parent;
        return _category === category;
      });
    }
    function isReferencedCategoryValue(elements, categoryValue) {
      return elements.some(function (element) {
        var businessObject = getBusinessObject(element);
        return businessObject.categoryValueRef === categoryValue;
      });
    }
    function removeCategoryValue(categoryValue, category, businessObject) {
      var groups = getGroupElements().filter(function (element) {
        return element.businessObject !== businessObject;
      });
      if (category && !isReferencedCategory(groups, category)) {
        unlinkCategory(category);
      }
      if (categoryValue && !isReferencedCategoryValue(groups, categoryValue)) {
        unlinkCategoryValue(categoryValue);
      }
    }
    function addCategoryValue(categoryValue, category) {
      return linkCategoryValue(categoryValue, category, bpmnjs.getDefinitions());
    }
    function setCategoryValue(element, context) {
      var businessObject = getBusinessObject(element),
        categoryValue = businessObject.categoryValueRef;
      if (!categoryValue) {
        categoryValue = businessObject.categoryValueRef = context.categoryValue = context.categoryValue || createCategoryValue(bpmnFactory);
      }
      var category = categoryValue.$parent;
      if (!category) {
        category = categoryValue.$parent = context.category = context.category || createCategory(bpmnFactory);
      }
      addCategoryValue(categoryValue, category, bpmnjs.getDefinitions());
    }
    function unsetCategoryValue(element, context) {
      var category = context.category,
        categoryValue = context.categoryValue,
        businessObject = getBusinessObject(element);
      if (categoryValue) {
        businessObject.categoryValueRef = null;
        removeCategoryValue(categoryValue, category, businessObject);
      } else {
        removeCategoryValue(null, businessObject.categoryValueRef.$parent, businessObject);
      }
    }
    this.execute('label.create', function (event) {
      var context = event.context,
        labelTarget = context.labelTarget;
      if (!is(labelTarget, 'bpmn:Group')) {
        return;
      }
      setCategoryValue(labelTarget, context);
    });
    this.revert('label.create', function (event) {
      var context = event.context,
        labelTarget = context.labelTarget;
      if (!is(labelTarget, 'bpmn:Group')) {
        return;
      }
      unsetCategoryValue(labelTarget, context);
    });
    this.execute('shape.delete', function (event) {
      var context = event.context,
        shape = context.shape,
        businessObject = getBusinessObject(shape);
      if (!is(shape, 'bpmn:Group') || shape.labelTarget) {
        return;
      }
      var categoryValue = context.categoryValue = businessObject.categoryValueRef,
        category;
      if (categoryValue) {
        category = context.category = categoryValue.$parent;
        removeCategoryValue(categoryValue, category, businessObject);
        businessObject.categoryValueRef = null;
      }
    });
    this.reverted('shape.delete', function (event) {
      var context = event.context,
        shape = context.shape;
      if (!is(shape, 'bpmn:Group') || shape.labelTarget) {
        return;
      }
      var category = context.category,
        categoryValue = context.categoryValue,
        businessObject = getBusinessObject(shape);
      if (categoryValue) {
        businessObject.categoryValueRef = categoryValue;
        addCategoryValue(categoryValue, category);
      }
    });
    this.execute('shape.create', function (event) {
      var context = event.context,
        shape = context.shape;
      if (!is(shape, 'bpmn:Group') || shape.labelTarget) {
        return;
      }
      if (getBusinessObject(shape).categoryValueRef) {
        setCategoryValue(shape, context);
      }
    });
    this.reverted('shape.create', function (event) {
      var context = event.context,
        shape = context.shape;
      if (!is(shape, 'bpmn:Group') || shape.labelTarget) {
        return;
      }
      if (getBusinessObject(shape).categoryValueRef) {
        unsetCategoryValue(shape, context);
      }
    });
    function copy(bo, clone) {
      var targetBo = bpmnFactory.create(bo.$type);
      return moddleCopy.copyElement(bo, targetBo, null, clone);
    }
    eventBus.on('copyPaste.copyElement', LOWER_PRIORITY$1, function (context) {
      var descriptor = context.descriptor,
        element = context.element;
      if (!is(element, 'bpmn:Group') || element.labelTarget) {
        return;
      }
      var groupBo = getBusinessObject(element);
      if (groupBo.categoryValueRef) {
        var categoryValue = groupBo.categoryValueRef;
        descriptor.categoryValue = copy(categoryValue, true);
        if (categoryValue.$parent) {
          descriptor.category = copy(categoryValue.$parent, true);
        }
      }
    });
    eventBus.on('copyPaste.pasteElement', LOWER_PRIORITY$1, function (context) {
      var descriptor = context.descriptor,
        businessObject = descriptor.businessObject,
        categoryValue = descriptor.categoryValue,
        category = descriptor.category;
      if (categoryValue) {
        categoryValue = businessObject.categoryValueRef = copy(categoryValue);
      }
      if (category) {
        categoryValue.$parent = copy(category);
      }
      delete descriptor.category;
      delete descriptor.categoryValue;
    });
  }
  GroupBehavior.$inject = ['bpmnFactory', 'bpmnjs', 'elementRegistry', 'eventBus', 'injector', 'moddleCopy'];
  e$2(GroupBehavior, CommandInterceptor);
  function lineIntersect(l1s, l1e, l2s, l2e) {
    var denominator, a, b, c, numerator;
    denominator = (l2e.y - l2s.y) * (l1e.x - l1s.x) - (l2e.x - l2s.x) * (l1e.y - l1s.y);
    if (denominator == 0) {
      return null;
    }
    a = l1s.y - l2s.y;
    b = l1s.x - l2s.x;
    numerator = (l2e.x - l2s.x) * a - (l2e.y - l2s.y) * b;
    c = numerator / denominator;
    return {
      x: Math.round(l1s.x + c * (l1e.x - l1s.x)),
      y: Math.round(l1s.y + c * (l1e.y - l1s.y))
    };
  }
  function ImportDockingFix(eventBus) {
    function adjustDocking(startPoint, nextPoint, elementMid) {
      var elementTop = {
        x: elementMid.x,
        y: elementMid.y - 50
      };
      var elementLeft = {
        x: elementMid.x - 50,
        y: elementMid.y
      };
      var verticalIntersect = lineIntersect(startPoint, nextPoint, elementMid, elementTop),
        horizontalIntersect = lineIntersect(startPoint, nextPoint, elementMid, elementLeft);
      var centerIntersect;
      if (verticalIntersect && horizontalIntersect) {
        if (getDistance$1(verticalIntersect, elementMid) > getDistance$1(horizontalIntersect, elementMid)) {
          centerIntersect = horizontalIntersect;
        } else {
          centerIntersect = verticalIntersect;
        }
      } else {
        centerIntersect = verticalIntersect || horizontalIntersect;
      }
      startPoint.original = centerIntersect;
    }
    function fixDockings(connection) {
      var waypoints = connection.waypoints;
      adjustDocking(waypoints[0], waypoints[1], getMid(connection.source));
      adjustDocking(waypoints[waypoints.length - 1], waypoints[waypoints.length - 2], getMid(connection.target));
    }
    eventBus.on('bpmnElement.added', function (e) {
      var element = e.element;
      if (element.waypoints) {
        fixDockings(element);
      }
    });
  }
  ImportDockingFix.$inject = ['eventBus'];
  function getDistance$1(p1, p2) {
    return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
  }
  function IsHorizontalFix(eventBus) {
    CommandInterceptor.call(this, eventBus);
    var elementTypesToUpdate = ['bpmn:Participant', 'bpmn:Lane'];
    this.executed(['shape.move', 'shape.create', 'shape.resize'], function (event) {
      var shape = event.context.shape,
        bo = getBusinessObject(shape),
        di = getDi(shape);
      if (isAny(bo, elementTypesToUpdate)) {
        var isHorizontal = di.get('isHorizontal');
        if (isHorizontal === undefined) {
          isHorizontal = true;
        }
        di.set('isHorizontal', isHorizontal);
      }
    });
  }
  IsHorizontalFix.$inject = ['eventBus'];
  e$2(IsHorizontalFix, CommandInterceptor);
  var sqrt = Math.sqrt,
    min$2 = Math.min,
    max$4 = Math.max,
    abs$3 = Math.abs;
  function sq(n) {
    return Math.pow(n, 2);
  }
  function getDistance(p1, p2) {
    return sqrt(sq(p1.x - p2.x) + sq(p1.y - p2.y));
  }
  function getAttachment(point, line) {
    var idx = 0,
      segmentStart,
      segmentEnd,
      segmentStartDistance,
      segmentEndDistance,
      attachmentPosition,
      minDistance,
      intersections,
      attachment,
      attachmentDistance,
      closestAttachmentDistance,
      closestAttachment;
    for (idx = 0; idx < line.length - 1; idx++) {
      segmentStart = line[idx];
      segmentEnd = line[idx + 1];
      if (pointsEqual(segmentStart, segmentEnd)) {
        intersections = [segmentStart];
      } else {
        segmentStartDistance = getDistance(point, segmentStart);
        segmentEndDistance = getDistance(point, segmentEnd);
        minDistance = min$2(segmentStartDistance, segmentEndDistance);
        intersections = getCircleSegmentIntersections(segmentStart, segmentEnd, point, minDistance);
      }
      if (intersections.length < 1) {
        throw new Error('expected between [1, 2] circle -> line intersections');
      }
      if (intersections.length === 1) {
        attachment = {
          type: 'bendpoint',
          position: intersections[0],
          segmentIndex: idx,
          bendpointIndex: pointsEqual(segmentStart, intersections[0]) ? idx : idx + 1
        };
      }
      if (intersections.length === 2) {
        attachmentPosition = mid$1(intersections[0], intersections[1]);
        attachment = {
          type: 'segment',
          position: attachmentPosition,
          segmentIndex: idx,
          relativeLocation: getDistance(segmentStart, attachmentPosition) / getDistance(segmentStart, segmentEnd)
        };
      }
      attachmentDistance = getDistance(attachment.position, point);
      if (!closestAttachment || closestAttachmentDistance > attachmentDistance) {
        closestAttachment = attachment;
        closestAttachmentDistance = attachmentDistance;
      }
    }
    return closestAttachment;
  }
  function getCircleSegmentIntersections(s1, s2, cc, cr) {
    var baX = s2.x - s1.x;
    var baY = s2.y - s1.y;
    var caX = cc.x - s1.x;
    var caY = cc.y - s1.y;
    var a = baX * baX + baY * baY;
    var bBy2 = baX * caX + baY * caY;
    var c = caX * caX + caY * caY - cr * cr;
    var pBy2 = bBy2 / a;
    var q = c / a;
    var disc = pBy2 * pBy2 - q;
    if (disc < 0 && disc > -1e-6) {
      disc = 0;
    }
    if (disc < 0) {
      return [];
    }
    var tmpSqrt = sqrt(disc);
    var abScalingFactor1 = -pBy2 + tmpSqrt;
    var abScalingFactor2 = -pBy2 - tmpSqrt;
    var i1 = {
      x: s1.x - baX * abScalingFactor1,
      y: s1.y - baY * abScalingFactor1
    };
    if (disc === 0) {
      return [i1];
    }
    var i2 = {
      x: s1.x - baX * abScalingFactor2,
      y: s1.y - baY * abScalingFactor2
    };
    return [i1, i2].filter(function (p) {
      return isPointInSegment(p, s1, s2);
    });
  }
  function isPointInSegment(p, segmentStart, segmentEnd) {
    return fenced(p.x, segmentStart.x, segmentEnd.x) && fenced(p.y, segmentStart.y, segmentEnd.y);
  }
  function fenced(n, rangeStart, rangeEnd) {
    return n >= min$2(rangeStart, rangeEnd) - EQUAL_THRESHOLD && n <= max$4(rangeStart, rangeEnd) + EQUAL_THRESHOLD;
  }
  function mid$1(p1, p2) {
    return {
      x: (p1.x + p2.x) / 2,
      y: (p1.y + p2.y) / 2
    };
  }
  var EQUAL_THRESHOLD = 0.1;
  function pointsEqual(p1, p2) {
    return abs$3(p1.x - p2.x) <= EQUAL_THRESHOLD && abs$3(p1.y - p2.y) <= EQUAL_THRESHOLD;
  }
  function findNewLineStartIndex(oldWaypoints, newWaypoints, attachment, hints) {
    var index = attachment.segmentIndex;
    var offset = newWaypoints.length - oldWaypoints.length;
    if (hints.segmentMove) {
      var oldSegmentStartIndex = hints.segmentMove.segmentStartIndex,
        newSegmentStartIndex = hints.segmentMove.newSegmentStartIndex;
      if (index === oldSegmentStartIndex) {
        return newSegmentStartIndex;
      }
      if (index >= newSegmentStartIndex) {
        return index + offset < newSegmentStartIndex ? newSegmentStartIndex : index + offset;
      }
      return index;
    }
    if (hints.bendpointMove) {
      var insert = hints.bendpointMove.insert,
        bendpointIndex = hints.bendpointMove.bendpointIndex,
        newIndex;
      if (offset === 0) {
        return index;
      }
      if (index >= bendpointIndex) {
        newIndex = insert ? index + 1 : index - 1;
      }
      if (index < bendpointIndex) {
        newIndex = index;
        if (insert && attachment.type !== 'bendpoint' && bendpointIndex - 1 === index) {
          var rel = relativePositionMidWaypoint(newWaypoints, bendpointIndex);
          if (rel < attachment.relativeLocation) {
            newIndex++;
          }
        }
      }
      return newIndex;
    }
    if (offset === 0) {
      return index;
    }
    if (hints.connectionStart && index === 0) {
      return 0;
    }
    if (hints.connectionEnd && index === oldWaypoints.length - 2) {
      return newWaypoints.length - 2;
    }
    return Math.floor((newWaypoints.length - 2) / 2);
  }
  function getAnchorPointAdjustment(position, newWaypoints, oldWaypoints, hints) {
    var dx = 0,
      dy = 0;
    var oldPosition = {
      point: position,
      delta: {
        x: 0,
        y: 0
      }
    };
    var attachment = getAttachment(position, oldWaypoints),
      oldLabelLineIndex = attachment.segmentIndex,
      newLabelLineIndex = findNewLineStartIndex(oldWaypoints, newWaypoints, attachment, hints);
    if (newLabelLineIndex < 0 || newLabelLineIndex > newWaypoints.length - 2 || newLabelLineIndex === null) {
      return oldPosition;
    }
    var oldLabelLine = getLine(oldWaypoints, oldLabelLineIndex),
      newLabelLine = getLine(newWaypoints, newLabelLineIndex),
      oldFoot = attachment.position;
    var relativeFootPosition = getRelativeFootPosition(oldLabelLine, oldFoot),
      angleDelta = getAngleDelta(oldLabelLine, newLabelLine);
    if (attachment.type === 'bendpoint') {
      var offset = newWaypoints.length - oldWaypoints.length,
        oldBendpointIndex = attachment.bendpointIndex,
        oldBendpoint = oldWaypoints[oldBendpointIndex];
      if (newWaypoints.indexOf(oldBendpoint) !== -1) {
        return oldPosition;
      }
      if (offset === 0) {
        var newBendpoint = newWaypoints[oldBendpointIndex];
        dx = newBendpoint.x - attachment.position.x, dy = newBendpoint.y - attachment.position.y;
        return {
          delta: {
            x: dx,
            y: dy
          },
          point: {
            x: position.x + dx,
            y: position.y + dy
          }
        };
      }
      if (offset < 0 && oldBendpointIndex !== 0 && oldBendpointIndex < oldWaypoints.length - 1) {
        relativeFootPosition = relativePositionMidWaypoint(oldWaypoints, oldBendpointIndex);
      }
    }
    var newFoot = {
      x: (newLabelLine[1].x - newLabelLine[0].x) * relativeFootPosition + newLabelLine[0].x,
      y: (newLabelLine[1].y - newLabelLine[0].y) * relativeFootPosition + newLabelLine[0].y
    };
    var newLabelVector = rotateVector({
      x: position.x - oldFoot.x,
      y: position.y - oldFoot.y
    }, angleDelta);
    dx = newFoot.x + newLabelVector.x - position.x;
    dy = newFoot.y + newLabelVector.y - position.y;
    return {
      point: roundPoint(newFoot),
      delta: roundPoint({
        x: dx,
        y: dy
      })
    };
  }
  function relativePositionMidWaypoint(waypoints, idx) {
    var distanceSegment1 = getDistancePointPoint(waypoints[idx - 1], waypoints[idx]),
      distanceSegment2 = getDistancePointPoint(waypoints[idx], waypoints[idx + 1]);
    var relativePosition = distanceSegment1 / (distanceSegment1 + distanceSegment2);
    return relativePosition;
  }
  function getAngleDelta(l1, l2) {
    var a1 = getAngle(l1),
      a2 = getAngle(l2);
    return a2 - a1;
  }
  function getLine(waypoints, idx) {
    return [waypoints[idx], waypoints[idx + 1]];
  }
  function getRelativeFootPosition(line, foot) {
    var length = getDistancePointPoint(line[0], line[1]),
      lengthToFoot = getDistancePointPoint(line[0], foot);
    return length === 0 ? 0 : lengthToFoot / length;
  }
  function getLabelAdjustment(label, newWaypoints, oldWaypoints, hints) {
    var labelPosition = getMid(label);
    return getAnchorPointAdjustment(labelPosition, newWaypoints, oldWaypoints, hints).delta;
  }
  function getNewAttachPoint(point, oldBounds, newBounds) {
    var oldCenter = center(oldBounds),
      newCenter = center(newBounds),
      oldDelta = delta(point, oldCenter);
    var newDelta = {
      x: oldDelta.x * (newBounds.width / oldBounds.width),
      y: oldDelta.y * (newBounds.height / oldBounds.height)
    };
    return roundPoint({
      x: newCenter.x + newDelta.x,
      y: newCenter.y + newDelta.y
    });
  }
  function getNewAttachShapeDelta(shape, oldBounds, newBounds) {
    var shapeCenter = center(shape),
      oldCenter = center(oldBounds),
      newCenter = center(newBounds),
      shapeDelta = delta(shape, shapeCenter),
      oldCenterDelta = delta(shapeCenter, oldCenter),
      stickyPositionDelta = getStickyPositionDelta(shapeCenter, oldBounds, newBounds);
    if (stickyPositionDelta) {
      return stickyPositionDelta;
    }
    var newCenterDelta = {
      x: oldCenterDelta.x * (newBounds.width / oldBounds.width),
      y: oldCenterDelta.y * (newBounds.height / oldBounds.height)
    };
    var newShapeCenter = {
      x: newCenter.x + newCenterDelta.x,
      y: newCenter.y + newCenterDelta.y
    };
    return roundPoint({
      x: newShapeCenter.x + shapeDelta.x - shape.x,
      y: newShapeCenter.y + shapeDelta.y - shape.y
    });
  }
  function getStickyPositionDelta(oldShapeCenter, oldBounds, newBounds) {
    var oldTRBL = asTRBL(oldBounds),
      newTRBL = asTRBL(newBounds);
    if (isMoved(oldTRBL, newTRBL)) {
      return null;
    }
    var oldOrientation = getOrientation(oldBounds, oldShapeCenter),
      stickyPositionDelta,
      newShapeCenter,
      newOrientation;
    if (oldOrientation === 'top') {
      stickyPositionDelta = {
        x: 0,
        y: newTRBL.bottom - oldTRBL.bottom
      };
    } else if (oldOrientation === 'bottom') {
      stickyPositionDelta = {
        x: 0,
        y: newTRBL.top - oldTRBL.top
      };
    } else if (oldOrientation === 'right') {
      stickyPositionDelta = {
        x: newTRBL.left - oldTRBL.left,
        y: 0
      };
    } else if (oldOrientation === 'left') {
      stickyPositionDelta = {
        x: newTRBL.right - oldTRBL.right,
        y: 0
      };
    } else {
      return null;
    }
    newShapeCenter = {
      x: oldShapeCenter.x + stickyPositionDelta.x,
      y: oldShapeCenter.y + stickyPositionDelta.y
    };
    newOrientation = getOrientation(newBounds, newShapeCenter);
    if (newOrientation !== oldOrientation) {
      return null;
    }
    return stickyPositionDelta;
  }
  function isMoved(oldTRBL, newTRBL) {
    return isHorizontallyMoved(oldTRBL, newTRBL) || isVerticallyMoved(oldTRBL, newTRBL);
  }
  function isHorizontallyMoved(oldTRBL, newTRBL) {
    return oldTRBL.right !== newTRBL.right && oldTRBL.left !== newTRBL.left;
  }
  function isVerticallyMoved(oldTRBL, newTRBL) {
    return oldTRBL.top !== newTRBL.top && oldTRBL.bottom !== newTRBL.bottom;
  }
  var NAME_PROPERTY = 'name';
  var TEXT_PROPERTY = 'text';
  function LabelBehavior(eventBus, modeling, bpmnFactory, textRenderer) {
    CommandInterceptor.call(this, eventBus);
    this.postExecute('element.updateProperties', onPropertyUpdate);
    this.postExecute('element.updateModdleProperties', function (e) {
      var elementBo = getBusinessObject(e.context.element);
      if (elementBo === e.context.moddleElement) {
        onPropertyUpdate(e);
      }
    });
    function onPropertyUpdate(e) {
      var context = e.context,
        element = context.element,
        properties = context.properties;
      if (NAME_PROPERTY in properties) {
        modeling.updateLabel(element, properties[NAME_PROPERTY]);
      }
      if (TEXT_PROPERTY in properties && is(element, 'bpmn:TextAnnotation')) {
        var newBounds = textRenderer.getTextAnnotationBounds({
          x: element.x,
          y: element.y,
          width: element.width,
          height: element.height
        }, properties[TEXT_PROPERTY] || '');
        modeling.updateLabel(element, properties.text, newBounds);
      }
    }
    this.postExecute(['shape.create', 'connection.create'], function (e) {
      var context = e.context,
        hints = context.hints || {};
      if (hints.createElementsBehavior === false) {
        return;
      }
      var element = context.shape || context.connection;
      if (isLabel(element) || !isLabelExternal(element)) {
        return;
      }
      if (!getLabel(element)) {
        return;
      }
      modeling.updateLabel(element, getLabel(element));
    });
    this.postExecute('shape.delete', function (event) {
      var context = event.context,
        labelTarget = context.labelTarget,
        hints = context.hints || {};
      if (labelTarget && hints.unsetLabel !== false) {
        modeling.updateLabel(labelTarget, null, null, {
          removeShape: false
        });
      }
    });
    function getVisibleLabelAdjustment(event) {
      var context = event.context,
        connection = context.connection,
        label = connection.label,
        hints = assign$1({}, context.hints),
        newWaypoints = context.newWaypoints || connection.waypoints,
        oldWaypoints = context.oldWaypoints;
      if (typeof hints.startChanged === 'undefined') {
        hints.startChanged = !!hints.connectionStart;
      }
      if (typeof hints.endChanged === 'undefined') {
        hints.endChanged = !!hints.connectionEnd;
      }
      return getLabelAdjustment(label, newWaypoints, oldWaypoints, hints);
    }
    this.postExecute(['connection.layout', 'connection.updateWaypoints'], function (event) {
      var context = event.context,
        hints = context.hints || {};
      if (hints.labelBehavior === false) {
        return;
      }
      var connection = context.connection,
        label = connection.label,
        labelAdjustment;
      if (!label || !label.parent) {
        return;
      }
      labelAdjustment = getVisibleLabelAdjustment(event);
      modeling.moveShape(label, labelAdjustment);
    });
    this.postExecute(['shape.replace'], function (event) {
      var context = event.context,
        newShape = context.newShape,
        oldShape = context.oldShape;
      var businessObject = getBusinessObject(newShape);
      if (businessObject && isLabelExternal(businessObject) && oldShape.label && newShape.label) {
        newShape.label.x = oldShape.label.x;
        newShape.label.y = oldShape.label.y;
      }
    });
    this.postExecute('shape.resize', function (event) {
      var context = event.context,
        shape = context.shape,
        newBounds = context.newBounds,
        oldBounds = context.oldBounds;
      if (hasExternalLabel(shape)) {
        var label = shape.label,
          labelMid = getMid(label),
          edges = asEdges(oldBounds);
        var referencePoint = getReferencePoint$1(labelMid, edges);
        var delta = getReferencePointDelta(referencePoint, oldBounds, newBounds);
        modeling.moveShape(label, delta);
      }
    });
  }
  e$2(LabelBehavior, CommandInterceptor);
  LabelBehavior.$inject = ['eventBus', 'modeling', 'bpmnFactory', 'textRenderer'];
  function getReferencePointDelta(referencePoint, oldBounds, newBounds) {
    var newReferencePoint = getNewAttachPoint(referencePoint, oldBounds, newBounds);
    return roundPoint(delta(newReferencePoint, referencePoint));
  }
  function getReferencePoint$1(point, lines) {
    if (!lines.length) {
      return;
    }
    var nearestLine = getNearestLine(point, lines);
    return perpendicularFoot(point, nearestLine);
  }
  function asEdges(bounds) {
    return [[{
      x: bounds.x,
      y: bounds.y
    }, {
      x: bounds.x + (bounds.width || 0),
      y: bounds.y
    }], [{
      x: bounds.x + (bounds.width || 0),
      y: bounds.y
    }, {
      x: bounds.x + (bounds.width || 0),
      y: bounds.y + (bounds.height || 0)
    }], [{
      x: bounds.x,
      y: bounds.y + (bounds.height || 0)
    }, {
      x: bounds.x + (bounds.width || 0),
      y: bounds.y + (bounds.height || 0)
    }], [{
      x: bounds.x,
      y: bounds.y
    }, {
      x: bounds.x,
      y: bounds.y + (bounds.height || 0)
    }]];
  }
  function getNearestLine(point, lines) {
    var distances = lines.map(function (l) {
      return {
        line: l,
        distance: getDistancePointLine(point, l)
      };
    });
    var sorted = sortBy(distances, 'distance');
    return sorted[0].line;
  }
  function getConnectionAdjustment(position, newWaypoints, oldWaypoints, hints) {
    return getAnchorPointAdjustment(position, newWaypoints, oldWaypoints, hints).point;
  }
  function LayoutConnectionBehavior(eventBus, modeling) {
    CommandInterceptor.call(this, eventBus);
    function getnewAnchorPoint(event, point) {
      var context = event.context,
        connection = context.connection,
        hints = assign$1({}, context.hints),
        newWaypoints = context.newWaypoints || connection.waypoints,
        oldWaypoints = context.oldWaypoints;
      if (typeof hints.startChanged === 'undefined') {
        hints.startChanged = !!hints.connectionStart;
      }
      if (typeof hints.endChanged === 'undefined') {
        hints.endChanged = !!hints.connectionEnd;
      }
      return getConnectionAdjustment(point, newWaypoints, oldWaypoints, hints);
    }
    this.postExecute(['connection.layout', 'connection.updateWaypoints'], function (event) {
      var context = event.context;
      var connection = context.connection,
        outgoing = connection.outgoing,
        incoming = connection.incoming;
      incoming.forEach(function (connection) {
        var endPoint = connection.waypoints[connection.waypoints.length - 1];
        var newEndpoint = getnewAnchorPoint(event, endPoint);
        var newWaypoints = [].concat(connection.waypoints.slice(0, -1), [newEndpoint]);
        modeling.updateWaypoints(connection, newWaypoints);
      });
      outgoing.forEach(function (connection) {
        var startpoint = connection.waypoints[0];
        var newStartpoint = getnewAnchorPoint(event, startpoint);
        var newWaypoints = [].concat([newStartpoint], connection.waypoints.slice(1));
        modeling.updateWaypoints(connection, newWaypoints);
      });
    });
    this.postExecute(['connection.move'], function (event) {
      var context = event.context;
      var connection = context.connection,
        outgoing = connection.outgoing,
        incoming = connection.incoming,
        delta = context.delta;
      incoming.forEach(function (connection) {
        var endPoint = connection.waypoints[connection.waypoints.length - 1];
        var newEndpoint = {
          x: endPoint.x + delta.x,
          y: endPoint.y + delta.y
        };
        var newWaypoints = [].concat(connection.waypoints.slice(0, -1), [newEndpoint]);
        modeling.updateWaypoints(connection, newWaypoints);
      });
      outgoing.forEach(function (connection) {
        var startpoint = connection.waypoints[0];
        var newStartpoint = {
          x: startpoint.x + delta.x,
          y: startpoint.y + delta.y
        };
        var newWaypoints = [].concat([newStartpoint], connection.waypoints.slice(1));
        modeling.updateWaypoints(connection, newWaypoints);
      });
    });
  }
  e$2(LayoutConnectionBehavior, CommandInterceptor);
  LayoutConnectionBehavior.$inject = ['eventBus', 'modeling'];
  function getResizedSourceAnchor(connection, shape, oldBounds) {
    var waypoints = safeGetWaypoints(connection),
      waypointsInsideNewBounds = getWaypointsInsideBounds(waypoints, shape),
      oldAnchor = waypoints[0];
    if (waypointsInsideNewBounds.length) {
      return waypointsInsideNewBounds[waypointsInsideNewBounds.length - 1];
    }
    return getNewAttachPoint(oldAnchor.original || oldAnchor, oldBounds, shape);
  }
  function getResizedTargetAnchor(connection, shape, oldBounds) {
    var waypoints = safeGetWaypoints(connection),
      waypointsInsideNewBounds = getWaypointsInsideBounds(waypoints, shape),
      oldAnchor = waypoints[waypoints.length - 1];
    if (waypointsInsideNewBounds.length) {
      return waypointsInsideNewBounds[0];
    }
    return getNewAttachPoint(oldAnchor.original || oldAnchor, oldBounds, shape);
  }
  function getMovedSourceAnchor(connection, source, moveDelta) {
    var waypoints = safeGetWaypoints(connection),
      oldBounds = subtract(source, moveDelta),
      oldAnchor = waypoints[0];
    return getNewAttachPoint(oldAnchor.original || oldAnchor, oldBounds, source);
  }
  function getMovedTargetAnchor(connection, target, moveDelta) {
    var waypoints = safeGetWaypoints(connection),
      oldBounds = subtract(target, moveDelta),
      oldAnchor = waypoints[waypoints.length - 1];
    return getNewAttachPoint(oldAnchor.original || oldAnchor, oldBounds, target);
  }
  function subtract(bounds, delta) {
    return {
      x: bounds.x - delta.x,
      y: bounds.y - delta.y,
      width: bounds.width,
      height: bounds.height
    };
  }
  function safeGetWaypoints(connection) {
    var waypoints = connection.waypoints;
    if (!waypoints.length) {
      throw new Error('connection#' + connection.id + ': no waypoints');
    }
    return waypoints;
  }
  function getWaypointsInsideBounds(waypoints, bounds) {
    var originalWaypoints = map$1(waypoints, getOriginal);
    return filter(originalWaypoints, function (waypoint) {
      return isInsideBounds(waypoint, bounds);
    });
  }
  function isInsideBounds(point, bounds) {
    return getOrientation(bounds, point, 1) === 'intersect';
  }
  function getOriginal(point) {
    return point.original || point;
  }
  function MessageFlowBehavior(eventBus, modeling) {
    CommandInterceptor.call(this, eventBus);
    this.postExecute('shape.replace', function (context) {
      var oldShape = context.oldShape,
        newShape = context.newShape;
      if (!isParticipantCollapse(oldShape, newShape)) {
        return;
      }
      var messageFlows = getMessageFlows(oldShape);
      messageFlows.incoming.forEach(function (incoming) {
        var anchor = getResizedTargetAnchor(incoming, newShape, oldShape);
        modeling.reconnectEnd(incoming, newShape, anchor);
      });
      messageFlows.outgoing.forEach(function (outgoing) {
        var anchor = getResizedSourceAnchor(outgoing, newShape, oldShape);
        modeling.reconnectStart(outgoing, newShape, anchor);
      });
    }, true);
  }
  MessageFlowBehavior.$inject = ['eventBus', 'modeling'];
  e$2(MessageFlowBehavior, CommandInterceptor);
  function isParticipantCollapse(oldShape, newShape) {
    return is(oldShape, 'bpmn:Participant') && isExpanded(oldShape) && is(newShape, 'bpmn:Participant') && !isExpanded(newShape);
  }
  function getMessageFlows(parent) {
    var elements = selfAndAllChildren([parent], false);
    var incoming = [],
      outgoing = [];
    elements.forEach(function (element) {
      if (element === parent) {
        return;
      }
      element.incoming.forEach(function (connection) {
        if (is(connection, 'bpmn:MessageFlow')) {
          incoming.push(connection);
        }
      });
      element.outgoing.forEach(function (connection) {
        if (is(connection, 'bpmn:MessageFlow')) {
          outgoing.push(connection);
        }
      });
    }, []);
    return {
      incoming: incoming,
      outgoing: outgoing
    };
  }
  var NON_INTERRUPTING_EVENT_TYPES = ['bpmn:MessageEventDefinition', 'bpmn:TimerEventDefinition', 'bpmn:EscalationEventDefinition', 'bpmn:ConditionalEventDefinition', 'bpmn:SignalEventDefinition'];
  function canBeNonInterrupting(shape) {
    var businessObject = getBusinessObject(shape);
    if (!is(businessObject, 'bpmn:BoundaryEvent') && !(is(businessObject, 'bpmn:StartEvent') && isEventSubProcess(businessObject.$parent))) {
      return false;
    }
    var eventDefinitions = businessObject.get('eventDefinitions');
    if (!eventDefinitions || !eventDefinitions.length) {
      return false;
    }
    return NON_INTERRUPTING_EVENT_TYPES.some(function (event) {
      return is(eventDefinitions[0], event);
    });
  }
  function getInterruptingProperty(shape) {
    return is(shape, 'bpmn:BoundaryEvent') ? 'cancelActivity' : 'isInterrupting';
  }
  function NonInterruptingBehavior(injector, modeling) {
    injector.invoke(CommandInterceptor, this);
    this.postExecuted('shape.replace', function (event) {
      var oldShape = event.context.oldShape;
      var newShape = event.context.newShape;
      var hints = event.context.hints;
      if (!canBeNonInterrupting(newShape)) {
        return;
      }
      var property = getInterruptingProperty(newShape);
      var isExplicitChange = hints.targetElement && hints.targetElement[property] !== undefined;
      if (isExplicitChange) {
        return;
      }
      var isOldInterrupting = getBusinessObject(oldShape).get(property);
      var isNewInterruptingDefault = getBusinessObject(newShape).get(property);
      if (isOldInterrupting === isNewInterruptingDefault) {
        return;
      }
      modeling.updateProperties(newShape, {
        [property]: isOldInterrupting
      });
    });
  }
  NonInterruptingBehavior.$inject = ['injector', 'modeling'];
  e$2(NonInterruptingBehavior, CommandInterceptor);
  function RemoveEmbeddedLabelBoundsBehavior(eventBus, modeling) {
    CommandInterceptor.call(this, eventBus);
    this.preExecute('shape.resize', function (context) {
      var shape = context.shape;
      var di = getDi(shape),
        label = di && di.get('label'),
        bounds = label && label.get('bounds');
      if (bounds) {
        modeling.updateModdleProperties(shape, label, {
          bounds: undefined
        });
      }
    }, true);
  }
  e$2(RemoveEmbeddedLabelBoundsBehavior, CommandInterceptor);
  RemoveEmbeddedLabelBoundsBehavior.$inject = ['eventBus', 'modeling'];
  function RemoveElementBehavior(eventBus, bpmnRules, modeling) {
    CommandInterceptor.call(this, eventBus);
    this.preExecute('shape.delete', function (e) {
      var shape = e.context.shape;
      if (shape.incoming.length !== 1 || shape.outgoing.length !== 1) {
        return;
      }
      var inConnection = shape.incoming[0],
        outConnection = shape.outgoing[0];
      if (!is(inConnection, 'bpmn:SequenceFlow') || !is(outConnection, 'bpmn:SequenceFlow')) {
        return;
      }
      if (bpmnRules.canConnect(inConnection.source, outConnection.target, inConnection)) {
        var newWaypoints = getNewWaypoints(inConnection.waypoints, outConnection.waypoints);
        modeling.reconnectEnd(inConnection, outConnection.target, newWaypoints);
      }
    });
  }
  e$2(RemoveElementBehavior, CommandInterceptor);
  RemoveElementBehavior.$inject = ['eventBus', 'bpmnRules', 'modeling'];
  function getDocking$1(point) {
    return point.original || point;
  }
  function getNewWaypoints(inWaypoints, outWaypoints) {
    var intersection = lineIntersect(getDocking$1(inWaypoints[inWaypoints.length - 2]), getDocking$1(inWaypoints[inWaypoints.length - 1]), getDocking$1(outWaypoints[1]), getDocking$1(outWaypoints[0]));
    if (intersection) {
      return [].concat(inWaypoints.slice(0, inWaypoints.length - 1), [intersection], outWaypoints.slice(1));
    } else {
      return [getDocking$1(inWaypoints[0]), getDocking$1(outWaypoints[outWaypoints.length - 1])];
    }
  }
  function RemoveParticipantBehavior(eventBus, modeling) {
    CommandInterceptor.call(this, eventBus);
    this.preExecute('shape.delete', function (context) {
      var shape = context.shape,
        parent = shape.parent;
      if (is(shape, 'bpmn:Participant')) {
        context.collaborationRoot = parent;
      }
    }, true);
    this.postExecute('shape.delete', function (context) {
      var collaborationRoot = context.collaborationRoot;
      if (collaborationRoot && !collaborationRoot.businessObject.participants.length) {
        var process = modeling.makeProcess();
        var children = collaborationRoot.children.slice();
        modeling.moveElements(children, {
          x: 0,
          y: 0
        }, process);
      }
    }, true);
  }
  RemoveParticipantBehavior.$inject = ['eventBus', 'modeling'];
  e$2(RemoveParticipantBehavior, CommandInterceptor);
  function ReplaceConnectionBehavior(eventBus, modeling, bpmnRules, injector) {
    CommandInterceptor.call(this, eventBus);
    var dragging = injector.get('dragging', false);
    function fixConnection(connection) {
      var source = connection.source,
        target = connection.target,
        parent = connection.parent;
      if (!parent) {
        return;
      }
      var replacementType, remove;
      if (is(connection, 'bpmn:SequenceFlow')) {
        if (!bpmnRules.canConnectSequenceFlow(source, target)) {
          remove = true;
        }
        if (bpmnRules.canConnectMessageFlow(source, target)) {
          replacementType = 'bpmn:MessageFlow';
        }
      }
      if (is(connection, 'bpmn:MessageFlow')) {
        if (!bpmnRules.canConnectMessageFlow(source, target)) {
          remove = true;
        }
        if (bpmnRules.canConnectSequenceFlow(source, target)) {
          replacementType = 'bpmn:SequenceFlow';
        }
      }
      if (remove) {
        modeling.removeConnection(connection);
      }
      if (replacementType) {
        modeling.connect(source, target, {
          type: replacementType,
          waypoints: connection.waypoints.slice()
        });
      }
    }
    function replaceReconnectedConnection(event) {
      var context = event.context,
        connection = context.connection,
        source = context.newSource || connection.source,
        target = context.newTarget || connection.target,
        allowed,
        replacement;
      allowed = bpmnRules.canConnect(source, target);
      if (!allowed || allowed.type === connection.type) {
        return;
      }
      replacement = modeling.connect(source, target, {
        type: allowed.type,
        associationDirection: allowed.associationDirection,
        waypoints: connection.waypoints.slice()
      });
      if (connection.parent) {
        modeling.removeConnection(connection);
      }
      context.connection = replacement;
      if (dragging) {
        cleanDraggingSelection(connection, replacement);
      }
    }
    function cleanDraggingSelection(oldConnection, newConnection) {
      var context = dragging.context(),
        previousSelection = context && context.payload.previousSelection,
        index;
      if (!previousSelection || !previousSelection.length) {
        return;
      }
      index = previousSelection.indexOf(oldConnection);
      if (index === -1) {
        return;
      }
      previousSelection.splice(index, 1, newConnection);
    }
    this.postExecuted('elements.move', function (context) {
      var closure = context.closure,
        allConnections = closure.allConnections;
      forEach$1(allConnections, fixConnection);
    }, true);
    this.preExecute('connection.reconnect', replaceReconnectedConnection);
    this.postExecuted('element.updateProperties', function (event) {
      var context = event.context,
        properties = context.properties,
        element = context.element,
        businessObject = element.businessObject,
        connection;
      if (properties.default) {
        connection = find(element.outgoing, matchPattern({
          id: element.businessObject.default.id
        }));
        if (connection) {
          modeling.updateProperties(connection, {
            conditionExpression: undefined
          });
        }
      }
      if (properties.conditionExpression && businessObject.sourceRef.default === businessObject) {
        modeling.updateProperties(element.source, {
          default: undefined
        });
      }
    });
  }
  e$2(ReplaceConnectionBehavior, CommandInterceptor);
  ReplaceConnectionBehavior.$inject = ['eventBus', 'modeling', 'bpmnRules', 'injector'];
  function ReplaceElementBehaviour(bpmnReplace, bpmnRules, elementRegistry, injector, modeling, selection) {
    injector.invoke(CommandInterceptor, this);
    this._bpmnReplace = bpmnReplace;
    this._elementRegistry = elementRegistry;
    this._selection = selection;
    this.postExecuted(['elements.create'], 500, function (event) {
      var context = event.context,
        target = context.parent,
        elements = context.elements;
      var elementReplacements = reduce(elements, function (replacements, element) {
        var canReplace = bpmnRules.canReplace([element], element.host || element.parent || target);
        return canReplace ? replacements.concat(canReplace.replacements) : replacements;
      }, []);
      if (elementReplacements.length) {
        this._replaceElements(elements, elementReplacements);
      }
    }, this);
    this.postExecuted(['elements.move'], 500, function (event) {
      var context = event.context,
        target = context.newParent,
        newHost = context.newHost,
        elements = [];
      forEach$1(context.closure.topLevel, function (topLevelElements) {
        if (isEventSubProcess(topLevelElements)) {
          elements = elements.concat(topLevelElements.children);
        } else {
          elements = elements.concat(topLevelElements);
        }
      });
      if (elements.length === 1 && newHost) {
        target = newHost;
      }
      var canReplace = bpmnRules.canReplace(elements, target);
      if (canReplace) {
        this._replaceElements(elements, canReplace.replacements, newHost);
      }
    }, this);
    this.postExecute(['shape.replace'], 1500, function (e) {
      var context = e.context,
        oldShape = context.oldShape,
        newShape = context.newShape,
        attachers = oldShape.attachers,
        canReplace;
      if (attachers && attachers.length) {
        canReplace = bpmnRules.canReplace(attachers, newShape);
        this._replaceElements(attachers, canReplace.replacements);
      }
    }, this);
    this.postExecuted(['shape.replace'], 1500, function (e) {
      var context = e.context,
        oldShape = context.oldShape,
        newShape = context.newShape;
      modeling.unclaimId(oldShape.businessObject.id, oldShape.businessObject);
      modeling.updateProperties(newShape, {
        id: oldShape.id
      });
    });
  }
  e$2(ReplaceElementBehaviour, CommandInterceptor);
  ReplaceElementBehaviour.prototype._replaceElements = function (elements, newElements) {
    var elementRegistry = this._elementRegistry,
      bpmnReplace = this._bpmnReplace,
      selection = this._selection;
    forEach$1(newElements, function (replacement) {
      var newElement = {
        type: replacement.newElementType
      };
      var oldElement = elementRegistry.get(replacement.oldElementId);
      var idx = elements.indexOf(oldElement);
      elements[idx] = bpmnReplace.replaceElement(oldElement, newElement, {
        select: false
      });
    });
    if (newElements) {
      selection.select(elements);
    }
  };
  ReplaceElementBehaviour.$inject = ['bpmnReplace', 'bpmnRules', 'elementRegistry', 'injector', 'modeling', 'selection'];
  var HIGH_PRIORITY$e = 1500;
  var GROUP_MIN_DIMENSIONS = {
    width: 140,
    height: 120
  };
  var LANE_MIN_DIMENSIONS = {
    width: 300,
    height: 60
  };
  var VERTICAL_LANE_MIN_DIMENSIONS = {
    width: 60,
    height: 300
  };
  var PARTICIPANT_MIN_DIMENSIONS = {
    width: 300,
    height: 150
  };
  var VERTICAL_PARTICIPANT_MIN_DIMENSIONS = {
    width: 150,
    height: 300
  };
  var SUB_PROCESS_MIN_DIMENSIONS = {
    width: 140,
    height: 120
  };
  var TEXT_ANNOTATION_MIN_DIMENSIONS = {
    width: 50,
    height: 30
  };
  function ResizeBehavior$1(eventBus) {
    eventBus.on('resize.start', HIGH_PRIORITY$e, function (event) {
      var context = event.context,
        shape = context.shape,
        direction = context.direction,
        balanced = context.balanced;
      if (is(shape, 'bpmn:Lane') || is(shape, 'bpmn:Participant')) {
        context.resizeConstraints = getParticipantResizeConstraints(shape, direction, balanced);
      }
      if (is(shape, 'bpmn:SubProcess') && isExpanded(shape)) {
        context.minDimensions = SUB_PROCESS_MIN_DIMENSIONS;
      }
      if (is(shape, 'bpmn:TextAnnotation')) {
        context.minDimensions = TEXT_ANNOTATION_MIN_DIMENSIONS;
      }
    });
  }
  ResizeBehavior$1.$inject = ['eventBus'];
  var abs$2 = Math.abs,
    min$1 = Math.min,
    max$3 = Math.max;
  function addToTrbl(trbl, attr, value, choice) {
    var current = trbl[attr];
    trbl[attr] = current === undefined ? value : choice(value, current);
  }
  function addMin(trbl, attr, value) {
    return addToTrbl(trbl, attr, value, min$1);
  }
  function addMax(trbl, attr, value) {
    return addToTrbl(trbl, attr, value, max$3);
  }
  var LANE_PADDING = {
      top: 20,
      left: 50,
      right: 20,
      bottom: 20
    },
    VERTICAL_LANE_PADDING = {
      top: 50,
      left: 20,
      right: 20,
      bottom: 20
    };
  function getParticipantResizeConstraints(laneShape, resizeDirection, balanced) {
    var lanesRoot = getLanesRoot(laneShape);
    var isFirst = true,
      isLast = true;
    var allLanes = collectLanes(lanesRoot, [lanesRoot]);
    var laneTrbl = asTRBL(laneShape);
    var maxTrbl = {},
      minTrbl = {};
    var isHorizontalLane = isHorizontal$3(laneShape);
    var minDimensions = isHorizontalLane ? LANE_MIN_DIMENSIONS : VERTICAL_LANE_MIN_DIMENSIONS;
    if (/n/.test(resizeDirection)) {
      minTrbl.top = laneTrbl.bottom - minDimensions.height;
    } else if (/e/.test(resizeDirection)) {
      minTrbl.right = laneTrbl.left + minDimensions.width;
    } else if (/s/.test(resizeDirection)) {
      minTrbl.bottom = laneTrbl.top + minDimensions.height;
    } else if (/w/.test(resizeDirection)) {
      minTrbl.left = laneTrbl.right - minDimensions.width;
    }
    allLanes.forEach(function (other) {
      var otherTrbl = asTRBL(other);
      if (isHorizontalLane) {
        if (otherTrbl.top < laneTrbl.top - 10) {
          isFirst = false;
        }
        if (otherTrbl.bottom > laneTrbl.bottom + 10) {
          isLast = false;
        }
      } else {
        if (otherTrbl.left < laneTrbl.left - 10) {
          isFirst = false;
        }
        if (otherTrbl.right > laneTrbl.right + 10) {
          isLast = false;
        }
      }
      if (/n/.test(resizeDirection)) {
        if (balanced && abs$2(laneTrbl.top - otherTrbl.bottom) < 10) {
          addMax(maxTrbl, 'top', otherTrbl.top + minDimensions.height);
        }
        if (abs$2(laneTrbl.top - otherTrbl.top) < 5) {
          addMin(minTrbl, 'top', otherTrbl.bottom - minDimensions.height);
        }
      }
      if (/e/.test(resizeDirection)) {
        if (balanced && abs$2(laneTrbl.right - otherTrbl.left) < 10) {
          addMin(maxTrbl, 'right', otherTrbl.right - minDimensions.width);
        }
        if (abs$2(laneTrbl.right - otherTrbl.right) < 5) {
          addMax(minTrbl, 'right', otherTrbl.left + minDimensions.width);
        }
      }
      if (/s/.test(resizeDirection)) {
        if (balanced && abs$2(laneTrbl.bottom - otherTrbl.top) < 10) {
          addMin(maxTrbl, 'bottom', otherTrbl.bottom - minDimensions.height);
        }
        if (abs$2(laneTrbl.bottom - otherTrbl.bottom) < 5) {
          addMax(minTrbl, 'bottom', otherTrbl.top + minDimensions.height);
        }
      }
      if (/w/.test(resizeDirection)) {
        if (balanced && abs$2(laneTrbl.left - otherTrbl.right) < 10) {
          addMax(maxTrbl, 'left', otherTrbl.left + minDimensions.width);
        }
        if (abs$2(laneTrbl.left - otherTrbl.left) < 5) {
          addMin(minTrbl, 'left', otherTrbl.right - minDimensions.width);
        }
      }
    });
    var flowElements = lanesRoot.children.filter(function (s) {
      return !s.hidden && !s.waypoints && (is(s, 'bpmn:FlowElement') || is(s, 'bpmn:Artifact'));
    });
    var padding = isHorizontalLane ? LANE_PADDING : VERTICAL_LANE_PADDING;
    flowElements.forEach(function (flowElement) {
      var flowElementTrbl = asTRBL(flowElement);
      if (/n/.test(resizeDirection) && (!isHorizontalLane || isFirst)) {
        addMin(minTrbl, 'top', flowElementTrbl.top - padding.top);
      }
      if (/e/.test(resizeDirection) && (isHorizontalLane || isLast)) {
        addMax(minTrbl, 'right', flowElementTrbl.right + padding.right);
      }
      if (/s/.test(resizeDirection) && (!isHorizontalLane || isLast)) {
        addMax(minTrbl, 'bottom', flowElementTrbl.bottom + padding.bottom);
      }
      if (/w/.test(resizeDirection) && (isHorizontalLane || isFirst)) {
        addMin(minTrbl, 'left', flowElementTrbl.left - padding.left);
      }
    });
    return {
      min: minTrbl,
      max: maxTrbl
    };
  }
  var SLIGHTLY_HIGHER_PRIORITY = 1001;
  function ResizeLaneBehavior(eventBus, modeling) {
    eventBus.on('resize.start', SLIGHTLY_HIGHER_PRIORITY + 500, function (event) {
      var context = event.context,
        shape = context.shape;
      if (is(shape, 'bpmn:Lane') || is(shape, 'bpmn:Participant')) {
        context.balanced = !hasPrimaryModifier(event);
      }
    });
    eventBus.on('resize.end', SLIGHTLY_HIGHER_PRIORITY, function (event) {
      var context = event.context,
        shape = context.shape,
        canExecute = context.canExecute,
        newBounds = context.newBounds;
      if (is(shape, 'bpmn:Lane') || is(shape, 'bpmn:Participant')) {
        if (canExecute) {
          newBounds = roundBounds(newBounds);
          modeling.resizeLane(shape, newBounds, context.balanced);
        }
        return false;
      }
    });
  }
  ResizeLaneBehavior.$inject = ['eventBus', 'modeling'];
  var LOW_PRIORITY$g = 500;
  function RootElementReferenceBehavior(bpmnjs, eventBus, injector, moddleCopy, bpmnFactory) {
    injector.invoke(CommandInterceptor, this);
    function canHaveRootElementReference(element) {
      return isAny(element, ['bpmn:ReceiveTask', 'bpmn:SendTask']) || hasAnyEventDefinition(element, ['bpmn:ErrorEventDefinition', 'bpmn:EscalationEventDefinition', 'bpmn:MessageEventDefinition', 'bpmn:SignalEventDefinition']);
    }
    function hasRootElement(rootElement) {
      var definitions = bpmnjs.getDefinitions(),
        rootElements = definitions.get('rootElements');
      return !!find(rootElements, matchPattern({
        id: rootElement.id
      }));
    }
    function getRootElementReferencePropertyName(eventDefinition) {
      if (is(eventDefinition, 'bpmn:ErrorEventDefinition')) {
        return 'errorRef';
      } else if (is(eventDefinition, 'bpmn:EscalationEventDefinition')) {
        return 'escalationRef';
      } else if (is(eventDefinition, 'bpmn:MessageEventDefinition')) {
        return 'messageRef';
      } else if (is(eventDefinition, 'bpmn:SignalEventDefinition')) {
        return 'signalRef';
      }
    }
    function getRootElement(businessObject) {
      if (isAny(businessObject, ['bpmn:ReceiveTask', 'bpmn:SendTask'])) {
        return businessObject.get('messageRef');
      }
      var eventDefinitions = businessObject.get('eventDefinitions'),
        eventDefinition = eventDefinitions[0];
      return eventDefinition.get(getRootElementReferencePropertyName(eventDefinition));
    }
    function setRootElement(businessObject, rootElement) {
      if (isAny(businessObject, ['bpmn:ReceiveTask', 'bpmn:SendTask'])) {
        return businessObject.set('messageRef', rootElement);
      }
      var eventDefinitions = businessObject.get('eventDefinitions'),
        eventDefinition = eventDefinitions[0];
      return eventDefinition.set(getRootElementReferencePropertyName(eventDefinition), rootElement);
    }
    this.executed(['shape.create', 'element.updateProperties', 'element.updateModdleProperties'], function (context) {
      var shape = context.shape || context.element;
      if (!canHaveRootElementReference(shape)) {
        return;
      }
      var businessObject = getBusinessObject(shape),
        rootElement = getRootElement(businessObject),
        rootElements;
      if (rootElement && !hasRootElement(rootElement)) {
        rootElements = bpmnjs.getDefinitions().get('rootElements');
        add(rootElements, rootElement);
        context.addedRootElement = rootElement;
      }
    }, true);
    this.reverted(['shape.create', 'element.updateProperties', 'element.updateModdleProperties'], function (context) {
      var addedRootElement = context.addedRootElement;
      if (!addedRootElement) {
        return;
      }
      var rootElements = bpmnjs.getDefinitions().get('rootElements');
      remove(rootElements, addedRootElement);
    }, true);
    eventBus.on('copyPaste.copyElement', function (context) {
      var descriptor = context.descriptor,
        element = context.element;
      if (element.labelTarget || !canHaveRootElementReference(element)) {
        return;
      }
      var businessObject = getBusinessObject(element),
        rootElement = getRootElement(businessObject);
      if (rootElement) {
        descriptor.referencedRootElement = rootElement;
      }
    });
    eventBus.on('copyPaste.pasteElement', LOW_PRIORITY$g, function (context) {
      var descriptor = context.descriptor,
        businessObject = descriptor.businessObject,
        referencedRootElement = descriptor.referencedRootElement;
      if (!referencedRootElement) {
        return;
      }
      if (!hasRootElement(referencedRootElement)) {
        referencedRootElement = moddleCopy.copyElement(referencedRootElement, bpmnFactory.create(referencedRootElement.$type));
      }
      setRootElement(businessObject, referencedRootElement);
      delete descriptor.referencedRootElement;
    });
  }
  RootElementReferenceBehavior.$inject = ['bpmnjs', 'eventBus', 'injector', 'moddleCopy', 'bpmnFactory'];
  e$2(RootElementReferenceBehavior, CommandInterceptor);
  function hasAnyEventDefinition(element, types) {
    if (!isArray$3(types)) {
      types = [types];
    }
    return some(types, function (type) {
      return hasEventDefinition$2(element, type);
    });
  }
  var max$2 = Math.max;
  function SpaceToolBehavior$1(eventBus) {
    eventBus.on('spaceTool.getMinDimensions', function (context) {
      var shapes = context.shapes,
        axis = context.axis,
        start = context.start,
        minDimensions = {};
      forEach$1(shapes, function (shape) {
        var id = shape.id;
        if (is(shape, 'bpmn:Participant')) {
          minDimensions[id] = getParticipantMinDimensions(shape, axis, start);
        }
        if (is(shape, 'bpmn:Lane')) {
          minDimensions[id] = isHorizontal$3(shape) ? LANE_MIN_DIMENSIONS : VERTICAL_LANE_MIN_DIMENSIONS;
        }
        if (is(shape, 'bpmn:SubProcess') && isExpanded(shape)) {
          minDimensions[id] = SUB_PROCESS_MIN_DIMENSIONS;
        }
        if (is(shape, 'bpmn:TextAnnotation')) {
          minDimensions[id] = TEXT_ANNOTATION_MIN_DIMENSIONS;
        }
        if (is(shape, 'bpmn:Group')) {
          minDimensions[id] = GROUP_MIN_DIMENSIONS;
        }
      });
      return minDimensions;
    });
  }
  SpaceToolBehavior$1.$inject = ['eventBus'];
  function isHorizontalAxis(axis) {
    return axis === 'x';
  }
  function getParticipantMinDimensions(participant, axis, start) {
    var isHorizontalLane = isHorizontal$3(participant);
    if (!hasChildLanes(participant)) {
      return isHorizontalLane ? PARTICIPANT_MIN_DIMENSIONS : VERTICAL_PARTICIPANT_MIN_DIMENSIONS;
    }
    var isHorizontalResize = isHorizontalAxis(axis);
    var minDimensions = {};
    if (isHorizontalResize) {
      if (isHorizontalLane) {
        minDimensions = PARTICIPANT_MIN_DIMENSIONS;
      } else {
        minDimensions = {
          width: getParticipantMinWidth(participant, start, isHorizontalResize),
          height: VERTICAL_PARTICIPANT_MIN_DIMENSIONS.height
        };
      }
    } else {
      if (isHorizontalLane) {
        minDimensions = {
          width: PARTICIPANT_MIN_DIMENSIONS.width,
          height: getParticipantMinHeight(participant, start, isHorizontalResize)
        };
      } else {
        minDimensions = VERTICAL_PARTICIPANT_MIN_DIMENSIONS;
      }
    }
    return minDimensions;
  }
  function getParticipantMinHeight(participant, start, isHorizontalResize) {
    var lanesMinHeight;
    lanesMinHeight = getLanesMinHeight(participant, start, isHorizontalResize);
    return max$2(PARTICIPANT_MIN_DIMENSIONS.height, lanesMinHeight);
  }
  function getParticipantMinWidth(participant, start, isHorizontalResize) {
    var lanesMinWidth;
    lanesMinWidth = getLanesMinWidth(participant, start, isHorizontalResize);
    return max$2(VERTICAL_PARTICIPANT_MIN_DIMENSIONS.width, lanesMinWidth);
  }
  function hasChildLanes(element) {
    return !!getChildLanes(element).length;
  }
  function getLanesMinHeight(participant, resizeStart, isHorizontalResize) {
    var lanes = getChildLanes(participant),
      resizedLane;
    resizedLane = findResizedLane(lanes, resizeStart, isHorizontalResize);
    return participant.height - resizedLane.height + LANE_MIN_DIMENSIONS.height;
  }
  function getLanesMinWidth(participant, resizeStart, isHorizontalResize) {
    var lanes = getChildLanes(participant),
      resizedLane;
    resizedLane = findResizedLane(lanes, resizeStart, isHorizontalResize);
    return participant.width - resizedLane.width + VERTICAL_LANE_MIN_DIMENSIONS.width;
  }
  function findResizedLane(lanes, resizeStart, isHorizontalResize) {
    var i, lane, childLanes;
    for (i = 0; i < lanes.length; i++) {
      lane = lanes[i];
      if (!isHorizontalResize && resizeStart >= lane.y && resizeStart <= lane.y + lane.height || isHorizontalResize && resizeStart >= lane.x && resizeStart <= lane.x + lane.width) {
        childLanes = getChildLanes(lane);
        if (childLanes.length) {
          return findResizedLane(childLanes, resizeStart, isHorizontalResize);
        }
        return lane;
      }
    }
  }
  var LOW_PRIORITY$f = 400;
  var HIGH_PRIORITY$d = 600;
  var DEFAULT_POSITION = {
    x: 180,
    y: 160
  };
  function SubProcessPlaneBehavior(canvas, eventBus, modeling, elementFactory, bpmnFactory, bpmnjs, elementRegistry) {
    CommandInterceptor.call(this, eventBus);
    this._canvas = canvas;
    this._eventBus = eventBus;
    this._modeling = modeling;
    this._elementFactory = elementFactory;
    this._bpmnFactory = bpmnFactory;
    this._bpmnjs = bpmnjs;
    this._elementRegistry = elementRegistry;
    var self = this;
    function isCollapsedSubProcess(element) {
      return is(element, 'bpmn:SubProcess') && !isExpanded(element);
    }
    function createRoot(context) {
      var shape = context.shape,
        rootElement = context.newRootElement;
      var businessObject = getBusinessObject(shape);
      rootElement = self._addDiagram(rootElement || businessObject);
      context.newRootElement = canvas.addRootElement(rootElement);
    }
    function removeRoot(context) {
      var shape = context.shape;
      var businessObject = getBusinessObject(shape);
      self._removeDiagram(businessObject);
      var rootElement = context.newRootElement = elementRegistry.get(getPlaneIdFromShape(businessObject));
      canvas.removeRootElement(rootElement);
    }
    this.executed('shape.create', function (context) {
      var shape = context.shape;
      if (!isCollapsedSubProcess(shape)) {
        return;
      }
      createRoot(context);
    }, true);
    this.postExecuted('shape.create', function (context) {
      var shape = context.shape,
        rootElement = context.newRootElement;
      if (!rootElement || !shape.children) {
        return;
      }
      self._showRecursively(shape.children);
      self._moveChildrenToShape(shape, rootElement);
    }, true);
    this.reverted('shape.create', function (context) {
      var shape = context.shape;
      if (!isCollapsedSubProcess(shape)) {
        return;
      }
      removeRoot(context);
    }, true);
    this.preExecuted('shape.delete', function (context) {
      var shape = context.shape;
      if (!isCollapsedSubProcess(shape)) {
        return;
      }
      var attachedRoot = elementRegistry.get(getPlaneIdFromShape(shape));
      if (!attachedRoot) {
        return;
      }
      modeling.removeElements(attachedRoot.children.slice());
    }, true);
    this.executed('shape.delete', function (context) {
      var shape = context.shape;
      if (!isCollapsedSubProcess(shape)) {
        return;
      }
      removeRoot(context);
    }, true);
    this.reverted('shape.delete', function (context) {
      var shape = context.shape;
      if (!isCollapsedSubProcess(shape)) {
        return;
      }
      createRoot(context);
    }, true);
    this.preExecuted('shape.replace', function (context) {
      var oldShape = context.oldShape;
      var newShape = context.newShape;
      if (!isCollapsedSubProcess(oldShape) || !isCollapsedSubProcess(newShape)) {
        return;
      }
      context.oldRoot = canvas.removeRootElement(getPlaneIdFromShape(oldShape));
    }, true);
    this.postExecuted('shape.replace', function (context) {
      var newShape = context.newShape,
        source = context.oldRoot,
        target = canvas.findRoot(getPlaneIdFromShape(newShape));
      if (!source || !target) {
        return;
      }
      var elements = source.children;
      modeling.moveElements(elements, {
        x: 0,
        y: 0
      }, target);
    }, true);
    this.executed('element.updateProperties', function (context) {
      var shape = context.element;
      if (!is(shape, 'bpmn:SubProcess')) {
        return;
      }
      var properties = context.properties;
      var oldProperties = context.oldProperties;
      var oldId = oldProperties.id,
        newId = properties.id;
      if (oldId === newId) {
        return;
      }
      if (isPlane(shape)) {
        elementRegistry.updateId(shape, toPlaneId(newId));
        elementRegistry.updateId(oldId, newId);
        return;
      }
      var planeElement = elementRegistry.get(toPlaneId(oldId));
      if (!planeElement) {
        return;
      }
      elementRegistry.updateId(toPlaneId(oldId), toPlaneId(newId));
    }, true);
    this.reverted('element.updateProperties', function (context) {
      var shape = context.element;
      if (!is(shape, 'bpmn:SubProcess')) {
        return;
      }
      var properties = context.properties;
      var oldProperties = context.oldProperties;
      var oldId = oldProperties.id,
        newId = properties.id;
      if (oldId === newId) {
        return;
      }
      if (isPlane(shape)) {
        elementRegistry.updateId(shape, toPlaneId(oldId));
        elementRegistry.updateId(newId, oldId);
        return;
      }
      var planeElement = elementRegistry.get(toPlaneId(newId));
      if (!planeElement) {
        return;
      }
      elementRegistry.updateId(planeElement, toPlaneId(oldId));
    }, true);
    eventBus.on('element.changed', function (context) {
      var element = context.element;
      if (!isPlane(element)) {
        return;
      }
      var plane = element;
      var primaryShape = elementRegistry.get(getShapeIdFromPlane(plane));
      if (!primaryShape || primaryShape === plane) {
        return;
      }
      eventBus.fire('element.changed', {
        element: primaryShape
      });
    });
    this.executed('shape.toggleCollapse', LOW_PRIORITY$f, function (context) {
      var shape = context.shape;
      if (!is(shape, 'bpmn:SubProcess')) {
        return;
      }
      if (!isExpanded(shape)) {
        createRoot(context);
        self._showRecursively(shape.children);
      } else {
        removeRoot(context);
      }
    }, true);
    this.reverted('shape.toggleCollapse', LOW_PRIORITY$f, function (context) {
      var shape = context.shape;
      if (!is(shape, 'bpmn:SubProcess')) {
        return;
      }
      if (!isExpanded(shape)) {
        createRoot(context);
        self._showRecursively(shape.children);
      } else {
        removeRoot(context);
      }
    }, true);
    this.postExecuted('shape.toggleCollapse', HIGH_PRIORITY$d, function (context) {
      var shape = context.shape;
      if (!is(shape, 'bpmn:SubProcess')) {
        return;
      }
      var rootElement = context.newRootElement;
      if (!rootElement) {
        return;
      }
      if (!isExpanded(shape)) {
        self._moveChildrenToShape(shape, rootElement);
      } else {
        self._moveChildrenToShape(rootElement, shape);
      }
    }, true);
    eventBus.on('copyPaste.createTree', function (context) {
      var element = context.element,
        children = context.children;
      if (!isCollapsedSubProcess(element)) {
        return;
      }
      var id = getPlaneIdFromShape(element);
      var parent = elementRegistry.get(id);
      if (parent) {
        children.push.apply(children, parent.children);
      }
    });
    eventBus.on('copyPaste.copyElement', function (context) {
      var descriptor = context.descriptor,
        element = context.element,
        elements = context.elements;
      var parent = element.parent;
      var isPlane = is(getDi(parent), 'bpmndi:BPMNPlane');
      if (!isPlane) {
        return;
      }
      var parentId = getShapeIdFromPlane(parent);
      var referencedShape = find(elements, function (element) {
        return element.id === parentId;
      });
      if (!referencedShape) {
        return;
      }
      descriptor.parent = referencedShape.id;
    });
    eventBus.on('copyPaste.pasteElement', function (context) {
      var descriptor = context.descriptor;
      if (!descriptor.parent) {
        return;
      }
      if (isCollapsedSubProcess(descriptor.parent) || descriptor.parent.hidden) {
        descriptor.hidden = true;
      }
    });
  }
  e$2(SubProcessPlaneBehavior, CommandInterceptor);
  SubProcessPlaneBehavior.prototype._moveChildrenToShape = function (source, target) {
    var modeling = this._modeling;
    var children = source.children;
    var offset;
    if (!children) {
      return;
    }
    children = children.concat(children.reduce(function (labels, child) {
      if (child.label && child.label.parent !== source) {
        return labels.concat(child.label);
      }
      return labels;
    }, []));
    var visibleChildren = children.filter(function (child) {
      return !child.hidden;
    });
    if (!visibleChildren.length) {
      modeling.moveElements(children, {
        x: 0,
        y: 0
      }, target, {
        autoResize: false
      });
      return;
    }
    var childrenBounds = getBBox(visibleChildren);
    if (!target.x) {
      offset = {
        x: DEFAULT_POSITION.x - childrenBounds.x,
        y: DEFAULT_POSITION.y - childrenBounds.y
      };
    } else {
      var targetMid = getMid(target);
      var childrenMid = getMid(childrenBounds);
      offset = {
        x: targetMid.x - childrenMid.x,
        y: targetMid.y - childrenMid.y
      };
    }
    modeling.moveElements(children, offset, target, {
      autoResize: false
    });
  };
  SubProcessPlaneBehavior.prototype._showRecursively = function (elements, hidden) {
    var self = this;
    var result = [];
    elements.forEach(function (element) {
      element.hidden = !!hidden;
      result = result.concat(element);
      if (element.children) {
        result = result.concat(self._showRecursively(element.children, element.collapsed || hidden));
      }
    });
    return result;
  };
  SubProcessPlaneBehavior.prototype._addDiagram = function (planeElement) {
    var bpmnjs = this._bpmnjs;
    var diagrams = bpmnjs.getDefinitions().diagrams;
    if (!planeElement.businessObject) {
      planeElement = this._createNewDiagram(planeElement);
    }
    diagrams.push(planeElement.di.$parent);
    return planeElement;
  };
  SubProcessPlaneBehavior.prototype._createNewDiagram = function (bpmnElement) {
    var bpmnFactory = this._bpmnFactory,
      elementFactory = this._elementFactory;
    var diPlane = bpmnFactory.create('bpmndi:BPMNPlane', {
      bpmnElement: bpmnElement
    });
    var diDiagram = bpmnFactory.create('bpmndi:BPMNDiagram', {
      plane: diPlane
    });
    diPlane.$parent = diDiagram;
    var planeElement = elementFactory.createRoot({
      id: getPlaneIdFromShape(bpmnElement),
      type: bpmnElement.$type,
      di: diPlane,
      businessObject: bpmnElement,
      collapsed: true
    });
    return planeElement;
  };
  SubProcessPlaneBehavior.prototype._removeDiagram = function (rootElement) {
    var bpmnjs = this._bpmnjs;
    var diagrams = bpmnjs.getDefinitions().diagrams;
    var removedDiagram = find(diagrams, function (diagram) {
      return diagram.plane.bpmnElement.id === rootElement.id;
    });
    diagrams.splice(diagrams.indexOf(removedDiagram), 1);
    return removedDiagram;
  };
  SubProcessPlaneBehavior.$inject = ['canvas', 'eventBus', 'modeling', 'elementFactory', 'bpmnFactory', 'bpmnjs', 'elementRegistry'];
  function SubProcessStartEventBehavior(injector, modeling) {
    injector.invoke(CommandInterceptor, this);
    this.postExecuted('shape.replace', function (event) {
      var oldShape = event.context.oldShape,
        newShape = event.context.newShape;
      if (!is(newShape, 'bpmn:SubProcess') || is(newShape, 'bpmn:AdHocSubProcess') || !(is(oldShape, 'bpmn:Task') || is(oldShape, 'bpmn:CallActivity')) || !isExpanded(newShape)) {
        return;
      }
      var position = getStartEventPosition(newShape);
      modeling.createShape({
        type: 'bpmn:StartEvent'
      }, position, newShape);
    });
  }
  SubProcessStartEventBehavior.$inject = ['injector', 'modeling'];
  e$2(SubProcessStartEventBehavior, CommandInterceptor);
  function getStartEventPosition(shape) {
    return {
      x: shape.x + shape.width / 6,
      y: shape.y + shape.height / 2
    };
  }
  function TextAnnotationBehavior(eventBus) {
    CommandInterceptor.call(this, eventBus);
    this.preExecute('connection.create', function (context) {
      var target = context.target;
      if (!is(target, 'bpmn:TextAnnotation')) {
        return;
      }
      context.parent = target.parent;
    }, true);
    this.preExecute(['shape.create', 'shape.resize', 'elements.move'], function (context) {
      var shapes = context.shapes || [context.shape];
      if (shapes.length === 1 && is(shapes[0], 'bpmn:TextAnnotation')) {
        context.hints = context.hints || {};
        context.hints.autoResize = false;
      }
    }, true);
  }
  e$2(TextAnnotationBehavior, CommandInterceptor);
  TextAnnotationBehavior.$inject = ['eventBus'];
  function ToggleCollapseConnectionBehaviour(eventBus, modeling) {
    CommandInterceptor.call(this, eventBus);
    this.postExecuted('shape.toggleCollapse', 1500, function (context) {
      var shape = context.shape;
      if (isExpanded(shape)) {
        return;
      }
      var allChildren = selfAndAllChildren(shape);
      allChildren.forEach(function (child) {
        var incomingConnections = child.incoming.slice(),
          outgoingConnections = child.outgoing.slice();
        forEach$1(incomingConnections, function (c) {
          handleConnection(c, true);
        });
        forEach$1(outgoingConnections, function (c) {
          handleConnection(c, false);
        });
      });
      function handleConnection(c, incoming) {
        if (allChildren.indexOf(c.source) !== -1 && allChildren.indexOf(c.target) !== -1) {
          return;
        }
        if (incoming) {
          modeling.reconnectEnd(c, shape, getMid(shape));
        } else {
          modeling.reconnectStart(c, shape, getMid(shape));
        }
      }
    }, true);
  }
  e$2(ToggleCollapseConnectionBehaviour, CommandInterceptor);
  ToggleCollapseConnectionBehaviour.$inject = ['eventBus', 'modeling'];
  var LOW_PRIORITY$e = 500;
  function ToggleElementCollapseBehaviour(eventBus, elementFactory, modeling) {
    CommandInterceptor.call(this, eventBus);
    function hideEmptyLabels(children) {
      if (children.length) {
        children.forEach(function (child) {
          if (child.type === 'label' && !child.businessObject.name) {
            child.hidden = true;
          }
        });
      }
    }
    function expandedBounds(shape, defaultSize) {
      var children = shape.children,
        newBounds = defaultSize,
        visibleElements,
        visibleBBox;
      visibleElements = filterVisible(children).concat([shape]);
      visibleBBox = computeChildrenBBox(visibleElements);
      if (visibleBBox) {
        newBounds.width = Math.max(visibleBBox.width, newBounds.width);
        newBounds.height = Math.max(visibleBBox.height, newBounds.height);
        newBounds.x = visibleBBox.x + (visibleBBox.width - newBounds.width) / 2;
        newBounds.y = visibleBBox.y + (visibleBBox.height - newBounds.height) / 2;
      } else {
        newBounds.x = shape.x + (shape.width - newBounds.width) / 2;
        newBounds.y = shape.y + (shape.height - newBounds.height) / 2;
      }
      return newBounds;
    }
    function collapsedBounds(shape, defaultSize) {
      return {
        x: shape.x + (shape.width - defaultSize.width) / 2,
        y: shape.y + (shape.height - defaultSize.height) / 2,
        width: defaultSize.width,
        height: defaultSize.height
      };
    }
    this.executed(['shape.toggleCollapse'], LOW_PRIORITY$e, function (e) {
      var context = e.context,
        shape = context.shape;
      if (!is(shape, 'bpmn:SubProcess')) {
        return;
      }
      if (!shape.collapsed) {
        hideEmptyLabels(shape.children);
        getDi(shape).isExpanded = true;
      } else {
        getDi(shape).isExpanded = false;
      }
    });
    this.reverted(['shape.toggleCollapse'], LOW_PRIORITY$e, function (e) {
      var context = e.context;
      var shape = context.shape;
      if (!shape.collapsed) {
        getDi(shape).isExpanded = true;
      } else {
        getDi(shape).isExpanded = false;
      }
    });
    this.postExecuted(['shape.toggleCollapse'], LOW_PRIORITY$e, function (e) {
      var shape = e.context.shape,
        defaultSize = elementFactory.getDefaultSize(shape),
        newBounds;
      if (shape.collapsed) {
        newBounds = collapsedBounds(shape, defaultSize);
      } else {
        newBounds = expandedBounds(shape, defaultSize);
      }
      modeling.resizeShape(shape, newBounds, null, {
        autoResize: shape.collapsed ? false : 'nwse'
      });
    });
  }
  e$2(ToggleElementCollapseBehaviour, CommandInterceptor);
  ToggleElementCollapseBehaviour.$inject = ['eventBus', 'elementFactory', 'modeling'];
  function filterVisible(elements) {
    return elements.filter(function (e) {
      return !e.hidden;
    });
  }
  function UnclaimIdBehavior(canvas, injector, moddle, modeling) {
    injector.invoke(CommandInterceptor, this);
    this.preExecute('shape.delete', function (event) {
      var context = event.context,
        shape = context.shape,
        shapeBo = shape.businessObject;
      if (isLabel(shape)) {
        return;
      }
      if (is(shape, 'bpmn:Participant') && isExpanded(shape)) {
        moddle.ids.unclaim(shapeBo.processRef.id);
      }
      modeling.unclaimId(shapeBo.id, shapeBo);
    });
    this.preExecute('connection.delete', function (event) {
      var context = event.context,
        connection = context.connection,
        connectionBo = connection.businessObject;
      modeling.unclaimId(connectionBo.id, connectionBo);
    });
    this.preExecute('canvas.updateRoot', function () {
      var rootElement = canvas.getRootElement(),
        rootElementBo = rootElement.businessObject;
      if (is(rootElement, 'bpmn:Collaboration')) {
        moddle.ids.unclaim(rootElementBo.id);
      }
    });
  }
  e$2(UnclaimIdBehavior, CommandInterceptor);
  UnclaimIdBehavior.$inject = ['canvas', 'injector', 'moddle', 'modeling'];
  function DeleteSequenceFlowBehavior(eventBus, modeling) {
    CommandInterceptor.call(this, eventBus);
    this.preExecute('connection.delete', function (event) {
      var context = event.context,
        connection = context.connection,
        source = connection.source;
      if (isDefaultFlow(connection, source)) {
        modeling.updateProperties(source, {
          'default': null
        });
      }
    });
  }
  e$2(DeleteSequenceFlowBehavior, CommandInterceptor);
  DeleteSequenceFlowBehavior.$inject = ['eventBus', 'modeling'];
  function isDefaultFlow(connection, source) {
    if (!is(connection, 'bpmn:SequenceFlow')) {
      return false;
    }
    var sourceBo = getBusinessObject(source),
      sequenceFlow = getBusinessObject(connection);
    return sourceBo.get('default') === sequenceFlow;
  }
  var LOW_PRIORITY$d = 500,
    HIGH_PRIORITY$c = 5000;
  function UpdateFlowNodeRefsBehavior(eventBus, modeling) {
    CommandInterceptor.call(this, eventBus);
    var context;
    function initContext() {
      context = context || new UpdateContext();
      context.enter();
      return context;
    }
    function getContext() {
      if (!context) {
        throw new Error('out of bounds release');
      }
      return context;
    }
    function releaseContext() {
      if (!context) {
        throw new Error('out of bounds release');
      }
      var triggerUpdate = context.leave();
      if (triggerUpdate) {
        modeling.updateLaneRefs(context.flowNodes, context.lanes);
        context = null;
      }
      return triggerUpdate;
    }
    var laneRefUpdateEvents = ['spaceTool', 'lane.add', 'lane.resize', 'lane.split', 'elements.create', 'elements.delete', 'elements.move', 'shape.create', 'shape.delete', 'shape.move', 'shape.resize'];
    this.preExecute(laneRefUpdateEvents, HIGH_PRIORITY$c, function (event) {
      initContext();
    });
    this.postExecuted(laneRefUpdateEvents, LOW_PRIORITY$d, function (event) {
      releaseContext();
    });
    this.preExecute(['shape.create', 'shape.move', 'shape.delete', 'shape.resize'], function (event) {
      var context = event.context,
        shape = context.shape;
      var updateContext = getContext();
      if (shape.labelTarget) {
        return;
      }
      if (is(shape, 'bpmn:Lane')) {
        updateContext.addLane(shape);
      }
      if (is(shape, 'bpmn:FlowNode')) {
        updateContext.addFlowNode(shape);
      }
    });
  }
  UpdateFlowNodeRefsBehavior.$inject = ['eventBus', 'modeling'];
  e$2(UpdateFlowNodeRefsBehavior, CommandInterceptor);
  function UpdateContext() {
    this.flowNodes = [];
    this.lanes = [];
    this.counter = 0;
    this.addLane = function (lane) {
      this.lanes.push(lane);
    };
    this.addFlowNode = function (flowNode) {
      this.flowNodes.push(flowNode);
    };
    this.enter = function () {
      this.counter++;
    };
    this.leave = function () {
      this.counter--;
      return !this.counter;
    };
  }
  function SetCompensationActivityAfterPasteBehavior(eventBus, modeling) {
    CommandInterceptor.call(this, eventBus);
    this.postExecuted('elements.create', function (event) {
      var context = event.context,
        elements = context.elements;
      var _iterator6 = _createForOfIteratorHelper(elements),
        _step6;
      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var element = _step6.value;
          if (isForCompensation$1(element) && !isConnectedToCompensationBoundaryEvent(element)) {
            modeling.updateProperties(element, {
              isForCompensation: undefined
            });
          }
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }
    });
  }
  e$2(SetCompensationActivityAfterPasteBehavior, CommandInterceptor);
  SetCompensationActivityAfterPasteBehavior.$inject = ['eventBus', 'modeling'];
  function isForCompensation$1(element) {
    var bo = getBusinessObject(element);
    return bo && bo.isForCompensation;
  }
  function isCompensationBoundaryEvent(element) {
    return element && is(element, 'bpmn:BoundaryEvent') && hasEventDefinition$2(element, 'bpmn:CompensateEventDefinition');
  }
  function isConnectedToCompensationBoundaryEvent(element) {
    var compensationAssociations = element.incoming.filter(function (connection) {
      return isCompensationBoundaryEvent(connection.source);
    });
    if (compensationAssociations.length > 0) {
      return true;
    }
    return false;
  }
  var BehaviorModule = {
    __init__: ['adaptiveLabelPositioningBehavior', 'appendBehavior', 'associationBehavior', 'attachEventBehavior', 'boundaryEventBehavior', 'compensateBoundaryEventBehaviour', 'createBehavior', 'createDataObjectBehavior', 'createParticipantBehavior', 'dataInputAssociationBehavior', 'dataStoreBehavior', 'deleteLaneBehavior', 'detachEventBehavior', 'dropOnFlowBehavior', 'eventBasedGatewayBehavior', 'fixHoverBehavior', 'groupBehavior', 'importDockingFix', 'isHorizontalFix', 'labelBehavior', 'layoutConnectionBehavior', 'messageFlowBehavior', 'nonInterruptingBehavior', 'removeElementBehavior', 'removeEmbeddedLabelBoundsBehavior', 'removeParticipantBehavior', 'replaceConnectionBehavior', 'replaceElementBehaviour', 'resizeBehavior', 'resizeLaneBehavior', 'rootElementReferenceBehavior', 'spaceToolBehavior', 'subProcessPlaneBehavior', 'subProcessStartEventBehavior', 'textAnnotationBehavior', 'toggleCollapseConnectionBehaviour', 'toggleElementCollapseBehaviour', 'unclaimIdBehavior', 'updateFlowNodeRefsBehavior', 'unsetDefaultFlowBehavior', 'setCompensationActivityAfterPasteBehavior'],
    adaptiveLabelPositioningBehavior: ['type', AdaptiveLabelPositioningBehavior],
    appendBehavior: ['type', AppendBehavior],
    associationBehavior: ['type', AssociationBehavior],
    attachEventBehavior: ['type', AttachEventBehavior],
    boundaryEventBehavior: ['type', BoundaryEventBehavior],
    compensateBoundaryEventBehaviour: ['type', CompensateBoundaryEventBehavior],
    createBehavior: ['type', CreateBehavior],
    createDataObjectBehavior: ['type', CreateDataObjectBehavior],
    createParticipantBehavior: ['type', CreateParticipantBehavior],
    dataInputAssociationBehavior: ['type', DataInputAssociationBehavior],
    dataStoreBehavior: ['type', DataStoreBehavior],
    deleteLaneBehavior: ['type', DeleteLaneBehavior],
    detachEventBehavior: ['type', DetachEventBehavior],
    dropOnFlowBehavior: ['type', DropOnFlowBehavior],
    eventBasedGatewayBehavior: ['type', EventBasedGatewayBehavior],
    fixHoverBehavior: ['type', FixHoverBehavior],
    groupBehavior: ['type', GroupBehavior],
    importDockingFix: ['type', ImportDockingFix],
    isHorizontalFix: ['type', IsHorizontalFix],
    labelBehavior: ['type', LabelBehavior],
    layoutConnectionBehavior: ['type', LayoutConnectionBehavior],
    messageFlowBehavior: ['type', MessageFlowBehavior],
    nonInterruptingBehavior: ['type', NonInterruptingBehavior],
    removeElementBehavior: ['type', RemoveElementBehavior],
    removeEmbeddedLabelBoundsBehavior: ['type', RemoveEmbeddedLabelBoundsBehavior],
    removeParticipantBehavior: ['type', RemoveParticipantBehavior],
    replaceConnectionBehavior: ['type', ReplaceConnectionBehavior],
    replaceElementBehaviour: ['type', ReplaceElementBehaviour],
    resizeBehavior: ['type', ResizeBehavior$1],
    resizeLaneBehavior: ['type', ResizeLaneBehavior],
    rootElementReferenceBehavior: ['type', RootElementReferenceBehavior],
    spaceToolBehavior: ['type', SpaceToolBehavior$1],
    subProcessPlaneBehavior: ['type', SubProcessPlaneBehavior],
    subProcessStartEventBehavior: ['type', SubProcessStartEventBehavior],
    textAnnotationBehavior: ['type', TextAnnotationBehavior],
    toggleCollapseConnectionBehaviour: ['type', ToggleCollapseConnectionBehaviour],
    toggleElementCollapseBehaviour: ['type', ToggleElementCollapseBehaviour],
    unclaimIdBehavior: ['type', UnclaimIdBehavior],
    unsetDefaultFlowBehavior: ['type', DeleteSequenceFlowBehavior],
    updateFlowNodeRefsBehavior: ['type', UpdateFlowNodeRefsBehavior],
    setCompensationActivityAfterPasteBehavior: ['type', SetCompensationActivityAfterPasteBehavior]
  };
  function getBoundaryAttachment(position, targetBounds) {
    var orientation = getOrientation(position, targetBounds, -15);
    if (orientation !== 'intersect') {
      return orientation;
    } else {
      return null;
    }
  }
  function BpmnRules(eventBus) {
    RuleProvider.call(this, eventBus);
  }
  e$2(BpmnRules, RuleProvider);
  BpmnRules.$inject = ['eventBus'];
  BpmnRules.prototype.init = function () {
    this.addRule('connection.start', function (context) {
      var source = context.source;
      return canStartConnection(source);
    });
    this.addRule('connection.create', function (context) {
      var source = context.source,
        target = context.target,
        hints = context.hints || {},
        targetParent = hints.targetParent,
        targetAttach = hints.targetAttach;
      if (targetAttach) {
        return false;
      }
      if (targetParent) {
        target.parent = targetParent;
      }
      try {
        return canConnect(source, target);
      } finally {
        if (targetParent) {
          target.parent = null;
        }
      }
    });
    this.addRule('connection.reconnect', function (context) {
      var connection = context.connection,
        source = context.source,
        target = context.target;
      return canConnect(source, target, connection);
    });
    this.addRule('connection.updateWaypoints', function (context) {
      return {
        type: context.connection.type
      };
    });
    this.addRule('shape.resize', function (context) {
      var shape = context.shape,
        newBounds = context.newBounds;
      return canResize(shape, newBounds);
    });
    this.addRule('elements.create', function (context) {
      var elements = context.elements,
        position = context.position,
        target = context.target;
      if (isConnection(target) && !canInsert(elements, target)) {
        return false;
      }
      return every(elements, function (element) {
        if (isConnection(element)) {
          return canConnect(element.source, element.target, element);
        }
        if (element.host) {
          return canAttach(element, element.host, null, position);
        }
        return canCreate(element, target, null);
      });
    });
    this.addRule('elements.move', function (context) {
      var target = context.target,
        shapes = context.shapes,
        position = context.position;
      return canAttach(shapes, target, null, position) || canReplace(shapes, target, position) || canMove(shapes, target) || canInsert(shapes, target);
    });
    this.addRule('shape.create', function (context) {
      return canCreate(context.shape, context.target, context.source, context.position);
    });
    this.addRule('shape.attach', function (context) {
      return canAttach(context.shape, context.target, null, context.position);
    });
    this.addRule('element.copy', function (context) {
      var element = context.element,
        elements = context.elements;
      return canCopy(elements, element);
    });
  };
  BpmnRules.prototype.canConnectMessageFlow = canConnectMessageFlow;
  BpmnRules.prototype.canConnectSequenceFlow = canConnectSequenceFlow;
  BpmnRules.prototype.canConnectDataAssociation = canConnectDataAssociation;
  BpmnRules.prototype.canConnectAssociation = canConnectAssociation;
  BpmnRules.prototype.canConnectCompensationAssociation = canConnectCompensationAssociation;
  BpmnRules.prototype.canMove = canMove;
  BpmnRules.prototype.canAttach = canAttach;
  BpmnRules.prototype.canReplace = canReplace;
  BpmnRules.prototype.canDrop = canDrop;
  BpmnRules.prototype.canInsert = canInsert;
  BpmnRules.prototype.canCreate = canCreate;
  BpmnRules.prototype.canConnect = canConnect;
  BpmnRules.prototype.canResize = canResize;
  BpmnRules.prototype.canCopy = canCopy;
  function canStartConnection(element) {
    if (nonExistingOrLabel(element)) {
      return null;
    }
    return isAny(element, ['bpmn:FlowNode', 'bpmn:InteractionNode', 'bpmn:DataObjectReference', 'bpmn:DataStoreReference', 'bpmn:Group', 'bpmn:TextAnnotation']);
  }
  function nonExistingOrLabel(element) {
    return !element || isLabel(element);
  }
  function isSame$1(a, b) {
    return a === b;
  }
  function getOrganizationalParent(element) {
    do {
      if (is(element, 'bpmn:Process')) {
        return getBusinessObject(element);
      }
      if (is(element, 'bpmn:Participant')) {
        return getBusinessObject(element).processRef || getBusinessObject(element);
      }
    } while (element = element.parent);
  }
  function isTextAnnotation(element) {
    return is(element, 'bpmn:TextAnnotation');
  }
  function isGroup(element) {
    return is(element, 'bpmn:Group') && !element.labelTarget;
  }
  function isCompensationBoundary(element) {
    return is(element, 'bpmn:BoundaryEvent') && hasEventDefinition$1(element, 'bpmn:CompensateEventDefinition');
  }
  function isForCompensation(element) {
    return getBusinessObject(element).isForCompensation;
  }
  function isSameOrganization(a, b) {
    var parentA = getOrganizationalParent(a),
      parentB = getOrganizationalParent(b);
    return parentA === parentB;
  }
  function isMessageFlowSource(element) {
    return is(element, 'bpmn:InteractionNode') && !is(element, 'bpmn:BoundaryEvent') && (!is(element, 'bpmn:Event') || is(element, 'bpmn:ThrowEvent') && hasEventDefinitionOrNone(element, 'bpmn:MessageEventDefinition'));
  }
  function isMessageFlowTarget(element) {
    return is(element, 'bpmn:InteractionNode') && !isForCompensation(element) && (!is(element, 'bpmn:Event') || is(element, 'bpmn:CatchEvent') && hasEventDefinitionOrNone(element, 'bpmn:MessageEventDefinition')) && !(is(element, 'bpmn:BoundaryEvent') && !hasEventDefinition$1(element, 'bpmn:MessageEventDefinition'));
  }
  function getScopeParent(element) {
    var parent = element;
    while (parent = parent.parent) {
      if (is(parent, 'bpmn:FlowElementsContainer')) {
        return getBusinessObject(parent);
      }
      if (is(parent, 'bpmn:Participant')) {
        return getBusinessObject(parent).processRef;
      }
    }
    return null;
  }
  function isSameScope(a, b) {
    var scopeParentA = getScopeParent(a),
      scopeParentB = getScopeParent(b);
    return scopeParentA === scopeParentB;
  }
  function hasEventDefinition$1(element, eventDefinition) {
    var businessObject = getBusinessObject(element);
    return !!find(businessObject.eventDefinitions || [], function (definition) {
      return is(definition, eventDefinition);
    });
  }
  function hasEventDefinitionOrNone(element, eventDefinition) {
    var businessObject = getBusinessObject(element);
    return (businessObject.eventDefinitions || []).every(function (definition) {
      return is(definition, eventDefinition);
    });
  }
  function isSequenceFlowSource(element) {
    return is(element, 'bpmn:FlowNode') && !is(element, 'bpmn:EndEvent') && !isEventSubProcess(element) && !(is(element, 'bpmn:IntermediateThrowEvent') && hasEventDefinition$1(element, 'bpmn:LinkEventDefinition')) && !isCompensationBoundary(element) && !isForCompensation(element);
  }
  function isSequenceFlowTarget(element) {
    return is(element, 'bpmn:FlowNode') && !is(element, 'bpmn:StartEvent') && !is(element, 'bpmn:BoundaryEvent') && !isEventSubProcess(element) && !(is(element, 'bpmn:IntermediateCatchEvent') && hasEventDefinition$1(element, 'bpmn:LinkEventDefinition')) && !isForCompensation(element);
  }
  function isEventBasedTarget(element) {
    return is(element, 'bpmn:ReceiveTask') || is(element, 'bpmn:IntermediateCatchEvent') && (hasEventDefinition$1(element, 'bpmn:MessageEventDefinition') || hasEventDefinition$1(element, 'bpmn:TimerEventDefinition') || hasEventDefinition$1(element, 'bpmn:ConditionalEventDefinition') || hasEventDefinition$1(element, 'bpmn:SignalEventDefinition'));
  }
  function getParents(element) {
    var parents = [];
    while (element) {
      element = element.parent;
      if (element) {
        parents.push(element);
      }
    }
    return parents;
  }
  function isParent(possibleParent, element) {
    var allParents = getParents(element);
    return allParents.indexOf(possibleParent) !== -1;
  }
  function canConnect(source, target, connection) {
    if (nonExistingOrLabel(source) || nonExistingOrLabel(target)) {
      return null;
    }
    if (!is(connection, 'bpmn:DataAssociation')) {
      if (canConnectMessageFlow(source, target)) {
        return {
          type: 'bpmn:MessageFlow'
        };
      }
      if (canConnectSequenceFlow(source, target)) {
        return {
          type: 'bpmn:SequenceFlow'
        };
      }
    }
    var connectDataAssociation = canConnectDataAssociation(source, target);
    if (connectDataAssociation) {
      return connectDataAssociation;
    }
    if (canConnectCompensationAssociation(source, target)) {
      return {
        type: 'bpmn:Association',
        associationDirection: 'One'
      };
    }
    if (canConnectAssociation(source, target)) {
      return {
        type: 'bpmn:Association',
        associationDirection: 'None'
      };
    }
    return false;
  }
  function canDrop(element, target) {
    if (isLabel(element) || isGroup(element)) {
      return true;
    }
    if (is(target, 'bpmn:Participant') && !isExpanded(target)) {
      return false;
    }
    if (is(element, 'bpmn:Participant')) {
      return is(target, 'bpmn:Process') || is(target, 'bpmn:Collaboration');
    }
    if (isAny(element, ['bpmn:DataInput', 'bpmn:DataOutput'])) {
      if (element.parent) {
        return target === element.parent;
      }
    }
    if (is(element, 'bpmn:Lane')) {
      return is(target, 'bpmn:Participant') || is(target, 'bpmn:Lane');
    }
    if (is(element, 'bpmn:BoundaryEvent') && !isDroppableBoundaryEvent(element)) {
      return false;
    }
    if (is(element, 'bpmn:FlowElement') && !is(element, 'bpmn:DataStoreReference')) {
      if (is(target, 'bpmn:FlowElementsContainer')) {
        return isExpanded(target);
      }
      return isAny(target, ['bpmn:Participant', 'bpmn:Lane']);
    }
    if (is(element, 'bpmn:DataStoreReference') && is(target, 'bpmn:Collaboration')) {
      return some(getBusinessObject(target).get('participants'), function (participant) {
        return !!participant.get('processRef');
      });
    }
    if (isAny(element, ['bpmn:Artifact', 'bpmn:DataAssociation', 'bpmn:DataStoreReference'])) {
      return isAny(target, ['bpmn:Collaboration', 'bpmn:Lane', 'bpmn:Participant', 'bpmn:Process', 'bpmn:SubProcess']);
    }
    if (is(element, 'bpmn:MessageFlow')) {
      return is(target, 'bpmn:Collaboration') || element.source.parent == target || element.target.parent == target;
    }
    return false;
  }
  function isDroppableBoundaryEvent(event) {
    return getBusinessObject(event).cancelActivity && (hasNoEventDefinition(event) || hasCommonBoundaryIntermediateEventDefinition(event));
  }
  function isBoundaryEvent(element) {
    return !isLabel(element) && is(element, 'bpmn:BoundaryEvent');
  }
  function isLane(element) {
    return is(element, 'bpmn:Lane');
  }
  function isBoundaryCandidate(element) {
    if (isBoundaryEvent(element)) {
      return true;
    }
    if (is(element, 'bpmn:IntermediateThrowEvent') && hasNoEventDefinition(element)) {
      return true;
    }
    return is(element, 'bpmn:IntermediateCatchEvent') && hasCommonBoundaryIntermediateEventDefinition(element);
  }
  function hasNoEventDefinition(element) {
    var businessObject = getBusinessObject(element);
    return businessObject && !(businessObject.eventDefinitions && businessObject.eventDefinitions.length);
  }
  function hasCommonBoundaryIntermediateEventDefinition(element) {
    return hasOneOfEventDefinitions(element, ['bpmn:MessageEventDefinition', 'bpmn:TimerEventDefinition', 'bpmn:SignalEventDefinition', 'bpmn:ConditionalEventDefinition']);
  }
  function hasOneOfEventDefinitions(element, eventDefinitions) {
    return eventDefinitions.some(function (definition) {
      return hasEventDefinition$1(element, definition);
    });
  }
  function isReceiveTaskAfterEventBasedGateway(element) {
    return is(element, 'bpmn:ReceiveTask') && find(element.incoming, function (incoming) {
      return is(incoming.source, 'bpmn:EventBasedGateway');
    });
  }
  function canAttach(elements, target, source, position) {
    if (!Array.isArray(elements)) {
      elements = [elements];
    }
    if (elements.length !== 1) {
      return false;
    }
    var element = elements[0];
    if (isLabel(element)) {
      return false;
    }
    if (!isBoundaryCandidate(element)) {
      return false;
    }
    if (isEventSubProcess(target)) {
      return false;
    }
    if (!is(target, 'bpmn:Activity') || isForCompensation(target)) {
      return false;
    }
    if (position && !getBoundaryAttachment(position, target)) {
      return false;
    }
    if (isReceiveTaskAfterEventBasedGateway(target)) {
      return false;
    }
    return 'attach';
  }
  function canReplace(elements, target, position) {
    if (!target) {
      return false;
    }
    var canExecute = {
      replacements: []
    };
    forEach$1(elements, function (element) {
      if (!isEventSubProcess(target)) {
        if (is(element, 'bpmn:StartEvent') && element.type !== 'label' && canDrop(element, target)) {
          if (!isInterrupting(element)) {
            canExecute.replacements.push({
              oldElementId: element.id,
              newElementType: 'bpmn:StartEvent'
            });
          }
          if (hasErrorEventDefinition(element) || hasEscalationEventDefinition(element) || hasCompensateEventDefinition(element)) {
            canExecute.replacements.push({
              oldElementId: element.id,
              newElementType: 'bpmn:StartEvent'
            });
          }
          if (hasOneOfEventDefinitions(element, ['bpmn:MessageEventDefinition', 'bpmn:TimerEventDefinition', 'bpmn:SignalEventDefinition', 'bpmn:ConditionalEventDefinition']) && is(target, 'bpmn:SubProcess')) {
            canExecute.replacements.push({
              oldElementId: element.id,
              newElementType: 'bpmn:StartEvent'
            });
          }
        }
      }
      if (!is(target, 'bpmn:Transaction')) {
        if (hasEventDefinition$1(element, 'bpmn:CancelEventDefinition') && element.type !== 'label') {
          if (is(element, 'bpmn:EndEvent') && canDrop(element, target)) {
            canExecute.replacements.push({
              oldElementId: element.id,
              newElementType: 'bpmn:EndEvent'
            });
          }
          if (is(element, 'bpmn:BoundaryEvent') && canAttach(element, target, null, position)) {
            canExecute.replacements.push({
              oldElementId: element.id,
              newElementType: 'bpmn:BoundaryEvent'
            });
          }
        }
      }
    });
    return canExecute.replacements.length ? canExecute : false;
  }
  function canMove(elements, target) {
    if (some(elements, isLane)) {
      return false;
    }
    if (!target) {
      return true;
    }
    return elements.every(function (element) {
      return canDrop(element, target);
    });
  }
  function canCreate(shape, target, source, position) {
    if (!target) {
      return false;
    }
    if (isLabel(shape) || isGroup(shape)) {
      return true;
    }
    if (isSame$1(source, target)) {
      return false;
    }
    if (source && isParent(source, target)) {
      return false;
    }
    return canDrop(shape, target) || canInsert(shape, target);
  }
  function canResize(shape, newBounds) {
    if (is(shape, 'bpmn:SubProcess')) {
      return isExpanded(shape) && (!newBounds || newBounds.width >= 100 && newBounds.height >= 80);
    }
    if (is(shape, 'bpmn:Lane')) {
      return true;
    }
    if (is(shape, 'bpmn:Participant')) {
      return true;
    }
    if (isTextAnnotation(shape)) {
      return true;
    }
    if (isGroup(shape)) {
      return true;
    }
    return false;
  }
  function isOneTextAnnotation(source, target) {
    var sourceTextAnnotation = isTextAnnotation(source),
      targetTextAnnotation = isTextAnnotation(target);
    return (sourceTextAnnotation || targetTextAnnotation) && sourceTextAnnotation !== targetTextAnnotation;
  }
  function canConnectAssociation(source, target) {
    if (isParent(target, source) || isParent(source, target)) {
      return false;
    }
    if (isOneTextAnnotation(source, target)) {
      return true;
    }
    return !!canConnectDataAssociation(source, target);
  }
  function canConnectCompensationAssociation(source, target) {
    return isSameScope(source, target) && isCompensationBoundary(source) && is(target, 'bpmn:Activity') && !isHostOfElement(target, source) && !isEventSubProcess(target);
  }
  function canConnectMessageFlow(source, target) {
    if (getRootElement(source) && !getRootElement(target)) {
      return false;
    }
    return isMessageFlowSource(source) && isMessageFlowTarget(target) && !isSameOrganization(source, target);
  }
  function canConnectSequenceFlow(source, target) {
    return isSequenceFlowSource(source) && isSequenceFlowTarget(target) && isSameScope(source, target) && !(is(source, 'bpmn:EventBasedGateway') && !isEventBasedTarget(target));
  }
  function canConnectDataAssociation(source, target) {
    if (isAny(source, ['bpmn:DataObjectReference', 'bpmn:DataStoreReference']) && isAny(target, ['bpmn:Activity', 'bpmn:ThrowEvent'])) {
      return {
        type: 'bpmn:DataInputAssociation'
      };
    }
    if (isAny(target, ['bpmn:DataObjectReference', 'bpmn:DataStoreReference']) && isAny(source, ['bpmn:Activity', 'bpmn:CatchEvent'])) {
      return {
        type: 'bpmn:DataOutputAssociation'
      };
    }
    return false;
  }
  function canInsert(shape, connection, position) {
    if (!connection) {
      return false;
    }
    if (Array.isArray(shape)) {
      if (shape.length !== 1) {
        return false;
      }
      shape = shape[0];
    }
    if (connection.source === shape || connection.target === shape) {
      return false;
    }
    return isAny(connection, ['bpmn:SequenceFlow', 'bpmn:MessageFlow']) && !isLabel(connection) && is(shape, 'bpmn:FlowNode') && !is(shape, 'bpmn:BoundaryEvent') && canDrop(shape, connection.parent);
  }
  function includes$5(elements, element) {
    return elements && element && elements.indexOf(element) !== -1;
  }
  function canCopy(elements, element) {
    if (isLabel(element)) {
      return true;
    }
    if (is(element, 'bpmn:Lane') && !includes$5(elements, element.parent)) {
      return false;
    }
    return true;
  }
  function getRootElement(element) {
    return getParent(element, 'bpmn:Process') || getParent(element, 'bpmn:Collaboration');
  }
  function isHostOfElement(potentialHost, element) {
    return potentialHost.attachers.includes(element);
  }
  var RulesModule = {
    __depends__: [RulesModule$1],
    __init__: ['bpmnRules'],
    bpmnRules: ['type', BpmnRules]
  };
  var HIGH_PRIORITY$b = 2000;
  function BpmnDiOrdering(eventBus, canvas) {
    eventBus.on('saveXML.start', HIGH_PRIORITY$b, orderDi);
    function orderDi() {
      var rootElements = canvas.getRootElements();
      forEach$1(rootElements, function (root) {
        var rootDi = getDi(root),
          elements,
          diElements;
        elements = selfAndAllChildren([root], false);
        elements = filter(elements, function (element) {
          return element !== root && !element.labelTarget;
        });
        diElements = map$1(elements, getDi);
        rootDi.set('planeElement', diElements);
      });
    }
  }
  BpmnDiOrdering.$inject = ['eventBus', 'canvas'];
  var DiOrderingModule = {
    __init__: ['bpmnDiOrdering'],
    bpmnDiOrdering: ['type', BpmnDiOrdering]
  };
  function OrderingProvider(eventBus) {
    CommandInterceptor.call(this, eventBus);
    var self = this;
    this.preExecute(['shape.create', 'connection.create'], function (event) {
      var context = event.context,
        element = context.shape || context.connection,
        parent = context.parent;
      var ordering = self.getOrdering(element, parent);
      if (ordering) {
        if (ordering.parent !== undefined) {
          context.parent = ordering.parent;
        }
        context.parentIndex = ordering.index;
      }
    });
    this.preExecute(['shape.move', 'connection.move'], function (event) {
      var context = event.context,
        element = context.shape || context.connection,
        parent = context.newParent || element.parent;
      var ordering = self.getOrdering(element, parent);
      if (ordering) {
        if (ordering.parent !== undefined) {
          context.newParent = ordering.parent;
        }
        context.newParentIndex = ordering.index;
      }
    });
  }
  OrderingProvider.prototype.getOrdering = function (element, newParent) {
    return null;
  };
  e$2(OrderingProvider, CommandInterceptor);
  function BpmnOrderingProvider(eventBus, canvas) {
    OrderingProvider.call(this, eventBus);
    var orders = [{
      type: 'bpmn:SubProcess',
      order: {
        level: 6
      }
    }, {
      type: 'bpmn:SequenceFlow',
      order: {
        level: 9,
        containers: ['bpmn:Participant', 'bpmn:FlowElementsContainer']
      }
    }, {
      type: 'bpmn:DataAssociation',
      order: {
        level: 9,
        containers: ['bpmn:Collaboration', 'bpmn:FlowElementsContainer']
      }
    }, {
      type: 'bpmn:TextAnnotation',
      order: {
        level: 9
      }
    }, {
      type: 'bpmn:MessageFlow',
      order: {
        level: 9,
        containers: ['bpmn:Collaboration']
      }
    }, {
      type: 'bpmn:Association',
      order: {
        level: 6,
        containers: ['bpmn:Participant', 'bpmn:FlowElementsContainer', 'bpmn:Collaboration']
      }
    }, {
      type: 'bpmn:BoundaryEvent',
      order: {
        level: 8
      }
    }, {
      type: 'bpmn:Group',
      order: {
        level: 10,
        containers: ['bpmn:Collaboration', 'bpmn:FlowElementsContainer']
      }
    }, {
      type: 'bpmn:FlowElement',
      order: {
        level: 5
      }
    }, {
      type: 'bpmn:Participant',
      order: {
        level: -2
      }
    }, {
      type: 'bpmn:Lane',
      order: {
        level: -1
      }
    }];
    function computeOrder(element) {
      if (element.labelTarget) {
        return {
          level: 10
        };
      }
      var entry = find(orders, function (o) {
        return isAny(element, [o.type]);
      });
      return entry && entry.order || {
        level: 1
      };
    }
    function getOrder(element) {
      var order = element.order;
      if (!order) {
        element.order = order = computeOrder(element);
      }
      if (!order) {
        throw new Error(`no order for <${element.id}>`);
      }
      return order;
    }
    function findActualParent(element, newParent, containers) {
      var actualParent = newParent;
      while (actualParent) {
        if (isAny(actualParent, containers)) {
          break;
        }
        actualParent = actualParent.parent;
      }
      if (!actualParent) {
        throw new Error(`no parent for <${element.id}> in <${newParent && newParent.id}>`);
      }
      return actualParent;
    }
    this.getOrdering = function (element, newParent) {
      if (element.labelTarget || is(element, 'bpmn:TextAnnotation')) {
        return {
          parent: canvas.findRoot(newParent) || canvas.getRootElement(),
          index: -1
        };
      }
      var elementOrder = getOrder(element);
      if (elementOrder.containers) {
        newParent = findActualParent(element, newParent, elementOrder.containers);
      }
      var currentIndex = newParent.children.indexOf(element);
      var insertIndex = findIndex(newParent.children, function (child) {
        if (!element.labelTarget && child.labelTarget) {
          return false;
        }
        return elementOrder.level < getOrder(child).level;
      });
      if (insertIndex !== -1) {
        if (currentIndex !== -1 && currentIndex < insertIndex) {
          insertIndex -= 1;
        }
      }
      return {
        index: insertIndex,
        parent: newParent
      };
    };
  }
  BpmnOrderingProvider.$inject = ['eventBus', 'canvas'];
  e$2(BpmnOrderingProvider, OrderingProvider);
  var OrderingModule = {
    __init__: ['bpmnOrderingProvider'],
    bpmnOrderingProvider: ['type', BpmnOrderingProvider]
  };
  function Clipboard() {}
  Clipboard.prototype.get = function () {
    return this._data;
  };
  Clipboard.prototype.set = function (data) {
    this._data = data;
  };
  Clipboard.prototype.clear = function () {
    var data = this._data;
    delete this._data;
    return data;
  };
  Clipboard.prototype.isEmpty = function () {
    return !this._data;
  };
  var ClipboardModule = {
    clipboard: ['type', Clipboard]
  };
  var MARKER_OK$2 = 'drop-ok',
    MARKER_NOT_OK$2 = 'drop-not-ok',
    MARKER_ATTACH$2 = 'attach-ok',
    MARKER_NEW_PARENT$1 = 'new-parent';
  var PREFIX = 'create';
  var HIGH_PRIORITY$a = 2000;
  function Create(canvas, dragging, eventBus, modeling, rules) {
    function canCreate(elements, target, position, source, hints) {
      if (!target) {
        return false;
      }
      elements = filter(elements, function (element) {
        var labelTarget = element.labelTarget;
        return !element.parent && !(isLabel(element) && elements.indexOf(labelTarget) !== -1);
      });
      var shape = find(elements, function (element) {
        return !isConnection(element);
      });
      var attach = false,
        connect = false,
        create = false;
      if (isSingleShape(elements)) {
        attach = rules.allowed('shape.attach', {
          position: position,
          shape: shape,
          target: target
        });
      }
      if (!attach) {
        if (isSingleShape(elements)) {
          create = rules.allowed('shape.create', {
            position: position,
            shape: shape,
            source: source,
            target: target
          });
        } else {
          create = rules.allowed('elements.create', {
            elements: elements,
            position: position,
            target: target
          });
        }
      }
      var connectionTarget = hints.connectionTarget;
      if (create || attach) {
        if (shape && source) {
          connect = rules.allowed('connection.create', {
            source: connectionTarget === source ? shape : source,
            target: connectionTarget === source ? source : shape,
            hints: {
              targetParent: target,
              targetAttach: attach
            }
          });
        }
        return {
          attach: attach,
          connect: connect
        };
      }
      if (create === null || attach === null) {
        return null;
      }
      return false;
    }
    function setMarker(element, marker) {
      [MARKER_ATTACH$2, MARKER_OK$2, MARKER_NOT_OK$2, MARKER_NEW_PARENT$1].forEach(function (m) {
        if (m === marker) {
          canvas.addMarker(element, m);
        } else {
          canvas.removeMarker(element, m);
        }
      });
    }
    eventBus.on(['create.move', 'create.hover'], function (event) {
      var context = event.context,
        elements = context.elements,
        hover = event.hover,
        source = context.source,
        hints = context.hints || {};
      if (!hover) {
        context.canExecute = false;
        context.target = null;
        return;
      }
      ensureConstraints$1(event);
      var position = {
        x: event.x,
        y: event.y
      };
      var canExecute = context.canExecute = hover && canCreate(elements, hover, position, source, hints);
      if (hover && canExecute !== null) {
        context.target = hover;
        if (canExecute && canExecute.attach) {
          setMarker(hover, MARKER_ATTACH$2);
        } else {
          setMarker(hover, canExecute ? MARKER_NEW_PARENT$1 : MARKER_NOT_OK$2);
        }
      }
    });
    eventBus.on(['create.end', 'create.out', 'create.cleanup'], function (event) {
      var hover = event.hover;
      if (hover) {
        setMarker(hover, null);
      }
    });
    eventBus.on('create.end', function (event) {
      var context = event.context,
        source = context.source,
        shape = context.shape,
        elements = context.elements,
        target = context.target,
        canExecute = context.canExecute,
        attach = canExecute && canExecute.attach,
        connect = canExecute && canExecute.connect,
        hints = context.hints || {};
      if (canExecute === false || !target) {
        return false;
      }
      ensureConstraints$1(event);
      var position = {
        x: event.x,
        y: event.y
      };
      if (connect) {
        shape = modeling.appendShape(source, shape, position, target, {
          attach: attach,
          connection: connect === true ? {} : connect,
          connectionTarget: hints.connectionTarget
        });
      } else {
        elements = modeling.createElements(elements, position, target, assign$1({}, hints, {
          attach: attach
        }));
        shape = find(elements, function (element) {
          return !isConnection(element);
        });
      }
      assign$1(context, {
        elements: elements,
        shape: shape
      });
      assign$1(event, {
        elements: elements,
        shape: shape
      });
    });
    function cancel() {
      var context = dragging.context();
      if (context && context.prefix === PREFIX) {
        dragging.cancel();
      }
    }
    eventBus.on('create.init', function () {
      eventBus.on('elements.changed', cancel);
      eventBus.once(['create.cancel', 'create.end'], HIGH_PRIORITY$a, function () {
        eventBus.off('elements.changed', cancel);
      });
    });
    this.start = function (event, elements, context) {
      if (!isArray$3(elements)) {
        elements = [elements];
      }
      var shape = find(elements, function (element) {
        return !isConnection(element);
      });
      if (!shape) {
        return;
      }
      context = assign$1({
        elements: elements,
        hints: {},
        shape: shape
      }, context || {});
      forEach$1(elements, function (element) {
        if (!isNumber(element.x)) {
          element.x = 0;
        }
        if (!isNumber(element.y)) {
          element.y = 0;
        }
      });
      var visibleElements = filter(elements, function (element) {
        return !element.hidden;
      });
      var bbox = getBBox(visibleElements);
      forEach$1(elements, function (element) {
        if (isConnection(element)) {
          element.waypoints = map$1(element.waypoints, function (waypoint) {
            return {
              x: waypoint.x - bbox.x - bbox.width / 2,
              y: waypoint.y - bbox.y - bbox.height / 2
            };
          });
        }
        assign$1(element, {
          x: element.x - bbox.x - bbox.width / 2,
          y: element.y - bbox.y - bbox.height / 2
        });
      });
      dragging.init(event, PREFIX, {
        cursor: 'grabbing',
        autoActivate: true,
        data: {
          shape: shape,
          elements: elements,
          context: context
        }
      });
    };
  }
  Create.$inject = ['canvas', 'dragging', 'eventBus', 'modeling', 'rules'];
  function ensureConstraints$1(event) {
    var context = event.context,
      createConstraints = context.createConstraints;
    if (!createConstraints) {
      return;
    }
    if (createConstraints.left) {
      event.x = Math.max(event.x, createConstraints.left);
    }
    if (createConstraints.right) {
      event.x = Math.min(event.x, createConstraints.right);
    }
    if (createConstraints.top) {
      event.y = Math.max(event.y, createConstraints.top);
    }
    if (createConstraints.bottom) {
      event.y = Math.min(event.y, createConstraints.bottom);
    }
  }
  function isSingleShape(elements) {
    return elements && elements.length === 1 && !isConnection(elements[0]);
  }
  var LOW_PRIORITY$c = 750;
  function CreatePreview(canvas, eventBus, graphicsFactory, previewSupport, styles) {
    function createDragGroup(elements) {
      var dragGroup = create$1('g');
      attr(dragGroup, styles.cls('djs-drag-group', ['no-events']));
      var childrenGfx = create$1('g');
      elements.forEach(function (element) {
        var gfx;
        if (element.hidden) {
          return;
        }
        if (element.waypoints) {
          gfx = graphicsFactory._createContainer('connection', childrenGfx);
          graphicsFactory.drawConnection(getVisual(gfx), element);
        } else {
          gfx = graphicsFactory._createContainer('shape', childrenGfx);
          graphicsFactory.drawShape(getVisual(gfx), element);
          translate$1(gfx, element.x, element.y);
        }
        previewSupport.addDragger(element, dragGroup, gfx);
      });
      return dragGroup;
    }
    eventBus.on('create.move', LOW_PRIORITY$c, function (event) {
      var hover = event.hover,
        context = event.context,
        elements = context.elements,
        dragGroup = context.dragGroup;
      if (!dragGroup) {
        dragGroup = context.dragGroup = createDragGroup(elements);
      }
      var activeLayer;
      if (hover) {
        if (!dragGroup.parentNode) {
          activeLayer = canvas.getActiveLayer();
          append(activeLayer, dragGroup);
        }
        translate$1(dragGroup, event.x, event.y);
      } else {
        remove$1(dragGroup);
      }
    });
    eventBus.on('create.cleanup', function (event) {
      var context = event.context,
        dragGroup = context.dragGroup;
      if (dragGroup) {
        remove$1(dragGroup);
      }
    });
  }
  CreatePreview.$inject = ['canvas', 'eventBus', 'graphicsFactory', 'previewSupport', 'styles'];
  var CreateModule = {
    __depends__: [DraggingModule, PreviewSupportModule, RulesModule$1, SelectionModule],
    __init__: ['create', 'createPreview'],
    create: ['type', Create],
    createPreview: ['type', CreatePreview]
  };
  function Mouse(eventBus) {
    var self = this;
    this._lastMoveEvent = null;
    function setLastMoveEvent(mousemoveEvent) {
      self._lastMoveEvent = mousemoveEvent;
    }
    eventBus.on('canvas.init', function (context) {
      var svg = self._svg = context.svg;
      svg.addEventListener('mousemove', setLastMoveEvent);
    });
    eventBus.on('canvas.destroy', function () {
      self._lastMouseEvent = null;
      self._svg.removeEventListener('mousemove', setLastMoveEvent);
    });
  }
  Mouse.$inject = ['eventBus'];
  Mouse.prototype.getLastMoveEvent = function () {
    return this._lastMoveEvent || createMoveEvent(0, 0);
  };
  function createMoveEvent(x, y) {
    var event = document.createEvent('MouseEvent');
    var screenX = x,
      screenY = y,
      clientX = x,
      clientY = y;
    if (event.initMouseEvent) {
      event.initMouseEvent('mousemove', true, true, window, 0, screenX, screenY, clientX, clientY, false, false, false, false, 0, null);
    }
    return event;
  }
  var MouseModule = {
    __init__: ['mouse'],
    mouse: ['type', Mouse]
  };
  function CopyPaste(canvas, create, clipboard, elementFactory, eventBus, modeling, mouse, rules) {
    this._canvas = canvas;
    this._create = create;
    this._clipboard = clipboard;
    this._elementFactory = elementFactory;
    this._eventBus = eventBus;
    this._modeling = modeling;
    this._mouse = mouse;
    this._rules = rules;
    eventBus.on('copyPaste.copyElement', function (context) {
      var descriptor = context.descriptor,
        element = context.element,
        elements = context.elements;
      descriptor.priority = 1;
      descriptor.id = element.id;
      var parentCopied = find(elements, function (e) {
        return e === element.parent;
      });
      if (parentCopied) {
        descriptor.parent = element.parent.id;
      }
      if (isAttacher$2(element)) {
        descriptor.priority = 2;
        descriptor.host = element.host.id;
      }
      if (isConnection(element)) {
        descriptor.priority = 3;
        descriptor.source = element.source.id;
        descriptor.target = element.target.id;
        descriptor.waypoints = copyWaypoints$1(element);
      }
      if (isLabel(element)) {
        descriptor.priority = 4;
        descriptor.labelTarget = element.labelTarget.id;
      }
      forEach$1(['x', 'y', 'width', 'height'], function (property) {
        if (isNumber(element[property])) {
          descriptor[property] = element[property];
        }
      });
      descriptor.hidden = element.hidden;
      descriptor.collapsed = element.collapsed;
    });
    eventBus.on('copyPaste.pasteElements', function (context) {
      var hints = context.hints;
      assign$1(hints, {
        createElementsBehavior: false
      });
    });
  }
  CopyPaste.$inject = ['canvas', 'create', 'clipboard', 'elementFactory', 'eventBus', 'modeling', 'mouse', 'rules'];
  CopyPaste.prototype.copy = function (elements) {
    var allowed, tree;
    if (!isArray$3(elements)) {
      elements = elements ? [elements] : [];
    }
    allowed = this._eventBus.fire('copyPaste.canCopyElements', {
      elements: elements
    });
    if (allowed === false) {
      tree = {};
    } else {
      tree = this.createTree(isArray$3(allowed) ? allowed : elements);
    }
    this._clipboard.set(tree);
    this._eventBus.fire('copyPaste.elementsCopied', {
      elements: elements,
      tree: tree
    });
    return tree;
  };
  CopyPaste.prototype.paste = function (context) {
    var tree = this._clipboard.get();
    if (this._clipboard.isEmpty()) {
      return;
    }
    var hints = context && context.hints || {};
    this._eventBus.fire('copyPaste.pasteElements', {
      hints: hints
    });
    var elements = this._createElements(tree);
    if (context && context.element && context.point) {
      return this._paste(elements, context.element, context.point, hints);
    }
    this._create.start(this._mouse.getLastMoveEvent(), elements, {
      hints: hints || {}
    });
  };
  CopyPaste.prototype._paste = function (elements, target, position, hints) {
    forEach$1(elements, function (element) {
      if (!isNumber(element.x)) {
        element.x = 0;
      }
      if (!isNumber(element.y)) {
        element.y = 0;
      }
    });
    var bbox = getBBox(elements);
    forEach$1(elements, function (element) {
      if (isConnection(element)) {
        element.waypoints = map$1(element.waypoints, function (waypoint) {
          return {
            x: waypoint.x - bbox.x - bbox.width / 2,
            y: waypoint.y - bbox.y - bbox.height / 2
          };
        });
      }
      assign$1(element, {
        x: element.x - bbox.x - bbox.width / 2,
        y: element.y - bbox.y - bbox.height / 2
      });
    });
    return this._modeling.createElements(elements, position, target, assign$1({}, hints));
  };
  CopyPaste.prototype._createElements = function (tree) {
    var self = this;
    var eventBus = this._eventBus;
    var cache = {};
    var elements = [];
    forEach$1(tree, function (branch, depth) {
      branch = sortBy(branch, 'priority');
      forEach$1(branch, function (descriptor) {
        var attrs = assign$1({}, omit(descriptor, ['priority']));
        if (cache[descriptor.parent]) {
          attrs.parent = cache[descriptor.parent];
        } else {
          delete attrs.parent;
        }
        eventBus.fire('copyPaste.pasteElement', {
          cache: cache,
          descriptor: attrs
        });
        var element;
        if (isConnection(attrs)) {
          attrs.source = cache[descriptor.source];
          attrs.target = cache[descriptor.target];
          element = cache[descriptor.id] = self.createConnection(attrs);
          elements.push(element);
          return;
        }
        if (isLabel(attrs)) {
          attrs.labelTarget = cache[attrs.labelTarget];
          element = cache[descriptor.id] = self.createLabel(attrs);
          elements.push(element);
          return;
        }
        if (attrs.host) {
          attrs.host = cache[attrs.host];
        }
        element = cache[descriptor.id] = self.createShape(attrs);
        elements.push(element);
      });
    });
    return elements;
  };
  CopyPaste.prototype.createConnection = function (attrs) {
    var connection = this._elementFactory.createConnection(omit(attrs, ['id']));
    return connection;
  };
  CopyPaste.prototype.createLabel = function (attrs) {
    var label = this._elementFactory.createLabel(omit(attrs, ['id']));
    return label;
  };
  CopyPaste.prototype.createShape = function (attrs) {
    var shape = this._elementFactory.createShape(omit(attrs, ['id']));
    return shape;
  };
  CopyPaste.prototype.hasRelations = function (element, elements) {
    var labelTarget, source, target;
    if (isConnection(element)) {
      source = find(elements, matchPattern({
        id: element.source.id
      }));
      target = find(elements, matchPattern({
        id: element.target.id
      }));
      if (!source || !target) {
        return false;
      }
    }
    if (isLabel(element)) {
      labelTarget = find(elements, matchPattern({
        id: element.labelTarget.id
      }));
      if (!labelTarget) {
        return false;
      }
    }
    return true;
  };
  CopyPaste.prototype.createTree = function (elements) {
    var rules = this._rules,
      self = this;
    var tree = {},
      elementsData = [];
    var parents = getParents$1(elements);
    function canCopy(element, elements) {
      return rules.allowed('element.copy', {
        element: element,
        elements: elements
      });
    }
    function addElementData(element, depth) {
      var foundElementData = find(elementsData, function (elementsData) {
        return element === elementsData.element;
      });
      if (!foundElementData) {
        elementsData.push({
          element: element,
          depth: depth
        });
        return;
      }
      if (foundElementData.depth < depth) {
        elementsData = removeElementData(foundElementData, elementsData);
        elementsData.push({
          element: foundElementData.element,
          depth: depth
        });
      }
    }
    function removeElementData(elementData, elementsData) {
      var index = elementsData.indexOf(elementData);
      if (index !== -1) {
        elementsData.splice(index, 1);
      }
      return elementsData;
    }
    eachElement(parents, function (element, _index, depth) {
      if (isLabel(element)) {
        return;
      }
      forEach$1(element.labels, function (label) {
        addElementData(label, depth);
      });
      function addRelatedElements(elements) {
        elements && elements.length && forEach$1(elements, function (element) {
          forEach$1(element.labels, function (label) {
            addElementData(label, depth);
          });
          addElementData(element, depth);
        });
      }
      forEach$1([element.attachers, element.incoming, element.outgoing], addRelatedElements);
      addElementData(element, depth);
      var children = [];
      if (element.children) {
        children = element.children.slice();
      }
      self._eventBus.fire('copyPaste.createTree', {
        element: element,
        children: children
      });
      return children;
    });
    elements = map$1(elementsData, function (elementData) {
      return elementData.element;
    });
    elementsData = map$1(elementsData, function (elementData) {
      elementData.descriptor = {};
      self._eventBus.fire('copyPaste.copyElement', {
        descriptor: elementData.descriptor,
        element: elementData.element,
        elements: elements
      });
      return elementData;
    });
    elementsData = sortBy(elementsData, function (elementData) {
      return elementData.descriptor.priority;
    });
    elements = map$1(elementsData, function (elementData) {
      return elementData.element;
    });
    forEach$1(elementsData, function (elementData) {
      var depth = elementData.depth;
      if (!self.hasRelations(elementData.element, elements)) {
        removeElement(elementData.element, elements);
        return;
      }
      if (!canCopy(elementData.element, elements)) {
        removeElement(elementData.element, elements);
        return;
      }
      if (!tree[depth]) {
        tree[depth] = [];
      }
      tree[depth].push(elementData.descriptor);
    });
    return tree;
  };
  function isAttacher$2(element) {
    return !!element.host;
  }
  function copyWaypoints$1(element) {
    return map$1(element.waypoints, function (waypoint) {
      waypoint = copyWaypoint$1(waypoint);
      if (waypoint.original) {
        waypoint.original = copyWaypoint$1(waypoint.original);
      }
      return waypoint;
    });
  }
  function copyWaypoint$1(waypoint) {
    return assign$1({}, waypoint);
  }
  function removeElement(element, elements) {
    var index = elements.indexOf(element);
    if (index === -1) {
      return elements;
    }
    return elements.splice(index, 1);
  }
  var CopyPasteModule$1 = {
    __depends__: [ClipboardModule, CreateModule, MouseModule, RulesModule$1],
    __init__: ['copyPaste'],
    copyPaste: ['type', CopyPaste]
  };
  function copyProperties$1(source, target, properties) {
    if (!isArray$3(properties)) {
      properties = [properties];
    }
    forEach$1(properties, function (property) {
      if (!isUndefined$2(source[property])) {
        target[property] = source[property];
      }
    });
  }
  var LOW_PRIORITY$b = 750;
  function BpmnCopyPaste(bpmnFactory, eventBus, moddleCopy) {
    function copy(bo, clone) {
      var targetBo = bpmnFactory.create(bo.$type);
      return moddleCopy.copyElement(bo, targetBo, null, clone);
    }
    eventBus.on('copyPaste.copyElement', LOW_PRIORITY$b, function (context) {
      var descriptor = context.descriptor,
        element = context.element,
        businessObject = getBusinessObject(element);
      if (isLabel(element)) {
        return descriptor;
      }
      var businessObjectCopy = descriptor.businessObject = copy(businessObject, true);
      var diCopy = descriptor.di = copy(getDi(element), true);
      diCopy.bpmnElement = businessObjectCopy;
      copyProperties$1(businessObjectCopy, descriptor, 'name');
      copyProperties$1(diCopy, descriptor, 'isExpanded');
      if (businessObject.default) {
        descriptor.default = businessObject.default.id;
      }
    });
    var referencesKey = '-bpmn-js-refs';
    function getReferences(cache) {
      return cache[referencesKey] = cache[referencesKey] || {};
    }
    function setReferences(cache, references) {
      cache[referencesKey] = references;
    }
    function resolveReferences(descriptor, cache, references) {
      var businessObject = getBusinessObject(descriptor);
      if (descriptor.default) {
        references[descriptor.default] = {
          element: businessObject,
          property: 'default'
        };
      }
      if (descriptor.host) {
        getBusinessObject(descriptor).attachedToRef = getBusinessObject(cache[descriptor.host]);
      }
      return omit(references, reduce(references, function (array, reference, key) {
        var element = reference.element,
          property = reference.property;
        if (key === descriptor.id) {
          element.set(property, businessObject);
          array.push(descriptor.id);
        }
        return array;
      }, []));
    }
    eventBus.on('copyPaste.pasteElement', function (context) {
      var cache = context.cache,
        descriptor = context.descriptor,
        businessObject = descriptor.businessObject,
        di = descriptor.di;
      if (isLabel(descriptor)) {
        descriptor.businessObject = getBusinessObject(cache[descriptor.labelTarget]);
        descriptor.di = getDi(cache[descriptor.labelTarget]);
        return;
      }
      businessObject = descriptor.businessObject = copy(businessObject);
      di = descriptor.di = copy(di);
      di.bpmnElement = businessObject;
      copyProperties$1(descriptor, businessObject, ['isExpanded', 'name']);
      descriptor.type = businessObject.$type;
    });
    eventBus.on('copyPaste.copyElement', LOW_PRIORITY$b, function (context) {
      var descriptor = context.descriptor,
        element = context.element;
      if (!is(element, 'bpmn:Participant')) {
        return;
      }
      var participantBo = getBusinessObject(element);
      if (participantBo.processRef) {
        descriptor.processRef = copy(participantBo.processRef, true);
      }
    });
    eventBus.on('copyPaste.pasteElement', function (context) {
      var descriptor = context.descriptor,
        processRef = descriptor.processRef;
      if (processRef) {
        descriptor.processRef = copy(processRef);
      }
    });
    eventBus.on('copyPaste.pasteElement', LOW_PRIORITY$b, function (context) {
      var cache = context.cache,
        descriptor = context.descriptor;
      setReferences(cache, resolveReferences(descriptor, cache, getReferences(cache)));
    });
  }
  BpmnCopyPaste.$inject = ['bpmnFactory', 'eventBus', 'moddleCopy'];
  var DISALLOWED_PROPERTIES = ['artifacts', 'dataInputAssociations', 'dataOutputAssociations', 'default', 'flowElements', 'lanes', 'incoming', 'outgoing', 'categoryValue'];
  var ALLOWED_REFERENCES = ['errorRef', 'escalationRef', 'messageRef', 'signalRef'];
  function ModdleCopy(eventBus, bpmnFactory, moddle) {
    this._bpmnFactory = bpmnFactory;
    this._eventBus = eventBus;
    this._moddle = moddle;
    eventBus.on('moddleCopy.canCopyProperties', function (context) {
      var propertyNames = context.propertyNames;
      if (!propertyNames || !propertyNames.length) {
        return;
      }
      return sortBy(propertyNames, function (propertyName) {
        return propertyName === 'extensionElements';
      });
    });
    eventBus.on('moddleCopy.canCopyProperty', function (context) {
      var parent = context.parent,
        property = context.property,
        propertyName = context.propertyName;
      var parentDescriptor = isObject(parent) && parent.$descriptor;
      if (propertyName && ALLOWED_REFERENCES.includes(propertyName)) {
        return property;
      }
      if (propertyName && DISALLOWED_PROPERTIES.includes(propertyName)) {
        return false;
      }
      if (propertyName && parentDescriptor && !find(parentDescriptor.properties, matchPattern({
        name: propertyName
      }))) {
        return false;
      }
    });
    eventBus.on('moddleCopy.canSetCopiedProperty', function (context) {
      var property = context.property;
      if (is(property, 'bpmn:ExtensionElements') && (!property.values || !property.values.length)) {
        return false;
      }
    });
  }
  ModdleCopy.$inject = ['eventBus', 'bpmnFactory', 'moddle'];
  ModdleCopy.prototype.copyElement = function (sourceElement, targetElement, propertyNames) {
    var _this13 = this;
    var clone = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    if (propertyNames && !isArray$3(propertyNames)) {
      propertyNames = [propertyNames];
    }
    propertyNames = propertyNames || getPropertyNames(sourceElement.$descriptor);
    var canCopyProperties = this._eventBus.fire('moddleCopy.canCopyProperties', {
      propertyNames: propertyNames,
      sourceElement: sourceElement,
      targetElement: targetElement,
      clone: clone
    });
    if (canCopyProperties === false) {
      return targetElement;
    }
    if (isArray$3(canCopyProperties)) {
      propertyNames = canCopyProperties;
    }
    forEach$1(propertyNames, function (propertyName) {
      var sourceProperty;
      if (has$1(sourceElement, propertyName)) {
        sourceProperty = sourceElement.get(propertyName);
      }
      var copiedProperty = _this13.copyProperty(sourceProperty, targetElement, propertyName, clone);
      if (!isDefined(copiedProperty)) {
        return;
      }
      var canSetProperty = _this13._eventBus.fire('moddleCopy.canSetCopiedProperty', {
        parent: targetElement,
        property: copiedProperty,
        propertyName: propertyName
      });
      if (canSetProperty === false) {
        return;
      }
      targetElement.set(propertyName, copiedProperty);
    });
    return targetElement;
  };
  ModdleCopy.prototype.copyProperty = function (property, parent, propertyName) {
    var _this14 = this;
    var clone = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var copiedProperty = this._eventBus.fire('moddleCopy.canCopyProperty', {
      parent: parent,
      property: property,
      propertyName: propertyName,
      clone: clone
    });
    if (copiedProperty === false) {
      return;
    }
    if (copiedProperty) {
      if (isObject(copiedProperty) && copiedProperty.$type && !copiedProperty.$parent) {
        copiedProperty.$parent = parent;
      }
      return copiedProperty;
    }
    var propertyDescriptor = this._moddle.getPropertyDescriptor(parent, propertyName);
    if (propertyDescriptor.isReference) {
      return;
    }
    if (propertyDescriptor.isId) {
      return property && this._copyId(property, parent, clone);
    }
    if (isArray$3(property)) {
      return reduce(property, function (childProperties, childProperty) {
        var copiedProperty = _this14.copyProperty(childProperty, parent, propertyName, clone);
        if (copiedProperty) {
          return childProperties.concat(copiedProperty);
        }
        return childProperties;
      }, []);
    }
    if (isObject(property) && property.$type) {
      if (this._moddle.getElementDescriptor(property).isGeneric) {
        return;
      }
      copiedProperty = this._bpmnFactory.create(property.$type);
      copiedProperty.$parent = parent;
      copiedProperty = this.copyElement(property, copiedProperty, null, clone);
      return copiedProperty;
    }
    return property;
  };
  ModdleCopy.prototype._copyId = function (id, element) {
    var clone = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    if (clone) {
      return id;
    }
    if (this._moddle.ids.assigned(id)) {
      return;
    } else {
      this._moddle.ids.claim(id, element);
      return id;
    }
  };
  function getPropertyNames(descriptor, keepDefaultProperties) {
    return reduce(descriptor.properties, function (properties, property) {
      if (keepDefaultProperties && property.default) {
        return properties;
      }
      return properties.concat(property.name);
    }, []);
  }
  var CopyPasteModule = {
    __depends__: [CopyPasteModule$1],
    __init__: ['bpmnCopyPaste', 'moddleCopy'],
    bpmnCopyPaste: ['type', BpmnCopyPaste],
    moddleCopy: ['type', ModdleCopy]
  };
  var round$6 = Math.round;
  function Replace(modeling, eventBus) {
    this._modeling = modeling;
    this._eventBus = eventBus;
  }
  Replace.$inject = ['modeling', 'eventBus'];
  Replace.prototype.replaceElement = function (oldElement, attrs, hints) {
    if (oldElement.waypoints) {
      return null;
    }
    var modeling = this._modeling;
    var eventBus = this._eventBus;
    eventBus.fire('replace.start', {
      element: oldElement,
      attrs,
      hints
    });
    var width = attrs.width || oldElement.width,
      height = attrs.height || oldElement.height,
      x = attrs.x || oldElement.x,
      y = attrs.y || oldElement.y,
      centerX = round$6(x + width / 2),
      centerY = round$6(y + height / 2);
    var newElement = modeling.replaceShape(oldElement, assign$1({}, attrs, {
      x: centerX,
      y: centerY,
      width: width,
      height: height
    }), hints);
    eventBus.fire('replace.end', {
      element: oldElement,
      newElement,
      hints
    });
    return newElement;
  };
  function ReplaceSelectionBehavior(selection, eventBus) {
    eventBus.on('replace.end', 500, function (event) {
      var newElement = event.newElement,
        _event$hints = event.hints,
        hints = _event$hints === void 0 ? {} : _event$hints;
      if (hints.select === false) {
        return;
      }
      selection.select(newElement);
    });
  }
  ReplaceSelectionBehavior.$inject = ['selection', 'eventBus'];
  var ReplaceModule$1 = {
    __init__: ['replace', 'replaceSelectionBehavior'],
    replaceSelectionBehavior: ['type', ReplaceSelectionBehavior],
    replace: ['type', Replace]
  };
  function copyProperties(source, target, properties) {
    if (!isArray$3(properties)) {
      properties = [properties];
    }
    forEach$1(properties, function (property) {
      if (!isUndefined$2(source[property])) {
        target[property] = source[property];
      }
    });
  }
  var CUSTOM_PROPERTIES = ['cancelActivity', 'instantiate', 'eventGatewayType', 'triggeredByEvent', 'isInterrupting'];
  function shouldToggleCollapsed(element, targetElement) {
    var oldCollapsed = element && has$1(element, 'collapsed') ? element.collapsed : !isExpanded(element);
    var targetCollapsed;
    if (targetElement && (has$1(targetElement, 'collapsed') || has$1(targetElement, 'isExpanded'))) {
      targetCollapsed = has$1(targetElement, 'collapsed') ? targetElement.collapsed : !targetElement.isExpanded;
    } else {
      targetCollapsed = oldCollapsed;
    }
    if (oldCollapsed !== targetCollapsed) {
      return true;
    }
    return false;
  }
  function BpmnReplace(bpmnFactory, elementFactory, moddleCopy, modeling, replace, rules) {
    function replaceElement(element, targetElement, hints) {
      hints = hints || {};
      var type = targetElement.type,
        oldBusinessObject = element.businessObject;
      if (isSubProcess(oldBusinessObject) && (type === 'bpmn:SubProcess' || type === 'bpmn:AdHocSubProcess')) {
        if (shouldToggleCollapsed(element, targetElement)) {
          modeling.toggleCollapse(element);
          return element;
        }
      }
      var newBusinessObject = bpmnFactory.create(type);
      var newElement = {
        type: type,
        businessObject: newBusinessObject
      };
      newElement.di = {};
      if (type === 'bpmn:ExclusiveGateway') {
        newElement.di.isMarkerVisible = true;
      }
      copyProperties(element.di, newElement.di, ['fill', 'stroke', 'background-color', 'border-color', 'color']);
      var elementProps = getPropertyNames(oldBusinessObject.$descriptor),
        newElementProps = getPropertyNames(newBusinessObject.$descriptor, true),
        copyProps = intersection(elementProps, newElementProps);
      assign$1(newBusinessObject, pick(targetElement, CUSTOM_PROPERTIES));
      var properties = filter(copyProps, function (propertyName) {
        if (propertyName === 'eventDefinitions') {
          return hasEventDefinition(element, targetElement.eventDefinitionType);
        }
        if (propertyName === 'loopCharacteristics') {
          return !isEventSubProcess(newBusinessObject);
        }
        if (has$1(newBusinessObject, propertyName)) {
          return false;
        }
        if (propertyName === 'processRef' && targetElement.isExpanded === false) {
          return false;
        }
        if (propertyName === 'triggeredByEvent') {
          return false;
        }
        if (propertyName === 'isForCompensation') {
          return !isEventSubProcess(newBusinessObject);
        }
        return true;
      });
      newBusinessObject = moddleCopy.copyElement(oldBusinessObject, newBusinessObject, properties);
      if (targetElement.eventDefinitionType) {
        if (!hasEventDefinition(newBusinessObject, targetElement.eventDefinitionType)) {
          newElement.eventDefinitionType = targetElement.eventDefinitionType;
          newElement.eventDefinitionAttrs = targetElement.eventDefinitionAttrs;
        }
      }
      if (is(oldBusinessObject, 'bpmn:Activity')) {
        if (isSubProcess(oldBusinessObject)) {
          newElement.isExpanded = isExpanded(element);
        } else if (targetElement && has$1(targetElement, 'isExpanded')) {
          newElement.isExpanded = targetElement.isExpanded;
          var defaultSize = elementFactory.getDefaultSize(newBusinessObject, {
            isExpanded: newElement.isExpanded
          });
          newElement.width = defaultSize.width;
          newElement.height = defaultSize.height;
          newElement.x = element.x - (newElement.width - element.width) / 2;
          newElement.y = element.y - (newElement.height - element.height) / 2;
        }
        if (isExpanded(element) && !is(oldBusinessObject, 'bpmn:Task') && newElement.isExpanded) {
          newElement.width = element.width;
          newElement.height = element.height;
        }
      }
      if (isSubProcess(oldBusinessObject) && !isSubProcess(newBusinessObject)) {
        hints.moveChildren = false;
      }
      if (is(oldBusinessObject, 'bpmn:Participant')) {
        if (targetElement.isExpanded === true) {
          newBusinessObject.processRef = bpmnFactory.create('bpmn:Process');
        } else {
          hints.moveChildren = false;
        }
        var isHorizontalPool = isHorizontal$3(element);
        if (!getDi(element).isHorizontal) {
          getDi(newElement).isHorizontal = isHorizontalPool;
        }
        newElement.width = isHorizontalPool ? element.width : elementFactory.getDefaultSize(newElement).width;
        newElement.height = isHorizontalPool ? elementFactory.getDefaultSize(newElement).height : element.height;
      }
      if (!rules.allowed('shape.resize', {
        shape: newBusinessObject
      })) {
        newElement.height = elementFactory.getDefaultSize(newElement).height;
        newElement.width = elementFactory.getDefaultSize(newElement).width;
      }
      newBusinessObject.name = oldBusinessObject.name;
      if (isAny(oldBusinessObject, ['bpmn:ExclusiveGateway', 'bpmn:InclusiveGateway', 'bpmn:Activity']) && isAny(newBusinessObject, ['bpmn:ExclusiveGateway', 'bpmn:InclusiveGateway', 'bpmn:Activity'])) {
        newBusinessObject.default = oldBusinessObject.default;
      }
      if (targetElement.host && !is(oldBusinessObject, 'bpmn:BoundaryEvent') && is(newBusinessObject, 'bpmn:BoundaryEvent')) {
        newElement.host = targetElement.host;
      }
      if (newElement.type === 'bpmn:DataStoreReference' || newElement.type === 'bpmn:DataObjectReference') {
        newElement.x = element.x + (element.width - newElement.width) / 2;
      }
      return replace.replaceElement(element, newElement, _objectSpread(_objectSpread({}, hints), {}, {
        targetElement
      }));
    }
    this.replaceElement = replaceElement;
  }
  BpmnReplace.$inject = ['bpmnFactory', 'elementFactory', 'moddleCopy', 'modeling', 'replace', 'rules'];
  function isSubProcess(businessObject) {
    return is(businessObject, 'bpmn:SubProcess');
  }
  function hasEventDefinition(element, type) {
    var businessObject = getBusinessObject(element);
    return type && businessObject.get('eventDefinitions').some(function (definition) {
      return is(definition, type);
    });
  }
  function intersection(a, b) {
    return a.filter(function (item) {
      return b.includes(item);
    });
  }
  var ReplaceModule = {
    __depends__: [CopyPasteModule, ReplaceModule$1, SelectionModule],
    bpmnReplace: ['type', BpmnReplace]
  };
  var LOW_PRIORITY$a = 250;
  function ToolManager(eventBus) {
    this._eventBus = eventBus;
    this._tools = [];
    this._active = null;
  }
  ToolManager.$inject = ['eventBus'];
  ToolManager.prototype.registerTool = function (name, events) {
    var tools = this._tools;
    if (!events) {
      throw new Error('A tool has to be registered with it\'s "events"');
    }
    tools.push(name);
    this.bindEvents(name, events);
  };
  ToolManager.prototype.isActive = function (tool) {
    return tool && this._active === tool;
  };
  ToolManager.prototype.length = function (tool) {
    return this._tools.length;
  };
  ToolManager.prototype.setActive = function (tool) {
    var eventBus = this._eventBus;
    if (this._active !== tool) {
      this._active = tool;
      eventBus.fire('tool-manager.update', {
        tool: tool
      });
    }
  };
  ToolManager.prototype.bindEvents = function (name, events) {
    var eventBus = this._eventBus;
    var eventsToRegister = [];
    eventBus.on(events.tool + '.init', function (event) {
      var context = event.context;
      if (!context.reactivate && this.isActive(name)) {
        this.setActive(null);
        return;
      }
      this.setActive(name);
    }, this);
    forEach$1(events, function (event) {
      eventsToRegister.push(event + '.ended');
      eventsToRegister.push(event + '.canceled');
    });
    eventBus.on(eventsToRegister, LOW_PRIORITY$a, function (event) {
      if (!this._active) {
        return;
      }
      if (isPaletteClick(event)) {
        return;
      }
      this.setActive(null);
    }, this);
  };
  function isPaletteClick(event) {
    var target = event.originalEvent && event.originalEvent.target;
    return target && closest(target, '.group[data-group="tools"]');
  }
  var ToolManagerModule = {
    __depends__: [DraggingModule],
    __init__: ['toolManager'],
    toolManager: ['type', ToolManager]
  };
  function getDirection(axis, delta) {
    if (axis === 'x') {
      if (delta > 0) {
        return 'e';
      }
      if (delta < 0) {
        return 'w';
      }
    }
    if (axis === 'y') {
      if (delta > 0) {
        return 's';
      }
      if (delta < 0) {
        return 'n';
      }
    }
    return null;
  }
  function getWaypointsUpdatingConnections(movingShapes, resizingShapes) {
    var waypointsUpdatingConnections = [];
    forEach$1(movingShapes.concat(resizingShapes), function (shape) {
      var incoming = shape.incoming,
        outgoing = shape.outgoing;
      forEach$1(incoming.concat(outgoing), function (connection) {
        var source = connection.source,
          target = connection.target;
        if (includes$4(movingShapes, source) || includes$4(movingShapes, target) || includes$4(resizingShapes, source) || includes$4(resizingShapes, target)) {
          if (!includes$4(waypointsUpdatingConnections, connection)) {
            waypointsUpdatingConnections.push(connection);
          }
        }
      });
    });
    return waypointsUpdatingConnections;
  }
  function includes$4(array, item) {
    return array.indexOf(item) !== -1;
  }
  function resizeBounds(bounds, direction, delta) {
    var x = bounds.x,
      y = bounds.y,
      width = bounds.width,
      height = bounds.height,
      dx = delta.x,
      dy = delta.y;
    switch (direction) {
      case 'n':
        return {
          x: x,
          y: y + dy,
          width: width,
          height: height - dy
        };
      case 's':
        return {
          x: x,
          y: y,
          width: width,
          height: height + dy
        };
      case 'w':
        return {
          x: x + dx,
          y: y,
          width: width - dx,
          height: height
        };
      case 'e':
        return {
          x: x,
          y: y,
          width: width + dx,
          height: height
        };
      default:
        throw new Error('unknown direction: ' + direction);
    }
  }
  var abs$1 = Math.abs,
    round$5 = Math.round;
  var AXIS_TO_DIMENSION = {
    x: 'width',
    y: 'height'
  };
  var CURSOR_CROSSHAIR = 'crosshair';
  var DIRECTION_TO_TRBL = {
    n: 'top',
    w: 'left',
    s: 'bottom',
    e: 'right'
  };
  var HIGH_PRIORITY$9 = 1500;
  var DIRECTION_TO_OPPOSITE = {
    n: 's',
    w: 'e',
    s: 'n',
    e: 'w'
  };
  var PADDING = 20;
  function SpaceTool(canvas, dragging, eventBus, modeling, rules, toolManager, mouse) {
    this._canvas = canvas;
    this._dragging = dragging;
    this._eventBus = eventBus;
    this._modeling = modeling;
    this._rules = rules;
    this._toolManager = toolManager;
    this._mouse = mouse;
    var self = this;
    toolManager.registerTool('space', {
      tool: 'spaceTool.selection',
      dragging: 'spaceTool'
    });
    eventBus.on('spaceTool.selection.end', function (event) {
      eventBus.once('spaceTool.selection.ended', function () {
        self.activateMakeSpace(event.originalEvent);
      });
    });
    eventBus.on('spaceTool.move', HIGH_PRIORITY$9, function (event) {
      var context = event.context,
        initialized = context.initialized;
      if (!initialized) {
        initialized = context.initialized = self.init(event, context);
      }
      if (initialized) {
        ensureConstraints(event);
      }
    });
    eventBus.on('spaceTool.end', function (event) {
      var context = event.context,
        axis = context.axis,
        direction = context.direction,
        movingShapes = context.movingShapes,
        resizingShapes = context.resizingShapes,
        start = context.start;
      if (!context.initialized) {
        return;
      }
      ensureConstraints(event);
      var delta = {
        x: 0,
        y: 0
      };
      delta[axis] = round$5(event['d' + axis]);
      self.makeSpace(movingShapes, resizingShapes, delta, direction, start);
      eventBus.once('spaceTool.ended', function (event) {
        self.activateSelection(event.originalEvent, true, true);
      });
    });
  }
  SpaceTool.$inject = ['canvas', 'dragging', 'eventBus', 'modeling', 'rules', 'toolManager', 'mouse'];
  SpaceTool.prototype.activateSelection = function (event, autoActivate, reactivate) {
    this._dragging.init(event, 'spaceTool.selection', {
      autoActivate: autoActivate,
      cursor: CURSOR_CROSSHAIR,
      data: {
        context: {
          reactivate: reactivate
        }
      },
      trapClick: false
    });
  };
  SpaceTool.prototype.activateMakeSpace = function (event) {
    this._dragging.init(event, 'spaceTool', {
      autoActivate: true,
      cursor: CURSOR_CROSSHAIR,
      data: {
        context: {}
      }
    });
  };
  SpaceTool.prototype.makeSpace = function (movingShapes, resizingShapes, delta, direction, start) {
    return this._modeling.createSpace(movingShapes, resizingShapes, delta, direction, start);
  };
  SpaceTool.prototype.init = function (event, context) {
    var axis = abs$1(event.dx) > abs$1(event.dy) ? 'x' : 'y',
      delta = event['d' + axis],
      start = event[axis] - delta;
    if (abs$1(delta) < 5) {
      return false;
    }
    if (delta < 0) {
      delta *= -1;
    }
    if (hasPrimaryModifier(event)) {
      delta *= -1;
    }
    var direction = getDirection(axis, delta);
    var root = this._canvas.getRootElement();
    if (!hasSecondaryModifier(event) && event.hover) {
      root = event.hover;
    }
    var children = [].concat(_toConsumableArray(selfAndAllChildren(root, true)), _toConsumableArray(root.attachers || []));
    var elements = this.calculateAdjustments(children, axis, delta, start);
    var minDimensions = this._eventBus.fire('spaceTool.getMinDimensions', {
      axis: axis,
      direction: direction,
      shapes: elements.resizingShapes,
      start: start
    });
    var spaceToolConstraints = getSpaceToolConstraints(elements, axis, direction, start, minDimensions);
    assign$1(context, elements, {
      axis: axis,
      direction: direction,
      spaceToolConstraints: spaceToolConstraints,
      start: start
    });
    set('resize-' + (axis === 'x' ? 'ew' : 'ns'));
    return true;
  };
  SpaceTool.prototype.calculateAdjustments = function (elements, axis, delta, start) {
    var rules = this._rules;
    var movingShapes = [],
      resizingShapes = [];
    var attachers = [],
      connections = [];
    function moveShape(shape) {
      if (!movingShapes.includes(shape)) {
        movingShapes.push(shape);
      }
      var label = shape.label;
      if (label && !movingShapes.includes(label)) {
        movingShapes.push(label);
      }
    }
    function resizeShape(shape) {
      if (!resizingShapes.includes(shape)) {
        resizingShapes.push(shape);
      }
    }
    forEach$1(elements, function (element) {
      if (!element.parent || isLabel(element)) {
        return;
      }
      if (isConnection(element)) {
        connections.push(element);
        return;
      }
      var shapeStart = element[axis],
        shapeEnd = shapeStart + element[AXIS_TO_DIMENSION[axis]];
      if (isAttacher$1(element) && (delta > 0 && getMid(element)[axis] > start || delta < 0 && getMid(element)[axis] < start)) {
        attachers.push(element);
        return;
      }
      if (delta > 0 && shapeStart > start || delta < 0 && shapeEnd < start) {
        moveShape(element);
        return;
      }
      if (shapeStart < start && shapeEnd > start && rules.allowed('shape.resize', {
        shape: element
      })) {
        resizeShape(element);
        return;
      }
    });
    forEach$1(movingShapes, function (shape) {
      var attachers = shape.attachers;
      if (attachers) {
        forEach$1(attachers, function (attacher) {
          moveShape(attacher);
        });
      }
    });
    var allShapes = movingShapes.concat(resizingShapes);
    forEach$1(attachers, function (attacher) {
      var host = attacher.host;
      if (includes$3(allShapes, host)) {
        moveShape(attacher);
      }
    });
    allShapes = movingShapes.concat(resizingShapes);
    forEach$1(connections, function (connection) {
      var source = connection.source,
        target = connection.target,
        label = connection.label;
      if (includes$3(allShapes, source) && includes$3(allShapes, target) && label) {
        moveShape(label);
      }
    });
    return {
      movingShapes: movingShapes,
      resizingShapes: resizingShapes
    };
  };
  SpaceTool.prototype.toggle = function () {
    if (this.isActive()) {
      return this._dragging.cancel();
    }
    var mouseEvent = this._mouse.getLastMoveEvent();
    this.activateSelection(mouseEvent, !!mouseEvent);
  };
  SpaceTool.prototype.isActive = function () {
    var context = this._dragging.context();
    if (context) {
      return /^spaceTool/.test(context.prefix);
    }
    return false;
  };
  function addPadding(trbl) {
    return {
      top: trbl.top - PADDING,
      right: trbl.right + PADDING,
      bottom: trbl.bottom + PADDING,
      left: trbl.left - PADDING
    };
  }
  function ensureConstraints(event) {
    var context = event.context,
      spaceToolConstraints = context.spaceToolConstraints;
    if (!spaceToolConstraints) {
      return;
    }
    var x, y;
    if (isNumber(spaceToolConstraints.left)) {
      x = Math.max(event.x, spaceToolConstraints.left);
      event.dx = event.dx + x - event.x;
      event.x = x;
    }
    if (isNumber(spaceToolConstraints.right)) {
      x = Math.min(event.x, spaceToolConstraints.right);
      event.dx = event.dx + x - event.x;
      event.x = x;
    }
    if (isNumber(spaceToolConstraints.top)) {
      y = Math.max(event.y, spaceToolConstraints.top);
      event.dy = event.dy + y - event.y;
      event.y = y;
    }
    if (isNumber(spaceToolConstraints.bottom)) {
      y = Math.min(event.y, spaceToolConstraints.bottom);
      event.dy = event.dy + y - event.y;
      event.y = y;
    }
  }
  function getSpaceToolConstraints(elements, axis, direction, start, minDimensions) {
    var movingShapes = elements.movingShapes,
      resizingShapes = elements.resizingShapes;
    if (!resizingShapes.length) {
      return;
    }
    var spaceToolConstraints = {},
      min,
      max;
    forEach$1(resizingShapes, function (resizingShape) {
      var attachers = resizingShape.attachers,
        children = resizingShape.children;
      var resizingShapeBBox = asTRBL(resizingShape);
      var nonMovingResizingChildren = filter(children, function (child) {
        return !isConnection(child) && !isLabel(child) && !includes$3(movingShapes, child) && !includes$3(resizingShapes, child);
      });
      var movingChildren = filter(children, function (child) {
        return !isConnection(child) && !isLabel(child) && includes$3(movingShapes, child);
      });
      var minOrMax,
        nonMovingResizingChildrenBBox,
        movingChildrenBBox,
        movingAttachers = [],
        nonMovingAttachers = [],
        movingAttachersBBox,
        movingAttachersConstraint,
        nonMovingAttachersBBox,
        nonMovingAttachersConstraint;
      if (nonMovingResizingChildren.length) {
        nonMovingResizingChildrenBBox = addPadding(asTRBL(getBBox(nonMovingResizingChildren)));
        minOrMax = start - resizingShapeBBox[DIRECTION_TO_TRBL[direction]] + nonMovingResizingChildrenBBox[DIRECTION_TO_TRBL[direction]];
        if (direction === 'n') {
          spaceToolConstraints.bottom = max = isNumber(max) ? Math.min(max, minOrMax) : minOrMax;
        } else if (direction === 'w') {
          spaceToolConstraints.right = max = isNumber(max) ? Math.min(max, minOrMax) : minOrMax;
        } else if (direction === 's') {
          spaceToolConstraints.top = min = isNumber(min) ? Math.max(min, minOrMax) : minOrMax;
        } else if (direction === 'e') {
          spaceToolConstraints.left = min = isNumber(min) ? Math.max(min, minOrMax) : minOrMax;
        }
      }
      if (movingChildren.length) {
        movingChildrenBBox = addPadding(asTRBL(getBBox(movingChildren)));
        minOrMax = start - movingChildrenBBox[DIRECTION_TO_TRBL[DIRECTION_TO_OPPOSITE[direction]]] + resizingShapeBBox[DIRECTION_TO_TRBL[DIRECTION_TO_OPPOSITE[direction]]];
        if (direction === 'n') {
          spaceToolConstraints.bottom = max = isNumber(max) ? Math.min(max, minOrMax) : minOrMax;
        } else if (direction === 'w') {
          spaceToolConstraints.right = max = isNumber(max) ? Math.min(max, minOrMax) : minOrMax;
        } else if (direction === 's') {
          spaceToolConstraints.top = min = isNumber(min) ? Math.max(min, minOrMax) : minOrMax;
        } else if (direction === 'e') {
          spaceToolConstraints.left = min = isNumber(min) ? Math.max(min, minOrMax) : minOrMax;
        }
      }
      if (attachers && attachers.length) {
        attachers.forEach(function (attacher) {
          if (includes$3(movingShapes, attacher)) {
            movingAttachers.push(attacher);
          } else {
            nonMovingAttachers.push(attacher);
          }
        });
        if (movingAttachers.length) {
          movingAttachersBBox = asTRBL(getBBox(movingAttachers.map(getMid)));
          movingAttachersConstraint = resizingShapeBBox[DIRECTION_TO_TRBL[DIRECTION_TO_OPPOSITE[direction]]] - (movingAttachersBBox[DIRECTION_TO_TRBL[DIRECTION_TO_OPPOSITE[direction]]] - start);
        }
        if (nonMovingAttachers.length) {
          nonMovingAttachersBBox = asTRBL(getBBox(nonMovingAttachers.map(getMid)));
          nonMovingAttachersConstraint = nonMovingAttachersBBox[DIRECTION_TO_TRBL[direction]] - (resizingShapeBBox[DIRECTION_TO_TRBL[direction]] - start);
        }
        if (direction === 'n') {
          minOrMax = Math.min(movingAttachersConstraint || Infinity, nonMovingAttachersConstraint || Infinity);
          spaceToolConstraints.bottom = max = isNumber(max) ? Math.min(max, minOrMax) : minOrMax;
        } else if (direction === 'w') {
          minOrMax = Math.min(movingAttachersConstraint || Infinity, nonMovingAttachersConstraint || Infinity);
          spaceToolConstraints.right = max = isNumber(max) ? Math.min(max, minOrMax) : minOrMax;
        } else if (direction === 's') {
          minOrMax = Math.max(movingAttachersConstraint || -Infinity, nonMovingAttachersConstraint || -Infinity);
          spaceToolConstraints.top = min = isNumber(min) ? Math.max(min, minOrMax) : minOrMax;
        } else if (direction === 'e') {
          minOrMax = Math.max(movingAttachersConstraint || -Infinity, nonMovingAttachersConstraint || -Infinity);
          spaceToolConstraints.left = min = isNumber(min) ? Math.max(min, minOrMax) : minOrMax;
        }
      }
      var resizingShapeMinDimensions = minDimensions && minDimensions[resizingShape.id];
      if (resizingShapeMinDimensions) {
        if (direction === 'n') {
          minOrMax = start + resizingShape[AXIS_TO_DIMENSION[axis]] - resizingShapeMinDimensions[AXIS_TO_DIMENSION[axis]];
          spaceToolConstraints.bottom = max = isNumber(max) ? Math.min(max, minOrMax) : minOrMax;
        } else if (direction === 'w') {
          minOrMax = start + resizingShape[AXIS_TO_DIMENSION[axis]] - resizingShapeMinDimensions[AXIS_TO_DIMENSION[axis]];
          spaceToolConstraints.right = max = isNumber(max) ? Math.min(max, minOrMax) : minOrMax;
        } else if (direction === 's') {
          minOrMax = start - resizingShape[AXIS_TO_DIMENSION[axis]] + resizingShapeMinDimensions[AXIS_TO_DIMENSION[axis]];
          spaceToolConstraints.top = min = isNumber(min) ? Math.max(min, minOrMax) : minOrMax;
        } else if (direction === 'e') {
          minOrMax = start - resizingShape[AXIS_TO_DIMENSION[axis]] + resizingShapeMinDimensions[AXIS_TO_DIMENSION[axis]];
          spaceToolConstraints.left = min = isNumber(min) ? Math.max(min, minOrMax) : minOrMax;
        }
      }
    });
    return spaceToolConstraints;
  }
  function includes$3(array, item) {
    return array.indexOf(item) !== -1;
  }
  function isAttacher$1(element) {
    return !!element.host;
  }
  var MARKER_DRAGGING$1 = 'djs-dragging',
    MARKER_RESIZING$1 = 'djs-resizing';
  var LOW_PRIORITY$9 = 250;
  var max$1 = Math.max;
  function SpaceToolPreview(eventBus, elementRegistry, canvas, styles, previewSupport) {
    function addPreviewGfx(collection, dragGroup) {
      forEach$1(collection, function (element) {
        previewSupport.addDragger(element, dragGroup);
        canvas.addMarker(element, MARKER_DRAGGING$1);
      });
    }
    eventBus.on('spaceTool.selection.start', function (event) {
      var space = canvas.getLayer('space'),
        context = event.context;
      var orientation = {
        x: 'M 0,-10000 L 0,10000',
        y: 'M -10000,0 L 10000,0'
      };
      var crosshairGroup = create$1('g');
      attr(crosshairGroup, styles.cls('djs-crosshair-group', ['no-events']));
      append(space, crosshairGroup);
      var pathX = create$1('path');
      attr(pathX, 'd', orientation.x);
      classes(pathX).add('djs-crosshair');
      append(crosshairGroup, pathX);
      var pathY = create$1('path');
      attr(pathY, 'd', orientation.y);
      classes(pathY).add('djs-crosshair');
      append(crosshairGroup, pathY);
      context.crosshairGroup = crosshairGroup;
    });
    eventBus.on('spaceTool.selection.move', function (event) {
      var crosshairGroup = event.context.crosshairGroup;
      translate$1(crosshairGroup, event.x, event.y);
    });
    eventBus.on('spaceTool.selection.cleanup', function (event) {
      var context = event.context,
        crosshairGroup = context.crosshairGroup;
      if (crosshairGroup) {
        remove$1(crosshairGroup);
      }
    });
    eventBus.on('spaceTool.move', LOW_PRIORITY$9, function (event) {
      var context = event.context,
        line = context.line,
        axis = context.axis,
        movingShapes = context.movingShapes,
        resizingShapes = context.resizingShapes;
      if (!context.initialized) {
        return;
      }
      if (!context.dragGroup) {
        var spaceLayer = canvas.getLayer('space');
        line = create$1('path');
        attr(line, 'd', 'M0,0 L0,0');
        classes(line).add('djs-crosshair');
        append(spaceLayer, line);
        context.line = line;
        var dragGroup = create$1('g');
        attr(dragGroup, styles.cls('djs-drag-group', ['no-events']));
        append(canvas.getActiveLayer(), dragGroup);
        addPreviewGfx(movingShapes, dragGroup);
        var movingConnections = context.movingConnections = elementRegistry.filter(function (element) {
          var sourceIsMoving = false;
          forEach$1(movingShapes, function (shape) {
            forEach$1(shape.outgoing, function (connection) {
              if (element === connection) {
                sourceIsMoving = true;
              }
            });
          });
          var targetIsMoving = false;
          forEach$1(movingShapes, function (shape) {
            forEach$1(shape.incoming, function (connection) {
              if (element === connection) {
                targetIsMoving = true;
              }
            });
          });
          var sourceIsResizing = false;
          forEach$1(resizingShapes, function (shape) {
            forEach$1(shape.outgoing, function (connection) {
              if (element === connection) {
                sourceIsResizing = true;
              }
            });
          });
          var targetIsResizing = false;
          forEach$1(resizingShapes, function (shape) {
            forEach$1(shape.incoming, function (connection) {
              if (element === connection) {
                targetIsResizing = true;
              }
            });
          });
          return isConnection(element) && (sourceIsMoving || sourceIsResizing) && (targetIsMoving || targetIsResizing);
        });
        addPreviewGfx(movingConnections, dragGroup);
        context.dragGroup = dragGroup;
      }
      if (!context.frameGroup) {
        var frameGroup = create$1('g');
        attr(frameGroup, styles.cls('djs-frame-group', ['no-events']));
        append(canvas.getActiveLayer(), frameGroup);
        var frames = [];
        forEach$1(resizingShapes, function (shape) {
          var frame = previewSupport.addFrame(shape, frameGroup);
          var initialBounds = frame.getBBox();
          frames.push({
            element: frame,
            initialBounds: initialBounds
          });
          canvas.addMarker(shape, MARKER_RESIZING$1);
        });
        context.frameGroup = frameGroup;
        context.frames = frames;
      }
      var orientation = {
        x: 'M' + event.x + ', -10000 L' + event.x + ', 10000',
        y: 'M -10000, ' + event.y + ' L 10000, ' + event.y
      };
      attr(line, {
        d: orientation[axis]
      });
      var opposite = {
        x: 'y',
        y: 'x'
      };
      var delta = {
        x: event.dx,
        y: event.dy
      };
      delta[opposite[context.axis]] = 0;
      translate$1(context.dragGroup, delta.x, delta.y);
      forEach$1(context.frames, function (frame) {
        var element = frame.element,
          initialBounds = frame.initialBounds,
          width,
          height;
        if (context.direction === 'e') {
          attr(element, {
            width: max$1(initialBounds.width + delta.x, 5)
          });
        } else {
          width = max$1(initialBounds.width - delta.x, 5);
          attr(element, {
            width: width,
            x: initialBounds.x + initialBounds.width - width
          });
        }
        if (context.direction === 's') {
          attr(element, {
            height: max$1(initialBounds.height + delta.y, 5)
          });
        } else {
          height = max$1(initialBounds.height - delta.y, 5);
          attr(element, {
            height: height,
            y: initialBounds.y + initialBounds.height - height
          });
        }
      });
    });
    eventBus.on('spaceTool.cleanup', function (event) {
      var context = event.context,
        movingShapes = context.movingShapes,
        movingConnections = context.movingConnections,
        resizingShapes = context.resizingShapes,
        line = context.line,
        dragGroup = context.dragGroup,
        frameGroup = context.frameGroup;
      forEach$1(movingShapes, function (shape) {
        canvas.removeMarker(shape, MARKER_DRAGGING$1);
      });
      forEach$1(movingConnections, function (connection) {
        canvas.removeMarker(connection, MARKER_DRAGGING$1);
      });
      if (dragGroup) {
        remove$1(line);
        remove$1(dragGroup);
      }
      forEach$1(resizingShapes, function (shape) {
        canvas.removeMarker(shape, MARKER_RESIZING$1);
      });
      if (frameGroup) {
        remove$1(frameGroup);
      }
    });
  }
  SpaceToolPreview.$inject = ['eventBus', 'elementRegistry', 'canvas', 'styles', 'previewSupport'];
  var SpaceToolModule$1 = {
    __init__: ['spaceToolPreview'],
    __depends__: [DraggingModule, RulesModule$1, ToolManagerModule, PreviewSupportModule, MouseModule],
    spaceTool: ['type', SpaceTool],
    spaceToolPreview: ['type', SpaceToolPreview]
  };
  function BpmnSpaceTool(injector, canvas) {
    injector.invoke(SpaceTool, this);
    this._canvas = canvas;
  }
  BpmnSpaceTool.$inject = ['injector', 'canvas'];
  e$2(BpmnSpaceTool, SpaceTool);
  BpmnSpaceTool.prototype.calculateAdjustments = function (elements, axis, delta, start) {
    var canvasRoot = this._canvas.getRootElement(),
      spaceRoot = elements[0] === canvasRoot ? null : elements[0],
      enclosedArtifacts = [];
    if (spaceRoot) {
      enclosedArtifacts = values(getEnclosedElements(canvasRoot.children.filter(function (child) {
        return is(child, 'bpmn:Artifact');
      }), getBBox(spaceRoot)));
    }
    var elementsToMove = [].concat(_toConsumableArray(elements), _toConsumableArray(enclosedArtifacts));
    var adjustments = SpaceTool.prototype.calculateAdjustments.call(this, elementsToMove, axis, delta, start);
    adjustments.resizingShapes = adjustments.resizingShapes.filter(function (shape) {
      if (is(shape, 'bpmn:TextAnnotation')) {
        return false;
      }
      if (isCollapsedPool$1(shape)) {
        if (axis === 'y' && isHorizontal$3(shape) || axis === 'x' && !isHorizontal$3(shape)) {
          return false;
        }
      }
      return true;
    });
    return adjustments;
  };
  function isCollapsedPool$1(shape) {
    return is(shape, 'bpmn:Participant') && !getBusinessObject(shape).processRef;
  }
  var SpaceToolModule = {
    __depends__: [SpaceToolModule$1],
    spaceTool: ['type', BpmnSpaceTool]
  };
  function CommandStack(eventBus, injector) {
    this._handlerMap = {};
    this._stack = [];
    this._stackIdx = -1;
    this._currentExecution = {
      actions: [],
      dirty: [],
      trigger: null
    };
    this._injector = injector;
    this._eventBus = eventBus;
    this._uid = 1;
    eventBus.on(['diagram.destroy', 'diagram.clear'], function () {
      this.clear(false);
    }, this);
  }
  CommandStack.$inject = ['eventBus', 'injector'];
  CommandStack.prototype.execute = function (command, context) {
    if (!command) {
      throw new Error('command required');
    }
    this._currentExecution.trigger = 'execute';
    var action = {
      command: command,
      context: context
    };
    this._pushAction(action);
    this._internalExecute(action);
    this._popAction();
  };
  CommandStack.prototype.canExecute = function (command, context) {
    var action = {
      command: command,
      context: context
    };
    var handler = this._getHandler(command);
    var result = this._fire(command, 'canExecute', action);
    if (result === undefined) {
      if (!handler) {
        return false;
      }
      if (handler.canExecute) {
        result = handler.canExecute(context);
      }
    }
    return result;
  };
  CommandStack.prototype.clear = function (emit) {
    this._stack.length = 0;
    this._stackIdx = -1;
    if (emit !== false) {
      this._fire('changed', {
        trigger: 'clear'
      });
    }
  };
  CommandStack.prototype.undo = function () {
    var action = this._getUndoAction(),
      next;
    if (action) {
      this._currentExecution.trigger = 'undo';
      this._pushAction(action);
      while (action) {
        this._internalUndo(action);
        next = this._getUndoAction();
        if (!next || next.id !== action.id) {
          break;
        }
        action = next;
      }
      this._popAction();
    }
  };
  CommandStack.prototype.redo = function () {
    var action = this._getRedoAction(),
      next;
    if (action) {
      this._currentExecution.trigger = 'redo';
      this._pushAction(action);
      while (action) {
        this._internalExecute(action, true);
        next = this._getRedoAction();
        if (!next || next.id !== action.id) {
          break;
        }
        action = next;
      }
      this._popAction();
    }
  };
  CommandStack.prototype.register = function (command, handler) {
    this._setHandler(command, handler);
  };
  CommandStack.prototype.registerHandler = function (command, handlerCls) {
    if (!command || !handlerCls) {
      throw new Error('command and handlerCls must be defined');
    }
    var handler = this._injector.instantiate(handlerCls);
    this.register(command, handler);
  };
  CommandStack.prototype.canUndo = function () {
    return !!this._getUndoAction();
  };
  CommandStack.prototype.canRedo = function () {
    return !!this._getRedoAction();
  };
  CommandStack.prototype._getRedoAction = function () {
    return this._stack[this._stackIdx + 1];
  };
  CommandStack.prototype._getUndoAction = function () {
    return this._stack[this._stackIdx];
  };
  CommandStack.prototype._internalUndo = function (action) {
    var _this15 = this;
    var command = action.command,
      context = action.context;
    var handler = this._getHandler(command);
    this._atomicDo(function () {
      _this15._fire(command, 'revert', action);
      if (handler.revert) {
        _this15._markDirty(handler.revert(context));
      }
      _this15._revertedAction(action);
      _this15._fire(command, 'reverted', action);
    });
  };
  CommandStack.prototype._fire = function (command, qualifier, event) {
    if (arguments.length < 3) {
      event = qualifier;
      qualifier = null;
    }
    var names = qualifier ? [command + '.' + qualifier, qualifier] : [command];
    var result;
    event = this._eventBus.createEvent(event);
    for (var _i5 = 0, _names = names; _i5 < _names.length; _i5++) {
      var _name2 = _names[_i5];
      result = this._eventBus.fire('commandStack.' + _name2, event);
      if (event.cancelBubble) {
        break;
      }
    }
    return result;
  };
  CommandStack.prototype._createId = function () {
    return this._uid++;
  };
  CommandStack.prototype._atomicDo = function (fn) {
    var execution = this._currentExecution;
    execution.atomic = true;
    try {
      fn();
    } finally {
      execution.atomic = false;
    }
  };
  CommandStack.prototype._internalExecute = function (action, redo) {
    var _this16 = this;
    var command = action.command,
      context = action.context;
    var handler = this._getHandler(command);
    if (!handler) {
      throw new Error('no command handler registered for <' + command + '>');
    }
    this._pushAction(action);
    if (!redo) {
      this._fire(command, 'preExecute', action);
      if (handler.preExecute) {
        handler.preExecute(context);
      }
      this._fire(command, 'preExecuted', action);
    }
    this._atomicDo(function () {
      _this16._fire(command, 'execute', action);
      if (handler.execute) {
        _this16._markDirty(handler.execute(context));
      }
      _this16._executedAction(action, redo);
      _this16._fire(command, 'executed', action);
    });
    if (!redo) {
      this._fire(command, 'postExecute', action);
      if (handler.postExecute) {
        handler.postExecute(context);
      }
      this._fire(command, 'postExecuted', action);
    }
    this._popAction();
  };
  CommandStack.prototype._pushAction = function (action) {
    var execution = this._currentExecution,
      actions = execution.actions;
    var baseAction = actions[0];
    if (execution.atomic) {
      throw new Error('illegal invocation in <execute> or <revert> phase (action: ' + action.command + ')');
    }
    if (!action.id) {
      action.id = baseAction && baseAction.id || this._createId();
    }
    actions.push(action);
  };
  CommandStack.prototype._popAction = function () {
    var execution = this._currentExecution,
      trigger = execution.trigger,
      actions = execution.actions,
      dirty = execution.dirty;
    actions.pop();
    if (!actions.length) {
      this._eventBus.fire('elements.changed', {
        elements: uniqueBy('id', dirty.reverse())
      });
      dirty.length = 0;
      this._fire('changed', {
        trigger: trigger
      });
      execution.trigger = null;
    }
  };
  CommandStack.prototype._markDirty = function (elements) {
    var execution = this._currentExecution;
    if (!elements) {
      return;
    }
    elements = isArray$3(elements) ? elements : [elements];
    execution.dirty = execution.dirty.concat(elements);
  };
  CommandStack.prototype._executedAction = function (action, redo) {
    var stackIdx = ++this._stackIdx;
    if (!redo) {
      this._stack.splice(stackIdx, this._stack.length, action);
    }
  };
  CommandStack.prototype._revertedAction = function (action) {
    this._stackIdx--;
  };
  CommandStack.prototype._getHandler = function (command) {
    return this._handlerMap[command];
  };
  CommandStack.prototype._setHandler = function (command, handler) {
    if (!command || !handler) {
      throw new Error('command and handler required');
    }
    if (this._handlerMap[command]) {
      throw new Error('overriding handler for command <' + command + '>');
    }
    this._handlerMap[command] = handler;
  };
  var CommandModule = {
    commandStack: ['type', CommandStack]
  };
  function saveClear(collection, removeFn) {
    if (typeof removeFn !== 'function') {
      throw new Error('removeFn iterator must be a function');
    }
    if (!collection) {
      return;
    }
    var e;
    while (e = collection[0]) {
      removeFn(e);
    }
    return collection;
  }
  var LOW_PRIORITY$8 = 250,
    HIGH_PRIORITY$8 = 1400;
  function LabelSupport(injector, eventBus, modeling) {
    CommandInterceptor.call(this, eventBus);
    var movePreview = injector.get('movePreview', false);
    eventBus.on('shape.move.start', HIGH_PRIORITY$8, function (e) {
      var context = e.context,
        shapes = context.shapes,
        validatedShapes = context.validatedShapes;
      context.shapes = removeLabels(shapes);
      context.validatedShapes = removeLabels(validatedShapes);
    });
    movePreview && eventBus.on('shape.move.start', LOW_PRIORITY$8, function (e) {
      var context = e.context,
        shapes = context.shapes;
      var labels = [];
      forEach$1(shapes, function (element) {
        forEach$1(element.labels, function (label) {
          if (!label.hidden && context.shapes.indexOf(label) === -1) {
            labels.push(label);
          }
          if (element.labelTarget) {
            labels.push(element);
          }
        });
      });
      forEach$1(labels, function (label) {
        movePreview.makeDraggable(context, label, true);
      });
    });
    this.preExecuted('elements.move', HIGH_PRIORITY$8, function (e) {
      var context = e.context,
        closure = context.closure,
        enclosedElements = closure.enclosedElements;
      var enclosedLabels = [];
      forEach$1(enclosedElements, function (element) {
        forEach$1(element.labels, function (label) {
          if (!enclosedElements[label.id]) {
            enclosedLabels.push(label);
          }
        });
      });
      closure.addAll(enclosedLabels);
    });
    this.preExecute(['connection.delete', 'shape.delete'], function (e) {
      var context = e.context,
        element = context.connection || context.shape;
      saveClear(element.labels, function (label) {
        modeling.removeShape(label, {
          nested: true
        });
      });
    });
    this.execute('shape.delete', function (e) {
      var context = e.context,
        shape = context.shape,
        labelTarget = shape.labelTarget;
      if (labelTarget) {
        context.labelTargetIndex = indexOf(labelTarget.labels, shape);
        context.labelTarget = labelTarget;
        shape.labelTarget = null;
      }
    });
    this.revert('shape.delete', function (e) {
      var context = e.context,
        shape = context.shape,
        labelTarget = context.labelTarget,
        labelTargetIndex = context.labelTargetIndex;
      if (labelTarget) {
        add(labelTarget.labels, shape, labelTargetIndex);
        shape.labelTarget = labelTarget;
      }
    });
  }
  e$2(LabelSupport, CommandInterceptor);
  LabelSupport.$inject = ['injector', 'eventBus', 'modeling'];
  function removeLabels(elements) {
    return filter(elements, function (element) {
      return elements.indexOf(element.labelTarget) === -1;
    });
  }
  var LabelSupportModule = {
    __init__: ['labelSupport'],
    labelSupport: ['type', LabelSupport]
  };
  var LOW_PRIORITY$7 = 251,
    HIGH_PRIORITY$7 = 1401;
  var MARKER_ATTACH$1 = 'attach-ok';
  function AttachSupport(injector, eventBus, canvas, rules, modeling) {
    CommandInterceptor.call(this, eventBus);
    var movePreview = injector.get('movePreview', false);
    eventBus.on('shape.move.start', HIGH_PRIORITY$7, function (e) {
      var context = e.context,
        shapes = context.shapes,
        validatedShapes = context.validatedShapes;
      context.shapes = addAttached(shapes);
      context.validatedShapes = removeAttached(validatedShapes);
    });
    movePreview && eventBus.on('shape.move.start', LOW_PRIORITY$7, function (e) {
      var context = e.context,
        shapes = context.shapes,
        attachers = getAttachers(shapes);
      forEach$1(attachers, function (attacher) {
        movePreview.makeDraggable(context, attacher, true);
        forEach$1(attacher.labels, function (label) {
          movePreview.makeDraggable(context, label, true);
        });
      });
    });
    movePreview && eventBus.on('shape.move.start', function (event) {
      var context = event.context,
        shapes = context.shapes;
      if (shapes.length !== 1) {
        return;
      }
      var shape = shapes[0];
      var host = shape.host;
      if (host) {
        canvas.addMarker(host, MARKER_ATTACH$1);
        eventBus.once(['shape.move.out', 'shape.move.cleanup'], function () {
          canvas.removeMarker(host, MARKER_ATTACH$1);
        });
      }
    });
    this.preExecuted('elements.move', HIGH_PRIORITY$7, function (e) {
      var context = e.context,
        closure = context.closure,
        shapes = context.shapes,
        attachers = getAttachers(shapes);
      forEach$1(attachers, function (attacher) {
        closure.add(attacher, closure.topLevel[attacher.host.id]);
      });
    });
    this.postExecuted('elements.move', function (e) {
      var context = e.context,
        shapes = context.shapes,
        newHost = context.newHost,
        attachers;
      if (newHost && shapes.length !== 1) {
        return;
      }
      if (newHost) {
        attachers = shapes;
      } else {
        attachers = filter(shapes, function (shape) {
          var host = shape.host;
          return isAttacher(shape) && !includes$2(shapes, host);
        });
      }
      forEach$1(attachers, function (attacher) {
        modeling.updateAttachment(attacher, newHost);
      });
    });
    this.postExecuted('elements.move', function (e) {
      var shapes = e.context.shapes;
      forEach$1(shapes, function (shape) {
        forEach$1(shape.attachers, function (attacher) {
          forEach$1(attacher.outgoing.slice(), function (connection) {
            var allowed = rules.allowed('connection.reconnect', {
              connection: connection,
              source: connection.source,
              target: connection.target
            });
            if (!allowed) {
              modeling.removeConnection(connection);
            }
          });
          forEach$1(attacher.incoming.slice(), function (connection) {
            var allowed = rules.allowed('connection.reconnect', {
              connection: connection,
              source: connection.source,
              target: connection.target
            });
            if (!allowed) {
              modeling.removeConnection(connection);
            }
          });
        });
      });
    });
    this.postExecute('shape.create', function (e) {
      var context = e.context,
        shape = context.shape,
        host = context.host;
      if (host) {
        modeling.updateAttachment(shape, host);
      }
    });
    this.postExecute('shape.replace', function (e) {
      var context = e.context,
        oldShape = context.oldShape,
        newShape = context.newShape;
      saveClear(oldShape.attachers, function (attacher) {
        var allowed = rules.allowed('elements.move', {
          target: newShape,
          shapes: [attacher]
        });
        if (allowed === 'attach') {
          modeling.updateAttachment(attacher, newShape);
        } else {
          modeling.removeShape(attacher);
        }
      });
      if (newShape.attachers.length) {
        forEach$1(newShape.attachers, function (attacher) {
          var delta = getNewAttachShapeDelta(attacher, oldShape, newShape);
          modeling.moveShape(attacher, delta, attacher.parent);
        });
      }
    });
    this.postExecute('shape.resize', function (event) {
      var context = event.context,
        shape = context.shape,
        oldBounds = context.oldBounds,
        newBounds = context.newBounds,
        attachers = shape.attachers,
        hints = context.hints || {};
      if (hints.attachSupport === false) {
        return;
      }
      forEach$1(attachers, function (attacher) {
        var delta = getNewAttachShapeDelta(attacher, oldBounds, newBounds);
        modeling.moveShape(attacher, delta, attacher.parent);
        forEach$1(attacher.labels, function (label) {
          modeling.moveShape(label, delta, label.parent);
        });
      });
    });
    this.preExecute('shape.delete', function (event) {
      var shape = event.context.shape;
      saveClear(shape.attachers, function (attacher) {
        modeling.removeShape(attacher);
      });
      if (shape.host) {
        modeling.updateAttachment(shape, null);
      }
    });
  }
  e$2(AttachSupport, CommandInterceptor);
  AttachSupport.$inject = ['injector', 'eventBus', 'canvas', 'rules', 'modeling'];
  function getAttachers(shapes) {
    return flatten(map$1(shapes, function (s) {
      return s.attachers || [];
    }));
  }
  function addAttached(elements) {
    var attachers = getAttachers(elements);
    return unionBy('id', elements, attachers);
  }
  function removeAttached(elements) {
    var ids = groupBy(elements, 'id');
    return filter(elements, function (element) {
      while (element) {
        if (element.host && ids[element.host.id]) {
          return false;
        }
        element = element.parent;
      }
      return true;
    });
  }
  function isAttacher(shape) {
    return !!shape.host;
  }
  function includes$2(array, item) {
    return array.indexOf(item) !== -1;
  }
  var AttachSupportModule = {
    __depends__: [RulesModule$1],
    __init__: ['attachSupport'],
    attachSupport: ['type', AttachSupport]
  };
  function BpmnFactory(moddle) {
    this._model = moddle;
  }
  BpmnFactory.$inject = ['moddle'];
  BpmnFactory.prototype._needsId = function (element) {
    return isAny(element, ['bpmn:RootElement', 'bpmn:FlowElement', 'bpmn:MessageFlow', 'bpmn:DataAssociation', 'bpmn:Artifact', 'bpmn:Participant', 'bpmn:Lane', 'bpmn:LaneSet', 'bpmn:Process', 'bpmn:Collaboration', 'bpmndi:BPMNShape', 'bpmndi:BPMNEdge', 'bpmndi:BPMNDiagram', 'bpmndi:BPMNPlane', 'bpmn:Property', 'bpmn:CategoryValue']);
  };
  BpmnFactory.prototype._ensureId = function (element) {
    if (element.id) {
      this._model.ids.claim(element.id, element);
      return;
    }
    var prefix;
    if (is(element, 'bpmn:Activity')) {
      prefix = 'Activity';
    } else if (is(element, 'bpmn:Event')) {
      prefix = 'Event';
    } else if (is(element, 'bpmn:Gateway')) {
      prefix = 'Gateway';
    } else if (isAny(element, ['bpmn:SequenceFlow', 'bpmn:MessageFlow'])) {
      prefix = 'Flow';
    } else {
      prefix = (element.$type || '').replace(/^[^:]*:/g, '');
    }
    prefix += '_';
    if (!element.id && this._needsId(element)) {
      element.id = this._model.ids.nextPrefixed(prefix, element);
    }
  };
  BpmnFactory.prototype.create = function (type, attrs) {
    var element = this._model.create(type, attrs || {});
    this._ensureId(element);
    return element;
  };
  BpmnFactory.prototype.createDiLabel = function () {
    return this.create('bpmndi:BPMNLabel', {
      bounds: this.createDiBounds()
    });
  };
  BpmnFactory.prototype.createDiShape = function (semantic, attrs) {
    return this.create('bpmndi:BPMNShape', assign$1({
      bpmnElement: semantic,
      bounds: this.createDiBounds()
    }, attrs));
  };
  BpmnFactory.prototype.createDiBounds = function (bounds) {
    return this.create('dc:Bounds', bounds);
  };
  BpmnFactory.prototype.createDiWaypoints = function (waypoints) {
    var self = this;
    return map$1(waypoints, function (pos) {
      return self.createDiWaypoint(pos);
    });
  };
  BpmnFactory.prototype.createDiWaypoint = function (point) {
    return this.create('dc:Point', pick(point, ['x', 'y']));
  };
  BpmnFactory.prototype.createDiEdge = function (semantic, attrs) {
    return this.create('bpmndi:BPMNEdge', assign$1({
      bpmnElement: semantic,
      waypoint: this.createDiWaypoints([])
    }, attrs));
  };
  BpmnFactory.prototype.createDiPlane = function (semantic, attrs) {
    return this.create('bpmndi:BPMNPlane', assign$1({
      bpmnElement: semantic
    }, attrs));
  };
  function BpmnUpdater(eventBus, bpmnFactory, connectionDocking) {
    CommandInterceptor.call(this, eventBus);
    this._bpmnFactory = bpmnFactory;
    var self = this;
    function cropConnection(e) {
      var context = e.context,
        hints = context.hints || {},
        connection;
      if (!context.cropped && hints.createElementsBehavior !== false) {
        connection = context.connection;
        connection.waypoints = connectionDocking.getCroppedWaypoints(connection);
        context.cropped = true;
      }
    }
    this.executed(['connection.layout', 'connection.create'], cropConnection);
    this.reverted(['connection.layout'], function (e) {
      delete e.context.cropped;
    });
    function updateParent(e) {
      var context = e.context;
      self.updateParent(context.shape || context.connection, context.oldParent);
    }
    function reverseUpdateParent(e) {
      var context = e.context;
      var element = context.shape || context.connection,
        oldParent = context.parent || context.newParent;
      self.updateParent(element, oldParent);
    }
    this.executed(['shape.move', 'shape.create', 'shape.delete', 'connection.create', 'connection.move', 'connection.delete'], ifBpmn(updateParent));
    this.reverted(['shape.move', 'shape.create', 'shape.delete', 'connection.create', 'connection.move', 'connection.delete'], ifBpmn(reverseUpdateParent));
    function updateRoot(event) {
      var context = event.context,
        oldRoot = context.oldRoot,
        children = oldRoot.children;
      forEach$1(children, function (child) {
        if (is(child, 'bpmn:BaseElement')) {
          self.updateParent(child);
        }
      });
    }
    this.executed(['canvas.updateRoot'], updateRoot);
    this.reverted(['canvas.updateRoot'], updateRoot);
    function updateBounds(e) {
      var shape = e.context.shape;
      if (!is(shape, 'bpmn:BaseElement')) {
        return;
      }
      self.updateBounds(shape);
    }
    this.executed(['shape.move', 'shape.create', 'shape.resize'], ifBpmn(function (event) {
      if (event.context.shape.type === 'label') {
        return;
      }
      updateBounds(event);
    }));
    this.reverted(['shape.move', 'shape.create', 'shape.resize'], ifBpmn(function (event) {
      if (event.context.shape.type === 'label') {
        return;
      }
      updateBounds(event);
    }));
    eventBus.on('shape.changed', function (event) {
      if (event.element.type === 'label') {
        updateBounds({
          context: {
            shape: event.element
          }
        });
      }
    });
    function updateConnection(e) {
      self.updateConnection(e.context);
    }
    this.executed(['connection.create', 'connection.move', 'connection.delete', 'connection.reconnect'], ifBpmn(updateConnection));
    this.reverted(['connection.create', 'connection.move', 'connection.delete', 'connection.reconnect'], ifBpmn(updateConnection));
    function updateConnectionWaypoints(e) {
      self.updateConnectionWaypoints(e.context.connection);
    }
    this.executed(['connection.layout', 'connection.move', 'connection.updateWaypoints'], ifBpmn(updateConnectionWaypoints));
    this.reverted(['connection.layout', 'connection.move', 'connection.updateWaypoints'], ifBpmn(updateConnectionWaypoints));
    this.executed('connection.reconnect', ifBpmn(function (event) {
      var context = event.context,
        connection = context.connection,
        oldSource = context.oldSource,
        newSource = context.newSource,
        connectionBo = getBusinessObject(connection),
        oldSourceBo = getBusinessObject(oldSource),
        newSourceBo = getBusinessObject(newSource);
      if (connectionBo.conditionExpression && !isAny(newSourceBo, ['bpmn:Activity', 'bpmn:ExclusiveGateway', 'bpmn:InclusiveGateway'])) {
        context.oldConditionExpression = connectionBo.conditionExpression;
        delete connectionBo.conditionExpression;
      }
      if (oldSource !== newSource && oldSourceBo.default === connectionBo) {
        context.oldDefault = oldSourceBo.default;
        delete oldSourceBo.default;
      }
    }));
    this.reverted('connection.reconnect', ifBpmn(function (event) {
      var context = event.context,
        connection = context.connection,
        oldSource = context.oldSource,
        newSource = context.newSource,
        connectionBo = getBusinessObject(connection),
        oldSourceBo = getBusinessObject(oldSource),
        newSourceBo = getBusinessObject(newSource);
      if (context.oldConditionExpression) {
        connectionBo.conditionExpression = context.oldConditionExpression;
      }
      if (context.oldDefault) {
        oldSourceBo.default = context.oldDefault;
        delete newSourceBo.default;
      }
    }));
    function updateAttachment(e) {
      self.updateAttachment(e.context);
    }
    this.executed(['element.updateAttachment'], ifBpmn(updateAttachment));
    this.reverted(['element.updateAttachment'], ifBpmn(updateAttachment));
    this.executed('element.updateLabel', ifBpmn(updateBPMNLabel));
    this.reverted('element.updateLabel', ifBpmn(updateBPMNLabel));
    function updateBPMNLabel(event) {
      var element = event.context.element,
        label = getLabel(element);
      var di = getDi(element),
        diLabel = di && di.get('label');
      if (isLabelExternal(element) || isPlane(element)) {
        return;
      }
      if (label && !diLabel) {
        di.set('label', bpmnFactory.create('bpmndi:BPMNLabel'));
      } else if (!label && diLabel) {
        di.set('label', undefined);
      }
    }
  }
  e$2(BpmnUpdater, CommandInterceptor);
  BpmnUpdater.$inject = ['eventBus', 'bpmnFactory', 'connectionDocking'];
  BpmnUpdater.prototype.updateAttachment = function (context) {
    var shape = context.shape,
      businessObject = shape.businessObject,
      host = shape.host;
    businessObject.attachedToRef = host && host.businessObject;
  };
  BpmnUpdater.prototype.updateParent = function (element, oldParent) {
    if (isLabel(element)) {
      return;
    }
    if (is(element, 'bpmn:DataStoreReference') && element.parent && is(element.parent, 'bpmn:Collaboration')) {
      return;
    }
    var parentShape = element.parent;
    var businessObject = element.businessObject,
      di = getDi(element),
      parentBusinessObject = parentShape && parentShape.businessObject,
      parentDi = getDi(parentShape);
    if (is(element, 'bpmn:FlowNode')) {
      this.updateFlowNodeRefs(businessObject, parentBusinessObject, oldParent && oldParent.businessObject);
    }
    if (is(element, 'bpmn:DataOutputAssociation')) {
      if (element.source) {
        parentBusinessObject = element.source.businessObject;
      } else {
        parentBusinessObject = null;
      }
    }
    if (is(element, 'bpmn:DataInputAssociation')) {
      if (element.target) {
        parentBusinessObject = element.target.businessObject;
      } else {
        parentBusinessObject = null;
      }
    }
    this.updateSemanticParent(businessObject, parentBusinessObject);
    if (is(element, 'bpmn:DataObjectReference') && businessObject.dataObjectRef) {
      this.updateSemanticParent(businessObject.dataObjectRef, parentBusinessObject);
    }
    this.updateDiParent(di, parentDi);
  };
  BpmnUpdater.prototype.updateBounds = function (shape) {
    var di = getDi(shape),
      embeddedLabelBounds = getEmbeddedLabelBounds(shape);
    if (embeddedLabelBounds) {
      var embeddedLabelBoundsDelta = delta(embeddedLabelBounds, di.get('bounds'));
      assign$1(embeddedLabelBounds, {
        x: shape.x + embeddedLabelBoundsDelta.x,
        y: shape.y + embeddedLabelBoundsDelta.y
      });
    }
    var target = isLabel(shape) ? this._getLabel(di) : di;
    var bounds = target.bounds;
    if (!bounds) {
      bounds = this._bpmnFactory.createDiBounds();
      target.set('bounds', bounds);
    }
    assign$1(bounds, {
      x: shape.x,
      y: shape.y,
      width: shape.width,
      height: shape.height
    });
  };
  BpmnUpdater.prototype.updateFlowNodeRefs = function (businessObject, newContainment, oldContainment) {
    if (oldContainment === newContainment) {
      return;
    }
    var oldRefs, newRefs;
    if (is(oldContainment, 'bpmn:Lane')) {
      oldRefs = oldContainment.get('flowNodeRef');
      remove(oldRefs, businessObject);
    }
    if (is(newContainment, 'bpmn:Lane')) {
      newRefs = newContainment.get('flowNodeRef');
      add(newRefs, businessObject);
    }
  };
  BpmnUpdater.prototype.updateDiConnection = function (connection, newSource, newTarget) {
    var connectionDi = getDi(connection),
      newSourceDi = getDi(newSource),
      newTargetDi = getDi(newTarget);
    if (connectionDi.sourceElement && connectionDi.sourceElement.bpmnElement !== getBusinessObject(newSource)) {
      connectionDi.sourceElement = newSource && newSourceDi;
    }
    if (connectionDi.targetElement && connectionDi.targetElement.bpmnElement !== getBusinessObject(newTarget)) {
      connectionDi.targetElement = newTarget && newTargetDi;
    }
  };
  BpmnUpdater.prototype.updateDiParent = function (di, parentDi) {
    if (parentDi && !is(parentDi, 'bpmndi:BPMNPlane')) {
      parentDi = parentDi.$parent;
    }
    if (di.$parent === parentDi) {
      return;
    }
    var planeElements = (parentDi || di.$parent).get('planeElement');
    if (parentDi) {
      planeElements.push(di);
      di.$parent = parentDi;
    } else {
      remove(planeElements, di);
      di.$parent = null;
    }
  };
  function getDefinitions(element) {
    while (element && !is(element, 'bpmn:Definitions')) {
      element = element.$parent;
    }
    return element;
  }
  BpmnUpdater.prototype.getLaneSet = function (container) {
    var laneSet, laneSets;
    if (is(container, 'bpmn:Lane')) {
      laneSet = container.childLaneSet;
      if (!laneSet) {
        laneSet = this._bpmnFactory.create('bpmn:LaneSet');
        container.childLaneSet = laneSet;
        laneSet.$parent = container;
      }
      return laneSet;
    }
    if (is(container, 'bpmn:Participant')) {
      container = container.processRef;
    }
    laneSets = container.get('laneSets');
    laneSet = laneSets[0];
    if (!laneSet) {
      laneSet = this._bpmnFactory.create('bpmn:LaneSet');
      laneSet.$parent = container;
      laneSets.push(laneSet);
    }
    return laneSet;
  };
  BpmnUpdater.prototype.updateSemanticParent = function (businessObject, newParent, visualParent) {
    var containment;
    if (businessObject.$parent === newParent) {
      return;
    }
    if (is(businessObject, 'bpmn:DataInput') || is(businessObject, 'bpmn:DataOutput')) {
      if (is(newParent, 'bpmn:Participant') && 'processRef' in newParent) {
        newParent = newParent.processRef;
      }
      if ('ioSpecification' in newParent && newParent.ioSpecification === businessObject.$parent) {
        return;
      }
    }
    if (is(businessObject, 'bpmn:Lane')) {
      if (newParent) {
        newParent = this.getLaneSet(newParent);
      }
      containment = 'lanes';
    } else if (is(businessObject, 'bpmn:FlowElement')) {
      if (newParent) {
        if (is(newParent, 'bpmn:Participant')) {
          newParent = newParent.processRef;
        } else if (is(newParent, 'bpmn:Lane')) {
          do {
            newParent = newParent.$parent.$parent;
          } while (is(newParent, 'bpmn:Lane'));
        }
      }
      containment = 'flowElements';
    } else if (is(businessObject, 'bpmn:Artifact')) {
      while (newParent && !is(newParent, 'bpmn:Process') && !is(newParent, 'bpmn:SubProcess') && !is(newParent, 'bpmn:Collaboration')) {
        if (is(newParent, 'bpmn:Participant')) {
          newParent = newParent.processRef;
          break;
        } else {
          newParent = newParent.$parent;
        }
      }
      containment = 'artifacts';
    } else if (is(businessObject, 'bpmn:MessageFlow')) {
      containment = 'messageFlows';
    } else if (is(businessObject, 'bpmn:Participant')) {
      containment = 'participants';
      var process = businessObject.processRef,
        definitions;
      if (process) {
        definitions = getDefinitions(businessObject.$parent || newParent);
        if (businessObject.$parent) {
          remove(definitions.get('rootElements'), process);
          process.$parent = null;
        }
        if (newParent) {
          add(definitions.get('rootElements'), process);
          process.$parent = definitions;
        }
      }
    } else if (is(businessObject, 'bpmn:DataOutputAssociation')) {
      containment = 'dataOutputAssociations';
    } else if (is(businessObject, 'bpmn:DataInputAssociation')) {
      containment = 'dataInputAssociations';
    }
    if (!containment) {
      throw new Error(`no parent for <${businessObject.id}> in <${newParent.id}>`);
    }
    var children;
    if (businessObject.$parent) {
      children = businessObject.$parent.get(containment);
      remove(children, businessObject);
    }
    if (!newParent) {
      businessObject.$parent = null;
    } else {
      children = newParent.get(containment);
      children.push(businessObject);
      businessObject.$parent = newParent;
    }
    if (visualParent) {
      var diChildren = visualParent.get(containment);
      remove(children, businessObject);
      if (newParent) {
        if (!diChildren) {
          diChildren = [];
          newParent.set(containment, diChildren);
        }
        diChildren.push(businessObject);
      }
    }
  };
  BpmnUpdater.prototype.updateConnectionWaypoints = function (connection) {
    var di = getDi(connection);
    di.set('waypoint', this._bpmnFactory.createDiWaypoints(connection.waypoints));
  };
  BpmnUpdater.prototype.updateConnection = function (context) {
    var connection = context.connection,
      businessObject = getBusinessObject(connection),
      newSource = connection.source,
      newSourceBo = getBusinessObject(newSource),
      newTarget = connection.target,
      newTargetBo = getBusinessObject(connection.target),
      visualParent;
    if (!is(businessObject, 'bpmn:DataAssociation')) {
      var inverseSet = is(businessObject, 'bpmn:SequenceFlow');
      if (businessObject.sourceRef !== newSourceBo) {
        if (inverseSet) {
          remove(businessObject.sourceRef && businessObject.sourceRef.get('outgoing'), businessObject);
          if (newSourceBo && newSourceBo.get('outgoing')) {
            newSourceBo.get('outgoing').push(businessObject);
          }
        }
        businessObject.sourceRef = newSourceBo;
      }
      if (businessObject.targetRef !== newTargetBo) {
        if (inverseSet) {
          remove(businessObject.targetRef && businessObject.targetRef.get('incoming'), businessObject);
          if (newTargetBo && newTargetBo.get('incoming')) {
            newTargetBo.get('incoming').push(businessObject);
          }
        }
        businessObject.targetRef = newTargetBo;
      }
    } else if (is(businessObject, 'bpmn:DataInputAssociation')) {
      businessObject.get('sourceRef')[0] = newSourceBo;
      visualParent = context.parent || context.newParent || newTargetBo;
      this.updateSemanticParent(businessObject, newTargetBo, visualParent);
    } else if (is(businessObject, 'bpmn:DataOutputAssociation')) {
      visualParent = context.parent || context.newParent || newSourceBo;
      this.updateSemanticParent(businessObject, newSourceBo, visualParent);
      businessObject.targetRef = newTargetBo;
    }
    this.updateConnectionWaypoints(connection);
    this.updateDiConnection(connection, newSource, newTarget);
  };
  BpmnUpdater.prototype._getLabel = function (di) {
    if (!di.label) {
      di.label = this._bpmnFactory.createDiLabel();
    }
    return di.label;
  };
  function ifBpmn(fn) {
    return function (event) {
      var context = event.context,
        element = context.shape || context.connection || context.element;
      if (is(element, 'bpmn:BaseElement')) {
        fn(event);
      }
    };
  }
  function getEmbeddedLabelBounds(shape) {
    if (!is(shape, 'bpmn:Activity')) {
      return;
    }
    var di = getDi(shape);
    if (!di) {
      return;
    }
    var label = di.get('label');
    if (!label) {
      return;
    }
    return label.get('bounds');
  }
  function ElementFactory(bpmnFactory, moddle) {
    ElementFactory$1.call(this);
    this._bpmnFactory = bpmnFactory;
    this._moddle = moddle;
  }
  e$2(ElementFactory, ElementFactory$1);
  ElementFactory.$inject = ['bpmnFactory', 'moddle'];
  ElementFactory.prototype._baseCreate = ElementFactory$1.prototype.create;
  ElementFactory.prototype.create = function (elementType, attrs) {
    if (elementType === 'label') {
      var di = attrs.di || this._bpmnFactory.createDiLabel();
      return this._baseCreate(elementType, assign$1({
        type: 'label',
        di: di
      }, DEFAULT_LABEL_SIZE$1, attrs));
    }
    return this.createElement(elementType, attrs);
  };
  ElementFactory.prototype.createElement = function (elementType, attrs) {
    attrs = assign$1({}, attrs || {});
    var size;
    var businessObject = attrs.businessObject,
      di = attrs.di;
    if (!businessObject) {
      if (!attrs.type) {
        throw new Error('no shape type specified');
      }
      businessObject = this._bpmnFactory.create(attrs.type);
      ensureCompatDiRef(businessObject);
    }
    if (!isModdleDi(di)) {
      var diAttrs = assign$1({}, di || {}, {
        id: businessObject.id + '_di'
      });
      if (elementType === 'root') {
        di = this._bpmnFactory.createDiPlane(businessObject, diAttrs);
      } else if (elementType === 'connection') {
        di = this._bpmnFactory.createDiEdge(businessObject, diAttrs);
      } else {
        di = this._bpmnFactory.createDiShape(businessObject, diAttrs);
      }
    }
    if (is(businessObject, 'bpmn:Group')) {
      attrs = assign$1({
        isFrame: true
      }, attrs);
    }
    attrs = applyAttributes(businessObject, attrs, ['processRef', 'isInterrupting', 'associationDirection', 'isForCompensation']);
    if (attrs.isExpanded) {
      attrs = applyAttribute(di, attrs, 'isExpanded');
    }
    if (isAny(businessObject, ['bpmn:Lane', 'bpmn:Participant'])) {
      attrs = applyAttribute(di, attrs, 'isHorizontal');
    }
    if (is(businessObject, 'bpmn:SubProcess')) {
      attrs.collapsed = !isExpanded(businessObject, di);
    }
    if (is(businessObject, 'bpmn:ExclusiveGateway')) {
      if (has$1(di, 'isMarkerVisible')) {
        if (di.isMarkerVisible === undefined) {
          di.isMarkerVisible = false;
        }
      } else {
        di.isMarkerVisible = true;
      }
    }
    if (isDefined(attrs.triggeredByEvent)) {
      businessObject.triggeredByEvent = attrs.triggeredByEvent;
      delete attrs.triggeredByEvent;
    }
    if (isDefined(attrs.cancelActivity)) {
      businessObject.cancelActivity = attrs.cancelActivity;
      delete attrs.cancelActivity;
    }
    var eventDefinitions, newEventDefinition;
    if (attrs.eventDefinitionType) {
      eventDefinitions = businessObject.get('eventDefinitions') || [];
      newEventDefinition = this._bpmnFactory.create(attrs.eventDefinitionType, attrs.eventDefinitionAttrs);
      if (attrs.eventDefinitionType === 'bpmn:ConditionalEventDefinition') {
        newEventDefinition.condition = this._bpmnFactory.create('bpmn:FormalExpression');
      }
      eventDefinitions.push(newEventDefinition);
      newEventDefinition.$parent = businessObject;
      businessObject.eventDefinitions = eventDefinitions;
      delete attrs.eventDefinitionType;
    }
    size = this.getDefaultSize(businessObject, di);
    attrs = assign$1({
      id: businessObject.id
    }, size, attrs, {
      businessObject: businessObject,
      di: di
    });
    return this._baseCreate(elementType, attrs);
  };
  ElementFactory.prototype.getDefaultSize = function (element, di) {
    var bo = getBusinessObject(element);
    di = di || getDi(element);
    if (is(bo, 'bpmn:SubProcess')) {
      if (isExpanded(bo, di)) {
        return {
          width: 350,
          height: 200
        };
      } else {
        return {
          width: 100,
          height: 80
        };
      }
    }
    if (is(bo, 'bpmn:Task')) {
      return {
        width: 100,
        height: 80
      };
    }
    if (is(bo, 'bpmn:Gateway')) {
      return {
        width: 50,
        height: 50
      };
    }
    if (is(bo, 'bpmn:Event')) {
      return {
        width: 36,
        height: 36
      };
    }
    if (is(bo, 'bpmn:Participant')) {
      var isHorizontalPool = di.isHorizontal === undefined || di.isHorizontal === true;
      if (isExpanded(bo, di)) {
        if (isHorizontalPool) {
          return {
            width: 600,
            height: 250
          };
        }
        return {
          width: 250,
          height: 600
        };
      } else {
        if (isHorizontalPool) {
          return {
            width: 400,
            height: 60
          };
        }
        return {
          width: 60,
          height: 400
        };
      }
    }
    if (is(bo, 'bpmn:Lane')) {
      return {
        width: 400,
        height: 100
      };
    }
    if (is(bo, 'bpmn:DataObjectReference')) {
      return {
        width: 36,
        height: 50
      };
    }
    if (is(bo, 'bpmn:DataStoreReference')) {
      return {
        width: 50,
        height: 50
      };
    }
    if (is(bo, 'bpmn:TextAnnotation')) {
      return {
        width: 100,
        height: 30
      };
    }
    if (is(bo, 'bpmn:Group')) {
      return {
        width: 300,
        height: 300
      };
    }
    return {
      width: 100,
      height: 80
    };
  };
  ElementFactory.prototype.createParticipantShape = function (attrs) {
    if (!isObject(attrs)) {
      attrs = {
        isExpanded: attrs
      };
    }
    attrs = assign$1({
      type: 'bpmn:Participant'
    }, attrs || {});
    if (attrs.isExpanded !== false) {
      attrs.processRef = this._bpmnFactory.create('bpmn:Process');
    }
    return this.createShape(attrs);
  };
  function applyAttributes(element, attrs, attributeNames) {
    forEach$1(attributeNames, function (property) {
      attrs = applyAttribute(element, attrs, property);
    });
    return attrs;
  }
  function applyAttribute(element, attrs, attributeName) {
    if (attrs[attributeName] === undefined) {
      return attrs;
    }
    element[attributeName] = attrs[attributeName];
    return omit(attrs, [attributeName]);
  }
  function isModdleDi(element) {
    return isAny(element, ['bpmndi:BPMNShape', 'bpmndi:BPMNEdge', 'bpmndi:BPMNDiagram', 'bpmndi:BPMNPlane']);
  }
  function AlignElements(modeling, canvas) {
    this._modeling = modeling;
    this._canvas = canvas;
  }
  AlignElements.$inject = ['modeling', 'canvas'];
  AlignElements.prototype.preExecute = function (context) {
    var modeling = this._modeling;
    var elements = context.elements,
      alignment = context.alignment;
    forEach$1(elements, function (element) {
      var delta = {
        x: 0,
        y: 0
      };
      if (isDefined(alignment.left)) {
        delta.x = alignment.left - element.x;
      } else if (isDefined(alignment.right)) {
        delta.x = alignment.right - element.width - element.x;
      } else if (isDefined(alignment.center)) {
        delta.x = alignment.center - Math.round(element.width / 2) - element.x;
      } else if (isDefined(alignment.top)) {
        delta.y = alignment.top - element.y;
      } else if (isDefined(alignment.bottom)) {
        delta.y = alignment.bottom - element.height - element.y;
      } else if (isDefined(alignment.middle)) {
        delta.y = alignment.middle - Math.round(element.height / 2) - element.y;
      }
      modeling.moveElements([element], delta, element.parent);
    });
  };
  AlignElements.prototype.postExecute = function (context) {};
  function AppendShapeHandler(modeling) {
    this._modeling = modeling;
  }
  AppendShapeHandler.$inject = ['modeling'];
  AppendShapeHandler.prototype.preExecute = function (context) {
    var source = context.source;
    if (!source) {
      throw new Error('source required');
    }
    var target = context.target || source.parent,
      shape = context.shape,
      hints = context.hints || {};
    shape = context.shape = this._modeling.createShape(shape, context.position, target, {
      attach: hints.attach
    });
    context.shape = shape;
  };
  AppendShapeHandler.prototype.postExecute = function (context) {
    var hints = context.hints || {};
    if (!existsConnection(context.source, context.shape)) {
      if (hints.connectionTarget === context.source) {
        this._modeling.connect(context.shape, context.source, context.connection);
      } else {
        this._modeling.connect(context.source, context.shape, context.connection);
      }
    }
  };
  function existsConnection(source, target) {
    return some(source.outgoing, function (c) {
      return c.target === target;
    });
  }
  function CreateConnectionHandler(canvas, layouter) {
    this._canvas = canvas;
    this._layouter = layouter;
  }
  CreateConnectionHandler.$inject = ['canvas', 'layouter'];
  CreateConnectionHandler.prototype.execute = function (context) {
    var connection = context.connection,
      source = context.source,
      target = context.target,
      parent = context.parent,
      parentIndex = context.parentIndex,
      hints = context.hints;
    if (!source || !target) {
      throw new Error('source and target required');
    }
    if (!parent) {
      throw new Error('parent required');
    }
    connection.source = source;
    connection.target = target;
    if (!connection.waypoints) {
      connection.waypoints = this._layouter.layoutConnection(connection, hints);
    }
    this._canvas.addConnection(connection, parent, parentIndex);
    return connection;
  };
  CreateConnectionHandler.prototype.revert = function (context) {
    var connection = context.connection;
    this._canvas.removeConnection(connection);
    connection.source = null;
    connection.target = null;
    return connection;
  };
  var round$4 = Math.round;
  function CreateElementsHandler(modeling) {
    this._modeling = modeling;
  }
  CreateElementsHandler.$inject = ['modeling'];
  CreateElementsHandler.prototype.preExecute = function (context) {
    var elements = context.elements,
      parent = context.parent,
      parentIndex = context.parentIndex,
      position = context.position,
      hints = context.hints;
    var modeling = this._modeling;
    forEach$1(elements, function (element) {
      if (!isNumber(element.x)) {
        element.x = 0;
      }
      if (!isNumber(element.y)) {
        element.y = 0;
      }
    });
    var visibleElements = filter(elements, function (element) {
      return !element.hidden;
    });
    var bbox = getBBox(visibleElements);
    forEach$1(elements, function (element) {
      if (isConnection(element)) {
        element.waypoints = map$1(element.waypoints, function (waypoint) {
          return {
            x: round$4(waypoint.x - bbox.x - bbox.width / 2 + position.x),
            y: round$4(waypoint.y - bbox.y - bbox.height / 2 + position.y)
          };
        });
      }
      assign$1(element, {
        x: round$4(element.x - bbox.x - bbox.width / 2 + position.x),
        y: round$4(element.y - bbox.y - bbox.height / 2 + position.y)
      });
    });
    var parents = getParents$1(elements);
    var cache = {};
    forEach$1(elements, function (element) {
      if (isConnection(element)) {
        cache[element.id] = isNumber(parentIndex) ? modeling.createConnection(cache[element.source.id], cache[element.target.id], parentIndex, element, element.parent || parent, hints) : modeling.createConnection(cache[element.source.id], cache[element.target.id], element, element.parent || parent, hints);
        return;
      }
      var createShapeHints = assign$1({}, hints);
      if (parents.indexOf(element) === -1) {
        createShapeHints.autoResize = false;
      }
      if (isLabel(element)) {
        createShapeHints = omit(createShapeHints, ['attach']);
      }
      cache[element.id] = isNumber(parentIndex) ? modeling.createShape(element, pick(element, ['x', 'y', 'width', 'height']), element.parent || parent, parentIndex, createShapeHints) : modeling.createShape(element, pick(element, ['x', 'y', 'width', 'height']), element.parent || parent, createShapeHints);
    });
    context.elements = values(cache);
  };
  var round$3 = Math.round;
  function CreateShapeHandler(canvas) {
    this._canvas = canvas;
  }
  CreateShapeHandler.$inject = ['canvas'];
  CreateShapeHandler.prototype.execute = function (context) {
    var shape = context.shape,
      positionOrBounds = context.position,
      parent = context.parent,
      parentIndex = context.parentIndex;
    if (!parent) {
      throw new Error('parent required');
    }
    if (!positionOrBounds) {
      throw new Error('position required');
    }
    if (positionOrBounds.width !== undefined) {
      assign$1(shape, positionOrBounds);
    } else {
      assign$1(shape, {
        x: positionOrBounds.x - round$3(shape.width / 2),
        y: positionOrBounds.y - round$3(shape.height / 2)
      });
    }
    this._canvas.addShape(shape, parent, parentIndex);
    return shape;
  };
  CreateShapeHandler.prototype.revert = function (context) {
    var shape = context.shape;
    this._canvas.removeShape(shape);
    return shape;
  };
  function CreateLabelHandler(canvas) {
    CreateShapeHandler.call(this, canvas);
  }
  e$2(CreateLabelHandler, CreateShapeHandler);
  CreateLabelHandler.$inject = ['canvas'];
  var originalExecute = CreateShapeHandler.prototype.execute;
  CreateLabelHandler.prototype.execute = function (context) {
    var label = context.shape;
    ensureValidDimensions(label);
    label.labelTarget = context.labelTarget;
    return originalExecute.call(this, context);
  };
  var originalRevert = CreateShapeHandler.prototype.revert;
  CreateLabelHandler.prototype.revert = function (context) {
    context.shape.labelTarget = null;
    return originalRevert.call(this, context);
  };
  function ensureValidDimensions(label) {
    ['width', 'height'].forEach(function (prop) {
      if (typeof label[prop] === 'undefined') {
        label[prop] = 0;
      }
    });
  }
  function DeleteConnectionHandler(canvas, modeling) {
    this._canvas = canvas;
    this._modeling = modeling;
  }
  DeleteConnectionHandler.$inject = ['canvas', 'modeling'];
  DeleteConnectionHandler.prototype.preExecute = function (context) {
    var modeling = this._modeling;
    var connection = context.connection;
    saveClear(connection.incoming, function (connection) {
      modeling.removeConnection(connection, {
        nested: true
      });
    });
    saveClear(connection.outgoing, function (connection) {
      modeling.removeConnection(connection, {
        nested: true
      });
    });
  };
  DeleteConnectionHandler.prototype.execute = function (context) {
    var connection = context.connection,
      parent = connection.parent;
    context.parent = parent;
    context.parentIndex = indexOf(parent.children, connection);
    context.source = connection.source;
    context.target = connection.target;
    this._canvas.removeConnection(connection);
    connection.source = null;
    connection.target = null;
    return connection;
  };
  DeleteConnectionHandler.prototype.revert = function (context) {
    var connection = context.connection,
      parent = context.parent,
      parentIndex = context.parentIndex;
    connection.source = context.source;
    connection.target = context.target;
    add(parent.children, connection, parentIndex);
    this._canvas.addConnection(connection, parent);
    return connection;
  };
  function DeleteElementsHandler(modeling, elementRegistry) {
    this._modeling = modeling;
    this._elementRegistry = elementRegistry;
  }
  DeleteElementsHandler.$inject = ['modeling', 'elementRegistry'];
  DeleteElementsHandler.prototype.postExecute = function (context) {
    var modeling = this._modeling,
      elementRegistry = this._elementRegistry,
      elements = context.elements;
    forEach$1(elements, function (element) {
      if (!elementRegistry.get(element.id)) {
        return;
      }
      if (element.waypoints) {
        modeling.removeConnection(element);
      } else {
        modeling.removeShape(element);
      }
    });
  };
  function DeleteShapeHandler(canvas, modeling) {
    this._canvas = canvas;
    this._modeling = modeling;
  }
  DeleteShapeHandler.$inject = ['canvas', 'modeling'];
  DeleteShapeHandler.prototype.preExecute = function (context) {
    var modeling = this._modeling;
    var shape = context.shape;
    saveClear(shape.incoming, function (connection) {
      modeling.removeConnection(connection, {
        nested: true
      });
    });
    saveClear(shape.outgoing, function (connection) {
      modeling.removeConnection(connection, {
        nested: true
      });
    });
    saveClear(shape.children, function (child) {
      if (isConnection(child)) {
        modeling.removeConnection(child, {
          nested: true
        });
      } else {
        modeling.removeShape(child, {
          nested: true
        });
      }
    });
  };
  DeleteShapeHandler.prototype.execute = function (context) {
    var canvas = this._canvas;
    var shape = context.shape,
      oldParent = shape.parent;
    context.oldParent = oldParent;
    context.oldParentIndex = indexOf(oldParent.children, shape);
    canvas.removeShape(shape);
    return shape;
  };
  DeleteShapeHandler.prototype.revert = function (context) {
    var canvas = this._canvas;
    var shape = context.shape,
      oldParent = context.oldParent,
      oldParentIndex = context.oldParentIndex;
    add(oldParent.children, shape, oldParentIndex);
    canvas.addShape(shape, oldParent);
    return shape;
  };
  function DistributeElements$1(modeling) {
    this._modeling = modeling;
  }
  DistributeElements$1.$inject = ['modeling'];
  var OFF_AXIS = {
    x: 'y',
    y: 'x'
  };
  DistributeElements$1.prototype.preExecute = function (context) {
    var modeling = this._modeling;
    var groups = context.groups,
      axis = context.axis,
      dimension = context.dimension;
    function updateRange(group, element) {
      group.range.min = Math.min(element[axis], group.range.min);
      group.range.max = Math.max(element[axis] + element[dimension], group.range.max);
    }
    function center(element) {
      return element[axis] + element[dimension] / 2;
    }
    function lastIdx(arr) {
      return arr.length - 1;
    }
    function rangeDiff(range) {
      return range.max - range.min;
    }
    function centerElement(refCenter, element) {
      var delta = {
        y: 0
      };
      delta[axis] = refCenter - center(element);
      if (delta[axis]) {
        delta[OFF_AXIS[axis]] = 0;
        modeling.moveElements([element], delta, element.parent);
      }
    }
    var firstGroup = groups[0],
      lastGroupIdx = lastIdx(groups),
      lastGroup = groups[lastGroupIdx];
    var margin,
      spaceInBetween,
      groupsSize = 0;
    forEach$1(groups, function (group, idx) {
      var sortedElements, refElem, refCenter;
      if (group.elements.length < 2) {
        if (idx && idx !== groups.length - 1) {
          updateRange(group, group.elements[0]);
          groupsSize += rangeDiff(group.range);
        }
        return;
      }
      sortedElements = sortBy(group.elements, axis);
      refElem = sortedElements[0];
      if (idx === lastGroupIdx) {
        refElem = sortedElements[lastIdx(sortedElements)];
      }
      refCenter = center(refElem);
      group.range = null;
      forEach$1(sortedElements, function (element) {
        centerElement(refCenter, element);
        if (group.range === null) {
          group.range = {
            min: element[axis],
            max: element[axis] + element[dimension]
          };
          return;
        }
        updateRange(group, element);
      });
      if (idx && idx !== groups.length - 1) {
        groupsSize += rangeDiff(group.range);
      }
    });
    spaceInBetween = Math.abs(lastGroup.range.min - firstGroup.range.max);
    margin = Math.round((spaceInBetween - groupsSize) / (groups.length - 1));
    if (margin < groups.length - 1) {
      return;
    }
    forEach$1(groups, function (group, groupIdx) {
      var delta = {},
        prevGroup;
      if (group === firstGroup || group === lastGroup) {
        return;
      }
      prevGroup = groups[groupIdx - 1];
      group.range.max = 0;
      forEach$1(group.elements, function (element, idx) {
        delta[OFF_AXIS[axis]] = 0;
        delta[axis] = prevGroup.range.max - element[axis] + margin;
        if (group.range.min !== element[axis]) {
          delta[axis] += element[axis] - group.range.min;
        }
        if (delta[axis]) {
          modeling.moveElements([element], delta, element.parent);
        }
        group.range.max = Math.max(element[axis] + element[dimension], idx ? group.range.max : 0);
      });
    });
  };
  DistributeElements$1.prototype.postExecute = function (context) {};
  function LayoutConnectionHandler(layouter, canvas) {
    this._layouter = layouter;
    this._canvas = canvas;
  }
  LayoutConnectionHandler.$inject = ['layouter', 'canvas'];
  LayoutConnectionHandler.prototype.execute = function (context) {
    var connection = context.connection;
    var oldWaypoints = connection.waypoints;
    assign$1(context, {
      oldWaypoints: oldWaypoints
    });
    connection.waypoints = this._layouter.layoutConnection(connection, context.hints);
    return connection;
  };
  LayoutConnectionHandler.prototype.revert = function (context) {
    var connection = context.connection;
    connection.waypoints = context.oldWaypoints;
    return connection;
  };
  function MoveConnectionHandler() {}
  MoveConnectionHandler.prototype.execute = function (context) {
    var connection = context.connection,
      delta = context.delta;
    var newParent = context.newParent || connection.parent,
      newParentIndex = context.newParentIndex,
      oldParent = connection.parent;
    context.oldParent = oldParent;
    context.oldParentIndex = remove(oldParent.children, connection);
    add(newParent.children, connection, newParentIndex);
    connection.parent = newParent;
    forEach$1(connection.waypoints, function (p) {
      p.x += delta.x;
      p.y += delta.y;
      if (p.original) {
        p.original.x += delta.x;
        p.original.y += delta.y;
      }
    });
    return connection;
  };
  MoveConnectionHandler.prototype.revert = function (context) {
    var connection = context.connection,
      newParent = connection.parent,
      oldParent = context.oldParent,
      oldParentIndex = context.oldParentIndex,
      delta = context.delta;
    remove(newParent.children, connection);
    add(oldParent.children, connection, oldParentIndex);
    connection.parent = oldParent;
    forEach$1(connection.waypoints, function (p) {
      p.x -= delta.x;
      p.y -= delta.y;
      if (p.original) {
        p.original.x -= delta.x;
        p.original.y -= delta.y;
      }
    });
    return connection;
  };
  function MoveClosure() {
    this.allShapes = {};
    this.allConnections = {};
    this.enclosedElements = {};
    this.enclosedConnections = {};
    this.topLevel = {};
  }
  MoveClosure.prototype.add = function (element, isTopLevel) {
    return this.addAll([element], isTopLevel);
  };
  MoveClosure.prototype.addAll = function (elements, isTopLevel) {
    var newClosure = getClosure(elements, !!isTopLevel, this);
    assign$1(this, newClosure);
    return this;
  };
  function MoveHelper(modeling) {
    this._modeling = modeling;
  }
  MoveHelper.prototype.moveRecursive = function (elements, delta, newParent) {
    if (!elements) {
      return [];
    } else {
      return this.moveClosure(this.getClosure(elements), delta, newParent);
    }
  };
  MoveHelper.prototype.moveClosure = function (closure, delta, newParent, newHost, primaryShape) {
    var modeling = this._modeling;
    var allShapes = closure.allShapes,
      allConnections = closure.allConnections,
      enclosedConnections = closure.enclosedConnections,
      topLevel = closure.topLevel,
      keepParent = false;
    if (primaryShape && primaryShape.parent === newParent) {
      keepParent = true;
    }
    forEach$1(allShapes, function (shape) {
      modeling.moveShape(shape, delta, topLevel[shape.id] && !keepParent && newParent, {
        recurse: false,
        layout: false
      });
    });
    forEach$1(allConnections, function (c) {
      var sourceMoved = !!allShapes[c.source.id],
        targetMoved = !!allShapes[c.target.id];
      if (enclosedConnections[c.id] && sourceMoved && targetMoved) {
        modeling.moveConnection(c, delta, topLevel[c.id] && !keepParent && newParent);
      } else {
        modeling.layoutConnection(c, {
          connectionStart: sourceMoved && getMovedSourceAnchor(c, c.source, delta),
          connectionEnd: targetMoved && getMovedTargetAnchor(c, c.target, delta)
        });
      }
    });
  };
  MoveHelper.prototype.getClosure = function (elements) {
    return new MoveClosure().addAll(elements, true);
  };
  function MoveElementsHandler(modeling) {
    this._helper = new MoveHelper(modeling);
  }
  MoveElementsHandler.$inject = ['modeling'];
  MoveElementsHandler.prototype.preExecute = function (context) {
    context.closure = this._helper.getClosure(context.shapes);
  };
  MoveElementsHandler.prototype.postExecute = function (context) {
    var hints = context.hints,
      primaryShape;
    if (hints && hints.primaryShape) {
      primaryShape = hints.primaryShape;
      hints.oldParent = primaryShape.parent;
    }
    this._helper.moveClosure(context.closure, context.delta, context.newParent, context.newHost, primaryShape);
  };
  function MoveShapeHandler(modeling) {
    this._modeling = modeling;
    this._helper = new MoveHelper(modeling);
  }
  MoveShapeHandler.$inject = ['modeling'];
  MoveShapeHandler.prototype.execute = function (context) {
    var shape = context.shape,
      delta = context.delta,
      newParent = context.newParent || shape.parent,
      newParentIndex = context.newParentIndex,
      oldParent = shape.parent;
    context.oldBounds = pick(shape, ['x', 'y', 'width', 'height']);
    context.oldParent = oldParent;
    context.oldParentIndex = remove(oldParent.children, shape);
    add(newParent.children, shape, newParentIndex);
    assign$1(shape, {
      parent: newParent,
      x: shape.x + delta.x,
      y: shape.y + delta.y
    });
    return shape;
  };
  MoveShapeHandler.prototype.postExecute = function (context) {
    var shape = context.shape,
      delta = context.delta,
      hints = context.hints;
    var modeling = this._modeling;
    if (hints.layout !== false) {
      forEach$1(shape.incoming, function (c) {
        modeling.layoutConnection(c, {
          connectionEnd: getMovedTargetAnchor(c, shape, delta)
        });
      });
      forEach$1(shape.outgoing, function (c) {
        modeling.layoutConnection(c, {
          connectionStart: getMovedSourceAnchor(c, shape, delta)
        });
      });
    }
    if (hints.recurse !== false) {
      this.moveChildren(context);
    }
  };
  MoveShapeHandler.prototype.revert = function (context) {
    var shape = context.shape,
      oldParent = context.oldParent,
      oldParentIndex = context.oldParentIndex,
      delta = context.delta;
    add(oldParent.children, shape, oldParentIndex);
    assign$1(shape, {
      parent: oldParent,
      x: shape.x - delta.x,
      y: shape.y - delta.y
    });
    return shape;
  };
  MoveShapeHandler.prototype.moveChildren = function (context) {
    var delta = context.delta,
      shape = context.shape;
    this._helper.moveRecursive(shape.children, delta, null);
  };
  MoveShapeHandler.prototype.getNewParent = function (context) {
    return context.newParent || context.shape.parent;
  };
  function ReconnectConnectionHandler(modeling) {
    this._modeling = modeling;
  }
  ReconnectConnectionHandler.$inject = ['modeling'];
  ReconnectConnectionHandler.prototype.execute = function (context) {
    var newSource = context.newSource,
      newTarget = context.newTarget,
      connection = context.connection,
      dockingOrPoints = context.dockingOrPoints;
    if (!newSource && !newTarget) {
      throw new Error('newSource or newTarget required');
    }
    if (isArray$3(dockingOrPoints)) {
      context.oldWaypoints = connection.waypoints;
      connection.waypoints = dockingOrPoints;
    }
    if (newSource) {
      context.oldSource = connection.source;
      connection.source = newSource;
    }
    if (newTarget) {
      context.oldTarget = connection.target;
      connection.target = newTarget;
    }
    return connection;
  };
  ReconnectConnectionHandler.prototype.postExecute = function (context) {
    var connection = context.connection,
      newSource = context.newSource,
      newTarget = context.newTarget,
      dockingOrPoints = context.dockingOrPoints,
      hints = context.hints || {};
    var layoutConnectionHints = {};
    if (hints.connectionStart) {
      layoutConnectionHints.connectionStart = hints.connectionStart;
    }
    if (hints.connectionEnd) {
      layoutConnectionHints.connectionEnd = hints.connectionEnd;
    }
    if (hints.layoutConnection === false) {
      return;
    }
    if (newSource && (!newTarget || hints.docking === 'source')) {
      layoutConnectionHints.connectionStart = layoutConnectionHints.connectionStart || getDocking(isArray$3(dockingOrPoints) ? dockingOrPoints[0] : dockingOrPoints);
    }
    if (newTarget && (!newSource || hints.docking === 'target')) {
      layoutConnectionHints.connectionEnd = layoutConnectionHints.connectionEnd || getDocking(isArray$3(dockingOrPoints) ? dockingOrPoints[dockingOrPoints.length - 1] : dockingOrPoints);
    }
    if (hints.newWaypoints) {
      layoutConnectionHints.waypoints = hints.newWaypoints;
    }
    this._modeling.layoutConnection(connection, layoutConnectionHints);
  };
  ReconnectConnectionHandler.prototype.revert = function (context) {
    var oldSource = context.oldSource,
      oldTarget = context.oldTarget,
      oldWaypoints = context.oldWaypoints,
      connection = context.connection;
    if (oldSource) {
      connection.source = oldSource;
    }
    if (oldTarget) {
      connection.target = oldTarget;
    }
    if (oldWaypoints) {
      connection.waypoints = oldWaypoints;
    }
    return connection;
  };
  function getDocking(point) {
    return point.original || point;
  }
  function ReplaceShapeHandler(modeling, rules) {
    this._modeling = modeling;
    this._rules = rules;
  }
  ReplaceShapeHandler.$inject = ['modeling', 'rules'];
  ReplaceShapeHandler.prototype.preExecute = function (context) {
    var self = this,
      modeling = this._modeling,
      rules = this._rules;
    var oldShape = context.oldShape,
      newData = context.newData,
      hints = context.hints || {},
      newShape;
    function canReconnect(source, target, connection) {
      return rules.allowed('connection.reconnect', {
        connection: connection,
        source: source,
        target: target
      });
    }
    var position = {
      x: newData.x,
      y: newData.y
    };
    var oldBounds = {
      x: oldShape.x,
      y: oldShape.y,
      width: oldShape.width,
      height: oldShape.height
    };
    newShape = context.newShape = context.newShape || self.createShape(newData, position, oldShape.parent, hints);
    if (oldShape.host) {
      modeling.updateAttachment(newShape, oldShape.host);
    }
    var children;
    if (hints.moveChildren !== false) {
      children = oldShape.children.slice();
      modeling.moveElements(children, {
        x: 0,
        y: 0
      }, newShape, hints);
    }
    var incoming = oldShape.incoming.slice(),
      outgoing = oldShape.outgoing.slice();
    forEach$1(incoming, function (connection) {
      var source = connection.source,
        allowed = canReconnect(source, newShape, connection);
      if (allowed) {
        self.reconnectEnd(connection, newShape, getResizedTargetAnchor(connection, newShape, oldBounds), hints);
      }
    });
    forEach$1(outgoing, function (connection) {
      var target = connection.target,
        allowed = canReconnect(newShape, target, connection);
      if (allowed) {
        self.reconnectStart(connection, newShape, getResizedSourceAnchor(connection, newShape, oldBounds), hints);
      }
    });
  };
  ReplaceShapeHandler.prototype.postExecute = function (context) {
    var oldShape = context.oldShape;
    this._modeling.removeShape(oldShape);
  };
  ReplaceShapeHandler.prototype.execute = function (context) {};
  ReplaceShapeHandler.prototype.revert = function (context) {};
  ReplaceShapeHandler.prototype.createShape = function (shape, position, target, hints) {
    return this._modeling.createShape(shape, position, target, hints);
  };
  ReplaceShapeHandler.prototype.reconnectStart = function (connection, newSource, dockingPoint, hints) {
    this._modeling.reconnectStart(connection, newSource, dockingPoint, hints);
  };
  ReplaceShapeHandler.prototype.reconnectEnd = function (connection, newTarget, dockingPoint, hints) {
    this._modeling.reconnectEnd(connection, newTarget, dockingPoint, hints);
  };
  function ResizeShapeHandler(modeling) {
    this._modeling = modeling;
  }
  ResizeShapeHandler.$inject = ['modeling'];
  ResizeShapeHandler.prototype.execute = function (context) {
    var shape = context.shape,
      newBounds = context.newBounds,
      minBounds = context.minBounds;
    if (newBounds.x === undefined || newBounds.y === undefined || newBounds.width === undefined || newBounds.height === undefined) {
      throw new Error('newBounds must have {x, y, width, height} properties');
    }
    if (minBounds && (newBounds.width < minBounds.width || newBounds.height < minBounds.height)) {
      throw new Error('width and height cannot be less than minimum height and width');
    } else if (!minBounds && newBounds.width < 10 || newBounds.height < 10) {
      throw new Error('width and height cannot be less than 10px');
    }
    context.oldBounds = {
      width: shape.width,
      height: shape.height,
      x: shape.x,
      y: shape.y
    };
    assign$1(shape, {
      width: newBounds.width,
      height: newBounds.height,
      x: newBounds.x,
      y: newBounds.y
    });
    return shape;
  };
  ResizeShapeHandler.prototype.postExecute = function (context) {
    var modeling = this._modeling;
    var shape = context.shape,
      oldBounds = context.oldBounds,
      hints = context.hints || {};
    if (hints.layout === false) {
      return;
    }
    forEach$1(shape.incoming, function (c) {
      modeling.layoutConnection(c, {
        connectionEnd: getResizedTargetAnchor(c, shape, oldBounds)
      });
    });
    forEach$1(shape.outgoing, function (c) {
      modeling.layoutConnection(c, {
        connectionStart: getResizedSourceAnchor(c, shape, oldBounds)
      });
    });
  };
  ResizeShapeHandler.prototype.revert = function (context) {
    var shape = context.shape,
      oldBounds = context.oldBounds;
    assign$1(shape, {
      width: oldBounds.width,
      height: oldBounds.height,
      x: oldBounds.x,
      y: oldBounds.y
    });
    return shape;
  };
  function SpaceToolHandler(modeling) {
    this._modeling = modeling;
  }
  SpaceToolHandler.$inject = ['modeling'];
  SpaceToolHandler.prototype.preExecute = function (context) {
    var delta = context.delta,
      direction = context.direction,
      movingShapes = context.movingShapes,
      resizingShapes = context.resizingShapes,
      start = context.start,
      oldBounds = {};
    this.moveShapes(movingShapes, delta);
    forEach$1(resizingShapes, function (shape) {
      oldBounds[shape.id] = getBounds(shape);
    });
    this.resizeShapes(resizingShapes, delta, direction);
    this.updateConnectionWaypoints(getWaypointsUpdatingConnections(movingShapes, resizingShapes), delta, direction, start, movingShapes, resizingShapes, oldBounds);
  };
  SpaceToolHandler.prototype.execute = function () {};
  SpaceToolHandler.prototype.revert = function () {};
  SpaceToolHandler.prototype.moveShapes = function (shapes, delta) {
    var self = this;
    forEach$1(shapes, function (element) {
      self._modeling.moveShape(element, delta, null, {
        autoResize: false,
        layout: false,
        recurse: false
      });
    });
  };
  SpaceToolHandler.prototype.resizeShapes = function (shapes, delta, direction) {
    var self = this;
    forEach$1(shapes, function (shape) {
      var newBounds = resizeBounds(shape, direction, delta);
      self._modeling.resizeShape(shape, newBounds, null, {
        attachSupport: false,
        autoResize: false,
        layout: false
      });
    });
  };
  SpaceToolHandler.prototype.updateConnectionWaypoints = function (connections, delta, direction, start, movingShapes, resizingShapes, oldBounds) {
    var self = this,
      affectedShapes = movingShapes.concat(resizingShapes);
    forEach$1(connections, function (connection) {
      var source = connection.source,
        target = connection.target,
        waypoints = copyWaypoints(connection),
        axis = getAxisFromDirection(direction),
        layoutHints = {};
      if (includes$1(affectedShapes, source) && includes$1(affectedShapes, target)) {
        waypoints = map$1(waypoints, function (waypoint) {
          if (shouldMoveWaypoint(waypoint, start, direction)) {
            waypoint[axis] = waypoint[axis] + delta[axis];
          }
          if (waypoint.original && shouldMoveWaypoint(waypoint.original, start, direction)) {
            waypoint.original[axis] = waypoint.original[axis] + delta[axis];
          }
          return waypoint;
        });
        self._modeling.updateWaypoints(connection, waypoints, {
          labelBehavior: false
        });
      } else if (includes$1(affectedShapes, source) || includes$1(affectedShapes, target)) {
        if (includes$1(movingShapes, source)) {
          layoutHints.connectionStart = getMovedSourceAnchor(connection, source, delta);
        } else if (includes$1(movingShapes, target)) {
          layoutHints.connectionEnd = getMovedTargetAnchor(connection, target, delta);
        } else if (includes$1(resizingShapes, source)) {
          layoutHints.connectionStart = getResizedSourceAnchor(connection, source, oldBounds[source.id]);
        } else if (includes$1(resizingShapes, target)) {
          layoutHints.connectionEnd = getResizedTargetAnchor(connection, target, oldBounds[target.id]);
        }
        self._modeling.layoutConnection(connection, layoutHints);
      }
    });
  };
  function copyWaypoint(waypoint) {
    return assign$1({}, waypoint);
  }
  function copyWaypoints(connection) {
    return map$1(connection.waypoints, function (waypoint) {
      waypoint = copyWaypoint(waypoint);
      if (waypoint.original) {
        waypoint.original = copyWaypoint(waypoint.original);
      }
      return waypoint;
    });
  }
  function getAxisFromDirection(direction) {
    switch (direction) {
      case 'n':
        return 'y';
      case 'w':
        return 'x';
      case 's':
        return 'y';
      case 'e':
        return 'x';
    }
  }
  function shouldMoveWaypoint(waypoint, start, direction) {
    var relevantAxis = getAxisFromDirection(direction);
    if (/e|s/.test(direction)) {
      return waypoint[relevantAxis] > start;
    } else if (/n|w/.test(direction)) {
      return waypoint[relevantAxis] < start;
    }
  }
  function includes$1(array, item) {
    return array.indexOf(item) !== -1;
  }
  function getBounds(shape) {
    return {
      x: shape.x,
      y: shape.y,
      height: shape.height,
      width: shape.width
    };
  }
  function ToggleShapeCollapseHandler(modeling) {
    this._modeling = modeling;
  }
  ToggleShapeCollapseHandler.$inject = ['modeling'];
  ToggleShapeCollapseHandler.prototype.execute = function (context) {
    var shape = context.shape,
      children = shape.children;
    context.oldChildrenVisibility = getElementsVisibilityRecursive(children);
    shape.collapsed = !shape.collapsed;
    var result = setHiddenRecursive(children, shape.collapsed);
    return [shape].concat(result);
  };
  ToggleShapeCollapseHandler.prototype.revert = function (context) {
    var shape = context.shape,
      oldChildrenVisibility = context.oldChildrenVisibility;
    var children = shape.children;
    var result = restoreVisibilityRecursive(children, oldChildrenVisibility);
    shape.collapsed = !shape.collapsed;
    return [shape].concat(result);
  };
  function getElementsVisibilityRecursive(elements) {
    var result = {};
    forEach$1(elements, function (element) {
      result[element.id] = element.hidden;
      if (element.children) {
        result = assign$1({}, result, getElementsVisibilityRecursive(element.children));
      }
    });
    return result;
  }
  function setHiddenRecursive(elements, newHidden) {
    var result = [];
    forEach$1(elements, function (element) {
      element.hidden = newHidden;
      result = result.concat(element);
      if (element.children) {
        result = result.concat(setHiddenRecursive(element.children, element.collapsed || newHidden));
      }
    });
    return result;
  }
  function restoreVisibilityRecursive(elements, lastState) {
    var result = [];
    forEach$1(elements, function (element) {
      element.hidden = lastState[element.id];
      result = result.concat(element);
      if (element.children) {
        result = result.concat(restoreVisibilityRecursive(element.children, lastState));
      }
    });
    return result;
  }
  function UpdateAttachmentHandler(modeling) {
    this._modeling = modeling;
  }
  UpdateAttachmentHandler.$inject = ['modeling'];
  UpdateAttachmentHandler.prototype.execute = function (context) {
    var shape = context.shape,
      newHost = context.newHost,
      oldHost = shape.host;
    context.oldHost = oldHost;
    context.attacherIdx = removeAttacher(oldHost, shape);
    addAttacher(newHost, shape);
    shape.host = newHost;
    return shape;
  };
  UpdateAttachmentHandler.prototype.revert = function (context) {
    var shape = context.shape,
      newHost = context.newHost,
      oldHost = context.oldHost,
      attacherIdx = context.attacherIdx;
    shape.host = oldHost;
    removeAttacher(newHost, shape);
    addAttacher(oldHost, shape, attacherIdx);
    return shape;
  };
  function removeAttacher(host, attacher) {
    return remove(host && host.attachers, attacher);
  }
  function addAttacher(host, attacher, idx) {
    if (!host) {
      return;
    }
    var attachers = host.attachers;
    if (!attachers) {
      host.attachers = attachers = [];
    }
    add(attachers, attacher, idx);
  }
  function UpdateWaypointsHandler() {}
  UpdateWaypointsHandler.prototype.execute = function (context) {
    var connection = context.connection,
      newWaypoints = context.newWaypoints;
    context.oldWaypoints = connection.waypoints;
    connection.waypoints = newWaypoints;
    return connection;
  };
  UpdateWaypointsHandler.prototype.revert = function (context) {
    var connection = context.connection,
      oldWaypoints = context.oldWaypoints;
    connection.waypoints = oldWaypoints;
    return connection;
  };
  function Modeling$1(eventBus, elementFactory, commandStack) {
    this._eventBus = eventBus;
    this._elementFactory = elementFactory;
    this._commandStack = commandStack;
    var self = this;
    eventBus.on('diagram.init', function () {
      self.registerHandlers(commandStack);
    });
  }
  Modeling$1.$inject = ['eventBus', 'elementFactory', 'commandStack'];
  Modeling$1.prototype.getHandlers = function () {
    return {
      'shape.append': AppendShapeHandler,
      'shape.create': CreateShapeHandler,
      'shape.delete': DeleteShapeHandler,
      'shape.move': MoveShapeHandler,
      'shape.resize': ResizeShapeHandler,
      'shape.replace': ReplaceShapeHandler,
      'shape.toggleCollapse': ToggleShapeCollapseHandler,
      'spaceTool': SpaceToolHandler,
      'label.create': CreateLabelHandler,
      'connection.create': CreateConnectionHandler,
      'connection.delete': DeleteConnectionHandler,
      'connection.move': MoveConnectionHandler,
      'connection.layout': LayoutConnectionHandler,
      'connection.updateWaypoints': UpdateWaypointsHandler,
      'connection.reconnect': ReconnectConnectionHandler,
      'elements.create': CreateElementsHandler,
      'elements.move': MoveElementsHandler,
      'elements.delete': DeleteElementsHandler,
      'elements.distribute': DistributeElements$1,
      'elements.align': AlignElements,
      'element.updateAttachment': UpdateAttachmentHandler
    };
  };
  Modeling$1.prototype.registerHandlers = function (commandStack) {
    forEach$1(this.getHandlers(), function (handler, id) {
      commandStack.registerHandler(id, handler);
    });
  };
  Modeling$1.prototype.moveShape = function (shape, delta, newParent, newParentIndex, hints) {
    if (typeof newParentIndex === 'object') {
      hints = newParentIndex;
      newParentIndex = null;
    }
    var context = {
      shape: shape,
      delta: delta,
      newParent: newParent,
      newParentIndex: newParentIndex,
      hints: hints || {}
    };
    this._commandStack.execute('shape.move', context);
  };
  Modeling$1.prototype.updateAttachment = function (shape, newHost) {
    var context = {
      shape: shape,
      newHost: newHost
    };
    this._commandStack.execute('element.updateAttachment', context);
  };
  Modeling$1.prototype.moveElements = function (shapes, delta, target, hints) {
    hints = hints || {};
    var attach = hints.attach;
    var newParent = target,
      newHost;
    if (attach === true) {
      newHost = target;
      newParent = target.parent;
    } else if (attach === false) {
      newHost = null;
    }
    var context = {
      shapes: shapes,
      delta: delta,
      newParent: newParent,
      newHost: newHost,
      hints: hints
    };
    this._commandStack.execute('elements.move', context);
  };
  Modeling$1.prototype.moveConnection = function (connection, delta, newParent, newParentIndex, hints) {
    if (typeof newParentIndex === 'object') {
      hints = newParentIndex;
      newParentIndex = undefined;
    }
    var context = {
      connection: connection,
      delta: delta,
      newParent: newParent,
      newParentIndex: newParentIndex,
      hints: hints || {}
    };
    this._commandStack.execute('connection.move', context);
  };
  Modeling$1.prototype.layoutConnection = function (connection, hints) {
    var context = {
      connection: connection,
      hints: hints || {}
    };
    this._commandStack.execute('connection.layout', context);
  };
  Modeling$1.prototype.createConnection = function (source, target, parentIndex, connection, parent, hints) {
    if (typeof parentIndex === 'object') {
      hints = parent;
      parent = connection;
      connection = parentIndex;
      parentIndex = undefined;
    }
    connection = this._create('connection', connection);
    var context = {
      source: source,
      target: target,
      parent: parent,
      parentIndex: parentIndex,
      connection: connection,
      hints: hints
    };
    this._commandStack.execute('connection.create', context);
    return context.connection;
  };
  Modeling$1.prototype.createShape = function (shape, position, target, parentIndex, hints) {
    if (typeof parentIndex !== 'number') {
      hints = parentIndex;
      parentIndex = undefined;
    }
    hints = hints || {};
    var attach = hints.attach,
      parent,
      host;
    shape = this._create('shape', shape);
    if (attach) {
      parent = target.parent;
      host = target;
    } else {
      parent = target;
    }
    var context = {
      position: position,
      shape: shape,
      parent: parent,
      parentIndex: parentIndex,
      host: host,
      hints: hints
    };
    this._commandStack.execute('shape.create', context);
    return context.shape;
  };
  Modeling$1.prototype.createElements = function (elements, position, parent, parentIndex, hints) {
    if (!isArray$3(elements)) {
      elements = [elements];
    }
    if (typeof parentIndex !== 'number') {
      hints = parentIndex;
      parentIndex = undefined;
    }
    hints = hints || {};
    var context = {
      position: position,
      elements: elements,
      parent: parent,
      parentIndex: parentIndex,
      hints: hints
    };
    this._commandStack.execute('elements.create', context);
    return context.elements;
  };
  Modeling$1.prototype.createLabel = function (labelTarget, position, label, parent) {
    label = this._create('label', label);
    var context = {
      labelTarget: labelTarget,
      position: position,
      parent: parent || labelTarget.parent,
      shape: label
    };
    this._commandStack.execute('label.create', context);
    return context.shape;
  };
  Modeling$1.prototype.appendShape = function (source, shape, position, target, hints) {
    hints = hints || {};
    shape = this._create('shape', shape);
    var context = {
      source: source,
      position: position,
      target: target,
      shape: shape,
      connection: hints.connection,
      connectionParent: hints.connectionParent,
      hints: hints
    };
    this._commandStack.execute('shape.append', context);
    return context.shape;
  };
  Modeling$1.prototype.removeElements = function (elements) {
    var context = {
      elements: elements
    };
    this._commandStack.execute('elements.delete', context);
  };
  Modeling$1.prototype.distributeElements = function (groups, axis, dimension) {
    var context = {
      groups: groups,
      axis: axis,
      dimension: dimension
    };
    this._commandStack.execute('elements.distribute', context);
  };
  Modeling$1.prototype.removeShape = function (shape, hints) {
    var context = {
      shape: shape,
      hints: hints || {}
    };
    this._commandStack.execute('shape.delete', context);
  };
  Modeling$1.prototype.removeConnection = function (connection, hints) {
    var context = {
      connection: connection,
      hints: hints || {}
    };
    this._commandStack.execute('connection.delete', context);
  };
  Modeling$1.prototype.replaceShape = function (oldShape, newShape, hints) {
    var context = {
      oldShape: oldShape,
      newData: newShape,
      hints: hints || {}
    };
    this._commandStack.execute('shape.replace', context);
    return context.newShape;
  };
  Modeling$1.prototype.alignElements = function (elements, alignment) {
    var context = {
      elements: elements,
      alignment: alignment
    };
    this._commandStack.execute('elements.align', context);
  };
  Modeling$1.prototype.resizeShape = function (shape, newBounds, minBounds, hints) {
    var context = {
      shape: shape,
      newBounds: newBounds,
      minBounds: minBounds,
      hints: hints
    };
    this._commandStack.execute('shape.resize', context);
  };
  Modeling$1.prototype.createSpace = function (movingShapes, resizingShapes, delta, direction, start) {
    var context = {
      delta: delta,
      direction: direction,
      movingShapes: movingShapes,
      resizingShapes: resizingShapes,
      start: start
    };
    this._commandStack.execute('spaceTool', context);
  };
  Modeling$1.prototype.updateWaypoints = function (connection, newWaypoints, hints) {
    var context = {
      connection: connection,
      newWaypoints: newWaypoints,
      hints: hints || {}
    };
    this._commandStack.execute('connection.updateWaypoints', context);
  };
  Modeling$1.prototype.reconnect = function (connection, source, target, dockingOrPoints, hints) {
    var context = {
      connection: connection,
      newSource: source,
      newTarget: target,
      dockingOrPoints: dockingOrPoints,
      hints: hints || {}
    };
    this._commandStack.execute('connection.reconnect', context);
  };
  Modeling$1.prototype.reconnectStart = function (connection, newSource, dockingOrPoints, hints) {
    if (!hints) {
      hints = {};
    }
    this.reconnect(connection, newSource, connection.target, dockingOrPoints, assign$1(hints, {
      docking: 'source'
    }));
  };
  Modeling$1.prototype.reconnectEnd = function (connection, newTarget, dockingOrPoints, hints) {
    if (!hints) {
      hints = {};
    }
    this.reconnect(connection, connection.source, newTarget, dockingOrPoints, assign$1(hints, {
      docking: 'target'
    }));
  };
  Modeling$1.prototype.connect = function (source, target, attrs, hints) {
    return this.createConnection(source, target, attrs || {}, source.parent, hints);
  };
  Modeling$1.prototype._create = function (type, attrs) {
    if (isModelElement(attrs)) {
      return attrs;
    } else {
      return this._elementFactory.create(type, attrs);
    }
  };
  Modeling$1.prototype.toggleCollapse = function (shape, hints) {
    var context = {
      shape: shape,
      hints: hints || {}
    };
    this._commandStack.execute('shape.toggleCollapse', context);
  };
  function UpdateModdlePropertiesHandler(elementRegistry) {
    this._elementRegistry = elementRegistry;
  }
  UpdateModdlePropertiesHandler.$inject = ['elementRegistry'];
  UpdateModdlePropertiesHandler.prototype.execute = function (context) {
    var element = context.element,
      moddleElement = context.moddleElement,
      properties = context.properties;
    if (!moddleElement) {
      throw new Error('<moddleElement> required');
    }
    var changed = context.changed || this._getVisualReferences(moddleElement).concat(element);
    var oldProperties = context.oldProperties || getModdleProperties(moddleElement, keys(properties));
    setModdleProperties(moddleElement, properties);
    context.oldProperties = oldProperties;
    context.changed = changed;
    return changed;
  };
  UpdateModdlePropertiesHandler.prototype.revert = function (context) {
    var oldProperties = context.oldProperties,
      moddleElement = context.moddleElement,
      changed = context.changed;
    setModdleProperties(moddleElement, oldProperties);
    return changed;
  };
  UpdateModdlePropertiesHandler.prototype._getVisualReferences = function (moddleElement) {
    var elementRegistry = this._elementRegistry;
    if (is(moddleElement, 'bpmn:DataObject')) {
      return getAllDataObjectReferences(moddleElement, elementRegistry);
    }
    return [];
  };
  function getModdleProperties(moddleElement, propertyNames) {
    return reduce(propertyNames, function (result, key) {
      result[key] = moddleElement.get(key);
      return result;
    }, {});
  }
  function setModdleProperties(moddleElement, properties) {
    forEach$1(properties, function (value, key) {
      moddleElement.set(key, value);
    });
  }
  function getAllDataObjectReferences(dataObject, elementRegistry) {
    return elementRegistry.filter(function (element) {
      return is(element, 'bpmn:DataObjectReference') && getBusinessObject(element).dataObjectRef === dataObject;
    });
  }
  var DEFAULT_FLOW = 'default',
    ID = 'id',
    DI = 'di';
  var NULL_DIMENSIONS$1 = {
    width: 0,
    height: 0
  };
  function UpdatePropertiesHandler(elementRegistry, moddle, modeling, textRenderer) {
    this._elementRegistry = elementRegistry;
    this._moddle = moddle;
    this._modeling = modeling;
    this._textRenderer = textRenderer;
  }
  UpdatePropertiesHandler.$inject = ['elementRegistry', 'moddle', 'modeling', 'textRenderer'];
  UpdatePropertiesHandler.prototype.execute = function (context) {
    var element = context.element,
      changed = [element];
    if (!element) {
      throw new Error('element required');
    }
    var elementRegistry = this._elementRegistry,
      ids = this._moddle.ids;
    var businessObject = element.businessObject,
      properties = unwrapBusinessObjects(context.properties),
      oldProperties = context.oldProperties || getProperties(element, properties);
    if (isIdChange(properties, businessObject)) {
      ids.unclaim(businessObject[ID]);
      elementRegistry.updateId(element, properties[ID]);
      ids.claim(properties[ID], businessObject);
    }
    if (DEFAULT_FLOW in properties) {
      if (properties[DEFAULT_FLOW]) {
        changed.push(elementRegistry.get(properties[DEFAULT_FLOW].id));
      }
      if (businessObject[DEFAULT_FLOW]) {
        changed.push(elementRegistry.get(businessObject[DEFAULT_FLOW].id));
      }
    }
    setProperties(element, properties);
    context.oldProperties = oldProperties;
    context.changed = changed;
    return changed;
  };
  UpdatePropertiesHandler.prototype.postExecute = function (context) {
    var element = context.element,
      label = element.label;
    var text = label && getBusinessObject(label).name;
    if (!text) {
      return;
    }
    var newLabelBounds = this._textRenderer.getExternalLabelBounds(label, text);
    this._modeling.resizeShape(label, newLabelBounds, NULL_DIMENSIONS$1);
  };
  UpdatePropertiesHandler.prototype.revert = function (context) {
    var element = context.element,
      properties = context.properties,
      oldProperties = context.oldProperties,
      businessObject = element.businessObject,
      elementRegistry = this._elementRegistry,
      ids = this._moddle.ids;
    setProperties(element, oldProperties);
    if (isIdChange(properties, businessObject)) {
      ids.unclaim(properties[ID]);
      elementRegistry.updateId(element, oldProperties[ID]);
      ids.claim(oldProperties[ID], businessObject);
    }
    return context.changed;
  };
  function isIdChange(properties, businessObject) {
    return ID in properties && properties[ID] !== businessObject[ID];
  }
  function getProperties(element, properties) {
    var propertyNames = keys(properties),
      businessObject = element.businessObject,
      di = getDi(element);
    return reduce(propertyNames, function (result, key) {
      if (key !== DI) {
        result[key] = businessObject.get(key);
      } else {
        result[key] = getDiProperties(di, keys(properties.di));
      }
      return result;
    }, {});
  }
  function getDiProperties(di, propertyNames) {
    return reduce(propertyNames, function (result, key) {
      result[key] = di && di.get(key);
      return result;
    }, {});
  }
  function setProperties(element, properties) {
    var businessObject = element.businessObject,
      di = getDi(element);
    forEach$1(properties, function (value, key) {
      if (key !== DI) {
        businessObject.set(key, value);
      } else {
        if (di) {
          setDiProperties(di, value);
        }
      }
    });
  }
  function setDiProperties(di, properties) {
    forEach$1(properties, function (value, key) {
      di.set(key, value);
    });
  }
  var referencePropertyNames = ['default'];
  function unwrapBusinessObjects(properties) {
    var unwrappedProps = assign$1({}, properties);
    referencePropertyNames.forEach(function (name) {
      if (name in properties) {
        unwrappedProps[name] = getBusinessObject(unwrappedProps[name]);
      }
    });
    return unwrappedProps;
  }
  function UpdateCanvasRootHandler(canvas, modeling) {
    this._canvas = canvas;
    this._modeling = modeling;
  }
  UpdateCanvasRootHandler.$inject = ['canvas', 'modeling'];
  UpdateCanvasRootHandler.prototype.execute = function (context) {
    var canvas = this._canvas;
    var newRoot = context.newRoot,
      newRootBusinessObject = newRoot.businessObject,
      oldRoot = canvas.getRootElement(),
      oldRootBusinessObject = oldRoot.businessObject,
      bpmnDefinitions = oldRootBusinessObject.$parent,
      diPlane = getDi(oldRoot);
    canvas.setRootElement(newRoot);
    canvas.removeRootElement(oldRoot);
    add(bpmnDefinitions.rootElements, newRootBusinessObject);
    newRootBusinessObject.$parent = bpmnDefinitions;
    remove(bpmnDefinitions.rootElements, oldRootBusinessObject);
    oldRootBusinessObject.$parent = null;
    oldRoot.di = null;
    diPlane.bpmnElement = newRootBusinessObject;
    newRoot.di = diPlane;
    context.oldRoot = oldRoot;
    return [];
  };
  UpdateCanvasRootHandler.prototype.revert = function (context) {
    var canvas = this._canvas;
    var newRoot = context.newRoot,
      newRootBusinessObject = newRoot.businessObject,
      oldRoot = context.oldRoot,
      oldRootBusinessObject = oldRoot.businessObject,
      bpmnDefinitions = newRootBusinessObject.$parent,
      diPlane = getDi(newRoot);
    canvas.setRootElement(oldRoot);
    canvas.removeRootElement(newRoot);
    remove(bpmnDefinitions.rootElements, newRootBusinessObject);
    newRootBusinessObject.$parent = null;
    add(bpmnDefinitions.rootElements, oldRootBusinessObject);
    oldRootBusinessObject.$parent = bpmnDefinitions;
    newRoot.di = null;
    diPlane.bpmnElement = oldRootBusinessObject;
    oldRoot.di = diPlane;
    return [];
  };
  function AddLaneHandler(modeling, spaceTool) {
    this._modeling = modeling;
    this._spaceTool = spaceTool;
  }
  AddLaneHandler.$inject = ['modeling', 'spaceTool'];
  AddLaneHandler.prototype.preExecute = function (context) {
    var spaceTool = this._spaceTool,
      modeling = this._modeling;
    var shape = context.shape,
      location = context.location;
    var lanesRoot = getLanesRoot(shape);
    var isRoot = lanesRoot === shape,
      laneParent = isRoot ? shape : shape.parent;
    var existingChildLanes = getChildLanes(laneParent);
    var isHorizontalLane = isHorizontal$3(shape);
    if (isHorizontalLane) {
      if (location === 'left') {
        location = 'top';
      } else if (location === 'right') {
        location = 'bottom';
      }
    } else {
      if (location === 'top') {
        location = 'left';
      } else if (location === 'bottom') {
        location = 'right';
      }
    }
    if (!existingChildLanes.length) {
      var siblingPosition = isHorizontalLane ? {
        x: shape.x + LANE_INDENTATION,
        y: shape.y,
        width: shape.width - LANE_INDENTATION,
        height: shape.height
      } : {
        x: shape.x,
        y: shape.y + LANE_INDENTATION,
        width: shape.width,
        height: shape.height - LANE_INDENTATION
      };
      modeling.createShape({
        type: 'bpmn:Lane',
        isHorizontal: isHorizontalLane
      }, siblingPosition, laneParent);
    }
    var allAffected = [];
    eachElement(lanesRoot, function (element) {
      allAffected.push(element);
      if (element.label) {
        allAffected.push(element.label);
      }
      if (element === shape) {
        return [];
      }
      return filter(element.children, function (c) {
        return c !== shape;
      });
    });
    var offset, lanePosition, spacePos, direction, axis;
    if (location === 'top') {
      offset = -120;
      lanePosition = shape.y;
      spacePos = lanePosition + 10;
      direction = 'n';
      axis = 'y';
    } else if (location === 'left') {
      offset = -120;
      lanePosition = shape.x;
      spacePos = lanePosition + 10;
      direction = 'w';
      axis = 'x';
    } else if (location === 'bottom') {
      offset = 120;
      lanePosition = shape.y + shape.height;
      spacePos = lanePosition - 10;
      direction = 's';
      axis = 'y';
    } else if (location === 'right') {
      offset = 120;
      lanePosition = shape.x + shape.width;
      spacePos = lanePosition - 10;
      direction = 'e';
      axis = 'x';
    }
    var adjustments = spaceTool.calculateAdjustments(allAffected, axis, offset, spacePos);
    var delta = isHorizontalLane ? {
      x: 0,
      y: offset
    } : {
      x: offset,
      y: 0
    };
    spaceTool.makeSpace(adjustments.movingShapes, adjustments.resizingShapes, delta, direction, spacePos);
    var newLanePosition = isHorizontalLane ? {
      x: shape.x + (isRoot ? LANE_INDENTATION : 0),
      y: lanePosition - (location === 'top' ? 120 : 0),
      width: shape.width - (isRoot ? LANE_INDENTATION : 0),
      height: 120
    } : {
      x: lanePosition - (location === 'left' ? 120 : 0),
      y: shape.y + (isRoot ? LANE_INDENTATION : 0),
      width: 120,
      height: shape.height - (isRoot ? LANE_INDENTATION : 0)
    };
    context.newLane = modeling.createShape({
      type: 'bpmn:Lane',
      isHorizontal: isHorizontalLane
    }, newLanePosition, laneParent);
  };
  function SplitLaneHandler(modeling) {
    this._modeling = modeling;
  }
  SplitLaneHandler.$inject = ['modeling'];
  SplitLaneHandler.prototype.preExecute = function (context) {
    var modeling = this._modeling;
    var shape = context.shape,
      newLanesCount = context.count;
    var childLanes = getChildLanes(shape),
      existingLanesCount = childLanes.length;
    if (existingLanesCount > newLanesCount) {
      throw new Error(`more than <${newLanesCount}> child lanes`);
    }
    var isHorizontalLane = isHorizontal$3(shape);
    var laneBaseSize = isHorizontalLane ? shape.height : shape.width;
    var newLanesSize = Math.round(laneBaseSize / newLanesCount);
    var laneSize, laneBounds, newLaneAttrs, idx;
    for (idx = 0; idx < newLanesCount; idx++) {
      if (idx === newLanesCount - 1) {
        laneSize = laneBaseSize - newLanesSize * idx;
      } else {
        laneSize = newLanesSize;
      }
      laneBounds = isHorizontalLane ? {
        x: shape.x + LANE_INDENTATION,
        y: shape.y + idx * newLanesSize,
        width: shape.width - LANE_INDENTATION,
        height: laneSize
      } : {
        x: shape.x + idx * newLanesSize,
        y: shape.y + LANE_INDENTATION,
        width: laneSize,
        height: shape.height - LANE_INDENTATION
      };
      if (idx < existingLanesCount) {
        modeling.resizeShape(childLanes[idx], laneBounds);
      } else {
        newLaneAttrs = {
          type: 'bpmn:Lane',
          isHorizontal: isHorizontalLane
        };
        modeling.createShape(newLaneAttrs, laneBounds, shape);
      }
    }
  };
  function ResizeLaneHandler(modeling, spaceTool) {
    this._modeling = modeling;
    this._spaceTool = spaceTool;
  }
  ResizeLaneHandler.$inject = ['modeling', 'spaceTool'];
  ResizeLaneHandler.prototype.preExecute = function (context) {
    var shape = context.shape,
      newBounds = context.newBounds,
      balanced = context.balanced;
    if (balanced !== false) {
      this.resizeBalanced(shape, newBounds);
    } else {
      this.resizeSpace(shape, newBounds);
    }
  };
  ResizeLaneHandler.prototype.resizeBalanced = function (shape, newBounds) {
    var modeling = this._modeling;
    var resizeNeeded = computeLanesResize(shape, newBounds);
    modeling.resizeShape(shape, newBounds);
    resizeNeeded.forEach(function (r) {
      modeling.resizeShape(r.shape, r.newBounds);
    });
  };
  ResizeLaneHandler.prototype.resizeSpace = function (shape, newBounds) {
    var spaceTool = this._spaceTool;
    var shapeTrbl = asTRBL(shape),
      newTrbl = asTRBL(newBounds);
    var trblDiff = substractTRBL(newTrbl, shapeTrbl);
    var lanesRoot = getLanesRoot(shape);
    var allAffected = [],
      allLanes = [];
    eachElement(lanesRoot, function (element) {
      allAffected.push(element);
      if (is(element, 'bpmn:Lane') || is(element, 'bpmn:Participant')) {
        allLanes.push(element);
      }
      return element.children;
    });
    var change, spacePos, direction, offset, adjustments;
    if (trblDiff.bottom || trblDiff.top) {
      change = trblDiff.bottom || trblDiff.top;
      spacePos = shape.y + (trblDiff.bottom ? shape.height : 0) + (trblDiff.bottom ? -10 : 10);
      direction = trblDiff.bottom ? 's' : 'n';
      offset = trblDiff.top > 0 || trblDiff.bottom < 0 ? -change : change;
      adjustments = spaceTool.calculateAdjustments(allAffected, 'y', offset, spacePos);
      spaceTool.makeSpace(adjustments.movingShapes, adjustments.resizingShapes, {
        x: 0,
        y: change
      }, direction);
    }
    if (trblDiff.left || trblDiff.right) {
      change = trblDiff.right || trblDiff.left;
      spacePos = shape.x + (trblDiff.right ? shape.width : 0) + (trblDiff.right ? -10 : 100);
      direction = trblDiff.right ? 'e' : 'w';
      offset = trblDiff.left > 0 || trblDiff.right < 0 ? -change : change;
      adjustments = spaceTool.calculateAdjustments(allLanes, 'x', offset, spacePos);
      spaceTool.makeSpace(adjustments.movingShapes, adjustments.resizingShapes, {
        x: change,
        y: 0
      }, direction);
    }
  };
  var FLOW_NODE_REFS_ATTR = 'flowNodeRef',
    LANES_ATTR = 'lanes';
  function UpdateFlowNodeRefsHandler(elementRegistry) {
    this._elementRegistry = elementRegistry;
  }
  UpdateFlowNodeRefsHandler.$inject = ['elementRegistry'];
  UpdateFlowNodeRefsHandler.prototype._computeUpdates = function (flowNodeShapes, laneShapes) {
    var handledNodes = [];
    var updates = [];
    var participantCache = {};
    var allFlowNodeShapes = [];
    function isInLaneShape(element, laneShape) {
      var laneTrbl = asTRBL(laneShape);
      var elementMid = {
        x: element.x + element.width / 2,
        y: element.y + element.height / 2
      };
      return elementMid.x > laneTrbl.left && elementMid.x < laneTrbl.right && elementMid.y > laneTrbl.top && elementMid.y < laneTrbl.bottom;
    }
    function addFlowNodeShape(flowNodeShape) {
      if (handledNodes.indexOf(flowNodeShape) === -1) {
        allFlowNodeShapes.push(flowNodeShape);
        handledNodes.push(flowNodeShape);
      }
    }
    function getAllLaneShapes(flowNodeShape) {
      var root = getLanesRoot(flowNodeShape);
      if (!participantCache[root.id]) {
        participantCache[root.id] = collectLanes(root);
      }
      return participantCache[root.id];
    }
    function getNewLanes(flowNodeShape) {
      if (!flowNodeShape.parent) {
        return [];
      }
      var allLaneShapes = getAllLaneShapes(flowNodeShape);
      return allLaneShapes.filter(function (l) {
        return isInLaneShape(flowNodeShape, l);
      }).map(function (shape) {
        return shape.businessObject;
      });
    }
    laneShapes.forEach(function (laneShape) {
      var root = getLanesRoot(laneShape);
      if (!root || handledNodes.indexOf(root) !== -1) {
        return;
      }
      var children = root.children.filter(function (c) {
        return is(c, 'bpmn:FlowNode');
      });
      children.forEach(addFlowNodeShape);
      handledNodes.push(root);
    });
    flowNodeShapes.forEach(addFlowNodeShape);
    allFlowNodeShapes.forEach(function (flowNodeShape) {
      var flowNode = flowNodeShape.businessObject;
      var lanes = flowNode.get(LANES_ATTR),
        remove = lanes.slice(),
        add = getNewLanes(flowNodeShape);
      updates.push({
        flowNode: flowNode,
        remove: remove,
        add: add
      });
    });
    laneShapes.forEach(function (laneShape) {
      var lane = laneShape.businessObject;
      if (!laneShape.parent) {
        lane.get(FLOW_NODE_REFS_ATTR).forEach(function (flowNode) {
          updates.push({
            flowNode: flowNode,
            remove: [lane],
            add: []
          });
        });
      }
    });
    return updates;
  };
  UpdateFlowNodeRefsHandler.prototype.execute = function (context) {
    var updates = context.updates;
    if (!updates) {
      updates = context.updates = this._computeUpdates(context.flowNodeShapes, context.laneShapes);
    }
    updates.forEach(function (update) {
      var flowNode = update.flowNode,
        lanes = flowNode.get(LANES_ATTR);
      update.remove.forEach(function (oldLane) {
        remove(lanes, oldLane);
        remove(oldLane.get(FLOW_NODE_REFS_ATTR), flowNode);
      });
      update.add.forEach(function (newLane) {
        add(lanes, newLane);
        add(newLane.get(FLOW_NODE_REFS_ATTR), flowNode);
      });
    });
    return [];
  };
  UpdateFlowNodeRefsHandler.prototype.revert = function (context) {
    var updates = context.updates;
    updates.forEach(function (update) {
      var flowNode = update.flowNode,
        lanes = flowNode.get(LANES_ATTR);
      update.add.forEach(function (newLane) {
        remove(lanes, newLane);
        remove(newLane.get(FLOW_NODE_REFS_ATTR), flowNode);
      });
      update.remove.forEach(function (oldLane) {
        add(lanes, oldLane);
        add(oldLane.get(FLOW_NODE_REFS_ATTR), flowNode);
      });
    });
    return [];
  };
  function IdClaimHandler(moddle) {
    this._moddle = moddle;
  }
  IdClaimHandler.$inject = ['moddle'];
  IdClaimHandler.prototype.execute = function (context) {
    var ids = this._moddle.ids,
      id = context.id,
      element = context.element,
      claiming = context.claiming;
    if (claiming) {
      ids.claim(id, element);
    } else {
      ids.unclaim(id);
    }
    return [];
  };
  IdClaimHandler.prototype.revert = function (context) {
    var ids = this._moddle.ids,
      id = context.id,
      element = context.element,
      claiming = context.claiming;
    if (claiming) {
      ids.unclaim(id);
    } else {
      ids.claim(id, element);
    }
    return [];
  };
  var DEFAULT_COLORS = {
    fill: undefined,
    stroke: undefined
  };
  function SetColorHandler(commandStack) {
    this._commandStack = commandStack;
    this._normalizeColor = function (color) {
      if (!color) {
        return undefined;
      }
      if (isString(color)) {
        var hexColor = colorToHex(color);
        if (hexColor) {
          return hexColor;
        }
      }
      throw new Error(`invalid color value: ${color}`);
    };
  }
  SetColorHandler.$inject = ['commandStack'];
  SetColorHandler.prototype.postExecute = function (context) {
    var elements = context.elements,
      colors = context.colors || DEFAULT_COLORS;
    var self = this;
    var di = {};
    if ('fill' in colors) {
      assign$1(di, {
        'background-color': this._normalizeColor(colors.fill)
      });
    }
    if ('stroke' in colors) {
      assign$1(di, {
        'border-color': this._normalizeColor(colors.stroke)
      });
    }
    forEach$1(elements, function (element) {
      var assignedDi = isConnection(element) ? pick(di, ['border-color']) : di,
        elementDi = getDi(element);
      ensureLegacySupport(assignedDi);
      if (isLabel(element)) {
        self._commandStack.execute('element.updateModdleProperties', {
          element: element,
          moddleElement: elementDi.label,
          properties: {
            color: di['border-color']
          }
        });
      } else {
        if (!isAny(elementDi, ['bpmndi:BPMNEdge', 'bpmndi:BPMNShape'])) {
          return;
        }
        self._commandStack.execute('element.updateProperties', {
          element: element,
          properties: {
            di: assignedDi
          }
        });
      }
    });
  };
  function colorToHex(color) {
    var context = document.createElement('canvas').getContext('2d');
    context.fillStyle = 'transparent';
    context.fillStyle = color;
    return /^#[0-9a-fA-F]{6}$/.test(context.fillStyle) ? context.fillStyle : null;
  }
  function ensureLegacySupport(di) {
    if ('border-color' in di) {
      di.stroke = di['border-color'];
    }
    if ('background-color' in di) {
      di.fill = di['background-color'];
    }
  }
  var NULL_DIMENSIONS = {
    width: 0,
    height: 0
  };
  function UpdateLabelHandler(modeling, textRenderer, bpmnFactory) {
    function setText(element, text) {
      var label = element.label || element;
      var labelTarget = element.labelTarget || element;
      setLabel(label, text);
      return [label, labelTarget];
    }
    function preExecute(ctx) {
      var element = ctx.element,
        businessObject = element.businessObject,
        newLabel = ctx.newLabel;
      if (!isLabel(element) && isLabelExternal(element) && !hasExternalLabel(element) && !isEmptyText$1(newLabel)) {
        var paddingTop = 7;
        var labelCenter = getExternalLabelMid(element);
        labelCenter = {
          x: labelCenter.x,
          y: labelCenter.y + paddingTop
        };
        modeling.createLabel(element, labelCenter, {
          id: businessObject.id + '_label',
          businessObject: businessObject,
          di: element.di
        });
      }
    }
    function execute(ctx) {
      ctx.oldLabel = getLabel(ctx.element);
      return setText(ctx.element, ctx.newLabel);
    }
    function revert(ctx) {
      return setText(ctx.element, ctx.oldLabel);
    }
    function postExecute(ctx) {
      var element = ctx.element,
        label = element.label || element,
        newLabel = ctx.newLabel,
        newBounds = ctx.newBounds,
        hints = ctx.hints || {};
      if (!isLabel(label) && !is(label, 'bpmn:TextAnnotation')) {
        return;
      }
      if (isLabel(label) && isEmptyText$1(newLabel)) {
        if (hints.removeShape !== false) {
          modeling.removeShape(label, {
            unsetLabel: false
          });
        }
        return;
      }
      var text = getLabel(element);
      if (typeof newBounds === 'undefined') {
        newBounds = textRenderer.getExternalLabelBounds(label, text);
      }
      if (newBounds) {
        modeling.resizeShape(label, newBounds, NULL_DIMENSIONS);
      }
    }
    this.preExecute = preExecute;
    this.execute = execute;
    this.revert = revert;
    this.postExecute = postExecute;
  }
  UpdateLabelHandler.$inject = ['modeling', 'textRenderer', 'bpmnFactory'];
  function isEmptyText$1(label) {
    return !label || !label.trim();
  }
  function Modeling(eventBus, elementFactory, commandStack, bpmnRules) {
    Modeling$1.call(this, eventBus, elementFactory, commandStack);
    this._bpmnRules = bpmnRules;
  }
  e$2(Modeling, Modeling$1);
  Modeling.$inject = ['eventBus', 'elementFactory', 'commandStack', 'bpmnRules'];
  Modeling.prototype.getHandlers = function () {
    var handlers = Modeling$1.prototype.getHandlers.call(this);
    handlers['element.updateModdleProperties'] = UpdateModdlePropertiesHandler;
    handlers['element.updateProperties'] = UpdatePropertiesHandler;
    handlers['canvas.updateRoot'] = UpdateCanvasRootHandler;
    handlers['lane.add'] = AddLaneHandler;
    handlers['lane.resize'] = ResizeLaneHandler;
    handlers['lane.split'] = SplitLaneHandler;
    handlers['lane.updateRefs'] = UpdateFlowNodeRefsHandler;
    handlers['id.updateClaim'] = IdClaimHandler;
    handlers['element.setColor'] = SetColorHandler;
    handlers['element.updateLabel'] = UpdateLabelHandler;
    return handlers;
  };
  Modeling.prototype.updateLabel = function (element, newLabel, newBounds, hints) {
    this._commandStack.execute('element.updateLabel', {
      element: element,
      newLabel: newLabel,
      newBounds: newBounds,
      hints: hints || {}
    });
  };
  Modeling.prototype.connect = function (source, target, attrs, hints) {
    var bpmnRules = this._bpmnRules;
    if (!attrs) {
      attrs = bpmnRules.canConnect(source, target);
    }
    if (!attrs) {
      return;
    }
    return this.createConnection(source, target, attrs, source.parent, hints);
  };
  Modeling.prototype.updateModdleProperties = function (element, moddleElement, properties) {
    this._commandStack.execute('element.updateModdleProperties', {
      element: element,
      moddleElement: moddleElement,
      properties: properties
    });
  };
  Modeling.prototype.updateProperties = function (element, properties) {
    this._commandStack.execute('element.updateProperties', {
      element: element,
      properties: properties
    });
  };
  Modeling.prototype.resizeLane = function (laneShape, newBounds, balanced) {
    this._commandStack.execute('lane.resize', {
      shape: laneShape,
      newBounds: newBounds,
      balanced: balanced
    });
  };
  Modeling.prototype.addLane = function (targetLaneShape, location) {
    var context = {
      shape: targetLaneShape,
      location: location
    };
    this._commandStack.execute('lane.add', context);
    return context.newLane;
  };
  Modeling.prototype.splitLane = function (targetLane, count) {
    this._commandStack.execute('lane.split', {
      shape: targetLane,
      count: count
    });
  };
  Modeling.prototype.makeCollaboration = function () {
    var collaborationElement = this._create('root', {
      type: 'bpmn:Collaboration'
    });
    var context = {
      newRoot: collaborationElement
    };
    this._commandStack.execute('canvas.updateRoot', context);
    return collaborationElement;
  };
  Modeling.prototype.makeProcess = function () {
    var processElement = this._create('root', {
      type: 'bpmn:Process'
    });
    var context = {
      newRoot: processElement
    };
    this._commandStack.execute('canvas.updateRoot', context);
    return processElement;
  };
  Modeling.prototype.updateLaneRefs = function (flowNodeShapes, laneShapes) {
    this._commandStack.execute('lane.updateRefs', {
      flowNodeShapes: flowNodeShapes,
      laneShapes: laneShapes
    });
  };
  Modeling.prototype.claimId = function (id, moddleElement) {
    this._commandStack.execute('id.updateClaim', {
      id: id,
      element: moddleElement,
      claiming: true
    });
  };
  Modeling.prototype.unclaimId = function (id, moddleElement) {
    this._commandStack.execute('id.updateClaim', {
      id: id,
      element: moddleElement
    });
  };
  Modeling.prototype.setColor = function (elements, colors) {
    if (!elements.length) {
      elements = [elements];
    }
    this._commandStack.execute('element.setColor', {
      elements: elements,
      colors: colors
    });
  };
  function BaseLayouter() {}
  BaseLayouter.prototype.layoutConnection = function (connection, hints) {
    hints = hints || {};
    return [hints.connectionStart || getMid(hints.source || connection.source), hints.connectionEnd || getMid(hints.target || connection.target)];
  };
  var MIN_SEGMENT_LENGTH = 20,
    POINT_ORIENTATION_PADDING = 5;
  var round$2 = Math.round;
  var INTERSECTION_THRESHOLD = 20,
    ORIENTATION_THRESHOLD = {
      'h:h': 20,
      'v:v': 20,
      'h:v': -10,
      'v:h': -10
    };
  function needsTurn(orientation, startDirection) {
    return !{
      t: /top/,
      r: /right/,
      b: /bottom/,
      l: /left/,
      h: /./,
      v: /./
    }[startDirection].test(orientation);
  }
  function canLayoutStraight(direction, targetOrientation) {
    return {
      t: /top/,
      r: /right/,
      b: /bottom/,
      l: /left/,
      h: /left|right/,
      v: /top|bottom/
    }[direction].test(targetOrientation);
  }
  function getSegmentBendpoints(a, b, directions) {
    var orientation = getOrientation(b, a, POINT_ORIENTATION_PADDING);
    var startDirection = directions.split(':')[0];
    var xmid = round$2((b.x - a.x) / 2 + a.x),
      ymid = round$2((b.y - a.y) / 2 + a.y);
    var segmentEnd, segmentDirections;
    var layoutStraight = canLayoutStraight(startDirection, orientation),
      layoutHorizontal = /h|r|l/.test(startDirection),
      layoutTurn = false;
    var turnNextDirections = false;
    if (layoutStraight) {
      segmentEnd = layoutHorizontal ? {
        x: xmid,
        y: a.y
      } : {
        x: a.x,
        y: ymid
      };
      segmentDirections = layoutHorizontal ? 'h:h' : 'v:v';
    } else {
      layoutTurn = needsTurn(orientation, startDirection);
      segmentDirections = layoutHorizontal ? 'h:v' : 'v:h';
      if (layoutTurn) {
        if (layoutHorizontal) {
          turnNextDirections = ymid === a.y;
          segmentEnd = {
            x: a.x + MIN_SEGMENT_LENGTH * (/l/.test(startDirection) ? -1 : 1),
            y: turnNextDirections ? ymid + MIN_SEGMENT_LENGTH : ymid
          };
        } else {
          turnNextDirections = xmid === a.x;
          segmentEnd = {
            x: turnNextDirections ? xmid + MIN_SEGMENT_LENGTH : xmid,
            y: a.y + MIN_SEGMENT_LENGTH * (/t/.test(startDirection) ? -1 : 1)
          };
        }
      } else {
        segmentEnd = {
          x: xmid,
          y: ymid
        };
      }
    }
    return {
      waypoints: getBendpoints(a, segmentEnd, segmentDirections).concat(segmentEnd),
      directions: segmentDirections,
      turnNextDirections: turnNextDirections
    };
  }
  function getStartSegment(a, b, directions) {
    return getSegmentBendpoints(a, b, directions);
  }
  function getEndSegment(a, b, directions) {
    var invertedSegment = getSegmentBendpoints(b, a, invertDirections(directions));
    return {
      waypoints: invertedSegment.waypoints.slice().reverse(),
      directions: invertDirections(invertedSegment.directions),
      turnNextDirections: invertedSegment.turnNextDirections
    };
  }
  function getMidSegment(startSegment, endSegment) {
    var startDirection = startSegment.directions.split(':')[1],
      endDirection = endSegment.directions.split(':')[0];
    if (startSegment.turnNextDirections) {
      startDirection = startDirection == 'h' ? 'v' : 'h';
    }
    if (endSegment.turnNextDirections) {
      endDirection = endDirection == 'h' ? 'v' : 'h';
    }
    var directions = startDirection + ':' + endDirection;
    var bendpoints = getBendpoints(startSegment.waypoints[startSegment.waypoints.length - 1], endSegment.waypoints[0], directions);
    return {
      waypoints: bendpoints,
      directions: directions
    };
  }
  function invertDirections(directions) {
    return directions.split(':').reverse().join(':');
  }
  function getSimpleBendpoints(a, b, directions) {
    var xmid = round$2((b.x - a.x) / 2 + a.x),
      ymid = round$2((b.y - a.y) / 2 + a.y);
    if (directions === 'h:v') {
      return [{
        x: b.x,
        y: a.y
      }];
    }
    if (directions === 'v:h') {
      return [{
        x: a.x,
        y: b.y
      }];
    }
    if (directions === 'h:h') {
      return [{
        x: xmid,
        y: a.y
      }, {
        x: xmid,
        y: b.y
      }];
    }
    if (directions === 'v:v') {
      return [{
        x: a.x,
        y: ymid
      }, {
        x: b.x,
        y: ymid
      }];
    }
    throw new Error('invalid directions: can only handle varians of [hv]:[hv]');
  }
  function getBendpoints(a, b, directions) {
    directions = directions || 'h:h';
    if (!isValidDirections(directions)) {
      throw new Error('unknown directions: <' + directions + '>: ' + 'must be specified as <start>:<end> ' + 'with start/end in { h,v,t,r,b,l }');
    }
    if (isExplicitDirections(directions)) {
      var startSegment = getStartSegment(a, b, directions),
        endSegment = getEndSegment(a, b, directions),
        midSegment = getMidSegment(startSegment, endSegment);
      return [].concat(startSegment.waypoints, midSegment.waypoints, endSegment.waypoints);
    }
    return getSimpleBendpoints(a, b, directions);
  }
  function connectPoints(a, b, directions) {
    var points = getBendpoints(a, b, directions);
    points.unshift(a);
    points.push(b);
    return withoutRedundantPoints(points);
  }
  function connectRectangles(source, target, start, end, hints) {
    var preferredLayouts = hints && hints.preferredLayouts || [];
    var preferredLayout = without(preferredLayouts, 'straight')[0] || 'h:h';
    var threshold = ORIENTATION_THRESHOLD[preferredLayout] || 0;
    var orientation = getOrientation(source, target, threshold);
    var directions = getDirections(orientation, preferredLayout);
    start = start || getMid(source);
    end = end || getMid(target);
    var directionSplit = directions.split(':');
    var startDocking = getDockingPoint(start, source, directionSplit[0], invertOrientation(orientation)),
      endDocking = getDockingPoint(end, target, directionSplit[1], orientation);
    return connectPoints(startDocking, endDocking, directions);
  }
  function repairConnection(source, target, start, end, waypoints, hints) {
    if (isArray$3(start)) {
      waypoints = start;
      hints = end;
      start = getMid(source);
      end = getMid(target);
    }
    hints = assign$1({
      preferredLayouts: []
    }, hints);
    waypoints = waypoints || [];
    var preferredLayouts = hints.preferredLayouts,
      preferStraight = preferredLayouts.indexOf('straight') !== -1,
      repairedWaypoints;
    repairedWaypoints = preferStraight && tryLayoutStraight(source, target, start, end, hints);
    if (repairedWaypoints) {
      return repairedWaypoints;
    }
    repairedWaypoints = hints.connectionEnd && tryRepairConnectionEnd(target, source, end, waypoints);
    if (repairedWaypoints) {
      return repairedWaypoints;
    }
    repairedWaypoints = hints.connectionStart && tryRepairConnectionStart(source, target, start, waypoints);
    if (repairedWaypoints) {
      return repairedWaypoints;
    }
    if (!hints.connectionStart && !hints.connectionEnd && waypoints && waypoints.length) {
      return waypoints;
    }
    return connectRectangles(source, target, start, end, hints);
  }
  function inRange(a, start, end) {
    return a >= start && a <= end;
  }
  function isInRange(axis, a, b) {
    var size = {
      x: 'width',
      y: 'height'
    };
    return inRange(a[axis], b[axis], b[axis] + b[size[axis]]);
  }
  function tryLayoutStraight(source, target, start, end, hints) {
    var axis = {},
      primaryAxis,
      orientation;
    orientation = getOrientation(source, target);
    if (!/^(top|bottom|left|right)$/.test(orientation)) {
      return null;
    }
    if (/top|bottom/.test(orientation)) {
      primaryAxis = 'x';
    }
    if (/left|right/.test(orientation)) {
      primaryAxis = 'y';
    }
    if (hints.preserveDocking === 'target') {
      if (!isInRange(primaryAxis, end, source)) {
        return null;
      }
      axis[primaryAxis] = end[primaryAxis];
      return [{
        x: axis.x !== undefined ? axis.x : start.x,
        y: axis.y !== undefined ? axis.y : start.y,
        original: {
          x: axis.x !== undefined ? axis.x : start.x,
          y: axis.y !== undefined ? axis.y : start.y
        }
      }, {
        x: end.x,
        y: end.y
      }];
    } else {
      if (!isInRange(primaryAxis, start, target)) {
        return null;
      }
      axis[primaryAxis] = start[primaryAxis];
      return [{
        x: start.x,
        y: start.y
      }, {
        x: axis.x !== undefined ? axis.x : end.x,
        y: axis.y !== undefined ? axis.y : end.y,
        original: {
          x: axis.x !== undefined ? axis.x : end.x,
          y: axis.y !== undefined ? axis.y : end.y
        }
      }];
    }
  }
  function tryRepairConnectionStart(moved, other, newDocking, points) {
    return _tryRepairConnectionSide(moved, other, newDocking, points);
  }
  function tryRepairConnectionEnd(moved, other, newDocking, points) {
    var waypoints = points.slice().reverse();
    waypoints = _tryRepairConnectionSide(moved, other, newDocking, waypoints);
    return waypoints ? waypoints.reverse() : null;
  }
  function _tryRepairConnectionSide(moved, other, newDocking, points) {
    function needsRelayout(points) {
      if (points.length < 3) {
        return true;
      }
      if (points.length > 4) {
        return false;
      }
      return !!find(points, function (p, idx) {
        var q = points[idx - 1];
        return q && pointDistance(p, q) < 3;
      });
    }
    function repairBendpoint(candidate, oldPeer, newPeer) {
      var alignment = pointsAligned(oldPeer, candidate);
      switch (alignment) {
        case 'v':
          return {
            x: newPeer.x,
            y: candidate.y
          };
        case 'h':
          return {
            x: candidate.x,
            y: newPeer.y
          };
      }
      return {
        x: candidate.x,
        y: candidate.y
      };
    }
    function removeOverlapping(points, a, b) {
      var i;
      for (i = points.length - 2; i !== 0; i--) {
        if (pointInRect(points[i], a, INTERSECTION_THRESHOLD) || pointInRect(points[i], b, INTERSECTION_THRESHOLD)) {
          return points.slice(i);
        }
      }
      return points;
    }
    if (needsRelayout(points)) {
      return null;
    }
    var oldDocking = points[0],
      newPoints = points.slice(),
      slicedPoints;
    newPoints[0] = newDocking;
    newPoints[1] = repairBendpoint(newPoints[1], oldDocking, newDocking);
    slicedPoints = removeOverlapping(newPoints, moved, other);
    if (slicedPoints !== newPoints) {
      newPoints = _tryRepairConnectionSide(moved, other, newDocking, slicedPoints);
    }
    if (newPoints && pointsAligned(newPoints)) {
      return null;
    }
    return newPoints;
  }
  function getDirections(orientation, defaultLayout) {
    if (isExplicitDirections(defaultLayout)) {
      return defaultLayout;
    }
    switch (orientation) {
      case 'intersect':
        return 't:t';
      case 'top':
      case 'bottom':
        return 'v:v';
      case 'left':
      case 'right':
        return 'h:h';
      default:
        return defaultLayout;
    }
  }
  function isValidDirections(directions) {
    return directions && /^h|v|t|r|b|l:h|v|t|r|b|l$/.test(directions);
  }
  function isExplicitDirections(directions) {
    return directions && /t|r|b|l/.test(directions);
  }
  function invertOrientation(orientation) {
    return {
      'top': 'bottom',
      'bottom': 'top',
      'left': 'right',
      'right': 'left',
      'top-left': 'bottom-right',
      'bottom-right': 'top-left',
      'top-right': 'bottom-left',
      'bottom-left': 'top-right'
    }[orientation];
  }
  function getDockingPoint(point, rectangle, dockingDirection, targetOrientation) {
    if (dockingDirection === 'h') {
      dockingDirection = /left/.test(targetOrientation) ? 'l' : 'r';
    }
    if (dockingDirection === 'v') {
      dockingDirection = /top/.test(targetOrientation) ? 't' : 'b';
    }
    if (dockingDirection === 't') {
      return {
        original: point,
        x: point.x,
        y: rectangle.y
      };
    }
    if (dockingDirection === 'r') {
      return {
        original: point,
        x: rectangle.x + rectangle.width,
        y: point.y
      };
    }
    if (dockingDirection === 'b') {
      return {
        original: point,
        x: point.x,
        y: rectangle.y + rectangle.height
      };
    }
    if (dockingDirection === 'l') {
      return {
        original: point,
        x: rectangle.x,
        y: point.y
      };
    }
    throw new Error('unexpected dockingDirection: <' + dockingDirection + '>');
  }
  function withoutRedundantPoints(waypoints) {
    return waypoints.reduce(function (points, p, idx) {
      var previous = points[points.length - 1],
        next = waypoints[idx + 1];
      if (!pointsOnLine(previous, next, p, 0)) {
        points.push(p);
      }
      return points;
    }, []);
  }
  var ATTACH_ORIENTATION_PADDING = -10,
    BOUNDARY_TO_HOST_THRESHOLD$1 = 40;
  var PREFERRED_LAYOUTS_HORIZONTAL = {
    default: ['h:h'],
    fromGateway: ['v:h'],
    toGateway: ['h:v'],
    loop: {
      fromTop: ['t:r'],
      fromRight: ['r:b'],
      fromLeft: ['l:t'],
      fromBottom: ['b:l']
    },
    boundaryLoop: {
      alternateHorizontalSide: 'b',
      alternateVerticalSide: 'l',
      default: 'v'
    },
    messageFlow: ['straight', 'v:v'],
    subProcess: ['straight', 'h:h'],
    isHorizontal: true
  };
  var PREFERRED_LAYOUTS_VERTICAL = {
    default: ['v:v'],
    fromGateway: ['h:v'],
    toGateway: ['v:h'],
    loop: {
      fromTop: ['t:l'],
      fromRight: ['r:t'],
      fromLeft: ['l:b'],
      fromBottom: ['b:r']
    },
    boundaryLoop: {
      alternateHorizontalSide: 't',
      alternateVerticalSide: 'r',
      default: 'h'
    },
    messageFlow: ['straight', 'h:h'],
    subProcess: ['straight', 'v:v'],
    isHorizontal: false
  };
  var oppositeOrientationMapping = {
    'top': 'bottom',
    'top-right': 'bottom-left',
    'top-left': 'bottom-right',
    'right': 'left',
    'bottom': 'top',
    'bottom-right': 'top-left',
    'bottom-left': 'top-right',
    'left': 'right'
  };
  var orientationDirectionMapping = {
    top: 't',
    right: 'r',
    bottom: 'b',
    left: 'l'
  };
  function BpmnLayouter(elementRegistry) {
    this._elementRegistry = elementRegistry;
  }
  e$2(BpmnLayouter, BaseLayouter);
  BpmnLayouter.prototype.layoutConnection = function (connection, hints) {
    if (!hints) {
      hints = {};
    }
    var source = hints.source || connection.source,
      target = hints.target || connection.target,
      waypoints = hints.waypoints || connection.waypoints,
      connectionStart = hints.connectionStart,
      connectionEnd = hints.connectionEnd,
      elementRegistry = this._elementRegistry;
    var manhattanOptions, updatedWaypoints;
    if (!connectionStart) {
      connectionStart = getConnectionDocking(waypoints && waypoints[0], source);
    }
    if (!connectionEnd) {
      connectionEnd = getConnectionDocking(waypoints && waypoints[waypoints.length - 1], target);
    }
    if (is(connection, 'bpmn:Association') || is(connection, 'bpmn:DataAssociation')) {
      if (waypoints && !isCompensationAssociation(source, target)) {
        return [].concat([connectionStart], waypoints.slice(1, -1), [connectionEnd]);
      }
    }
    var layout = isDirectionHorizontal(source, elementRegistry) ? PREFERRED_LAYOUTS_HORIZONTAL : PREFERRED_LAYOUTS_VERTICAL;
    if (is(connection, 'bpmn:MessageFlow')) {
      manhattanOptions = getMessageFlowManhattanOptions(source, target, layout);
    } else if (is(connection, 'bpmn:SequenceFlow') || isCompensationAssociation(source, target)) {
      if (source === target) {
        manhattanOptions = {
          preferredLayouts: getLoopPreferredLayout(source, connection, layout)
        };
      } else if (is(source, 'bpmn:BoundaryEvent')) {
        manhattanOptions = {
          preferredLayouts: getBoundaryEventPreferredLayouts(source, target, connectionEnd, layout)
        };
      } else if (isExpandedSubProcess$1(source) || isExpandedSubProcess$1(target)) {
        manhattanOptions = {
          preferredLayouts: layout.subProcess,
          preserveDocking: getSubProcessPreserveDocking(source)
        };
      } else if (is(source, 'bpmn:Gateway')) {
        manhattanOptions = {
          preferredLayouts: layout.fromGateway
        };
      } else if (is(target, 'bpmn:Gateway')) {
        manhattanOptions = {
          preferredLayouts: layout.toGateway
        };
      } else {
        manhattanOptions = {
          preferredLayouts: layout.default
        };
      }
    }
    if (manhattanOptions) {
      manhattanOptions = assign$1(manhattanOptions, hints);
      updatedWaypoints = withoutRedundantPoints(repairConnection(source, target, connectionStart, connectionEnd, waypoints, manhattanOptions));
    }
    return updatedWaypoints || [connectionStart, connectionEnd];
  };
  function getAttachOrientation(attachedElement) {
    var hostElement = attachedElement.host;
    return getOrientation(getMid(attachedElement), hostElement, ATTACH_ORIENTATION_PADDING);
  }
  function getMessageFlowManhattanOptions(source, target, layout) {
    return {
      preferredLayouts: layout.messageFlow,
      preserveDocking: getMessageFlowPreserveDocking(source, target)
    };
  }
  function getMessageFlowPreserveDocking(source, target) {
    if (is(target, 'bpmn:Participant')) {
      return 'source';
    }
    if (is(source, 'bpmn:Participant')) {
      return 'target';
    }
    if (isExpandedSubProcess$1(target)) {
      return 'source';
    }
    if (isExpandedSubProcess$1(source)) {
      return 'target';
    }
    if (is(target, 'bpmn:Event')) {
      return 'target';
    }
    if (is(source, 'bpmn:Event')) {
      return 'source';
    }
    return null;
  }
  function getSubProcessPreserveDocking(source) {
    return isExpandedSubProcess$1(source) ? 'target' : 'source';
  }
  function getConnectionDocking(point, shape) {
    return point ? point.original || point : getMid(shape);
  }
  function isCompensationAssociation(source, target) {
    return is(target, 'bpmn:Activity') && is(source, 'bpmn:BoundaryEvent') && target.businessObject.isForCompensation;
  }
  function isExpandedSubProcess$1(element) {
    return is(element, 'bpmn:SubProcess') && isExpanded(element);
  }
  function isSame(a, b) {
    return a === b;
  }
  function isAnyOrientation(orientation, orientations) {
    return orientations.indexOf(orientation) !== -1;
  }
  function getHorizontalOrientation(orientation) {
    var matches = /right|left/.exec(orientation);
    return matches && matches[0];
  }
  function getVerticalOrientation(orientation) {
    var matches = /top|bottom/.exec(orientation);
    return matches && matches[0];
  }
  function isOppositeOrientation(a, b) {
    return oppositeOrientationMapping[a] === b;
  }
  function isOppositeHorizontalOrientation(a, b) {
    var horizontalOrientation = getHorizontalOrientation(a);
    var oppositeHorizontalOrientation = oppositeOrientationMapping[horizontalOrientation];
    return b.indexOf(oppositeHorizontalOrientation) !== -1;
  }
  function isOppositeVerticalOrientation(a, b) {
    var verticalOrientation = getVerticalOrientation(a);
    var oppositeVerticalOrientation = oppositeOrientationMapping[verticalOrientation];
    return b.indexOf(oppositeVerticalOrientation) !== -1;
  }
  function isHorizontalOrientation(orientation) {
    return orientation === 'right' || orientation === 'left';
  }
  function getLoopPreferredLayout(source, connection, layout) {
    var waypoints = connection.waypoints;
    var orientation = waypoints && waypoints.length && getOrientation(waypoints[0], source);
    if (orientation === 'top') {
      return layout.loop.fromTop;
    } else if (orientation === 'right') {
      return layout.loop.fromRight;
    } else if (orientation === 'left') {
      return layout.loop.fromLeft;
    }
    return layout.loop.fromBottom;
  }
  function getBoundaryEventPreferredLayouts(source, target, end, layout) {
    var sourceMid = getMid(source),
      targetMid = getMid(target),
      attachOrientation = getAttachOrientation(source),
      sourceLayout,
      targetLayout;
    var isLoop = isSame(source.host, target);
    var attachedToSide = isAnyOrientation(attachOrientation, ['top', 'right', 'bottom', 'left']);
    var targetOrientation = getOrientation(targetMid, sourceMid, {
      x: source.width / 2 + target.width / 2,
      y: source.height / 2 + target.height / 2
    });
    if (isLoop) {
      return getBoundaryEventLoopLayout(attachOrientation, attachedToSide, source, target, end, layout);
    }
    sourceLayout = getBoundaryEventSourceLayout(attachOrientation, targetOrientation, attachedToSide, layout.isHorizontal);
    targetLayout = getBoundaryEventTargetLayout(attachOrientation, targetOrientation, attachedToSide, layout.isHorizontal);
    return [sourceLayout + ':' + targetLayout];
  }
  function getBoundaryEventLoopLayout(attachOrientation, attachedToSide, source, target, end, layout) {
    var orientation = attachedToSide ? attachOrientation : layout.isHorizontal ? getVerticalOrientation(attachOrientation) : getHorizontalOrientation(attachOrientation),
      sourceLayout = orientationDirectionMapping[orientation],
      targetLayout;
    if (attachedToSide) {
      if (isHorizontalOrientation(attachOrientation)) {
        targetLayout = shouldConnectToSameSide('y', source, target, end) ? 'h' : layout.boundaryLoop.alternateHorizontalSide;
      } else {
        targetLayout = shouldConnectToSameSide('x', source, target, end) ? 'v' : layout.boundaryLoop.alternateVerticalSide;
      }
    } else {
      targetLayout = layout.boundaryLoop.default;
    }
    return [sourceLayout + ':' + targetLayout];
  }
  function shouldConnectToSameSide(axis, source, target, end) {
    var threshold = BOUNDARY_TO_HOST_THRESHOLD$1;
    return !(areCloseOnAxis(axis, end, target, threshold) || areCloseOnAxis(axis, end, {
      x: target.x + target.width,
      y: target.y + target.height
    }, threshold) || areCloseOnAxis(axis, end, getMid(source), threshold));
  }
  function areCloseOnAxis(axis, a, b, threshold) {
    return Math.abs(a[axis] - b[axis]) < threshold;
  }
  function getBoundaryEventSourceLayout(attachOrientation, targetOrientation, attachedToSide, isHorizontal) {
    if (attachedToSide) {
      return orientationDirectionMapping[attachOrientation];
    }
    var verticalAttachOrientation = getVerticalOrientation(attachOrientation),
      horizontalAttachOrientation = getHorizontalOrientation(attachOrientation),
      verticalTargetOrientation = getVerticalOrientation(targetOrientation),
      horizontalTargetOrientation = getHorizontalOrientation(targetOrientation);
    if (isHorizontal) {
      if (isSame(verticalAttachOrientation, verticalTargetOrientation) || isOppositeOrientation(horizontalAttachOrientation, horizontalTargetOrientation)) {
        return orientationDirectionMapping[verticalAttachOrientation];
      }
    } else {
      if (isSame(horizontalAttachOrientation, horizontalTargetOrientation) || isOppositeOrientation(verticalAttachOrientation, verticalTargetOrientation)) {
        return orientationDirectionMapping[horizontalAttachOrientation];
      }
    }
    return orientationDirectionMapping[isHorizontal ? horizontalAttachOrientation : verticalAttachOrientation];
  }
  function getBoundaryEventTargetLayout(attachOrientation, targetOrientation, attachedToSide, isHorizontal) {
    if (attachedToSide) {
      if (isHorizontalOrientation(attachOrientation)) {
        if (isOppositeHorizontalOrientation(attachOrientation, targetOrientation) || isSame(attachOrientation, targetOrientation)) {
          return 'h';
        }
        return 'v';
      } else {
        if (isOppositeVerticalOrientation(attachOrientation, targetOrientation) || isSame(attachOrientation, targetOrientation)) {
          return 'v';
        }
        return 'h';
      }
    }
    if (isHorizontal) {
      if (isSame(getVerticalOrientation(attachOrientation), getVerticalOrientation(targetOrientation))) {
        return 'h';
      } else {
        return 'v';
      }
    } else {
      if (isSame(getHorizontalOrientation(attachOrientation), getHorizontalOrientation(targetOrientation))) {
        return 'v';
      } else {
        return 'h';
      }
    }
  }
  BpmnLayouter.$inject = ['elementRegistry'];
  function dockingToPoint(docking) {
    return assign$1({
      original: docking.point.original || docking.point
    }, docking.actual);
  }
  function CroppingConnectionDocking(elementRegistry, graphicsFactory) {
    this._elementRegistry = elementRegistry;
    this._graphicsFactory = graphicsFactory;
  }
  CroppingConnectionDocking.$inject = ['elementRegistry', 'graphicsFactory'];
  CroppingConnectionDocking.prototype.getCroppedWaypoints = function (connection, source, target) {
    source = source || connection.source;
    target = target || connection.target;
    var sourceDocking = this.getDockingPoint(connection, source, true),
      targetDocking = this.getDockingPoint(connection, target);
    var croppedWaypoints = connection.waypoints.slice(sourceDocking.idx + 1, targetDocking.idx);
    croppedWaypoints.unshift(dockingToPoint(sourceDocking));
    croppedWaypoints.push(dockingToPoint(targetDocking));
    return croppedWaypoints;
  };
  CroppingConnectionDocking.prototype.getDockingPoint = function (connection, shape, dockStart) {
    var waypoints = connection.waypoints,
      dockingIdx,
      dockingPoint,
      croppedPoint;
    dockingIdx = dockStart ? 0 : waypoints.length - 1;
    dockingPoint = waypoints[dockingIdx];
    croppedPoint = this._getIntersection(shape, connection, dockStart);
    return {
      point: dockingPoint,
      actual: croppedPoint || dockingPoint,
      idx: dockingIdx
    };
  };
  CroppingConnectionDocking.prototype._getIntersection = function (shape, connection, takeFirst) {
    var shapePath = this._getShapePath(shape),
      connectionPath = this._getConnectionPath(connection);
    return getElementLineIntersection(shapePath, connectionPath, takeFirst);
  };
  CroppingConnectionDocking.prototype._getConnectionPath = function (connection) {
    return this._graphicsFactory.getConnectionPath(connection);
  };
  CroppingConnectionDocking.prototype._getShapePath = function (shape) {
    return this._graphicsFactory.getShapePath(shape);
  };
  CroppingConnectionDocking.prototype._getGfx = function (element) {
    return this._elementRegistry.getGraphics(element);
  };
  var ModelingModule = {
    __init__: ['modeling', 'bpmnUpdater'],
    __depends__: [BehaviorModule, RulesModule, DiOrderingModule, OrderingModule, ReplaceModule, CommandModule, LabelSupportModule, AttachSupportModule, SelectionModule, ChangeSupportModule, SpaceToolModule],
    bpmnFactory: ['type', BpmnFactory],
    bpmnUpdater: ['type', BpmnUpdater],
    elementFactory: ['type', ElementFactory],
    modeling: ['type', Modeling],
    layouter: ['type', BpmnLayouter],
    connectionDocking: ['type', CroppingConnectionDocking]
  };
  var round$1 = Math.round;
  function AppendPreview(complexPreview, connectionDocking, elementFactory, eventBus, layouter, rules) {
    this._complexPreview = complexPreview;
    this._connectionDocking = connectionDocking;
    this._elementFactory = elementFactory;
    this._eventBus = eventBus;
    this._layouter = layouter;
    this._rules = rules;
  }
  AppendPreview.prototype.create = function (source, type, options) {
    var complexPreview = this._complexPreview,
      connectionDocking = this._connectionDocking,
      elementFactory = this._elementFactory,
      eventBus = this._eventBus,
      layouter = this._layouter,
      rules = this._rules;
    var shape = elementFactory.createShape(assign$1({
      type
    }, options));
    var position = eventBus.fire('autoPlace', {
      source,
      shape
    });
    if (!position) {
      return;
    }
    assign$1(shape, {
      x: position.x - round$1(shape.width / 2),
      y: position.y - round$1(shape.height / 2)
    });
    var connectionCreateAllowed = rules.allowed('connection.create', {
      source,
      target: shape,
      hints: {
        targetParent: source.parent
      }
    });
    var connection = null;
    if (connectionCreateAllowed) {
      connection = elementFactory.createConnection(connectionCreateAllowed);
      connection.waypoints = layouter.layoutConnection(connection, {
        source,
        target: shape
      });
      connection.waypoints = connectionDocking.getCroppedWaypoints(connection, source, shape);
    }
    complexPreview.create({
      created: [shape, connection].filter(function (element) {
        return !isNil(element);
      })
    });
  };
  AppendPreview.prototype.cleanUp = function () {
    this._complexPreview.cleanUp();
  };
  AppendPreview.$inject = ['complexPreview', 'connectionDocking', 'elementFactory', 'eventBus', 'layouter', 'rules'];
  var AppendPreviewModule = {
    __depends__: [AutoPlaceModule, ComplexPreviewModule, ModelingModule],
    __init__: ['appendPreview'],
    appendPreview: ['type', AppendPreview]
  };
  var min = Math.min,
    max = Math.max;
  function preventDefault(e) {
    e.preventDefault();
  }
  function stopPropagation(e) {
    e.stopPropagation();
  }
  function isTextNode(node) {
    return node.nodeType === Node.TEXT_NODE;
  }
  function toArray(nodeList) {
    return [].slice.call(nodeList);
  }
  function TextBox(options) {
    this.container = options.container;
    this.parent = domify$1('<div class="djs-direct-editing-parent">' + '<div class="djs-direct-editing-content" contenteditable="true"></div>' + '</div>');
    this.content = query('[contenteditable]', this.parent);
    this.keyHandler = options.keyHandler || function () {};
    this.resizeHandler = options.resizeHandler || function () {};
    this.autoResize = bind$2(this.autoResize, this);
    this.handlePaste = bind$2(this.handlePaste, this);
  }
  TextBox.prototype.create = function (bounds, style, value, options) {
    var self = this;
    var parent = this.parent,
      content = this.content,
      container = this.container;
    options = this.options = options || {};
    style = this.style = style || {};
    var parentStyle = pick(style, ['width', 'height', 'maxWidth', 'maxHeight', 'minWidth', 'minHeight', 'left', 'top', 'backgroundColor', 'position', 'overflow', 'border', 'wordWrap', 'textAlign', 'outline', 'transform']);
    assign$1(parent.style, {
      width: bounds.width + 'px',
      height: bounds.height + 'px',
      maxWidth: bounds.maxWidth + 'px',
      maxHeight: bounds.maxHeight + 'px',
      minWidth: bounds.minWidth + 'px',
      minHeight: bounds.minHeight + 'px',
      left: bounds.x + 'px',
      top: bounds.y + 'px',
      backgroundColor: '#ffffff',
      position: 'absolute',
      overflow: 'visible',
      border: '1px solid #ccc',
      boxSizing: 'border-box',
      wordWrap: 'normal',
      textAlign: 'center',
      outline: 'none'
    }, parentStyle);
    var contentStyle = pick(style, ['fontFamily', 'fontSize', 'fontWeight', 'lineHeight', 'padding', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft']);
    assign$1(content.style, {
      boxSizing: 'border-box',
      width: '100%',
      outline: 'none',
      wordWrap: 'break-word'
    }, contentStyle);
    if (options.centerVertically) {
      assign$1(content.style, {
        position: 'absolute',
        top: '50%',
        transform: 'translate(0, -50%)'
      }, contentStyle);
    }
    content.innerText = value;
    event.bind(content, 'keydown', this.keyHandler);
    event.bind(content, 'mousedown', stopPropagation);
    event.bind(content, 'paste', self.handlePaste);
    if (options.autoResize) {
      event.bind(content, 'input', this.autoResize);
    }
    if (options.resizable) {
      this.resizable(style);
    }
    container.appendChild(parent);
    this.setSelection(content.lastChild, content.lastChild && content.lastChild.length);
    return parent;
  };
  TextBox.prototype.handlePaste = function (e) {
    var options = this.options,
      style = this.style;
    e.preventDefault();
    var text;
    if (e.clipboardData) {
      text = e.clipboardData.getData('text/plain');
    } else {
      text = window.clipboardData.getData('Text');
    }
    this.insertText(text);
    if (options.autoResize) {
      var hasResized = this.autoResize(style);
      if (hasResized) {
        this.resizeHandler(hasResized);
      }
    }
  };
  TextBox.prototype.insertText = function (text) {
    text = normalizeEndOfLineSequences(text);
    var success = document.execCommand('insertText', false, text);
    if (success) {
      return;
    }
    this._insertTextIE(text);
  };
  TextBox.prototype._insertTextIE = function (text) {
    var range = this.getSelection(),
      startContainer = range.startContainer,
      endContainer = range.endContainer,
      startOffset = range.startOffset,
      endOffset = range.endOffset,
      commonAncestorContainer = range.commonAncestorContainer;
    var childNodesArray = toArray(commonAncestorContainer.childNodes);
    var container, offset;
    if (isTextNode(commonAncestorContainer)) {
      var containerTextContent = startContainer.textContent;
      startContainer.textContent = containerTextContent.substring(0, startOffset) + text + containerTextContent.substring(endOffset);
      container = startContainer;
      offset = startOffset + text.length;
    } else if (startContainer === this.content && endContainer === this.content) {
      var textNode = document.createTextNode(text);
      this.content.insertBefore(textNode, childNodesArray[startOffset]);
      container = textNode;
      offset = textNode.textContent.length;
    } else {
      var startContainerChildIndex = childNodesArray.indexOf(startContainer),
        endContainerChildIndex = childNodesArray.indexOf(endContainer);
      childNodesArray.forEach(function (childNode, index) {
        if (index === startContainerChildIndex) {
          childNode.textContent = startContainer.textContent.substring(0, startOffset) + text + endContainer.textContent.substring(endOffset);
        } else if (index > startContainerChildIndex && index <= endContainerChildIndex) {
          remove$2(childNode);
        }
      });
      container = startContainer;
      offset = startOffset + text.length;
    }
    if (container && offset !== undefined) {
      setTimeout(function () {
        self.setSelection(container, offset);
      });
    }
  };
  TextBox.prototype.autoResize = function () {
    var parent = this.parent,
      content = this.content;
    var fontSize = parseInt(this.style.fontSize) || 12;
    if (content.scrollHeight > parent.offsetHeight || content.scrollHeight < parent.offsetHeight - fontSize) {
      var bounds = parent.getBoundingClientRect();
      var height = content.scrollHeight;
      parent.style.height = height + 'px';
      this.resizeHandler({
        width: bounds.width,
        height: bounds.height,
        dx: 0,
        dy: height - bounds.height
      });
    }
  };
  TextBox.prototype.resizable = function () {
    var self = this;
    var parent = this.parent,
      resizeHandle = this.resizeHandle;
    var minWidth = parseInt(this.style.minWidth) || 0,
      minHeight = parseInt(this.style.minHeight) || 0,
      maxWidth = parseInt(this.style.maxWidth) || Infinity,
      maxHeight = parseInt(this.style.maxHeight) || Infinity;
    if (!resizeHandle) {
      resizeHandle = this.resizeHandle = domify$1('<div class="djs-direct-editing-resize-handle"></div>');
      var startX, startY, startWidth, startHeight;
      var onMouseDown = function onMouseDown(e) {
        preventDefault(e);
        stopPropagation(e);
        startX = e.clientX;
        startY = e.clientY;
        var bounds = parent.getBoundingClientRect();
        startWidth = bounds.width;
        startHeight = bounds.height;
        event.bind(document, 'mousemove', onMouseMove);
        event.bind(document, 'mouseup', _onMouseUp);
      };
      var onMouseMove = function onMouseMove(e) {
        preventDefault(e);
        stopPropagation(e);
        var newWidth = min(max(startWidth + e.clientX - startX, minWidth), maxWidth);
        var newHeight = min(max(startHeight + e.clientY - startY, minHeight), maxHeight);
        parent.style.width = newWidth + 'px';
        parent.style.height = newHeight + 'px';
        self.resizeHandler({
          width: startWidth,
          height: startHeight,
          dx: e.clientX - startX,
          dy: e.clientY - startY
        });
      };
      var _onMouseUp = function onMouseUp(e) {
        preventDefault(e);
        stopPropagation(e);
        event.unbind(document, 'mousemove', onMouseMove, false);
        event.unbind(document, 'mouseup', _onMouseUp, false);
      };
      event.bind(resizeHandle, 'mousedown', onMouseDown);
    }
    assign$1(resizeHandle.style, {
      position: 'absolute',
      bottom: '0px',
      right: '0px',
      cursor: 'nwse-resize',
      width: '0',
      height: '0',
      borderTop: (parseInt(this.style.fontSize) / 4 || 3) + 'px solid transparent',
      borderRight: (parseInt(this.style.fontSize) / 4 || 3) + 'px solid #ccc',
      borderBottom: (parseInt(this.style.fontSize) / 4 || 3) + 'px solid #ccc',
      borderLeft: (parseInt(this.style.fontSize) / 4 || 3) + 'px solid transparent'
    });
    parent.appendChild(resizeHandle);
  };
  TextBox.prototype.destroy = function () {
    var parent = this.parent,
      content = this.content,
      resizeHandle = this.resizeHandle;
    content.innerText = '';
    parent.removeAttribute('style');
    content.removeAttribute('style');
    event.unbind(content, 'keydown', this.keyHandler);
    event.unbind(content, 'mousedown', stopPropagation);
    event.unbind(content, 'input', this.autoResize);
    event.unbind(content, 'paste', this.handlePaste);
    if (resizeHandle) {
      resizeHandle.removeAttribute('style');
      remove$2(resizeHandle);
    }
    remove$2(parent);
  };
  TextBox.prototype.getValue = function () {
    return this.content.innerText.trim();
  };
  TextBox.prototype.getSelection = function () {
    var selection = window.getSelection(),
      range = selection.getRangeAt(0);
    return range;
  };
  TextBox.prototype.setSelection = function (container, offset) {
    var range = document.createRange();
    if (container === null) {
      range.selectNodeContents(this.content);
    } else {
      range.setStart(container, offset);
      range.setEnd(container, offset);
    }
    var selection = window.getSelection();
    selection.removeAllRanges();
    selection.addRange(range);
  };
  function normalizeEndOfLineSequences(string) {
    return string.replace(/\r\n|\r|\n/g, '\n');
  }
  function DirectEditing(eventBus, canvas) {
    this._eventBus = eventBus;
    this._canvas = canvas;
    this._providers = [];
    this._textbox = new TextBox({
      container: canvas.getContainer(),
      keyHandler: bind$2(this._handleKey, this),
      resizeHandler: bind$2(this._handleResize, this)
    });
  }
  DirectEditing.$inject = ['eventBus', 'canvas'];
  DirectEditing.prototype.registerProvider = function (provider) {
    this._providers.push(provider);
  };
  DirectEditing.prototype.isActive = function (element) {
    return !!(this._active && (!element || this._active.element === element));
  };
  DirectEditing.prototype.cancel = function () {
    if (!this._active) {
      return;
    }
    this._fire('cancel');
    this.close();
  };
  DirectEditing.prototype._fire = function (event, context) {
    this._eventBus.fire('directEditing.' + event, context || {
      active: this._active
    });
  };
  DirectEditing.prototype.close = function () {
    this._textbox.destroy();
    this._fire('deactivate');
    this._active = null;
    this.resizable = undefined;
    this._canvas.restoreFocus && this._canvas.restoreFocus();
  };
  DirectEditing.prototype.complete = function () {
    var active = this._active;
    if (!active) {
      return;
    }
    var containerBounds,
      previousBounds = active.context.bounds,
      newBounds = this.$textbox.getBoundingClientRect(),
      newText = this.getValue(),
      previousText = active.context.text;
    if (newText !== previousText || newBounds.height !== previousBounds.height || newBounds.width !== previousBounds.width) {
      containerBounds = this._textbox.container.getBoundingClientRect();
      active.provider.update(active.element, newText, active.context.text, {
        x: newBounds.left - containerBounds.left,
        y: newBounds.top - containerBounds.top,
        width: newBounds.width,
        height: newBounds.height
      });
    }
    this._fire('complete');
    this.close();
  };
  DirectEditing.prototype.getValue = function () {
    return this._textbox.getValue();
  };
  DirectEditing.prototype._handleKey = function (e) {
    e.stopPropagation();
    var key = e.keyCode || e.charCode;
    if (key === 27) {
      e.preventDefault();
      return this.cancel();
    }
    if (key === 13 && !e.shiftKey) {
      e.preventDefault();
      return this.complete();
    }
  };
  DirectEditing.prototype._handleResize = function (event) {
    this._fire('resize', event);
  };
  DirectEditing.prototype.activate = function (element) {
    if (this.isActive()) {
      this.cancel();
    }
    var context;
    var provider = find(this._providers, function (p) {
      return (context = p.activate(element)) ? p : null;
    });
    if (context) {
      this.$textbox = this._textbox.create(context.bounds, context.style, context.text, context.options);
      this._active = {
        element: element,
        context: context,
        provider: provider
      };
      if (context.options && context.options.resizable) {
        this.resizable = true;
      }
      this._fire('activate');
    }
    return !!context;
  };
  var DirectEditingModule = {
    __depends__: [InteractionEventsModule$1],
    __init__: ['directEditing'],
    directEditing: ['type', DirectEditing]
  };
  function isDifferentType(element) {
    return function (entry) {
      var target = entry.target;
      var businessObject = getBusinessObject(element),
        eventDefinition = businessObject.eventDefinitions && businessObject.eventDefinitions[0];
      var isTypeEqual = businessObject.$type === target.type;
      var isEventDefinitionEqual = (eventDefinition && eventDefinition.$type) === target.eventDefinitionType;
      var isTriggeredByEventEqual = !!target.triggeredByEvent === !!businessObject.triggeredByEvent;
      var isExpandedEqual = target.isExpanded === undefined || target.isExpanded === isExpanded(element);
      return !isTypeEqual || !isEventDefinitionEqual || !isTriggeredByEventEqual || !isExpandedEqual;
    };
  }
  var START_EVENT = [{
    label: 'Start event',
    actionName: 'replace-with-none-start',
    className: 'bpmn-icon-start-event-none',
    target: {
      type: 'bpmn:StartEvent'
    }
  }, {
    label: 'Intermediate throw event',
    actionName: 'replace-with-none-intermediate-throwing',
    className: 'bpmn-icon-intermediate-event-none',
    target: {
      type: 'bpmn:IntermediateThrowEvent'
    }
  }, {
    label: 'End event',
    actionName: 'replace-with-none-end',
    className: 'bpmn-icon-end-event-none',
    target: {
      type: 'bpmn:EndEvent'
    }
  }, {
    label: 'Message start event',
    actionName: 'replace-with-message-start',
    className: 'bpmn-icon-start-event-message',
    target: {
      type: 'bpmn:StartEvent',
      eventDefinitionType: 'bpmn:MessageEventDefinition'
    }
  }, {
    label: 'Timer start event',
    actionName: 'replace-with-timer-start',
    className: 'bpmn-icon-start-event-timer',
    target: {
      type: 'bpmn:StartEvent',
      eventDefinitionType: 'bpmn:TimerEventDefinition'
    }
  }, {
    label: 'Conditional start event',
    actionName: 'replace-with-conditional-start',
    className: 'bpmn-icon-start-event-condition',
    target: {
      type: 'bpmn:StartEvent',
      eventDefinitionType: 'bpmn:ConditionalEventDefinition'
    }
  }, {
    label: 'Signal start event',
    actionName: 'replace-with-signal-start',
    className: 'bpmn-icon-start-event-signal',
    target: {
      type: 'bpmn:StartEvent',
      eventDefinitionType: 'bpmn:SignalEventDefinition'
    }
  }];
  var START_EVENT_SUB_PROCESS = [{
    label: 'Start event',
    actionName: 'replace-with-none-start',
    className: 'bpmn-icon-start-event-none',
    target: {
      type: 'bpmn:StartEvent'
    }
  }, {
    label: 'Intermediate throw event',
    actionName: 'replace-with-none-intermediate-throwing',
    className: 'bpmn-icon-intermediate-event-none',
    target: {
      type: 'bpmn:IntermediateThrowEvent'
    }
  }, {
    label: 'End event',
    actionName: 'replace-with-none-end',
    className: 'bpmn-icon-end-event-none',
    target: {
      type: 'bpmn:EndEvent'
    }
  }];
  var INTERMEDIATE_EVENT = [{
    label: 'Start event',
    actionName: 'replace-with-none-start',
    className: 'bpmn-icon-start-event-none',
    target: {
      type: 'bpmn:StartEvent'
    }
  }, {
    label: 'Intermediate throw event',
    actionName: 'replace-with-none-intermediate-throw',
    className: 'bpmn-icon-intermediate-event-none',
    target: {
      type: 'bpmn:IntermediateThrowEvent'
    }
  }, {
    label: 'End event',
    actionName: 'replace-with-none-end',
    className: 'bpmn-icon-end-event-none',
    target: {
      type: 'bpmn:EndEvent'
    }
  }, {
    label: 'Message intermediate catch event',
    actionName: 'replace-with-message-intermediate-catch',
    className: 'bpmn-icon-intermediate-event-catch-message',
    target: {
      type: 'bpmn:IntermediateCatchEvent',
      eventDefinitionType: 'bpmn:MessageEventDefinition'
    }
  }, {
    label: 'Message intermediate throw event',
    actionName: 'replace-with-message-intermediate-throw',
    className: 'bpmn-icon-intermediate-event-throw-message',
    target: {
      type: 'bpmn:IntermediateThrowEvent',
      eventDefinitionType: 'bpmn:MessageEventDefinition'
    }
  }, {
    label: 'Timer intermediate catch event',
    actionName: 'replace-with-timer-intermediate-catch',
    className: 'bpmn-icon-intermediate-event-catch-timer',
    target: {
      type: 'bpmn:IntermediateCatchEvent',
      eventDefinitionType: 'bpmn:TimerEventDefinition'
    }
  }, {
    label: 'Escalation intermediate throw event',
    actionName: 'replace-with-escalation-intermediate-throw',
    className: 'bpmn-icon-intermediate-event-throw-escalation',
    target: {
      type: 'bpmn:IntermediateThrowEvent',
      eventDefinitionType: 'bpmn:EscalationEventDefinition'
    }
  }, {
    label: 'Conditional intermediate catch event',
    actionName: 'replace-with-conditional-intermediate-catch',
    className: 'bpmn-icon-intermediate-event-catch-condition',
    target: {
      type: 'bpmn:IntermediateCatchEvent',
      eventDefinitionType: 'bpmn:ConditionalEventDefinition'
    }
  }, {
    label: 'Link intermediate catch event',
    actionName: 'replace-with-link-intermediate-catch',
    className: 'bpmn-icon-intermediate-event-catch-link',
    target: {
      type: 'bpmn:IntermediateCatchEvent',
      eventDefinitionType: 'bpmn:LinkEventDefinition',
      eventDefinitionAttrs: {
        name: ''
      }
    }
  }, {
    label: 'Link intermediate throw event',
    actionName: 'replace-with-link-intermediate-throw',
    className: 'bpmn-icon-intermediate-event-throw-link',
    target: {
      type: 'bpmn:IntermediateThrowEvent',
      eventDefinitionType: 'bpmn:LinkEventDefinition',
      eventDefinitionAttrs: {
        name: ''
      }
    }
  }, {
    label: 'Compensation intermediate throw event',
    actionName: 'replace-with-compensation-intermediate-throw',
    className: 'bpmn-icon-intermediate-event-throw-compensation',
    target: {
      type: 'bpmn:IntermediateThrowEvent',
      eventDefinitionType: 'bpmn:CompensateEventDefinition'
    }
  }, {
    label: 'Signal intermediate catch event',
    actionName: 'replace-with-signal-intermediate-catch',
    className: 'bpmn-icon-intermediate-event-catch-signal',
    target: {
      type: 'bpmn:IntermediateCatchEvent',
      eventDefinitionType: 'bpmn:SignalEventDefinition'
    }
  }, {
    label: 'Signal intermediate throw event',
    actionName: 'replace-with-signal-intermediate-throw',
    className: 'bpmn-icon-intermediate-event-throw-signal',
    target: {
      type: 'bpmn:IntermediateThrowEvent',
      eventDefinitionType: 'bpmn:SignalEventDefinition'
    }
  }];
  var END_EVENT = [{
    label: 'Start event',
    actionName: 'replace-with-none-start',
    className: 'bpmn-icon-start-event-none',
    target: {
      type: 'bpmn:StartEvent'
    }
  }, {
    label: 'Intermediate throw event',
    actionName: 'replace-with-none-intermediate-throw',
    className: 'bpmn-icon-intermediate-event-none',
    target: {
      type: 'bpmn:IntermediateThrowEvent'
    }
  }, {
    label: 'End event',
    actionName: 'replace-with-none-end',
    className: 'bpmn-icon-end-event-none',
    target: {
      type: 'bpmn:EndEvent'
    }
  }, {
    label: 'Message end event',
    actionName: 'replace-with-message-end',
    className: 'bpmn-icon-end-event-message',
    target: {
      type: 'bpmn:EndEvent',
      eventDefinitionType: 'bpmn:MessageEventDefinition'
    }
  }, {
    label: 'Escalation end event',
    actionName: 'replace-with-escalation-end',
    className: 'bpmn-icon-end-event-escalation',
    target: {
      type: 'bpmn:EndEvent',
      eventDefinitionType: 'bpmn:EscalationEventDefinition'
    }
  }, {
    label: 'Error end event',
    actionName: 'replace-with-error-end',
    className: 'bpmn-icon-end-event-error',
    target: {
      type: 'bpmn:EndEvent',
      eventDefinitionType: 'bpmn:ErrorEventDefinition'
    }
  }, {
    label: 'Cancel end event',
    actionName: 'replace-with-cancel-end',
    className: 'bpmn-icon-end-event-cancel',
    target: {
      type: 'bpmn:EndEvent',
      eventDefinitionType: 'bpmn:CancelEventDefinition'
    }
  }, {
    label: 'Compensation end event',
    actionName: 'replace-with-compensation-end',
    className: 'bpmn-icon-end-event-compensation',
    target: {
      type: 'bpmn:EndEvent',
      eventDefinitionType: 'bpmn:CompensateEventDefinition'
    }
  }, {
    label: 'Signal end event',
    actionName: 'replace-with-signal-end',
    className: 'bpmn-icon-end-event-signal',
    target: {
      type: 'bpmn:EndEvent',
      eventDefinitionType: 'bpmn:SignalEventDefinition'
    }
  }, {
    label: 'Terminate end event',
    actionName: 'replace-with-terminate-end',
    className: 'bpmn-icon-end-event-terminate',
    target: {
      type: 'bpmn:EndEvent',
      eventDefinitionType: 'bpmn:TerminateEventDefinition'
    }
  }];
  var GATEWAY = [{
    label: 'Exclusive gateway',
    actionName: 'replace-with-exclusive-gateway',
    className: 'bpmn-icon-gateway-xor',
    target: {
      type: 'bpmn:ExclusiveGateway'
    }
  }, {
    label: 'Parallel gateway',
    actionName: 'replace-with-parallel-gateway',
    className: 'bpmn-icon-gateway-parallel',
    target: {
      type: 'bpmn:ParallelGateway'
    }
  }, {
    label: 'Inclusive gateway',
    actionName: 'replace-with-inclusive-gateway',
    className: 'bpmn-icon-gateway-or',
    target: {
      type: 'bpmn:InclusiveGateway'
    }
  }, {
    label: 'Complex gateway',
    actionName: 'replace-with-complex-gateway',
    className: 'bpmn-icon-gateway-complex',
    target: {
      type: 'bpmn:ComplexGateway'
    }
  }, {
    label: 'Event-based gateway',
    actionName: 'replace-with-event-based-gateway',
    className: 'bpmn-icon-gateway-eventbased',
    target: {
      type: 'bpmn:EventBasedGateway',
      instantiate: false,
      eventGatewayType: 'Exclusive'
    }
  }];
  var SUBPROCESS_EXPANDED = [{
    label: 'Transaction',
    actionName: 'replace-with-transaction',
    className: 'bpmn-icon-transaction',
    target: {
      type: 'bpmn:Transaction',
      isExpanded: true
    }
  }, {
    label: 'Event sub-process',
    actionName: 'replace-with-event-subprocess',
    className: 'bpmn-icon-event-subprocess-expanded',
    target: {
      type: 'bpmn:SubProcess',
      triggeredByEvent: true,
      isExpanded: true
    }
  }, {
    label: 'Ad-hoc sub-process',
    actionName: 'replace-with-ad-hoc-subprocess',
    className: 'bpmn-icon-subprocess-expanded',
    target: {
      type: 'bpmn:AdHocSubProcess',
      isExpanded: true
    }
  }, {
    label: 'Sub-process (collapsed)',
    actionName: 'replace-with-collapsed-subprocess',
    className: 'bpmn-icon-subprocess-collapsed',
    target: {
      type: 'bpmn:SubProcess',
      isExpanded: false
    }
  }];
  var AD_HOC_SUBPROCESS_EXPANDED = [{
    label: 'Sub-process',
    actionName: 'replace-with-subprocess',
    className: 'bpmn-icon-subprocess-expanded',
    target: {
      type: 'bpmn:SubProcess',
      isExpanded: true
    }
  }, {
    label: 'Transaction',
    actionName: 'replace-with-transaction',
    className: 'bpmn-icon-transaction',
    target: {
      type: 'bpmn:Transaction',
      isExpanded: true
    }
  }, {
    label: 'Event sub-process',
    actionName: 'replace-with-event-subprocess',
    className: 'bpmn-icon-event-subprocess-expanded',
    target: {
      type: 'bpmn:SubProcess',
      triggeredByEvent: true,
      isExpanded: true
    }
  }, {
    label: 'Ad-hoc sub-process (collapsed)',
    actionName: 'replace-with-collapsed-ad-hoc-subprocess',
    className: 'bpmn-icon-subprocess-collapsed',
    target: {
      type: 'bpmn:AdHocSubProcess',
      isExpanded: false
    }
  }];
  var TRANSACTION = [{
    label: 'Transaction',
    actionName: 'replace-with-transaction',
    className: 'bpmn-icon-transaction',
    target: {
      type: 'bpmn:Transaction',
      isExpanded: true
    }
  }, {
    label: 'Sub-process',
    actionName: 'replace-with-subprocess',
    className: 'bpmn-icon-subprocess-expanded',
    target: {
      type: 'bpmn:SubProcess',
      isExpanded: true
    }
  }, {
    label: 'Ad-hoc sub-process',
    actionName: 'replace-with-ad-hoc-subprocess',
    className: 'bpmn-icon-subprocess-expanded',
    target: {
      type: 'bpmn:AdHocSubProcess',
      isExpanded: true
    }
  }, {
    label: 'Event sub-process',
    actionName: 'replace-with-event-subprocess',
    className: 'bpmn-icon-event-subprocess-expanded',
    target: {
      type: 'bpmn:SubProcess',
      triggeredByEvent: true,
      isExpanded: true
    }
  }];
  var EVENT_SUB_PROCESS = TRANSACTION;
  var TASK = [{
    label: 'Task',
    actionName: 'replace-with-task',
    className: 'bpmn-icon-task',
    target: {
      type: 'bpmn:Task'
    }
  }, {
    label: 'User task',
    actionName: 'replace-with-user-task',
    className: 'bpmn-icon-user',
    target: {
      type: 'bpmn:UserTask'
    }
  }, {
    label: 'Service task',
    actionName: 'replace-with-service-task',
    className: 'bpmn-icon-service',
    target: {
      type: 'bpmn:ServiceTask'
    }
  }, {
    label: 'Send task',
    actionName: 'replace-with-send-task',
    className: 'bpmn-icon-send',
    target: {
      type: 'bpmn:SendTask'
    }
  }, {
    label: 'Receive task',
    actionName: 'replace-with-receive-task',
    className: 'bpmn-icon-receive',
    target: {
      type: 'bpmn:ReceiveTask'
    }
  }, {
    label: 'Manual task',
    actionName: 'replace-with-manual-task',
    className: 'bpmn-icon-manual',
    target: {
      type: 'bpmn:ManualTask'
    }
  }, {
    label: 'Business rule task',
    actionName: 'replace-with-rule-task',
    className: 'bpmn-icon-business-rule',
    target: {
      type: 'bpmn:BusinessRuleTask'
    }
  }, {
    label: 'Script task',
    actionName: 'replace-with-script-task',
    className: 'bpmn-icon-script',
    target: {
      type: 'bpmn:ScriptTask'
    }
  }, {
    label: 'Call activity',
    actionName: 'replace-with-call-activity',
    className: 'bpmn-icon-call-activity',
    target: {
      type: 'bpmn:CallActivity'
    }
  }, {
    label: 'Sub-process (collapsed)',
    actionName: 'replace-with-collapsed-subprocess',
    className: 'bpmn-icon-subprocess-collapsed',
    target: {
      type: 'bpmn:SubProcess',
      isExpanded: false
    }
  }, {
    label: 'Sub-process (expanded)',
    actionName: 'replace-with-expanded-subprocess',
    className: 'bpmn-icon-subprocess-expanded',
    target: {
      type: 'bpmn:SubProcess',
      isExpanded: true
    }
  }, {
    label: 'Ad-hoc sub-process (collapsed)',
    actionName: 'replace-with-collapsed-ad-hoc-subprocess',
    className: 'bpmn-icon-subprocess-collapsed',
    target: {
      type: 'bpmn:AdHocSubProcess',
      isExpanded: false
    }
  }, {
    label: 'Ad-hoc sub-process (expanded)',
    actionName: 'replace-with-ad-hoc-subprocess',
    className: 'bpmn-icon-subprocess-expanded',
    target: {
      type: 'bpmn:AdHocSubProcess',
      isExpanded: true
    }
  }];
  var DATA_OBJECT_REFERENCE = [{
    label: 'Data store reference',
    actionName: 'replace-with-data-store-reference',
    className: 'bpmn-icon-data-store',
    target: {
      type: 'bpmn:DataStoreReference'
    }
  }];
  var DATA_STORE_REFERENCE = [{
    label: 'Data object reference',
    actionName: 'replace-with-data-object-reference',
    className: 'bpmn-icon-data-object',
    target: {
      type: 'bpmn:DataObjectReference'
    }
  }];
  var BOUNDARY_EVENT = [{
    label: 'Message boundary event',
    actionName: 'replace-with-message-boundary',
    className: 'bpmn-icon-intermediate-event-catch-message',
    target: {
      type: 'bpmn:BoundaryEvent',
      eventDefinitionType: 'bpmn:MessageEventDefinition',
      cancelActivity: true
    }
  }, {
    label: 'Timer boundary event',
    actionName: 'replace-with-timer-boundary',
    className: 'bpmn-icon-intermediate-event-catch-timer',
    target: {
      type: 'bpmn:BoundaryEvent',
      eventDefinitionType: 'bpmn:TimerEventDefinition',
      cancelActivity: true
    }
  }, {
    label: 'Escalation boundary event',
    actionName: 'replace-with-escalation-boundary',
    className: 'bpmn-icon-intermediate-event-catch-escalation',
    target: {
      type: 'bpmn:BoundaryEvent',
      eventDefinitionType: 'bpmn:EscalationEventDefinition',
      cancelActivity: true
    }
  }, {
    label: 'Conditional boundary event',
    actionName: 'replace-with-conditional-boundary',
    className: 'bpmn-icon-intermediate-event-catch-condition',
    target: {
      type: 'bpmn:BoundaryEvent',
      eventDefinitionType: 'bpmn:ConditionalEventDefinition',
      cancelActivity: true
    }
  }, {
    label: 'Error boundary event',
    actionName: 'replace-with-error-boundary',
    className: 'bpmn-icon-intermediate-event-catch-error',
    target: {
      type: 'bpmn:BoundaryEvent',
      eventDefinitionType: 'bpmn:ErrorEventDefinition',
      cancelActivity: true
    }
  }, {
    label: 'Cancel boundary event',
    actionName: 'replace-with-cancel-boundary',
    className: 'bpmn-icon-intermediate-event-catch-cancel',
    target: {
      type: 'bpmn:BoundaryEvent',
      eventDefinitionType: 'bpmn:CancelEventDefinition',
      cancelActivity: true
    }
  }, {
    label: 'Signal boundary event',
    actionName: 'replace-with-signal-boundary',
    className: 'bpmn-icon-intermediate-event-catch-signal',
    target: {
      type: 'bpmn:BoundaryEvent',
      eventDefinitionType: 'bpmn:SignalEventDefinition',
      cancelActivity: true
    }
  }, {
    label: 'Compensation boundary event',
    actionName: 'replace-with-compensation-boundary',
    className: 'bpmn-icon-intermediate-event-catch-compensation',
    target: {
      type: 'bpmn:BoundaryEvent',
      eventDefinitionType: 'bpmn:CompensateEventDefinition',
      cancelActivity: true
    }
  }, {
    label: 'Message boundary event (non-interrupting)',
    actionName: 'replace-with-non-interrupting-message-boundary',
    className: 'bpmn-icon-intermediate-event-catch-non-interrupting-message',
    target: {
      type: 'bpmn:BoundaryEvent',
      eventDefinitionType: 'bpmn:MessageEventDefinition',
      cancelActivity: false
    }
  }, {
    label: 'Timer boundary event (non-interrupting)',
    actionName: 'replace-with-non-interrupting-timer-boundary',
    className: 'bpmn-icon-intermediate-event-catch-non-interrupting-timer',
    target: {
      type: 'bpmn:BoundaryEvent',
      eventDefinitionType: 'bpmn:TimerEventDefinition',
      cancelActivity: false
    }
  }, {
    label: 'Escalation boundary event (non-interrupting)',
    actionName: 'replace-with-non-interrupting-escalation-boundary',
    className: 'bpmn-icon-intermediate-event-catch-non-interrupting-escalation',
    target: {
      type: 'bpmn:BoundaryEvent',
      eventDefinitionType: 'bpmn:EscalationEventDefinition',
      cancelActivity: false
    }
  }, {
    label: 'Conditional boundary event (non-interrupting)',
    actionName: 'replace-with-non-interrupting-conditional-boundary',
    className: 'bpmn-icon-intermediate-event-catch-non-interrupting-condition',
    target: {
      type: 'bpmn:BoundaryEvent',
      eventDefinitionType: 'bpmn:ConditionalEventDefinition',
      cancelActivity: false
    }
  }, {
    label: 'Signal boundary event (non-interrupting)',
    actionName: 'replace-with-non-interrupting-signal-boundary',
    className: 'bpmn-icon-intermediate-event-catch-non-interrupting-signal',
    target: {
      type: 'bpmn:BoundaryEvent',
      eventDefinitionType: 'bpmn:SignalEventDefinition',
      cancelActivity: false
    }
  }];
  var EVENT_SUB_PROCESS_START_EVENT = [{
    label: 'Message start event',
    actionName: 'replace-with-message-start',
    className: 'bpmn-icon-start-event-message',
    target: {
      type: 'bpmn:StartEvent',
      eventDefinitionType: 'bpmn:MessageEventDefinition',
      isInterrupting: true
    }
  }, {
    label: 'Timer start event',
    actionName: 'replace-with-timer-start',
    className: 'bpmn-icon-start-event-timer',
    target: {
      type: 'bpmn:StartEvent',
      eventDefinitionType: 'bpmn:TimerEventDefinition',
      isInterrupting: true
    }
  }, {
    label: 'Conditional start event',
    actionName: 'replace-with-conditional-start',
    className: 'bpmn-icon-start-event-condition',
    target: {
      type: 'bpmn:StartEvent',
      eventDefinitionType: 'bpmn:ConditionalEventDefinition',
      isInterrupting: true
    }
  }, {
    label: 'Signal start event',
    actionName: 'replace-with-signal-start',
    className: 'bpmn-icon-start-event-signal',
    target: {
      type: 'bpmn:StartEvent',
      eventDefinitionType: 'bpmn:SignalEventDefinition',
      isInterrupting: true
    }
  }, {
    label: 'Error start event',
    actionName: 'replace-with-error-start',
    className: 'bpmn-icon-start-event-error',
    target: {
      type: 'bpmn:StartEvent',
      eventDefinitionType: 'bpmn:ErrorEventDefinition',
      isInterrupting: true
    }
  }, {
    label: 'Escalation start event',
    actionName: 'replace-with-escalation-start',
    className: 'bpmn-icon-start-event-escalation',
    target: {
      type: 'bpmn:StartEvent',
      eventDefinitionType: 'bpmn:EscalationEventDefinition',
      isInterrupting: true
    }
  }, {
    label: 'Compensation start event',
    actionName: 'replace-with-compensation-start',
    className: 'bpmn-icon-start-event-compensation',
    target: {
      type: 'bpmn:StartEvent',
      eventDefinitionType: 'bpmn:CompensateEventDefinition',
      isInterrupting: true
    }
  }, {
    label: 'Message start event (non-interrupting)',
    actionName: 'replace-with-non-interrupting-message-start',
    className: 'bpmn-icon-start-event-non-interrupting-message',
    target: {
      type: 'bpmn:StartEvent',
      eventDefinitionType: 'bpmn:MessageEventDefinition',
      isInterrupting: false
    }
  }, {
    label: 'Timer start event (non-interrupting)',
    actionName: 'replace-with-non-interrupting-timer-start',
    className: 'bpmn-icon-start-event-non-interrupting-timer',
    target: {
      type: 'bpmn:StartEvent',
      eventDefinitionType: 'bpmn:TimerEventDefinition',
      isInterrupting: false
    }
  }, {
    label: 'Conditional start event (non-interrupting)',
    actionName: 'replace-with-non-interrupting-conditional-start',
    className: 'bpmn-icon-start-event-non-interrupting-condition',
    target: {
      type: 'bpmn:StartEvent',
      eventDefinitionType: 'bpmn:ConditionalEventDefinition',
      isInterrupting: false
    }
  }, {
    label: 'Signal start event (non-interrupting)',
    actionName: 'replace-with-non-interrupting-signal-start',
    className: 'bpmn-icon-start-event-non-interrupting-signal',
    target: {
      type: 'bpmn:StartEvent',
      eventDefinitionType: 'bpmn:SignalEventDefinition',
      isInterrupting: false
    }
  }, {
    label: 'Escalation start event (non-interrupting)',
    actionName: 'replace-with-non-interrupting-escalation-start',
    className: 'bpmn-icon-start-event-non-interrupting-escalation',
    target: {
      type: 'bpmn:StartEvent',
      eventDefinitionType: 'bpmn:EscalationEventDefinition',
      isInterrupting: false
    }
  }];
  var SEQUENCE_FLOW = [{
    label: 'Sequence flow',
    actionName: 'replace-with-sequence-flow',
    className: 'bpmn-icon-connection'
  }, {
    label: 'Default flow',
    actionName: 'replace-with-default-flow',
    className: 'bpmn-icon-default-flow'
  }, {
    label: 'Conditional flow',
    actionName: 'replace-with-conditional-flow',
    className: 'bpmn-icon-conditional-flow'
  }];
  var PARTICIPANT = [{
    label: 'Expanded pool/participant',
    actionName: 'replace-with-expanded-pool',
    className: 'bpmn-icon-participant',
    target: {
      type: 'bpmn:Participant',
      isExpanded: true
    }
  }, {
    label: function label(element) {
      var label = 'Empty pool/participant';
      if (element.children && element.children.length) {
        label += ' (removes content)';
      }
      return label;
    },
    actionName: 'replace-with-collapsed-pool',
    className: 'bpmn-icon-lane',
    target: {
      type: 'bpmn:Participant',
      isExpanded: false
    }
  }];
  var TYPED_EVENT = {
    'bpmn:MessageEventDefinition': [{
      label: 'Message start event',
      actionName: 'replace-with-message-start',
      className: 'bpmn-icon-start-event-message',
      target: {
        type: 'bpmn:StartEvent',
        eventDefinitionType: 'bpmn:MessageEventDefinition'
      }
    }, {
      label: 'Message intermediate catch event',
      actionName: 'replace-with-message-intermediate-catch',
      className: 'bpmn-icon-intermediate-event-catch-message',
      target: {
        type: 'bpmn:IntermediateCatchEvent',
        eventDefinitionType: 'bpmn:MessageEventDefinition'
      }
    }, {
      label: 'Message intermediate throw event',
      actionName: 'replace-with-message-intermediate-throw',
      className: 'bpmn-icon-intermediate-event-throw-message',
      target: {
        type: 'bpmn:IntermediateThrowEvent',
        eventDefinitionType: 'bpmn:MessageEventDefinition'
      }
    }, {
      label: 'Message end event',
      actionName: 'replace-with-message-end',
      className: 'bpmn-icon-end-event-message',
      target: {
        type: 'bpmn:EndEvent',
        eventDefinitionType: 'bpmn:MessageEventDefinition'
      }
    }],
    'bpmn:TimerEventDefinition': [{
      label: 'Timer start event',
      actionName: 'replace-with-timer-start',
      className: 'bpmn-icon-start-event-timer',
      target: {
        type: 'bpmn:StartEvent',
        eventDefinitionType: 'bpmn:TimerEventDefinition'
      }
    }, {
      label: 'Timer intermediate catch event',
      actionName: 'replace-with-timer-intermediate-catch',
      className: 'bpmn-icon-intermediate-event-catch-timer',
      target: {
        type: 'bpmn:IntermediateCatchEvent',
        eventDefinitionType: 'bpmn:TimerEventDefinition'
      }
    }],
    'bpmn:ConditionalEventDefinition': [{
      label: 'Conditional start event',
      actionName: 'replace-with-conditional-start',
      className: 'bpmn-icon-start-event-condition',
      target: {
        type: 'bpmn:StartEvent',
        eventDefinitionType: 'bpmn:ConditionalEventDefinition'
      }
    }, {
      label: 'Conditional intermediate catch event',
      actionName: 'replace-with-conditional-intermediate-catch',
      className: 'bpmn-icon-intermediate-event-catch-condition',
      target: {
        type: 'bpmn:IntermediateCatchEvent',
        eventDefinitionType: 'bpmn:ConditionalEventDefinition'
      }
    }],
    'bpmn:SignalEventDefinition': [{
      label: 'Signal start event',
      actionName: 'replace-with-signal-start',
      className: 'bpmn-icon-start-event-signal',
      target: {
        type: 'bpmn:StartEvent',
        eventDefinitionType: 'bpmn:SignalEventDefinition'
      }
    }, {
      label: 'Signal intermediate catch event',
      actionName: 'replace-with-signal-intermediate-catch',
      className: 'bpmn-icon-intermediate-event-catch-signal',
      target: {
        type: 'bpmn:IntermediateCatchEvent',
        eventDefinitionType: 'bpmn:SignalEventDefinition'
      }
    }, {
      label: 'Signal intermediate throw event',
      actionName: 'replace-with-signal-intermediate-throw',
      className: 'bpmn-icon-intermediate-event-throw-signal',
      target: {
        type: 'bpmn:IntermediateThrowEvent',
        eventDefinitionType: 'bpmn:SignalEventDefinition'
      }
    }, {
      label: 'Signal end event',
      actionName: 'replace-with-signal-end',
      className: 'bpmn-icon-end-event-signal',
      target: {
        type: 'bpmn:EndEvent',
        eventDefinitionType: 'bpmn:SignalEventDefinition'
      }
    }],
    'bpmn:ErrorEventDefinition': [{
      label: 'Error start event',
      actionName: 'replace-with-error-start',
      className: 'bpmn-icon-start-event-error',
      target: {
        type: 'bpmn:StartEvent',
        eventDefinitionType: 'bpmn:ErrorEventDefinition'
      }
    }, {
      label: 'Error end event',
      actionName: 'replace-with-error-end',
      className: 'bpmn-icon-end-event-error',
      target: {
        type: 'bpmn:EndEvent',
        eventDefinitionType: 'bpmn:ErrorEventDefinition'
      }
    }],
    'bpmn:EscalationEventDefinition': [{
      label: 'Escalation start event',
      actionName: 'replace-with-escalation-start',
      className: 'bpmn-icon-start-event-escalation',
      target: {
        type: 'bpmn:StartEvent',
        eventDefinitionType: 'bpmn:EscalationEventDefinition'
      }
    }, {
      label: 'Escalation intermediate throw event',
      actionName: 'replace-with-escalation-intermediate-throw',
      className: 'bpmn-icon-intermediate-event-throw-escalation',
      target: {
        type: 'bpmn:IntermediateThrowEvent',
        eventDefinitionType: 'bpmn:EscalationEventDefinition'
      }
    }, {
      label: 'Escalation end event',
      actionName: 'replace-with-escalation-end',
      className: 'bpmn-icon-end-event-escalation',
      target: {
        type: 'bpmn:EndEvent',
        eventDefinitionType: 'bpmn:EscalationEventDefinition'
      }
    }],
    'bpmn:CompensateEventDefinition': [{
      label: 'Compensation start event',
      actionName: 'replace-with-compensation-start',
      className: 'bpmn-icon-start-event-compensation',
      target: {
        type: 'bpmn:StartEvent',
        eventDefinitionType: 'bpmn:CompensateEventDefinition'
      }
    }, {
      label: 'Compensation intermediate throw event',
      actionName: 'replace-with-compensation-intermediate-throw',
      className: 'bpmn-icon-intermediate-event-throw-compensation',
      target: {
        type: 'bpmn:IntermediateThrowEvent',
        eventDefinitionType: 'bpmn:CompensateEventDefinition'
      }
    }, {
      label: 'Compensation end event',
      actionName: 'replace-with-compensation-end',
      className: 'bpmn-icon-end-event-compensation',
      target: {
        type: 'bpmn:EndEvent',
        eventDefinitionType: 'bpmn:CompensateEventDefinition'
      }
    }]
  };
  var Icons = {
    'start-event-non-interrupting': `
  <svg viewBox="0 0 2048 2048" xmlns="http://www.w3.org/2000/svg">
    <g transform="translate(0 995.64)">
      <path d="m1899 28.357c21.545 567.43-598.38 1023.5-1133.6 835.92-548.09-147.21-801.57-873.95-463.59-1330 302.62-480.3 1071.7-507.54 1407.6-49.847 122.14 153.12 190.07 348.07 189.59 543.91z" fill="none" stroke="currentColor" stroke-dasharray="418.310422, 361.2328165" stroke-linecap="round" stroke-width="100"/>
    </g>
  </svg>`,
    'intermediate-event-non-interrupting': `
  <svg viewBox="0 0 2048 2048" xmlns="http://www.w3.org/2000/svg">
     <g transform="translate(0 995.64)" fill="none" stroke="currentColor" stroke-linecap="round">
        <circle cx="1024" cy="28.357" r="875" stroke-dasharray="418.310422, 361.2328165" stroke-width="100"/>
        <circle cx="1024" cy="28.357" r="685" stroke-dasharray="348.31044857,261.23283643" stroke-dashoffset="500" stroke-width="100"/>
     </g>
  </svg>`
  };
  function ReplaceMenuProvider(bpmnFactory, popupMenu, modeling, moddle, bpmnReplace, rules, translate, moddleCopy) {
    this._bpmnFactory = bpmnFactory;
    this._popupMenu = popupMenu;
    this._modeling = modeling;
    this._moddle = moddle;
    this._bpmnReplace = bpmnReplace;
    this._rules = rules;
    this._translate = translate;
    this._moddleCopy = moddleCopy;
    this._register();
  }
  ReplaceMenuProvider.$inject = ['bpmnFactory', 'popupMenu', 'modeling', 'moddle', 'bpmnReplace', 'rules', 'translate', 'moddleCopy'];
  ReplaceMenuProvider.prototype._register = function () {
    this._popupMenu.registerProvider('bpmn-replace', this);
  };
  ReplaceMenuProvider.prototype.getPopupMenuEntries = function (target) {
    var businessObject = target.businessObject;
    var rules = this._rules;
    var sameTypeEventOptions = [],
      eventDefinitionType;
    var filteredReplaceOptions = [];
    if (isArray$3(target) || !rules.allowed('shape.replace', {
      element: target
    })) {
      return {};
    }
    var differentType = isDifferentType(target);
    if (is(businessObject, 'bpmn:DataObjectReference')) {
      return this._createEntries(target, DATA_OBJECT_REFERENCE);
    }
    if (is(businessObject, 'bpmn:DataStoreReference') && !is(target.parent, 'bpmn:Collaboration')) {
      return this._createEntries(target, DATA_STORE_REFERENCE);
    }
    if (is(businessObject, 'bpmn:Event') && !is(businessObject, 'bpmn:BoundaryEvent')) {
      var _businessObject$get$;
      eventDefinitionType = (_businessObject$get$ = businessObject.get('eventDefinitions')[0]) === null || _businessObject$get$ === void 0 ? void 0 : _businessObject$get$.$type;
      sameTypeEventOptions = TYPED_EVENT[eventDefinitionType] || [];
      if (!isEventSubProcess(businessObject.$parent) && is(businessObject.$parent, 'bpmn:SubProcess')) {
        sameTypeEventOptions = filter(sameTypeEventOptions, function (option) {
          return option.target.type !== 'bpmn:StartEvent';
        });
      }
    }
    if (is(businessObject, 'bpmn:StartEvent') && !is(businessObject.$parent, 'bpmn:SubProcess')) {
      filteredReplaceOptions = filter(START_EVENT.concat(sameTypeEventOptions), differentType);
      return this._createEntries(target, filteredReplaceOptions);
    }
    if (is(businessObject, 'bpmn:Participant')) {
      filteredReplaceOptions = filter(PARTICIPANT, function (replaceOption) {
        return isExpanded(target) !== replaceOption.target.isExpanded;
      });
      return this._createEntries(target, filteredReplaceOptions);
    }
    if (is(businessObject, 'bpmn:StartEvent') && isEventSubProcess(businessObject.$parent)) {
      filteredReplaceOptions = filter(EVENT_SUB_PROCESS_START_EVENT.concat(sameTypeEventOptions), function (replaceOption) {
        var target = replaceOption.target;
        var isInterrupting = target.isInterrupting !== false;
        var isInterruptingEqual = businessObject.isInterrupting === isInterrupting;
        return differentType(replaceOption) || !differentType(replaceOption) && !isInterruptingEqual;
      });
      return this._createEntries(target, filteredReplaceOptions);
    }
    if (is(businessObject, 'bpmn:StartEvent') && !isEventSubProcess(businessObject.$parent) && is(businessObject.$parent, 'bpmn:SubProcess')) {
      filteredReplaceOptions = filter(START_EVENT_SUB_PROCESS.concat(sameTypeEventOptions), differentType);
      return this._createEntries(target, filteredReplaceOptions);
    }
    if (is(businessObject, 'bpmn:EndEvent')) {
      filteredReplaceOptions = filter(END_EVENT.concat(sameTypeEventOptions), function (replaceOption) {
        var target = replaceOption.target;
        if (target.eventDefinitionType == 'bpmn:CancelEventDefinition' && !is(businessObject.$parent, 'bpmn:Transaction')) {
          return false;
        }
        return differentType(replaceOption);
      });
      return this._createEntries(target, filteredReplaceOptions);
    }
    if (is(businessObject, 'bpmn:BoundaryEvent')) {
      filteredReplaceOptions = filter(BOUNDARY_EVENT, function (replaceOption) {
        var target = replaceOption.target;
        if (target.eventDefinitionType == 'bpmn:CancelEventDefinition' && !is(businessObject.attachedToRef, 'bpmn:Transaction')) {
          return false;
        }
        var cancelActivity = target.cancelActivity !== false;
        var isCancelActivityEqual = businessObject.cancelActivity == cancelActivity;
        return differentType(replaceOption) || !differentType(replaceOption) && !isCancelActivityEqual;
      });
      return this._createEntries(target, filteredReplaceOptions);
    }
    if (is(businessObject, 'bpmn:IntermediateCatchEvent') || is(businessObject, 'bpmn:IntermediateThrowEvent')) {
      filteredReplaceOptions = filter(INTERMEDIATE_EVENT.concat(sameTypeEventOptions), differentType);
      return this._createEntries(target, filteredReplaceOptions);
    }
    if (is(businessObject, 'bpmn:Gateway')) {
      filteredReplaceOptions = filter(GATEWAY, differentType);
      return this._createEntries(target, filteredReplaceOptions);
    }
    if (is(businessObject, 'bpmn:Transaction')) {
      filteredReplaceOptions = filter(TRANSACTION, differentType);
      return this._createEntries(target, filteredReplaceOptions);
    }
    if (isEventSubProcess(businessObject) && isExpanded(target)) {
      filteredReplaceOptions = filter(EVENT_SUB_PROCESS, differentType);
      return this._createEntries(target, filteredReplaceOptions);
    }
    if (is(businessObject, 'bpmn:AdHocSubProcess') && isExpanded(target)) {
      filteredReplaceOptions = filter(AD_HOC_SUBPROCESS_EXPANDED, differentType);
      return this._createEntries(target, filteredReplaceOptions);
    }
    if (is(businessObject, 'bpmn:SubProcess') && isExpanded(target)) {
      filteredReplaceOptions = filter(SUBPROCESS_EXPANDED, differentType);
      return this._createEntries(target, filteredReplaceOptions);
    }
    if (is(businessObject, 'bpmn:SubProcess') && !isExpanded(target)) {
      filteredReplaceOptions = filter(TASK, function (replaceOption) {
        var isTargetSameType = replaceOption.target.type === target.type;
        var isTargetExpanded = replaceOption.target.isExpanded === true;
        return isTargetSameType === isTargetExpanded;
      });
      return this._createEntries(target, filteredReplaceOptions);
    }
    if (is(businessObject, 'bpmn:SequenceFlow')) {
      return this._createSequenceFlowEntries(target, SEQUENCE_FLOW);
    }
    if (is(businessObject, 'bpmn:FlowNode')) {
      filteredReplaceOptions = filter(TASK, differentType);
      return this._createEntries(target, filteredReplaceOptions);
    }
    return {};
  };
  ReplaceMenuProvider.prototype.getPopupMenuHeaderEntries = function (target) {
    var headerEntries = {};
    if (is(target, 'bpmn:Activity') && !isEventSubProcess(target)) {
      headerEntries = _objectSpread(_objectSpread({}, headerEntries), this._getLoopCharacteristicsHeaderEntries(target));
    }
    if (is(target, 'bpmn:DataObjectReference')) {
      headerEntries = _objectSpread(_objectSpread({}, headerEntries), this._getCollectionHeaderEntries(target));
    }
    if (is(target, 'bpmn:Participant')) {
      headerEntries = _objectSpread(_objectSpread({}, headerEntries), this._getParticipantMultiplicityHeaderEntries(target));
    }
    if (canBeNonInterrupting(target)) {
      headerEntries = _objectSpread(_objectSpread({}, headerEntries), this._getNonInterruptingHeaderEntries(target));
    }
    return headerEntries;
  };
  ReplaceMenuProvider.prototype._createEntries = function (target, replaceOptions) {
    var entries = {};
    var self = this;
    forEach$1(replaceOptions, function (replaceOption) {
      entries[replaceOption.actionName] = self._createEntry(replaceOption, target);
    });
    return entries;
  };
  ReplaceMenuProvider.prototype._createSequenceFlowEntries = function (target, replaceOptions) {
    var businessObject = getBusinessObject(target);
    var entries = {};
    var modeling = this._modeling,
      moddle = this._moddle;
    var self = this;
    forEach$1(replaceOptions, function (replaceOption) {
      switch (replaceOption.actionName) {
        case 'replace-with-default-flow':
          if (businessObject.sourceRef.default !== businessObject && (is(businessObject.sourceRef, 'bpmn:ExclusiveGateway') || is(businessObject.sourceRef, 'bpmn:InclusiveGateway') || is(businessObject.sourceRef, 'bpmn:ComplexGateway') || is(businessObject.sourceRef, 'bpmn:Activity'))) {
            entries = _objectSpread(_objectSpread({}, entries), {}, {
              [replaceOption.actionName]: self._createEntry(replaceOption, target, function () {
                modeling.updateProperties(target.source, {
                  default: businessObject
                });
              })
            });
          }
          break;
        case 'replace-with-conditional-flow':
          if (!businessObject.conditionExpression && is(businessObject.sourceRef, 'bpmn:Activity')) {
            entries = _objectSpread(_objectSpread({}, entries), {}, {
              [replaceOption.actionName]: self._createEntry(replaceOption, target, function () {
                var conditionExpression = moddle.create('bpmn:FormalExpression', {
                  body: ''
                });
                modeling.updateProperties(target, {
                  conditionExpression: conditionExpression
                });
              })
            });
          }
          break;
        default:
          if (is(businessObject.sourceRef, 'bpmn:Activity') && businessObject.conditionExpression) {
            entries = _objectSpread(_objectSpread({}, entries), {}, {
              [replaceOption.actionName]: self._createEntry(replaceOption, target, function () {
                modeling.updateProperties(target, {
                  conditionExpression: undefined
                });
              })
            });
          }
          if ((is(businessObject.sourceRef, 'bpmn:ExclusiveGateway') || is(businessObject.sourceRef, 'bpmn:InclusiveGateway') || is(businessObject.sourceRef, 'bpmn:ComplexGateway') || is(businessObject.sourceRef, 'bpmn:Activity')) && businessObject.sourceRef.default === businessObject) {
            entries = _objectSpread(_objectSpread({}, entries), {}, {
              [replaceOption.actionName]: self._createEntry(replaceOption, target, function () {
                modeling.updateProperties(target.source, {
                  default: undefined
                });
              })
            });
          }
      }
    });
    return entries;
  };
  ReplaceMenuProvider.prototype._createEntry = function (replaceOption, target, action) {
    var translate = this._translate;
    var replaceElement = this._bpmnReplace.replaceElement;
    var replaceAction = function replaceAction() {
      return replaceElement(target, replaceOption.target);
    };
    var label = replaceOption.label;
    if (label && typeof label === 'function') {
      label = label(target);
    }
    action = action || replaceAction;
    return {
      label: translate(label),
      className: replaceOption.className,
      action: action
    };
  };
  ReplaceMenuProvider.prototype._getLoopCharacteristicsHeaderEntries = function (target) {
    var self = this;
    var translate = this._translate;
    function toggleLoopCharacteristics(event, entry) {
      if (entry.active) {
        self._modeling.updateProperties(target, {
          loopCharacteristics: undefined
        });
        return;
      }
      var loopCharacteristics = target.businessObject.get('loopCharacteristics');
      if (loopCharacteristics && is(loopCharacteristics, entry.options.loopCharacteristics)) {
        self._modeling.updateModdleProperties(target, loopCharacteristics, {
          isSequential: entry.options.isSequential
        });
      } else {
        loopCharacteristics = self._moddle.create(entry.options.loopCharacteristics, {
          isSequential: entry.options.isSequential
        });
        self._modeling.updateProperties(target, {
          loopCharacteristics: loopCharacteristics
        });
      }
    }
    var businessObject = getBusinessObject(target),
      loopCharacteristics = businessObject.loopCharacteristics;
    var isSequential, isLoop, isParallel;
    if (loopCharacteristics) {
      isSequential = loopCharacteristics.isSequential;
      isLoop = loopCharacteristics.isSequential === undefined;
      isParallel = loopCharacteristics.isSequential !== undefined && !loopCharacteristics.isSequential;
    }
    return {
      'toggle-parallel-mi': {
        className: 'bpmn-icon-parallel-mi-marker',
        title: translate('Parallel multi-instance'),
        active: isParallel,
        action: toggleLoopCharacteristics,
        options: {
          loopCharacteristics: 'bpmn:MultiInstanceLoopCharacteristics',
          isSequential: false
        }
      },
      'toggle-sequential-mi': {
        className: 'bpmn-icon-sequential-mi-marker',
        title: translate('Sequential multi-instance'),
        active: isSequential,
        action: toggleLoopCharacteristics,
        options: {
          loopCharacteristics: 'bpmn:MultiInstanceLoopCharacteristics',
          isSequential: true
        }
      },
      'toggle-loop': {
        className: 'bpmn-icon-loop-marker',
        title: translate('Loop'),
        active: isLoop,
        action: toggleLoopCharacteristics,
        options: {
          loopCharacteristics: 'bpmn:StandardLoopCharacteristics'
        }
      }
    };
  };
  ReplaceMenuProvider.prototype._getCollectionHeaderEntries = function (target) {
    var self = this;
    var translate = this._translate;
    var dataObject = target.businessObject.dataObjectRef;
    if (!dataObject) {
      return {};
    }
    function toggleIsCollection(event, entry) {
      self._modeling.updateModdleProperties(target, dataObject, {
        isCollection: !entry.active
      });
    }
    var isCollection = dataObject.isCollection;
    return {
      'toggle-is-collection': {
        className: 'bpmn-icon-parallel-mi-marker',
        title: translate('Collection'),
        active: isCollection,
        action: toggleIsCollection
      }
    };
  };
  ReplaceMenuProvider.prototype._getParticipantMultiplicityHeaderEntries = function (target) {
    var self = this;
    var bpmnFactory = this._bpmnFactory;
    var translate = this._translate;
    function toggleParticipantMultiplicity(event, entry) {
      var isActive = entry.active;
      var participantMultiplicity;
      if (!isActive) {
        participantMultiplicity = bpmnFactory.create('bpmn:ParticipantMultiplicity');
      }
      self._modeling.updateProperties(target, {
        participantMultiplicity: participantMultiplicity
      });
    }
    var participantMultiplicity = target.businessObject.participantMultiplicity;
    return {
      'toggle-participant-multiplicity': {
        className: 'bpmn-icon-parallel-mi-marker',
        title: translate('Participant multiplicity'),
        active: !!participantMultiplicity,
        action: toggleParticipantMultiplicity
      }
    };
  };
  ReplaceMenuProvider.prototype._getNonInterruptingHeaderEntries = function (element) {
    var translate = this._translate;
    var businessObject = getBusinessObject(element);
    var self = this;
    var interruptingProperty = getInterruptingProperty(element);
    var icon = is(element, 'bpmn:BoundaryEvent') ? Icons['intermediate-event-non-interrupting'] : Icons['start-event-non-interrupting'];
    var isNonInterrupting = !businessObject[interruptingProperty];
    return {
      'toggle-non-interrupting': {
        imageHtml: icon,
        title: translate('Toggle non-interrupting'),
        active: isNonInterrupting,
        action: function action() {
          self._modeling.updateProperties(element, {
            [interruptingProperty]: !!isNonInterrupting
          });
        }
      }
    };
  };
  var PopupMenuModule = {
    __depends__: [PopupMenuModule$1, ReplaceModule, AutoPlaceModule],
    __init__: ['replaceMenuProvider'],
    replaceMenuProvider: ['type', ReplaceMenuProvider]
  };
  function ContextPadProvider(config, injector, eventBus, contextPad, modeling, elementFactory, connect, create, popupMenu, canvas, rules, translate, appendPreview) {
    config = config || {};
    contextPad.registerProvider(this);
    this._contextPad = contextPad;
    this._modeling = modeling;
    this._elementFactory = elementFactory;
    this._connect = connect;
    this._create = create;
    this._popupMenu = popupMenu;
    this._canvas = canvas;
    this._rules = rules;
    this._translate = translate;
    this._eventBus = eventBus;
    this._appendPreview = appendPreview;
    if (config.autoPlace !== false) {
      this._autoPlace = injector.get('autoPlace', false);
    }
    eventBus.on('create.end', 250, function (event) {
      var context = event.context,
        shape = context.shape;
      if (!hasPrimaryModifier(event) || !contextPad.isOpen(shape)) {
        return;
      }
      var entries = contextPad.getEntries(shape);
      if (entries.replace) {
        entries.replace.action.click(event, shape);
      }
    });
    eventBus.on('contextPad.close', function () {
      appendPreview.cleanUp();
    });
  }
  ContextPadProvider.$inject = ['config.contextPad', 'injector', 'eventBus', 'contextPad', 'modeling', 'elementFactory', 'connect', 'create', 'popupMenu', 'canvas', 'rules', 'translate', 'appendPreview'];
  ContextPadProvider.prototype.getMultiElementContextPadEntries = function (elements) {
    var modeling = this._modeling;
    var actions = {};
    if (this._isDeleteAllowed(elements)) {
      assign$1(actions, {
        'delete': {
          group: 'edit',
          className: 'bpmn-icon-trash',
          title: this._translate('Delete'),
          action: {
            click: function click(event, elements) {
              modeling.removeElements(elements.slice());
            }
          }
        }
      });
    }
    return actions;
  };
  ContextPadProvider.prototype._isDeleteAllowed = function (elements) {
    var baseAllowed = this._rules.allowed('elements.delete', {
      elements: elements
    });
    if (isArray$3(baseAllowed)) {
      return every(elements, function (el) {
        return baseAllowed.includes(el);
      });
    }
    return baseAllowed;
  };
  ContextPadProvider.prototype.getContextPadEntries = function (element) {
    var contextPad = this._contextPad,
      modeling = this._modeling,
      elementFactory = this._elementFactory,
      connect = this._connect,
      create = this._create,
      popupMenu = this._popupMenu,
      autoPlace = this._autoPlace,
      translate = this._translate,
      appendPreview = this._appendPreview;
    var actions = {};
    if (element.type === 'label') {
      if (this._isDeleteAllowed([element])) {
        assign$1(actions, deleteAction());
      }
      return actions;
    }
    var businessObject = element.businessObject;
    function startConnect(event, element) {
      connect.start(event, element);
    }
    function removeElement(e, element) {
      modeling.removeElements([element]);
    }
    function deleteAction() {
      return {
        'delete': {
          group: 'edit',
          className: 'bpmn-icon-trash',
          title: translate('Delete'),
          action: {
            click: removeElement
          }
        }
      };
    }
    function getReplaceMenuPosition(element) {
      var Y_OFFSET = 5;
      var pad = contextPad.getPad(element).html;
      var padRect = pad.getBoundingClientRect();
      var pos = {
        x: padRect.left,
        y: padRect.bottom + Y_OFFSET
      };
      return pos;
    }
    function appendAction(type, className, title, options) {
      function appendStart(event, element) {
        var shape = elementFactory.createShape(assign$1({
          type: type
        }, options));
        create.start(event, shape, {
          source: element
        });
      }
      var append = autoPlace ? function (_, element) {
        var shape = elementFactory.createShape(assign$1({
          type: type
        }, options));
        autoPlace.append(element, shape);
      } : appendStart;
      var previewAppend = autoPlace ? function (_, element) {
        appendPreview.create(element, type, options);
        return function () {
          appendPreview.cleanUp();
        };
      } : null;
      return {
        group: 'model',
        className: className,
        title: title,
        action: {
          dragstart: appendStart,
          click: append,
          hover: previewAppend
        }
      };
    }
    function splitLaneHandler(count) {
      return function (_, element) {
        modeling.splitLane(element, count);
        contextPad.open(element, true);
      };
    }
    if (isAny(businessObject, ['bpmn:Lane', 'bpmn:Participant']) && isExpanded(element)) {
      var childLanes = getChildLanes(element);
      assign$1(actions, {
        'lane-insert-above': {
          group: 'lane-insert-above',
          className: 'bpmn-icon-lane-insert-above',
          title: translate('Add lane above'),
          action: {
            click: function click(event, element) {
              modeling.addLane(element, 'top');
            }
          }
        }
      });
      if (childLanes.length < 2) {
        if (isHorizontal$3(element) ? element.height >= 120 : element.width >= 120) {
          assign$1(actions, {
            'lane-divide-two': {
              group: 'lane-divide',
              className: 'bpmn-icon-lane-divide-two',
              title: translate('Divide into two lanes'),
              action: {
                click: splitLaneHandler(2)
              }
            }
          });
        }
        if (isHorizontal$3(element) ? element.height >= 180 : element.width >= 180) {
          assign$1(actions, {
            'lane-divide-three': {
              group: 'lane-divide',
              className: 'bpmn-icon-lane-divide-three',
              title: translate('Divide into three lanes'),
              action: {
                click: splitLaneHandler(3)
              }
            }
          });
        }
      }
      assign$1(actions, {
        'lane-insert-below': {
          group: 'lane-insert-below',
          className: 'bpmn-icon-lane-insert-below',
          title: translate('Add lane below'),
          action: {
            click: function click(event, element) {
              modeling.addLane(element, 'bottom');
            }
          }
        }
      });
    }
    if (is(businessObject, 'bpmn:FlowNode')) {
      if (is(businessObject, 'bpmn:EventBasedGateway')) {
        assign$1(actions, {
          'append.receive-task': appendAction('bpmn:ReceiveTask', 'bpmn-icon-receive-task', translate('Append receive task')),
          'append.message-intermediate-event': appendAction('bpmn:IntermediateCatchEvent', 'bpmn-icon-intermediate-event-catch-message', translate('Append message intermediate catch event'), {
            eventDefinitionType: 'bpmn:MessageEventDefinition'
          }),
          'append.timer-intermediate-event': appendAction('bpmn:IntermediateCatchEvent', 'bpmn-icon-intermediate-event-catch-timer', translate('Append timer intermediate catch event'), {
            eventDefinitionType: 'bpmn:TimerEventDefinition'
          }),
          'append.condition-intermediate-event': appendAction('bpmn:IntermediateCatchEvent', 'bpmn-icon-intermediate-event-catch-condition', translate('Append conditional intermediate catch event'), {
            eventDefinitionType: 'bpmn:ConditionalEventDefinition'
          }),
          'append.signal-intermediate-event': appendAction('bpmn:IntermediateCatchEvent', 'bpmn-icon-intermediate-event-catch-signal', translate('Append signal intermediate catch event'), {
            eventDefinitionType: 'bpmn:SignalEventDefinition'
          })
        });
      } else if (isEventType(businessObject, 'bpmn:BoundaryEvent', 'bpmn:CompensateEventDefinition')) {
        assign$1(actions, {
          'append.compensation-activity': appendAction('bpmn:Task', 'bpmn-icon-task', translate('Append compensation activity'), {
            isForCompensation: true
          })
        });
      } else if (!is(businessObject, 'bpmn:EndEvent') && !businessObject.isForCompensation && !isEventType(businessObject, 'bpmn:IntermediateThrowEvent', 'bpmn:LinkEventDefinition') && !isEventSubProcess(businessObject)) {
        assign$1(actions, {
          'append.end-event': appendAction('bpmn:EndEvent', 'bpmn-icon-end-event-none', translate('Append end event')),
          'append.gateway': appendAction('bpmn:ExclusiveGateway', 'bpmn-icon-gateway-none', translate('Append gateway')),
          'append.append-task': appendAction('bpmn:Task', 'bpmn-icon-task', translate('Append task')),
          'append.intermediate-event': appendAction('bpmn:IntermediateThrowEvent', 'bpmn-icon-intermediate-event-none', translate('Append intermediate/boundary event'))
        });
      }
    }
    if (!popupMenu.isEmpty(element, 'bpmn-replace')) {
      assign$1(actions, {
        'replace': {
          group: 'edit',
          className: 'bpmn-icon-screw-wrench',
          title: translate('Change element'),
          action: {
            click: function click(event, element) {
              var position = assign$1(getReplaceMenuPosition(element), {
                cursor: {
                  x: event.x,
                  y: event.y
                }
              });
              popupMenu.open(element, 'bpmn-replace', position, {
                title: translate('Change element'),
                width: 300,
                search: true
              });
            }
          }
        }
      });
    }
    if (is(businessObject, 'bpmn:SequenceFlow')) {
      assign$1(actions, {
        'append.text-annotation': appendAction('bpmn:TextAnnotation', 'bpmn-icon-text-annotation', translate('Add text annotation'))
      });
    }
    if (is(businessObject, 'bpmn:MessageFlow')) {
      assign$1(actions, {
        'append.text-annotation': appendAction('bpmn:TextAnnotation', 'bpmn-icon-text-annotation', translate('Add text annotation'))
      });
    }
    if (isAny(businessObject, ['bpmn:FlowNode', 'bpmn:InteractionNode', 'bpmn:DataObjectReference', 'bpmn:DataStoreReference'])) {
      assign$1(actions, {
        'append.text-annotation': appendAction('bpmn:TextAnnotation', 'bpmn-icon-text-annotation', translate('Add text annotation')),
        'connect': {
          group: 'connect',
          className: 'bpmn-icon-connection-multi',
          title: translate('Connect to other element'),
          action: {
            click: startConnect,
            dragstart: startConnect
          }
        }
      });
    }
    if (is(businessObject, 'bpmn:TextAnnotation')) {
      assign$1(actions, {
        'connect': {
          group: 'connect',
          className: 'bpmn-icon-connection-multi',
          title: translate('Connect using association'),
          action: {
            click: startConnect,
            dragstart: startConnect
          }
        }
      });
    }
    if (isAny(businessObject, ['bpmn:DataObjectReference', 'bpmn:DataStoreReference'])) {
      assign$1(actions, {
        'connect': {
          group: 'connect',
          className: 'bpmn-icon-connection-multi',
          title: translate('Connect using data input association'),
          action: {
            click: startConnect,
            dragstart: startConnect
          }
        }
      });
    }
    if (is(businessObject, 'bpmn:Group')) {
      assign$1(actions, {
        'append.text-annotation': appendAction('bpmn:TextAnnotation', 'bpmn-icon-text-annotation', translate('Add text annotation'))
      });
    }
    if (this._isDeleteAllowed([element])) {
      assign$1(actions, deleteAction());
    }
    return actions;
  };
  function isEventType(businessObject, type, eventDefinitionType) {
    var isType = businessObject.$instanceOf(type);
    var isDefinition = false;
    var definitions = businessObject.eventDefinitions || [];
    forEach$1(definitions, function (def) {
      if (def.$type === eventDefinitionType) {
        isDefinition = true;
      }
    });
    return isType && isDefinition;
  }
  var ContextPadModule = {
    __depends__: [AppendPreviewModule, DirectEditingModule, ContextPadModule$1, SelectionModule, ConnectModule, CreateModule, PopupMenuModule],
    __init__: ['contextPadProvider'],
    contextPadProvider: ['type', ContextPadProvider]
  };
  var AXIS_DIMENSIONS = {
    horizontal: ['x', 'width'],
    vertical: ['y', 'height']
  };
  var THRESHOLD = 5;
  function DistributeElements(modeling, rules) {
    this._modeling = modeling;
    this._filters = [];
    this.registerFilter(function (elements) {
      var allowed = rules.allowed('elements.distribute', {
        elements: elements
      });
      if (isArray$3(allowed)) {
        return allowed;
      }
      return allowed ? elements : [];
    });
  }
  DistributeElements.$inject = ['modeling', 'rules'];
  DistributeElements.prototype.registerFilter = function (filterFn) {
    if (typeof filterFn !== 'function') {
      throw new Error('the filter has to be a function');
    }
    this._filters.push(filterFn);
  };
  DistributeElements.prototype.trigger = function (elements, orientation) {
    var modeling = this._modeling;
    var groups, distributableElements;
    if (elements.length < 3) {
      return;
    }
    this._setOrientation(orientation);
    distributableElements = this._filterElements(elements);
    groups = this._createGroups(distributableElements);
    if (groups.length <= 2) {
      return;
    }
    modeling.distributeElements(groups, this._axis, this._dimension);
    return groups;
  };
  DistributeElements.prototype._filterElements = function (elements) {
    var filters = this._filters,
      axis = this._axis,
      dimension = this._dimension,
      distributableElements = [].concat(elements);
    if (!filters.length) {
      return elements;
    }
    forEach$1(filters, function (filterFn) {
      distributableElements = filterFn(distributableElements, axis, dimension);
    });
    return distributableElements;
  };
  DistributeElements.prototype._createGroups = function (elements) {
    var rangeGroups = [],
      self = this,
      axis = this._axis,
      dimension = this._dimension;
    if (!axis) {
      throw new Error('must have a defined "axis" and "dimension"');
    }
    var sortedElements = sortBy(elements, axis);
    forEach$1(sortedElements, function (element, idx) {
      var elementRange = self._findRange(element, axis, dimension),
        range;
      var previous = rangeGroups[rangeGroups.length - 1];
      if (previous && self._hasIntersection(previous.range, elementRange)) {
        rangeGroups[rangeGroups.length - 1].elements.push(element);
      } else {
        range = {
          range: elementRange,
          elements: [element]
        };
        rangeGroups.push(range);
      }
    });
    return rangeGroups;
  };
  DistributeElements.prototype._setOrientation = function (direction) {
    var orientation = AXIS_DIMENSIONS[direction];
    this._axis = orientation[0];
    this._dimension = orientation[1];
  };
  DistributeElements.prototype._hasIntersection = function (rangeA, rangeB) {
    return Math.max(rangeA.min, rangeA.max) >= Math.min(rangeB.min, rangeB.max) && Math.min(rangeA.min, rangeA.max) <= Math.max(rangeB.min, rangeB.max);
  };
  DistributeElements.prototype._findRange = function (element) {
    var axis = element[this._axis],
      dimension = element[this._dimension];
    return {
      min: axis + THRESHOLD,
      max: axis + dimension - THRESHOLD
    };
  };
  var DistributeElementsModule$1 = {
    __init__: ['distributeElements'],
    distributeElements: ['type', DistributeElements]
  };
  function BpmnDistributeElements(eventBus) {
    RuleProvider.call(this, eventBus);
  }
  BpmnDistributeElements.$inject = ['eventBus'];
  e$2(BpmnDistributeElements, RuleProvider);
  BpmnDistributeElements.prototype.init = function () {
    this.addRule('elements.distribute', function (context) {
      var elements = context.elements;
      elements = filter(elements, function (element) {
        var cannotDistribute = isAny(element, ['bpmn:Association', 'bpmn:BoundaryEvent', 'bpmn:DataInputAssociation', 'bpmn:DataOutputAssociation', 'bpmn:Lane', 'bpmn:MessageFlow', 'bpmn:SequenceFlow', 'bpmn:TextAnnotation']);
        return !(element.labelTarget || cannotDistribute);
      });
      elements = getParents$1(elements);
      if (elements.length < 3) {
        return false;
      }
      return elements;
    });
  };
  var icons = {
    horizontal: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1800 1800">
                <polyline points="450 400 450 150 1350 150 1350 400" style="fill:none;stroke:currentColor;stroke-width:100;stroke-linejoin:round;"/>
                <rect x="150" y="450" width="600" height="1200" rx="1" style="fill:none;stroke:currentColor;stroke-width:100;"></rect>
                <rect x="1050" y="450" width="600" height="800" rx="1" style="fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;"></rect>
              </svg>`,
    vertical: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1800 1800">
              <polyline points="400 1350 150 1350 150 450 400 450" style="fill:none;stroke:currentColor;stroke-width:100;stroke-linejoin:round;"/>
              <rect x="450" y="150" width="1200" height="600" rx="1" style="fill:none;stroke:currentColor;stroke-width:100;"></rect>
              <rect x="450" y="1050" width="800" height="600" rx="1" style="fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;"></rect>
            </svg>`
  };
  var LOW_PRIORITY$6 = 900;
  function DistributeElementsMenuProvider(popupMenu, distributeElements, translate, rules) {
    this._distributeElements = distributeElements;
    this._translate = translate;
    this._popupMenu = popupMenu;
    this._rules = rules;
    popupMenu.registerProvider('align-elements', LOW_PRIORITY$6, this);
  }
  DistributeElementsMenuProvider.$inject = ['popupMenu', 'distributeElements', 'translate', 'rules'];
  DistributeElementsMenuProvider.prototype.getPopupMenuEntries = function (target) {
    var entries = {};
    if (this._isAllowed(target)) {
      assign$1(entries, this._getEntries(target));
    }
    return entries;
  };
  DistributeElementsMenuProvider.prototype._isAllowed = function (elements) {
    return this._rules.allowed('elements.distribute', {
      elements: elements
    });
  };
  DistributeElementsMenuProvider.prototype._getEntries = function (elements) {
    var distributeElements = this._distributeElements,
      translate = this._translate,
      popupMenu = this._popupMenu;
    var entries = {
      'distribute-elements-horizontal': {
        group: 'distribute',
        title: translate('Distribute elements horizontally'),
        className: 'bjs-align-elements-menu-entry',
        imageHtml: icons['horizontal'],
        action: function action(event, entry) {
          distributeElements.trigger(elements, 'horizontal');
          popupMenu.close();
        }
      },
      'distribute-elements-vertical': {
        group: 'distribute',
        title: translate('Distribute elements vertically'),
        imageHtml: icons['vertical'],
        action: function action(event, entry) {
          distributeElements.trigger(elements, 'vertical');
          popupMenu.close();
        }
      }
    };
    return entries;
  };
  var DistributeElementsModule = {
    __depends__: [PopupMenuModule$1, DistributeElementsModule$1],
    __init__: ['bpmnDistributeElements', 'distributeElementsMenuProvider'],
    bpmnDistributeElements: ['type', BpmnDistributeElements],
    distributeElementsMenuProvider: ['type', DistributeElementsMenuProvider]
  };
  var NOT_REGISTERED_ERROR = 'is not a registered action',
    IS_REGISTERED_ERROR = 'is already registered';
  function EditorActions(eventBus, injector) {
    this._actions = {};
    var self = this;
    eventBus.on('diagram.init', function () {
      self._registerDefaultActions(injector);
      eventBus.fire('editorActions.init', {
        editorActions: self
      });
    });
  }
  EditorActions.$inject = ['eventBus', 'injector'];
  EditorActions.prototype._registerDefaultActions = function (injector) {
    var commandStack = injector.get('commandStack', false);
    var modeling = injector.get('modeling', false);
    var selection = injector.get('selection', false);
    var zoomScroll = injector.get('zoomScroll', false);
    var copyPaste = injector.get('copyPaste', false);
    var canvas = injector.get('canvas', false);
    var rules = injector.get('rules', false);
    var keyboardMove = injector.get('keyboardMove', false);
    var keyboardMoveSelection = injector.get('keyboardMoveSelection', false);
    if (commandStack) {
      this.register('undo', function () {
        commandStack.undo();
      });
      this.register('redo', function () {
        commandStack.redo();
      });
    }
    if (copyPaste && selection) {
      this.register('copy', function () {
        var selectedElements = selection.get();
        if (selectedElements.length) {
          return copyPaste.copy(selectedElements);
        }
      });
    }
    if (copyPaste) {
      this.register('paste', function () {
        copyPaste.paste();
      });
    }
    if (zoomScroll) {
      this.register('stepZoom', function (opts) {
        zoomScroll.stepZoom(opts.value);
      });
    }
    if (canvas) {
      this.register('zoom', function (opts) {
        canvas.zoom(opts.value);
      });
    }
    if (modeling && selection && rules) {
      this.register('removeSelection', function () {
        var selectedElements = selection.get();
        if (!selectedElements.length) {
          return;
        }
        var allowed = rules.allowed('elements.delete', {
            elements: selectedElements
          }),
          removableElements;
        if (allowed === false) {
          return;
        } else if (isArray$3(allowed)) {
          removableElements = allowed;
        } else {
          removableElements = selectedElements;
        }
        if (removableElements.length) {
          modeling.removeElements(removableElements.slice());
        }
      });
    }
    if (keyboardMove) {
      this.register('moveCanvas', function (opts) {
        keyboardMove.moveCanvas(opts);
      });
    }
    if (keyboardMoveSelection) {
      this.register('moveSelection', function (opts) {
        keyboardMoveSelection.moveSelection(opts.direction, opts.accelerated);
      });
    }
  };
  EditorActions.prototype.trigger = function (action, opts) {
    if (!this._actions[action]) {
      throw error(action, NOT_REGISTERED_ERROR);
    }
    return this._actions[action](opts);
  };
  EditorActions.prototype.register = function (actions, listener) {
    var self = this;
    if (typeof actions === 'string') {
      return this._registerAction(actions, listener);
    }
    forEach$1(actions, function (listener, action) {
      self._registerAction(action, listener);
    });
  };
  EditorActions.prototype._registerAction = function (action, listener) {
    if (this.isRegistered(action)) {
      throw error(action, IS_REGISTERED_ERROR);
    }
    this._actions[action] = listener;
  };
  EditorActions.prototype.unregister = function (action) {
    if (!this.isRegistered(action)) {
      throw error(action, NOT_REGISTERED_ERROR);
    }
    this._actions[action] = undefined;
  };
  EditorActions.prototype.getActions = function () {
    return Object.keys(this._actions);
  };
  EditorActions.prototype.isRegistered = function (action) {
    return !!this._actions[action];
  };
  function error(action, message) {
    return new Error(action + ' ' + message);
  }
  var EditorActionsModule$1 = {
    __init__: ['editorActions'],
    editorActions: ['type', EditorActions]
  };
  function BpmnEditorActions(injector) {
    injector.invoke(EditorActions, this);
  }
  e$2(BpmnEditorActions, EditorActions);
  BpmnEditorActions.$inject = ['injector'];
  BpmnEditorActions.prototype._registerDefaultActions = function (injector) {
    EditorActions.prototype._registerDefaultActions.call(this, injector);
    var canvas = injector.get('canvas', false);
    var elementRegistry = injector.get('elementRegistry', false);
    var selection = injector.get('selection', false);
    var spaceTool = injector.get('spaceTool', false);
    var lassoTool = injector.get('lassoTool', false);
    var handTool = injector.get('handTool', false);
    var globalConnect = injector.get('globalConnect', false);
    var distributeElements = injector.get('distributeElements', false);
    var alignElements = injector.get('alignElements', false);
    var directEditing = injector.get('directEditing', false);
    var searchPad = injector.get('searchPad', false);
    var modeling = injector.get('modeling', false);
    var contextPad = injector.get('contextPad', false);
    if (canvas && elementRegistry && selection) {
      this._registerAction('selectElements', function () {
        var rootElement = canvas.getRootElement();
        var elements = elementRegistry.filter(function (element) {
          return element !== rootElement;
        });
        selection.select(elements);
        return elements;
      });
    }
    if (spaceTool) {
      this._registerAction('spaceTool', function () {
        spaceTool.toggle();
      });
    }
    if (lassoTool) {
      this._registerAction('lassoTool', function () {
        lassoTool.toggle();
      });
    }
    if (handTool) {
      this._registerAction('handTool', function () {
        handTool.toggle();
      });
    }
    if (globalConnect) {
      this._registerAction('globalConnectTool', function () {
        globalConnect.toggle();
      });
    }
    if (selection && distributeElements) {
      this._registerAction('distributeElements', function (opts) {
        var currentSelection = selection.get(),
          type = opts.type;
        if (currentSelection.length) {
          distributeElements.trigger(currentSelection, type);
        }
      });
    }
    if (selection && alignElements) {
      this._registerAction('alignElements', function (opts) {
        var currentSelection = selection.get(),
          aligneableElements = [],
          type = opts.type;
        if (currentSelection.length) {
          aligneableElements = filter(currentSelection, function (element) {
            return !is(element, 'bpmn:Lane');
          });
          alignElements.trigger(aligneableElements, type);
        }
      });
    }
    if (selection && modeling) {
      this._registerAction('setColor', function (opts) {
        var currentSelection = selection.get();
        if (currentSelection.length) {
          modeling.setColor(currentSelection, opts);
        }
      });
    }
    if (selection && directEditing) {
      this._registerAction('directEditing', function () {
        var currentSelection = selection.get();
        if (currentSelection.length) {
          directEditing.activate(currentSelection[0]);
        }
      });
    }
    if (searchPad) {
      this._registerAction('find', function () {
        searchPad.toggle();
      });
    }
    if (canvas && modeling) {
      this._registerAction('moveToOrigin', function () {
        var rootElement = canvas.getRootElement(),
          boundingBox,
          elements;
        if (is(rootElement, 'bpmn:Collaboration')) {
          elements = elementRegistry.filter(function (element) {
            return is(element.parent, 'bpmn:Collaboration');
          });
        } else {
          elements = elementRegistry.filter(function (element) {
            return element !== rootElement && !is(element.parent, 'bpmn:SubProcess');
          });
        }
        boundingBox = getBBox(elements);
        modeling.moveElements(elements, {
          x: -boundingBox.x,
          y: -boundingBox.y
        }, rootElement);
      });
    }
    if (selection && contextPad) {
      this._registerAction('replaceElement', function (event) {
        contextPad.triggerEntry('replace', 'click', event);
      });
    }
  };
  var EditorActionsModule = {
    __depends__: [EditorActionsModule$1],
    editorActions: ['type', BpmnEditorActions]
  };
  function BpmnGridSnapping(eventBus) {
    eventBus.on(['create.init', 'shape.move.init'], function (event) {
      var context = event.context,
        shape = event.shape;
      if (isAny(shape, ['bpmn:Participant', 'bpmn:SubProcess', 'bpmn:TextAnnotation'])) {
        if (!context.gridSnappingContext) {
          context.gridSnappingContext = {};
        }
        context.gridSnappingContext.snapLocation = 'top-left';
      }
    });
  }
  BpmnGridSnapping.$inject = ['eventBus'];
  var SPACING = 10;
  function quantize(value, quantum, fn) {
    if (!fn) {
      fn = 'round';
    }
    return Math[fn](value / quantum) * quantum;
  }
  var LOWER_PRIORITY = 1200;
  var LOW_PRIORITY$5 = 800;
  function GridSnapping(elementRegistry, eventBus, config) {
    var active = !config || config.active !== false;
    this._eventBus = eventBus;
    var self = this;
    eventBus.on('diagram.init', LOW_PRIORITY$5, function () {
      self.setActive(active);
    });
    eventBus.on(['create.move', 'create.end', 'bendpoint.move.move', 'bendpoint.move.end', 'connect.move', 'connect.end', 'connectionSegment.move.move', 'connectionSegment.move.end', 'resize.move', 'resize.end', 'shape.move.move', 'shape.move.end'], LOWER_PRIORITY, function (event) {
      var originalEvent = event.originalEvent;
      if (!self.active || originalEvent && isCmd(originalEvent)) {
        return;
      }
      var context = event.context,
        gridSnappingContext = context.gridSnappingContext;
      if (!gridSnappingContext) {
        gridSnappingContext = context.gridSnappingContext = {};
      }
      ['x', 'y'].forEach(function (axis) {
        var options = {};
        var snapOffset = getSnapOffset(event, axis, elementRegistry);
        if (snapOffset) {
          options.offset = snapOffset;
        }
        var snapConstraints = getSnapConstraints(event, axis);
        if (snapConstraints) {
          assign$1(options, snapConstraints);
        }
        if (!isSnapped(event, axis)) {
          self.snapEvent(event, axis, options);
        }
      });
    });
  }
  GridSnapping.prototype.snapEvent = function (event, axis, options) {
    var snappedValue = this.snapValue(event[axis], options);
    setSnapped(event, axis, snappedValue);
  };
  GridSnapping.prototype.getGridSpacing = function () {
    return SPACING;
  };
  GridSnapping.prototype.snapValue = function (value, options) {
    var offset = 0;
    if (options && options.offset) {
      offset = options.offset;
    }
    value += offset;
    value = quantize(value, SPACING);
    var min, max;
    if (options && options.min) {
      min = options.min;
      if (isNumber(min)) {
        min = quantize(min + offset, SPACING, 'ceil');
        value = Math.max(value, min);
      }
    }
    if (options && options.max) {
      max = options.max;
      if (isNumber(max)) {
        max = quantize(max + offset, SPACING, 'floor');
        value = Math.min(value, max);
      }
    }
    value -= offset;
    return value;
  };
  GridSnapping.prototype.isActive = function () {
    return this.active;
  };
  GridSnapping.prototype.setActive = function (active) {
    this.active = active;
    this._eventBus.fire('gridSnapping.toggle', {
      active: active
    });
  };
  GridSnapping.prototype.toggleActive = function () {
    this.setActive(!this.active);
  };
  GridSnapping.$inject = ['elementRegistry', 'eventBus', 'config.gridSnapping'];
  function getSnapConstraints(event, axis) {
    var context = event.context,
      createConstraints = context.createConstraints,
      resizeConstraints = context.resizeConstraints || {},
      gridSnappingContext = context.gridSnappingContext,
      snapConstraints = gridSnappingContext.snapConstraints;
    if (snapConstraints && snapConstraints[axis]) {
      return snapConstraints[axis];
    }
    if (!snapConstraints) {
      snapConstraints = gridSnappingContext.snapConstraints = {};
    }
    if (!snapConstraints[axis]) {
      snapConstraints[axis] = {};
    }
    var direction = context.direction;
    if (createConstraints) {
      if (isHorizontal$2(axis)) {
        snapConstraints.x.min = createConstraints.left;
        snapConstraints.x.max = createConstraints.right;
      } else {
        snapConstraints.y.min = createConstraints.top;
        snapConstraints.y.max = createConstraints.bottom;
      }
    }
    var minResizeConstraints = resizeConstraints.min,
      maxResizeConstraints = resizeConstraints.max;
    if (minResizeConstraints) {
      if (isHorizontal$2(axis)) {
        if (isWest(direction)) {
          snapConstraints.x.max = minResizeConstraints.left;
        } else {
          snapConstraints.x.min = minResizeConstraints.right;
        }
      } else {
        if (isNorth(direction)) {
          snapConstraints.y.max = minResizeConstraints.top;
        } else {
          snapConstraints.y.min = minResizeConstraints.bottom;
        }
      }
    }
    if (maxResizeConstraints) {
      if (isHorizontal$2(axis)) {
        if (isWest(direction)) {
          snapConstraints.x.min = maxResizeConstraints.left;
        } else {
          snapConstraints.x.max = maxResizeConstraints.right;
        }
      } else {
        if (isNorth(direction)) {
          snapConstraints.y.min = maxResizeConstraints.top;
        } else {
          snapConstraints.y.max = maxResizeConstraints.bottom;
        }
      }
    }
    return snapConstraints[axis];
  }
  function getSnapOffset(event, axis, elementRegistry) {
    var context = event.context,
      shape = event.shape,
      gridSnappingContext = context.gridSnappingContext,
      snapLocation = gridSnappingContext.snapLocation,
      snapOffset = gridSnappingContext.snapOffset;
    if (snapOffset && isNumber(snapOffset[axis])) {
      return snapOffset[axis];
    }
    if (!snapOffset) {
      snapOffset = gridSnappingContext.snapOffset = {};
    }
    if (!isNumber(snapOffset[axis])) {
      snapOffset[axis] = 0;
    }
    if (!shape) {
      return snapOffset[axis];
    }
    if (!elementRegistry.get(shape.id)) {
      if (isHorizontal$2(axis)) {
        snapOffset[axis] += shape[axis] + shape.width / 2;
      } else {
        snapOffset[axis] += shape[axis] + shape.height / 2;
      }
    }
    if (!snapLocation) {
      return snapOffset[axis];
    }
    if (axis === 'x') {
      if (/left/.test(snapLocation)) {
        snapOffset[axis] -= shape.width / 2;
      } else if (/right/.test(snapLocation)) {
        snapOffset[axis] += shape.width / 2;
      }
    } else {
      if (/top/.test(snapLocation)) {
        snapOffset[axis] -= shape.height / 2;
      } else if (/bottom/.test(snapLocation)) {
        snapOffset[axis] += shape.height / 2;
      }
    }
    return snapOffset[axis];
  }
  function isHorizontal$2(axis) {
    return axis === 'x';
  }
  function isNorth(direction) {
    return direction.indexOf('n') !== -1;
  }
  function isWest(direction) {
    return direction.indexOf('w') !== -1;
  }
  function ResizeBehavior(eventBus, gridSnapping) {
    CommandInterceptor.call(this, eventBus);
    this._gridSnapping = gridSnapping;
    var self = this;
    this.preExecute('shape.resize', function (event) {
      var context = event.context,
        hints = context.hints || {},
        autoResize = hints.autoResize;
      if (!autoResize) {
        return;
      }
      var shape = context.shape,
        newBounds = context.newBounds;
      if (isString(autoResize)) {
        context.newBounds = self.snapComplex(newBounds, autoResize);
      } else {
        context.newBounds = self.snapSimple(shape, newBounds);
      }
    });
  }
  ResizeBehavior.$inject = ['eventBus', 'gridSnapping', 'modeling'];
  e$2(ResizeBehavior, CommandInterceptor);
  ResizeBehavior.prototype.snapSimple = function (shape, newBounds) {
    var gridSnapping = this._gridSnapping;
    newBounds.width = gridSnapping.snapValue(newBounds.width, {
      min: newBounds.width
    });
    newBounds.height = gridSnapping.snapValue(newBounds.height, {
      min: newBounds.height
    });
    newBounds.x = shape.x + shape.width / 2 - newBounds.width / 2;
    newBounds.y = shape.y + shape.height / 2 - newBounds.height / 2;
    return newBounds;
  };
  ResizeBehavior.prototype.snapComplex = function (newBounds, directions) {
    if (/w|e/.test(directions)) {
      newBounds = this.snapHorizontally(newBounds, directions);
    }
    if (/n|s/.test(directions)) {
      newBounds = this.snapVertically(newBounds, directions);
    }
    return newBounds;
  };
  ResizeBehavior.prototype.snapHorizontally = function (newBounds, directions) {
    var gridSnapping = this._gridSnapping,
      west = /w/.test(directions),
      east = /e/.test(directions);
    var snappedNewBounds = {};
    snappedNewBounds.width = gridSnapping.snapValue(newBounds.width, {
      min: newBounds.width
    });
    if (east) {
      if (west) {
        snappedNewBounds.x = gridSnapping.snapValue(newBounds.x, {
          max: newBounds.x
        });
        snappedNewBounds.width += gridSnapping.snapValue(newBounds.x - snappedNewBounds.x, {
          min: newBounds.x - snappedNewBounds.x
        });
      } else {
        newBounds.x = newBounds.x + newBounds.width - snappedNewBounds.width;
      }
    }
    assign$1(newBounds, snappedNewBounds);
    return newBounds;
  };
  ResizeBehavior.prototype.snapVertically = function (newBounds, directions) {
    var gridSnapping = this._gridSnapping,
      north = /n/.test(directions),
      south = /s/.test(directions);
    var snappedNewBounds = {};
    snappedNewBounds.height = gridSnapping.snapValue(newBounds.height, {
      min: newBounds.height
    });
    if (north) {
      if (south) {
        snappedNewBounds.y = gridSnapping.snapValue(newBounds.y, {
          max: newBounds.y
        });
        snappedNewBounds.height += gridSnapping.snapValue(newBounds.y - snappedNewBounds.y, {
          min: newBounds.y - snappedNewBounds.y
        });
      } else {
        newBounds.y = newBounds.y + newBounds.height - snappedNewBounds.height;
      }
    }
    assign$1(newBounds, snappedNewBounds);
    return newBounds;
  };
  var HIGH_PRIORITY$6 = 2000;
  function SpaceToolBehavior(eventBus, gridSnapping) {
    eventBus.on(['spaceTool.move', 'spaceTool.end'], HIGH_PRIORITY$6, function (event) {
      var context = event.context;
      if (!context.initialized) {
        return;
      }
      var axis = context.axis;
      var snapped;
      if (axis === 'x') {
        snapped = gridSnapping.snapValue(event.dx);
        event.x = event.x + snapped - event.dx;
        event.dx = snapped;
      } else {
        snapped = gridSnapping.snapValue(event.dy);
        event.y = event.y + snapped - event.dy;
        event.dy = snapped;
      }
    });
  }
  SpaceToolBehavior.$inject = ['eventBus', 'gridSnapping'];
  var GridSnappingBehaviorModule$1 = {
    __init__: ['gridSnappingResizeBehavior', 'gridSnappingSpaceToolBehavior'],
    gridSnappingResizeBehavior: ['type', ResizeBehavior],
    gridSnappingSpaceToolBehavior: ['type', SpaceToolBehavior]
  };
  var GridSnappingModule$1 = {
    __depends__: [GridSnappingBehaviorModule$1],
    __init__: ['gridSnapping'],
    gridSnapping: ['type', GridSnapping]
  };
  var HIGH_PRIORITY$5 = 2000;
  function GridSnappingAutoPlaceBehavior(eventBus, gridSnapping, elementRegistry) {
    eventBus.on('autoPlace', HIGH_PRIORITY$5, function (context) {
      var source = context.source,
        sourceMid = getMid(source),
        shape = context.shape;
      var position = getNewShapePosition(source, shape, elementRegistry);
      ['x', 'y'].forEach(function (axis) {
        var options = {};
        if (position[axis] === sourceMid[axis]) {
          return;
        }
        if (position[axis] > sourceMid[axis]) {
          options.min = position[axis];
        } else {
          options.max = position[axis];
        }
        if (is(shape, 'bpmn:TextAnnotation')) {
          if (isHorizontal$1(axis)) {
            options.offset = -shape.width / 2;
          } else {
            options.offset = -shape.height / 2;
          }
        }
        position[axis] = gridSnapping.snapValue(position[axis], options);
      });
      return position;
    });
  }
  GridSnappingAutoPlaceBehavior.$inject = ['eventBus', 'gridSnapping', 'elementRegistry'];
  function isHorizontal$1(axis) {
    return axis === 'x';
  }
  var HIGHER_PRIORITY$4 = 1750;
  function GridSnappingParticipantBehavior(canvas, eventBus, gridSnapping) {
    eventBus.on(['create.start', 'shape.move.start'], HIGHER_PRIORITY$4, function (event) {
      var context = event.context,
        shape = context.shape,
        rootElement = canvas.getRootElement();
      if (!is(shape, 'bpmn:Participant') || !is(rootElement, 'bpmn:Process') || !rootElement.children.length) {
        return;
      }
      var createConstraints = context.createConstraints;
      if (!createConstraints) {
        return;
      }
      shape.width = gridSnapping.snapValue(shape.width, {
        min: shape.width
      });
      shape.height = gridSnapping.snapValue(shape.height, {
        min: shape.height
      });
    });
  }
  GridSnappingParticipantBehavior.$inject = ['canvas', 'eventBus', 'gridSnapping'];
  var HIGH_PRIORITY$4 = 3000;
  function GridSnappingLayoutConnectionBehavior(eventBus, gridSnapping, modeling) {
    CommandInterceptor.call(this, eventBus);
    this._gridSnapping = gridSnapping;
    var self = this;
    this.postExecuted(['connection.create', 'connection.layout'], HIGH_PRIORITY$4, function (event) {
      var context = event.context,
        connection = context.connection,
        hints = context.hints || {},
        waypoints = connection.waypoints;
      if (hints.connectionStart || hints.connectionEnd || hints.createElementsBehavior === false) {
        return;
      }
      if (!hasMiddleSegments(waypoints)) {
        return;
      }
      modeling.updateWaypoints(connection, self.snapMiddleSegments(waypoints));
    });
  }
  GridSnappingLayoutConnectionBehavior.$inject = ['eventBus', 'gridSnapping', 'modeling'];
  e$2(GridSnappingLayoutConnectionBehavior, CommandInterceptor);
  GridSnappingLayoutConnectionBehavior.prototype.snapMiddleSegments = function (waypoints) {
    var gridSnapping = this._gridSnapping,
      snapped;
    waypoints = waypoints.slice();
    for (var i = 1; i < waypoints.length - 2; i++) {
      snapped = snapSegment(gridSnapping, waypoints[i], waypoints[i + 1]);
      waypoints[i] = snapped[0];
      waypoints[i + 1] = snapped[1];
    }
    return waypoints;
  };
  function hasMiddleSegments(waypoints) {
    return waypoints.length > 3;
  }
  function horizontallyAligned(aligned) {
    return aligned === 'h';
  }
  function verticallyAligned(aligned) {
    return aligned === 'v';
  }
  function snapSegment(gridSnapping, segmentStart, segmentEnd) {
    var aligned = pointsAligned(segmentStart, segmentEnd);
    var snapped = {};
    if (horizontallyAligned(aligned)) {
      snapped.y = gridSnapping.snapValue(segmentStart.y);
    }
    if (verticallyAligned(aligned)) {
      snapped.x = gridSnapping.snapValue(segmentStart.x);
    }
    if ('x' in snapped || 'y' in snapped) {
      segmentStart = assign$1({}, segmentStart, snapped);
      segmentEnd = assign$1({}, segmentEnd, snapped);
    }
    return [segmentStart, segmentEnd];
  }
  var GridSnappingBehaviorModule = {
    __init__: ['gridSnappingAutoPlaceBehavior', 'gridSnappingParticipantBehavior', 'gridSnappingLayoutConnectionBehavior'],
    gridSnappingAutoPlaceBehavior: ['type', GridSnappingAutoPlaceBehavior],
    gridSnappingParticipantBehavior: ['type', GridSnappingParticipantBehavior],
    gridSnappingLayoutConnectionBehavior: ['type', GridSnappingLayoutConnectionBehavior]
  };
  var GridSnappingModule = {
    __depends__: [GridSnappingModule$1, GridSnappingBehaviorModule],
    __init__: ['bpmnGridSnapping'],
    bpmnGridSnapping: ['type', BpmnGridSnapping]
  };
  var LABEL_WIDTH = 30,
    LABEL_HEIGHT = 30;
  function BpmnInteractionEvents(eventBus, interactionEvents) {
    this._interactionEvents = interactionEvents;
    var self = this;
    eventBus.on(['interactionEvents.createHit', 'interactionEvents.updateHit'], function (context) {
      var element = context.element,
        gfx = context.gfx;
      if (is(element, 'bpmn:Lane')) {
        return self._createParticipantHit(element, gfx);
      } else if (is(element, 'bpmn:Participant')) {
        if (isExpanded(element)) {
          return self._createParticipantHit(element, gfx);
        } else {
          return self._createDefaultHit(element, gfx);
        }
      } else if (is(element, 'bpmn:SubProcess')) {
        if (isExpanded(element)) {
          return self._createSubProcessHit(element, gfx);
        } else {
          return self._createDefaultHit(element, gfx);
        }
      }
    });
  }
  BpmnInteractionEvents.$inject = ['eventBus', 'interactionEvents'];
  BpmnInteractionEvents.prototype._createDefaultHit = function (element, gfx) {
    this._interactionEvents.removeHits(gfx);
    this._interactionEvents.createDefaultHit(element, gfx);
    return true;
  };
  BpmnInteractionEvents.prototype._createParticipantHit = function (element, gfx) {
    this._interactionEvents.removeHits(gfx);
    this._interactionEvents.createBoxHit(gfx, 'no-move', {
      width: element.width,
      height: element.height
    });
    this._interactionEvents.createBoxHit(gfx, 'click-stroke', {
      width: element.width,
      height: element.height
    });
    var box = isHorizontal$3(element) ? {
      width: LABEL_WIDTH,
      height: element.height
    } : {
      width: element.width,
      height: LABEL_HEIGHT
    };
    this._interactionEvents.createBoxHit(gfx, 'all', box);
    return true;
  };
  BpmnInteractionEvents.prototype._createSubProcessHit = function (element, gfx) {
    this._interactionEvents.removeHits(gfx);
    this._interactionEvents.createBoxHit(gfx, 'no-move', {
      width: element.width,
      height: element.height
    });
    this._interactionEvents.createBoxHit(gfx, 'click-stroke', {
      width: element.width,
      height: element.height
    });
    this._interactionEvents.createBoxHit(gfx, 'all', {
      width: element.width,
      height: LABEL_HEIGHT
    });
    return true;
  };
  var InteractionEventsModule = {
    __init__: ['bpmnInteractionEvents'],
    bpmnInteractionEvents: ['type', BpmnInteractionEvents]
  };
  function BpmnKeyboardBindings(injector) {
    injector.invoke(KeyboardBindings, this);
  }
  e$2(BpmnKeyboardBindings, KeyboardBindings);
  BpmnKeyboardBindings.$inject = ['injector'];
  BpmnKeyboardBindings.prototype.registerBindings = function (keyboard, editorActions) {
    KeyboardBindings.prototype.registerBindings.call(this, keyboard, editorActions);
    function addListener(action, fn) {
      if (editorActions.isRegistered(action)) {
        keyboard.addListener(fn);
      }
    }
    addListener('selectElements', function (context) {
      var event = context.keyEvent;
      if (keyboard.isKey(['a', 'A'], event) && keyboard.isCmd(event)) {
        editorActions.trigger('selectElements');
        return true;
      }
    });
    addListener('find', function (context) {
      var event = context.keyEvent;
      if (keyboard.isKey(['f', 'F'], event) && keyboard.isCmd(event)) {
        editorActions.trigger('find');
        return true;
      }
    });
    addListener('spaceTool', function (context) {
      var event = context.keyEvent;
      if (keyboard.hasModifier(event)) {
        return;
      }
      if (keyboard.isKey(['s', 'S'], event)) {
        editorActions.trigger('spaceTool');
        return true;
      }
    });
    addListener('lassoTool', function (context) {
      var event = context.keyEvent;
      if (keyboard.hasModifier(event)) {
        return;
      }
      if (keyboard.isKey(['l', 'L'], event)) {
        editorActions.trigger('lassoTool');
        return true;
      }
    });
    addListener('handTool', function (context) {
      var event = context.keyEvent;
      if (keyboard.hasModifier(event)) {
        return;
      }
      if (keyboard.isKey(['h', 'H'], event)) {
        editorActions.trigger('handTool');
        return true;
      }
    });
    addListener('globalConnectTool', function (context) {
      var event = context.keyEvent;
      if (keyboard.hasModifier(event)) {
        return;
      }
      if (keyboard.isKey(['c', 'C'], event)) {
        editorActions.trigger('globalConnectTool');
        return true;
      }
    });
    addListener('directEditing', function (context) {
      var event = context.keyEvent;
      if (keyboard.hasModifier(event)) {
        return;
      }
      if (keyboard.isKey(['e', 'E'], event)) {
        editorActions.trigger('directEditing');
        return true;
      }
    });
    addListener('replaceElement', function (context) {
      var event = context.keyEvent;
      if (keyboard.hasModifier(event)) {
        return;
      }
      if (keyboard.isKey(['r', 'R'], event)) {
        editorActions.trigger('replaceElement', event);
        return true;
      }
    });
  };
  var KeyboardModule = {
    __depends__: [KeyboardModule$1],
    __init__: ['keyboardBindings'],
    keyboardBindings: ['type', BpmnKeyboardBindings]
  };
  var DEFAULT_CONFIG = {
    moveSpeed: 1,
    moveSpeedAccelerated: 10
  };
  var HIGHER_PRIORITY$3 = 1500;
  var LEFT = 'left';
  var UP = 'up';
  var RIGHT = 'right';
  var DOWN = 'down';
  var KEY_TO_DIRECTION = {
    ArrowLeft: LEFT,
    Left: LEFT,
    ArrowUp: UP,
    Up: UP,
    ArrowRight: RIGHT,
    Right: RIGHT,
    ArrowDown: DOWN,
    Down: DOWN
  };
  var DIRECTIONS_DELTA = {
    left: function left(speed) {
      return {
        x: -speed,
        y: 0
      };
    },
    up: function up(speed) {
      return {
        x: 0,
        y: -speed
      };
    },
    right: function right(speed) {
      return {
        x: speed,
        y: 0
      };
    },
    down: function down(speed) {
      return {
        x: 0,
        y: speed
      };
    }
  };
  function KeyboardMoveSelection(config, keyboard, modeling, rules, selection) {
    var self = this;
    this._config = assign$1({}, DEFAULT_CONFIG, config || {});
    keyboard.addListener(HIGHER_PRIORITY$3, function (event) {
      var keyEvent = event.keyEvent;
      var direction = KEY_TO_DIRECTION[keyEvent.key];
      if (!direction) {
        return;
      }
      if (keyboard.isCmd(keyEvent)) {
        return;
      }
      var accelerated = keyboard.isShift(keyEvent);
      self.moveSelection(direction, accelerated);
      return true;
    });
    this.moveSelection = function (direction, accelerated) {
      var selectedElements = selection.get();
      if (!selectedElements.length) {
        return;
      }
      var speed = this._config[accelerated ? 'moveSpeedAccelerated' : 'moveSpeed'];
      var delta = DIRECTIONS_DELTA[direction](speed);
      var canMove = rules.allowed('elements.move', {
        shapes: selectedElements
      });
      if (canMove) {
        modeling.moveElements(selectedElements, delta);
      }
    };
  }
  KeyboardMoveSelection.$inject = ['config.keyboardMoveSelection', 'keyboard', 'modeling', 'rules', 'selection'];
  var KeyboardMoveSelectionModule = {
    __depends__: [KeyboardModule$1, SelectionModule],
    __init__: ['keyboardMoveSelection'],
    keyboardMoveSelection: ['type', KeyboardMoveSelection]
  };
  var DEFAULT_MIN_WIDTH = 10;
  function Resize(eventBus, rules, modeling, dragging) {
    this._dragging = dragging;
    this._rules = rules;
    var self = this;
    function handleMove(context, delta) {
      var shape = context.shape,
        direction = context.direction,
        resizeConstraints = context.resizeConstraints,
        newBounds;
      context.delta = delta;
      newBounds = resizeBounds$1(shape, direction, delta);
      context.newBounds = ensureConstraints$2(newBounds, resizeConstraints);
      context.canExecute = self.canResize(context);
    }
    function handleStart(context) {
      var resizeConstraints = context.resizeConstraints,
        minBounds = context.minBounds;
      if (resizeConstraints !== undefined) {
        return;
      }
      if (minBounds === undefined) {
        minBounds = self.computeMinResizeBox(context);
      }
      context.resizeConstraints = {
        min: asTRBL(minBounds)
      };
    }
    function handleEnd(context) {
      var shape = context.shape,
        canExecute = context.canExecute,
        newBounds = context.newBounds;
      if (canExecute) {
        newBounds = roundBounds(newBounds);
        if (!boundsChanged(shape, newBounds)) {
          return;
        }
        modeling.resizeShape(shape, newBounds);
      }
    }
    eventBus.on('resize.start', function (event) {
      handleStart(event.context);
    });
    eventBus.on('resize.move', function (event) {
      var delta = {
        x: event.dx,
        y: event.dy
      };
      handleMove(event.context, delta);
    });
    eventBus.on('resize.end', function (event) {
      handleEnd(event.context);
    });
  }
  Resize.prototype.canResize = function (context) {
    var rules = this._rules;
    var ctx = pick(context, ['newBounds', 'shape', 'delta', 'direction']);
    return rules.allowed('shape.resize', ctx);
  };
  Resize.prototype.activate = function (event, shape, contextOrDirection) {
    var dragging = this._dragging,
      context,
      direction;
    if (typeof contextOrDirection === 'string') {
      contextOrDirection = {
        direction: contextOrDirection
      };
    }
    context = assign$1({
      shape: shape
    }, contextOrDirection);
    direction = context.direction;
    if (!direction) {
      throw new Error('must provide a direction (n|w|s|e|nw|se|ne|sw)');
    }
    dragging.init(event, getReferencePoint(shape, direction), 'resize', {
      autoActivate: true,
      cursor: getCursor(direction),
      data: {
        shape: shape,
        context: context
      }
    });
  };
  Resize.prototype.computeMinResizeBox = function (context) {
    var shape = context.shape,
      direction = context.direction,
      minDimensions,
      childrenBounds;
    minDimensions = context.minDimensions || {
      width: DEFAULT_MIN_WIDTH,
      height: DEFAULT_MIN_WIDTH
    };
    childrenBounds = computeChildrenBBox(shape, context.childrenBoxPadding);
    return getMinResizeBounds(direction, shape, minDimensions, childrenBounds);
  };
  Resize.$inject = ['eventBus', 'rules', 'modeling', 'dragging'];
  function boundsChanged(shape, newBounds) {
    return shape.x !== newBounds.x || shape.y !== newBounds.y || shape.width !== newBounds.width || shape.height !== newBounds.height;
  }
  function getReferencePoint(shape, direction) {
    var mid = getMid(shape),
      trbl = asTRBL(shape);
    var referencePoint = {
      x: mid.x,
      y: mid.y
    };
    if (direction.indexOf('n') !== -1) {
      referencePoint.y = trbl.top;
    } else if (direction.indexOf('s') !== -1) {
      referencePoint.y = trbl.bottom;
    }
    if (direction.indexOf('e') !== -1) {
      referencePoint.x = trbl.right;
    } else if (direction.indexOf('w') !== -1) {
      referencePoint.x = trbl.left;
    }
    return referencePoint;
  }
  function getCursor(direction) {
    var prefix = 'resize-';
    if (direction === 'n' || direction === 's') {
      return prefix + 'ns';
    } else if (direction === 'e' || direction === 'w') {
      return prefix + 'ew';
    } else if (direction === 'nw' || direction === 'se') {
      return prefix + 'nwse';
    } else {
      return prefix + 'nesw';
    }
  }
  var MARKER_RESIZING = 'djs-resizing',
    MARKER_RESIZE_NOT_OK = 'resize-not-ok';
  var LOW_PRIORITY$4 = 500;
  function ResizePreview(eventBus, canvas, previewSupport) {
    function updateFrame(context) {
      var shape = context.shape,
        bounds = context.newBounds,
        frame = context.frame;
      if (!frame) {
        frame = context.frame = previewSupport.addFrame(shape, canvas.getActiveLayer());
        canvas.addMarker(shape, MARKER_RESIZING);
      }
      if (bounds.width > 5) {
        attr(frame, {
          x: bounds.x,
          width: bounds.width
        });
      }
      if (bounds.height > 5) {
        attr(frame, {
          y: bounds.y,
          height: bounds.height
        });
      }
      if (context.canExecute) {
        classes(frame).remove(MARKER_RESIZE_NOT_OK);
      } else {
        classes(frame).add(MARKER_RESIZE_NOT_OK);
      }
    }
    function removeFrame(context) {
      var shape = context.shape,
        frame = context.frame;
      if (frame) {
        remove$1(context.frame);
      }
      canvas.removeMarker(shape, MARKER_RESIZING);
    }
    eventBus.on('resize.move', LOW_PRIORITY$4, function (event) {
      updateFrame(event.context);
    });
    eventBus.on('resize.cleanup', function (event) {
      removeFrame(event.context);
    });
  }
  ResizePreview.$inject = ['eventBus', 'canvas', 'previewSupport'];
  var HANDLE_OFFSET = -6,
    HANDLE_SIZE = 8,
    HANDLE_HIT_SIZE = 20;
  var CLS_RESIZER = 'djs-resizer';
  var directions = ['n', 'w', 's', 'e', 'nw', 'ne', 'se', 'sw'];
  function ResizeHandles(eventBus, canvas, selection, resize) {
    this._resize = resize;
    this._canvas = canvas;
    var self = this;
    eventBus.on('selection.changed', function (e) {
      var newSelection = e.newSelection;
      self.removeResizers();
      if (newSelection.length === 1) {
        forEach$1(newSelection, bind$2(self.addResizer, self));
      }
    });
    eventBus.on('shape.changed', function (e) {
      var shape = e.element;
      if (selection.isSelected(shape)) {
        self.removeResizers();
        self.addResizer(shape);
      }
    });
  }
  ResizeHandles.prototype.makeDraggable = function (element, gfx, direction) {
    var resize = this._resize;
    function startResize(event) {
      if (isPrimaryButton(event)) {
        resize.activate(event, element, direction);
      }
    }
    event.bind(gfx, 'mousedown', startResize);
    event.bind(gfx, 'touchstart', startResize);
  };
  ResizeHandles.prototype._createResizer = function (element, x, y, direction) {
    var resizersParent = this._getResizersParent();
    var offset = getHandleOffset(direction);
    var group = create$1('g');
    classes(group).add(CLS_RESIZER);
    classes(group).add(CLS_RESIZER + '-' + element.id);
    classes(group).add(CLS_RESIZER + '-' + direction);
    append(resizersParent, group);
    var visual = create$1('rect');
    attr(visual, {
      x: -8 / 2 + offset.x,
      y: -8 / 2 + offset.y,
      width: HANDLE_SIZE,
      height: HANDLE_SIZE
    });
    classes(visual).add(CLS_RESIZER + '-visual');
    append(group, visual);
    var hit = create$1('rect');
    attr(hit, {
      x: -20 / 2 + offset.x,
      y: -20 / 2 + offset.y,
      width: HANDLE_HIT_SIZE,
      height: HANDLE_HIT_SIZE
    });
    classes(hit).add(CLS_RESIZER + '-hit');
    append(group, hit);
    transform(group, x, y);
    return group;
  };
  ResizeHandles.prototype.createResizer = function (element, direction) {
    var point = getReferencePoint(element, direction);
    var resizer = this._createResizer(element, point.x, point.y, direction);
    this.makeDraggable(element, resizer, direction);
  };
  ResizeHandles.prototype.addResizer = function (element) {
    var self = this;
    if (isConnection(element) || !this._resize.canResize({
      shape: element
    })) {
      return;
    }
    forEach$1(directions, function (direction) {
      self.createResizer(element, direction);
    });
  };
  ResizeHandles.prototype.removeResizers = function () {
    var resizersParent = this._getResizersParent();
    clear(resizersParent);
  };
  ResizeHandles.prototype._getResizersParent = function () {
    return this._canvas.getLayer('resizers');
  };
  ResizeHandles.$inject = ['eventBus', 'canvas', 'selection', 'resize'];
  function getHandleOffset(direction) {
    var offset = {
      x: 0,
      y: 0
    };
    if (direction.indexOf('e') !== -1) {
      offset.x = 6;
    } else if (direction.indexOf('w') !== -1) {
      offset.x = HANDLE_OFFSET;
    }
    if (direction.indexOf('s') !== -1) {
      offset.y = 6;
    } else if (direction.indexOf('n') !== -1) {
      offset.y = HANDLE_OFFSET;
    }
    return offset;
  }
  var ResizeModule = {
    __depends__: [RulesModule$1, DraggingModule, PreviewSupportModule],
    __init__: ['resize', 'resizePreview', 'resizeHandles'],
    resize: ['type', Resize],
    resizePreview: ['type', ResizePreview],
    resizeHandles: ['type', ResizeHandles]
  };
  var HIGH_PRIORITY$3 = 2000;
  function LabelEditingProvider(eventBus, bpmnFactory, canvas, directEditing, modeling, resizeHandles, textRenderer) {
    this._bpmnFactory = bpmnFactory;
    this._canvas = canvas;
    this._modeling = modeling;
    this._textRenderer = textRenderer;
    directEditing.registerProvider(this);
    eventBus.on('element.dblclick', function (event) {
      activateDirectEdit(event.element, true);
    });
    eventBus.on(['autoPlace.start', 'canvas.viewbox.changing', 'drag.init', 'element.mousedown', 'popupMenu.open', 'root.set', 'selection.changed'], function () {
      if (directEditing.isActive()) {
        directEditing.complete();
      }
    });
    eventBus.on(['shape.remove', 'connection.remove'], HIGH_PRIORITY$3, function (event) {
      if (directEditing.isActive(event.element)) {
        directEditing.cancel();
      }
    });
    eventBus.on(['commandStack.changed'], function (e) {
      if (directEditing.isActive()) {
        directEditing.cancel();
      }
    });
    eventBus.on('directEditing.activate', function (event) {
      resizeHandles.removeResizers();
    });
    eventBus.on('create.end', 500, function (event) {
      var context = event.context,
        element = context.shape,
        canExecute = event.context.canExecute,
        isTouch = event.isTouch;
      if (isTouch) {
        return;
      }
      if (!canExecute) {
        return;
      }
      if (context.hints && context.hints.createElementsBehavior === false) {
        return;
      }
      activateDirectEdit(element);
    });
    eventBus.on('autoPlace.end', 500, function (event) {
      activateDirectEdit(event.shape);
    });
    function activateDirectEdit(element, force) {
      if (force || isAny(element, ['bpmn:Task', 'bpmn:TextAnnotation', 'bpmn:Participant']) || isCollapsedSubProcess(element)) {
        directEditing.activate(element);
      }
    }
  }
  LabelEditingProvider.$inject = ['eventBus', 'bpmnFactory', 'canvas', 'directEditing', 'modeling', 'resizeHandles', 'textRenderer'];
  LabelEditingProvider.prototype.activate = function (element) {
    var text = getLabel(element);
    if (text === undefined) {
      return;
    }
    var context = {
      text: text
    };
    var bounds = this.getEditingBBox(element);
    assign$1(context, bounds);
    var options = {};
    var style = context.style || {};
    assign$1(style, {
      backgroundColor: null,
      border: null
    });
    if (isAny(element, ['bpmn:Task', 'bpmn:Participant', 'bpmn:Lane', 'bpmn:CallActivity']) || isCollapsedSubProcess(element)) {
      assign$1(options, {
        centerVertically: true
      });
    }
    if (isLabelExternal(element)) {
      assign$1(options, {
        autoResize: true
      });
      assign$1(style, {
        backgroundColor: '#ffffff',
        border: '1px solid #ccc'
      });
    }
    if (is(element, 'bpmn:TextAnnotation')) {
      assign$1(options, {
        resizable: true,
        autoResize: true
      });
      assign$1(style, {
        backgroundColor: '#ffffff',
        border: '1px solid #ccc'
      });
    }
    assign$1(context, {
      options: options,
      style: style
    });
    return context;
  };
  LabelEditingProvider.prototype.getEditingBBox = function (element) {
    var canvas = this._canvas;
    var target = element.label || element;
    var bbox = canvas.getAbsoluteBBox(target);
    var mid = {
      x: bbox.x + bbox.width / 2,
      y: bbox.y + bbox.height / 2
    };
    var bounds = {
      x: bbox.x,
      y: bbox.y
    };
    var zoom = canvas.zoom();
    var defaultStyle = this._textRenderer.getDefaultStyle(),
      externalStyle = this._textRenderer.getExternalStyle();
    var externalFontSize = externalStyle.fontSize * zoom,
      externalLineHeight = externalStyle.lineHeight,
      defaultFontSize = defaultStyle.fontSize * zoom,
      defaultLineHeight = defaultStyle.lineHeight;
    var style = {
      fontFamily: this._textRenderer.getDefaultStyle().fontFamily,
      fontWeight: this._textRenderer.getDefaultStyle().fontWeight
    };
    if (is(element, 'bpmn:Lane') || isExpandedPool(element)) {
      var isHorizontalLane = isHorizontal$3(element);
      var laneBounds = isHorizontalLane ? {
        width: bbox.height,
        height: 30 * zoom,
        x: bbox.x - bbox.height / 2 + 15 * zoom,
        y: mid.y - 30 * zoom / 2
      } : {
        width: bbox.width,
        height: 30 * zoom
      };
      assign$1(bounds, laneBounds);
      assign$1(style, {
        fontSize: defaultFontSize + 'px',
        lineHeight: defaultLineHeight,
        paddingTop: 7 * zoom + 'px',
        paddingBottom: 7 * zoom + 'px',
        paddingLeft: 5 * zoom + 'px',
        paddingRight: 5 * zoom + 'px',
        transform: isHorizontalLane ? 'rotate(-90deg)' : null
      });
    }
    if (isCollapsedPool(element)) {
      var isHorizontalPool = isHorizontal$3(element);
      var poolBounds = isHorizontalPool ? {
        width: bbox.width,
        height: bbox.height
      } : {
        width: bbox.height,
        height: bbox.width,
        x: mid.x - bbox.height / 2,
        y: mid.y - bbox.width / 2
      };
      assign$1(bounds, poolBounds);
      assign$1(style, {
        fontSize: defaultFontSize + 'px',
        lineHeight: defaultLineHeight,
        paddingTop: 7 * zoom + 'px',
        paddingBottom: 7 * zoom + 'px',
        paddingLeft: 5 * zoom + 'px',
        paddingRight: 5 * zoom + 'px',
        transform: isHorizontalPool ? null : 'rotate(-90deg)'
      });
    }
    if (isAny(element, ['bpmn:Task', 'bpmn:CallActivity']) || isCollapsedSubProcess(element)) {
      assign$1(bounds, {
        width: bbox.width,
        height: bbox.height
      });
      assign$1(style, {
        fontSize: defaultFontSize + 'px',
        lineHeight: defaultLineHeight,
        paddingTop: 7 * zoom + 'px',
        paddingBottom: 7 * zoom + 'px',
        paddingLeft: 5 * zoom + 'px',
        paddingRight: 5 * zoom + 'px'
      });
    }
    if (isExpandedSubProcess(element)) {
      assign$1(bounds, {
        width: bbox.width,
        x: bbox.x
      });
      assign$1(style, {
        fontSize: defaultFontSize + 'px',
        lineHeight: defaultLineHeight,
        paddingTop: 7 * zoom + 'px',
        paddingBottom: 7 * zoom + 'px',
        paddingLeft: 5 * zoom + 'px',
        paddingRight: 5 * zoom + 'px'
      });
    }
    var width = 90 * zoom,
      paddingTop = 7 * zoom,
      paddingBottom = 4 * zoom;
    if (target.labelTarget) {
      assign$1(bounds, {
        width: width,
        height: bbox.height + paddingTop + paddingBottom,
        x: mid.x - width / 2,
        y: bbox.y - paddingTop
      });
      assign$1(style, {
        fontSize: externalFontSize + 'px',
        lineHeight: externalLineHeight,
        paddingTop: paddingTop + 'px',
        paddingBottom: paddingBottom + 'px'
      });
    }
    if (isLabelExternal(target) && !hasExternalLabel(target) && !isLabel(target)) {
      var externalLabelMid = getExternalLabelMid(element);
      var absoluteBBox = canvas.getAbsoluteBBox({
        x: externalLabelMid.x,
        y: externalLabelMid.y,
        width: 0,
        height: 0
      });
      var height = externalFontSize + paddingTop + paddingBottom;
      assign$1(bounds, {
        width: width,
        height: height,
        x: absoluteBBox.x - width / 2,
        y: absoluteBBox.y - height / 2
      });
      assign$1(style, {
        fontSize: externalFontSize + 'px',
        lineHeight: externalLineHeight,
        paddingTop: paddingTop + 'px',
        paddingBottom: paddingBottom + 'px'
      });
    }
    if (is(element, 'bpmn:TextAnnotation')) {
      assign$1(bounds, {
        width: bbox.width,
        height: bbox.height,
        minWidth: 30 * zoom,
        minHeight: 10 * zoom
      });
      assign$1(style, {
        textAlign: 'left',
        paddingTop: 5 * zoom + 'px',
        paddingBottom: 7 * zoom + 'px',
        paddingLeft: 7 * zoom + 'px',
        paddingRight: 5 * zoom + 'px',
        fontSize: defaultFontSize + 'px',
        lineHeight: defaultLineHeight
      });
    }
    return {
      bounds: bounds,
      style: style
    };
  };
  LabelEditingProvider.prototype.update = function (element, newLabel, activeContextText, bounds) {
    var newBounds, bbox;
    if (is(element, 'bpmn:TextAnnotation')) {
      bbox = this._canvas.getAbsoluteBBox(element);
      newBounds = {
        x: element.x,
        y: element.y,
        width: element.width / bbox.width * bounds.width,
        height: element.height / bbox.height * bounds.height
      };
    }
    if (isEmptyText(newLabel)) {
      newLabel = null;
    }
    this._modeling.updateLabel(element, newLabel, newBounds);
  };
  function isCollapsedSubProcess(element) {
    return is(element, 'bpmn:SubProcess') && !isExpanded(element);
  }
  function isExpandedSubProcess(element) {
    return is(element, 'bpmn:SubProcess') && isExpanded(element);
  }
  function isCollapsedPool(element) {
    return is(element, 'bpmn:Participant') && !isExpanded(element);
  }
  function isExpandedPool(element) {
    return is(element, 'bpmn:Participant') && isExpanded(element);
  }
  function isEmptyText(label) {
    return !label || !label.trim();
  }
  var MARKER_HIDDEN = 'djs-element-hidden',
    MARKER_LABEL_HIDDEN = 'djs-label-hidden';
  function LabelEditingPreview(eventBus, canvas, pathMap) {
    var self = this;
    var defaultLayer = canvas.getDefaultLayer();
    var element, absoluteElementBBox, gfx;
    eventBus.on('directEditing.activate', function (context) {
      var activeProvider = context.active;
      element = activeProvider.element.label || activeProvider.element;
      if (is(element, 'bpmn:TextAnnotation')) {
        absoluteElementBBox = canvas.getAbsoluteBBox(element);
        gfx = create$1('g');
        var textPathData = pathMap.getScaledPath('TEXT_ANNOTATION', {
          xScaleFactor: 1,
          yScaleFactor: 1,
          containerWidth: element.width,
          containerHeight: element.height,
          position: {
            mx: 0.0,
            my: 0.0
          }
        });
        var path = self.path = create$1('path');
        attr(path, {
          d: textPathData,
          strokeWidth: 2,
          stroke: getStrokeColor(element)
        });
        append(gfx, path);
        append(defaultLayer, gfx);
        translate$1(gfx, element.x, element.y);
      }
      if (is(element, 'bpmn:TextAnnotation') || element.labelTarget) {
        canvas.addMarker(element, MARKER_HIDDEN);
      } else if (is(element, 'bpmn:Task') || is(element, 'bpmn:CallActivity') || is(element, 'bpmn:SubProcess') || is(element, 'bpmn:Participant') || is(element, 'bpmn:Lane')) {
        canvas.addMarker(element, MARKER_LABEL_HIDDEN);
      }
    });
    eventBus.on('directEditing.resize', function (context) {
      if (is(element, 'bpmn:TextAnnotation')) {
        var height = context.height,
          dy = context.dy;
        var newElementHeight = Math.max(element.height / absoluteElementBBox.height * (height + dy), 0);
        var textPathData = pathMap.getScaledPath('TEXT_ANNOTATION', {
          xScaleFactor: 1,
          yScaleFactor: 1,
          containerWidth: element.width,
          containerHeight: newElementHeight,
          position: {
            mx: 0.0,
            my: 0.0
          }
        });
        attr(self.path, {
          d: textPathData
        });
      }
    });
    eventBus.on(['directEditing.complete', 'directEditing.cancel'], function (context) {
      var activeProvider = context.active;
      if (activeProvider) {
        canvas.removeMarker(activeProvider.element.label || activeProvider.element, MARKER_HIDDEN);
        canvas.removeMarker(element, MARKER_LABEL_HIDDEN);
      }
      element = undefined;
      absoluteElementBBox = undefined;
      if (gfx) {
        remove$1(gfx);
        gfx = undefined;
      }
    });
  }
  LabelEditingPreview.$inject = ['eventBus', 'canvas', 'pathMap'];
  function getStrokeColor(element, defaultColor) {
    var di = getDi(element);
    return di.get('stroke') || defaultColor || 'black';
  }
  var LabelEditingModule = {
    __depends__: [ChangeSupportModule, ResizeModule, DirectEditingModule],
    __init__: ['labelEditingProvider', 'labelEditingPreview'],
    labelEditingProvider: ['type', LabelEditingProvider],
    labelEditingPreview: ['type', LabelEditingPreview]
  };
  var ids = new IdGenerator('tt');
  function createRoot(parentNode) {
    var root = domify$1('<div class="djs-tooltip-container" />');
    assign(root, {
      position: 'absolute',
      width: '0',
      height: '0'
    });
    parentNode.insertBefore(root, parentNode.firstChild);
    return root;
  }
  function setPosition(el, x, y) {
    assign(el, {
      left: x + 'px',
      top: y + 'px'
    });
  }
  function setVisible(el, visible) {
    el.style.display = visible === false ? 'none' : '';
  }
  var tooltipClass = 'djs-tooltip',
    tooltipSelector = '.' + tooltipClass;
  function Tooltips(eventBus, canvas) {
    this._eventBus = eventBus;
    this._canvas = canvas;
    this._ids = ids;
    this._tooltipDefaults = {
      show: {
        minZoom: 0.7,
        maxZoom: 5.0
      }
    };
    this._tooltips = {};
    this._tooltipRoot = createRoot(canvas.getContainer());
    var self = this;
    delegate.bind(this._tooltipRoot, tooltipSelector, 'mousedown', function (event) {
      event.stopPropagation();
    });
    delegate.bind(this._tooltipRoot, tooltipSelector, 'mouseover', function (event) {
      self.trigger('mouseover', event);
    });
    delegate.bind(this._tooltipRoot, tooltipSelector, 'mouseout', function (event) {
      self.trigger('mouseout', event);
    });
    this._init();
  }
  Tooltips.$inject = ['eventBus', 'canvas'];
  Tooltips.prototype.add = function (tooltip) {
    if (!tooltip.position) {
      throw new Error('must specifiy tooltip position');
    }
    if (!tooltip.html) {
      throw new Error('must specifiy tooltip html');
    }
    var id = this._ids.next();
    tooltip = assign$1({}, this._tooltipDefaults, tooltip, {
      id: id
    });
    this._addTooltip(tooltip);
    if (tooltip.timeout) {
      this.setTimeout(tooltip);
    }
    return id;
  };
  Tooltips.prototype.trigger = function (action, event) {
    var node = event.delegateTarget || event.target;
    var tooltip = this.get(attr$1(node, 'data-tooltip-id'));
    if (!tooltip) {
      return;
    }
    if (action === 'mouseover' && tooltip.timeout) {
      this.clearTimeout(tooltip);
    }
    if (action === 'mouseout' && tooltip.timeout) {
      tooltip.timeout = 1000;
      this.setTimeout(tooltip);
    }
  };
  Tooltips.prototype.get = function (id) {
    if (typeof id !== 'string') {
      id = id.id;
    }
    return this._tooltips[id];
  };
  Tooltips.prototype.clearTimeout = function (tooltip) {
    tooltip = this.get(tooltip);
    if (!tooltip) {
      return;
    }
    var removeTimer = tooltip.removeTimer;
    if (removeTimer) {
      clearTimeout(removeTimer);
      tooltip.removeTimer = null;
    }
  };
  Tooltips.prototype.setTimeout = function (tooltip) {
    tooltip = this.get(tooltip);
    if (!tooltip) {
      return;
    }
    this.clearTimeout(tooltip);
    var self = this;
    tooltip.removeTimer = setTimeout(function () {
      self.remove(tooltip);
    }, tooltip.timeout);
  };
  Tooltips.prototype.remove = function (id) {
    var tooltip = this.get(id);
    if (tooltip) {
      remove$2(tooltip.html);
      remove$2(tooltip.htmlContainer);
      delete tooltip.htmlContainer;
      delete this._tooltips[tooltip.id];
    }
  };
  Tooltips.prototype.show = function () {
    setVisible(this._tooltipRoot);
  };
  Tooltips.prototype.hide = function () {
    setVisible(this._tooltipRoot, false);
  };
  Tooltips.prototype._updateRoot = function (viewbox) {
    var a = viewbox.scale || 1;
    var d = viewbox.scale || 1;
    var matrix = 'matrix(' + a + ',0,0,' + d + ',' + -1 * viewbox.x * a + ',' + -1 * viewbox.y * d + ')';
    this._tooltipRoot.style.transform = matrix;
    this._tooltipRoot.style['-ms-transform'] = matrix;
  };
  Tooltips.prototype._addTooltip = function (tooltip) {
    var id = tooltip.id,
      html = tooltip.html,
      htmlContainer,
      tooltipRoot = this._tooltipRoot;
    if (html.get && html.constructor.prototype.jquery) {
      html = html.get(0);
    }
    if (isString(html)) {
      html = domify$1(html);
    }
    htmlContainer = domify$1('<div data-tooltip-id="' + id + '" class="' + tooltipClass + '">');
    assign(htmlContainer, {
      position: 'absolute'
    });
    htmlContainer.appendChild(html);
    if (tooltip.type) {
      classes$1(htmlContainer).add('djs-tooltip-' + tooltip.type);
    }
    if (tooltip.className) {
      classes$1(htmlContainer).add(tooltip.className);
    }
    tooltip.htmlContainer = htmlContainer;
    tooltipRoot.appendChild(htmlContainer);
    this._tooltips[id] = tooltip;
    this._updateTooltip(tooltip);
  };
  Tooltips.prototype._updateTooltip = function (tooltip) {
    var position = tooltip.position,
      htmlContainer = tooltip.htmlContainer;
    setPosition(htmlContainer, position.x, position.y);
  };
  Tooltips.prototype._updateTooltipVisibilty = function (viewbox) {
    forEach$1(this._tooltips, function (tooltip) {
      var show = tooltip.show,
        htmlContainer = tooltip.htmlContainer,
        visible = true;
      if (show) {
        if (show.minZoom > viewbox.scale || show.maxZoom < viewbox.scale) {
          visible = false;
        }
        setVisible(htmlContainer, visible);
      }
    });
  };
  Tooltips.prototype._init = function () {
    var self = this;
    function updateViewbox(viewbox) {
      self._updateRoot(viewbox);
      self._updateTooltipVisibilty(viewbox);
      self.show();
    }
    this._eventBus.on('canvas.viewbox.changing', function (event) {
      self.hide();
    });
    this._eventBus.on('canvas.viewbox.changed', function (event) {
      updateViewbox(event.viewbox);
    });
  };
  var TooltipsModule = {
    __init__: ['tooltips'],
    tooltips: ['type', Tooltips]
  };
  var COLLAB_ERR_MSG = 'flow elements must be children of pools/participants';
  var DATA_OBJECT_ERR_MSG = 'Data object must be placed within a pool/participant.';
  function ModelingFeedback(eventBus, tooltips, translate) {
    function showError(position, message, timeout) {
      tooltips.add({
        position: {
          x: position.x + 5,
          y: position.y + 5
        },
        type: 'error',
        timeout: 2000,
        html: '<div>' + message + '</div>'
      });
    }
    eventBus.on(['shape.move.rejected', 'create.rejected'], function (event) {
      var context = event.context,
        shape = context.shape,
        target = context.target;
      if (is(target, 'bpmn:Collaboration')) {
        if (is(shape, 'bpmn:FlowNode')) {
          showError(event, translate(COLLAB_ERR_MSG));
        } else if (is(shape, 'bpmn:DataObjectReference')) {
          showError(event, translate(DATA_OBJECT_ERR_MSG));
        }
      }
    });
  }
  ModelingFeedback.$inject = ['eventBus', 'tooltips', 'translate'];
  var ModelingFeedbackModule = {
    __depends__: [TooltipsModule],
    __init__: ['modelingFeedback'],
    modelingFeedback: ['type', ModelingFeedback]
  };
  var LOW_PRIORITY$3 = 500;
  var DEFAULT_PRIORITY$1 = 1000;
  function Outline(eventBus, styles) {
    this._eventBus = eventBus;
    this.offset = 5;
    var OUTLINE_STYLE = styles.cls('djs-outline', ['no-fill']);
    var self = this;
    function createOutline(gfx) {
      var outline = create$1('rect');
      attr(outline, assign$1({
        x: 0,
        y: 0,
        rx: 4,
        width: 100,
        height: 100
      }, OUTLINE_STYLE));
      return outline;
    }
    eventBus.on(['shape.added', 'shape.changed'], LOW_PRIORITY$3, function (event) {
      var element = event.element,
        gfx = event.gfx;
      var outline = query('.djs-outline', gfx);
      if (!outline) {
        outline = self.getOutline(element) || createOutline();
        append(gfx, outline);
      }
      self.updateShapeOutline(outline, element);
    });
    eventBus.on(['connection.added', 'connection.changed'], function (event) {
      var element = event.element,
        gfx = event.gfx;
      var outline = query('.djs-outline', gfx);
      if (!outline) {
        outline = createOutline();
        append(gfx, outline);
      }
      self.updateConnectionOutline(outline, element);
    });
  }
  Outline.prototype.updateShapeOutline = function (outline, element) {
    var updated = false;
    var providers = this._getProviders();
    if (providers.length) {
      forEach$1(providers, function (provider) {
        updated = updated || provider.updateOutline(element, outline);
      });
    }
    if (!updated) {
      attr(outline, {
        x: -this.offset,
        y: -this.offset,
        width: element.width + this.offset * 2,
        height: element.height + this.offset * 2
      });
    }
  };
  Outline.prototype.updateConnectionOutline = function (outline, connection) {
    var bbox = getBBox(connection);
    attr(outline, {
      x: bbox.x - this.offset,
      y: bbox.y - this.offset,
      width: bbox.width + this.offset * 2,
      height: bbox.height + this.offset * 2
    });
  };
  Outline.prototype.registerProvider = function (priority, provider) {
    if (!provider) {
      provider = priority;
      priority = DEFAULT_PRIORITY$1;
    }
    this._eventBus.on('outline.getProviders', priority, function (event) {
      event.providers.push(provider);
    });
  };
  Outline.prototype._getProviders = function () {
    var event = this._eventBus.createEvent({
      type: 'outline.getProviders',
      providers: []
    });
    this._eventBus.fire(event);
    return event.providers;
  };
  Outline.prototype.getOutline = function (element) {
    var outline;
    var providers = this._getProviders();
    forEach$1(providers, function (provider) {
      if (!isFunction(provider.getOutline)) {
        return;
      }
      outline = outline || provider.getOutline(element);
    });
    return outline;
  };
  Outline.$inject = ['eventBus', 'styles', 'elementRegistry'];
  var SELECTION_OUTLINE_PADDING = 6;
  function MultiSelectionOutline(eventBus, canvas, selection) {
    this._canvas = canvas;
    var self = this;
    eventBus.on('element.changed', function (event) {
      if (selection.isSelected(event.element)) {
        self._updateMultiSelectionOutline(selection.get());
      }
    });
    eventBus.on('selection.changed', function (event) {
      var newSelection = event.newSelection;
      self._updateMultiSelectionOutline(newSelection);
    });
  }
  MultiSelectionOutline.prototype._updateMultiSelectionOutline = function (selection) {
    var layer = this._canvas.getLayer('selectionOutline');
    clear(layer);
    var enabled = selection.length > 1;
    var container = this._canvas.getContainer();
    classes(container)[enabled ? 'add' : 'remove']('djs-multi-select');
    if (!enabled) {
      return;
    }
    var bBox = addSelectionOutlinePadding(getBBox(selection));
    var rect = create$1('rect');
    attr(rect, assign$1({
      rx: 3
    }, bBox));
    classes(rect).add('djs-selection-outline');
    append(layer, rect);
  };
  MultiSelectionOutline.$inject = ['eventBus', 'canvas', 'selection'];
  function addSelectionOutlinePadding(bBox) {
    return {
      x: bBox.x - SELECTION_OUTLINE_PADDING,
      y: bBox.y - SELECTION_OUTLINE_PADDING,
      width: bBox.width + SELECTION_OUTLINE_PADDING * 2,
      height: bBox.height + SELECTION_OUTLINE_PADDING * 2
    };
  }
  var Ouline = {
    __depends__: [SelectionModule],
    __init__: ['outline', 'multiSelectionOutline'],
    outline: ['type', Outline],
    multiSelectionOutline: ['type', MultiSelectionOutline]
  };
  var LOW_PRIORITY$2 = 500,
    MEDIUM_PRIORITY = 1250,
    HIGH_PRIORITY$2 = 1500;
  var round = Math.round;
  function mid(element) {
    return {
      x: element.x + round(element.width / 2),
      y: element.y + round(element.height / 2)
    };
  }
  function MoveEvents(eventBus, dragging, modeling, selection, rules) {
    function canMove(shapes, delta, position, target) {
      return rules.allowed('elements.move', {
        shapes: shapes,
        delta: delta,
        position: position,
        target: target
      });
    }
    eventBus.on('shape.move.start', HIGH_PRIORITY$2, function (event) {
      var context = event.context,
        shape = event.shape,
        shapes = selection.get().slice();
      if (shapes.indexOf(shape) === -1) {
        shapes = [shape];
      }
      shapes = removeNested(shapes);
      assign$1(context, {
        shapes: shapes,
        validatedShapes: shapes,
        shape: shape
      });
    });
    eventBus.on('shape.move.start', MEDIUM_PRIORITY, function (event) {
      var context = event.context,
        validatedShapes = context.validatedShapes,
        canExecute;
      canExecute = context.canExecute = canMove(validatedShapes);
      if (!canExecute) {
        return false;
      }
    });
    eventBus.on('shape.move.move', LOW_PRIORITY$2, function (event) {
      var context = event.context,
        validatedShapes = context.validatedShapes,
        hover = event.hover,
        delta = {
          x: event.dx,
          y: event.dy
        },
        position = {
          x: event.x,
          y: event.y
        },
        canExecute;
      canExecute = canMove(validatedShapes, delta, position, hover);
      context.delta = delta;
      context.canExecute = canExecute;
      if (canExecute === null) {
        context.target = null;
        return;
      }
      context.target = hover;
    });
    eventBus.on('shape.move.end', function (event) {
      var context = event.context;
      var delta = context.delta,
        canExecute = context.canExecute,
        isAttach = canExecute === 'attach',
        shapes = context.shapes;
      if (canExecute === false) {
        return false;
      }
      delta.x = round(delta.x);
      delta.y = round(delta.y);
      if (delta.x === 0 && delta.y === 0) {
        return;
      }
      modeling.moveElements(shapes, delta, context.target, {
        primaryShape: context.shape,
        attach: isAttach
      });
    });
    eventBus.on('element.mousedown', function (event) {
      if (!isPrimaryButton(event)) {
        return;
      }
      var originalEvent = getOriginal$1(event);
      if (!originalEvent) {
        throw new Error('must supply DOM mousedown event');
      }
      return start(originalEvent, event.element);
    });
    function start(event, element, activate, context) {
      if (isObject(activate)) {
        context = activate;
        activate = false;
      }
      if (element.waypoints || !element.parent) {
        return;
      }
      if (classes(event.target).has('djs-hit-no-move')) {
        return;
      }
      var referencePoint = mid(element);
      dragging.init(event, referencePoint, 'shape.move', {
        cursor: 'grabbing',
        autoActivate: activate,
        data: {
          shape: element,
          context: context || {}
        }
      });
      return true;
    }
    this.start = start;
  }
  MoveEvents.$inject = ['eventBus', 'dragging', 'modeling', 'selection', 'rules'];
  function removeNested(elements) {
    var ids = groupBy(elements, 'id');
    return filter(elements, function (element) {
      while (element = element.parent) {
        if (ids[element.id]) {
          return false;
        }
      }
      return true;
    });
  }
  var LOW_PRIORITY$1 = 499;
  var MARKER_DRAGGING = 'djs-dragging',
    MARKER_OK$1 = 'drop-ok',
    MARKER_NOT_OK$1 = 'drop-not-ok',
    MARKER_NEW_PARENT = 'new-parent',
    MARKER_ATTACH = 'attach-ok';
  function MovePreview(eventBus, canvas, styles, previewSupport) {
    function getVisualDragShapes(shapes) {
      var elements = getAllDraggedElements(shapes);
      var filteredElements = removeEdges(elements);
      return filteredElements;
    }
    function getAllDraggedElements(shapes) {
      var allShapes = selfAndAllChildren(shapes, true);
      var allConnections = allShapes.flatMap(function (shape) {
        return (shape.incoming || []).concat(shape.outgoing || []);
      });
      var allElements = allShapes.concat(allConnections);
      var uniqueElements = _toConsumableArray(new Set(allElements));
      return uniqueElements;
    }
    function setMarker(element, marker) {
      [MARKER_ATTACH, MARKER_OK$1, MARKER_NOT_OK$1, MARKER_NEW_PARENT].forEach(function (m) {
        if (m === marker) {
          canvas.addMarker(element, m);
        } else {
          canvas.removeMarker(element, m);
        }
      });
    }
    function makeDraggable(context, element, addMarker) {
      previewSupport.addDragger(element, context.dragGroup);
      if (addMarker) {
        canvas.addMarker(element, MARKER_DRAGGING);
      }
      if (context.allDraggedElements) {
        context.allDraggedElements.push(element);
      } else {
        context.allDraggedElements = [element];
      }
    }
    eventBus.on('shape.move.start', LOW_PRIORITY$1, function (event) {
      var context = event.context,
        dragShapes = context.shapes,
        allDraggedElements = context.allDraggedElements;
      var visuallyDraggedShapes = getVisualDragShapes(dragShapes);
      if (!context.dragGroup) {
        var dragGroup = create$1('g');
        attr(dragGroup, styles.cls('djs-drag-group', ['no-events']));
        var activeLayer = canvas.getActiveLayer();
        append(activeLayer, dragGroup);
        context.dragGroup = dragGroup;
      }
      visuallyDraggedShapes.forEach(function (shape) {
        previewSupport.addDragger(shape, context.dragGroup);
      });
      if (!allDraggedElements) {
        allDraggedElements = getAllDraggedElements(dragShapes);
      } else {
        allDraggedElements = flatten([allDraggedElements, getAllDraggedElements(dragShapes)]);
      }
      forEach$1(allDraggedElements, function (e) {
        canvas.addMarker(e, MARKER_DRAGGING);
      });
      context.allDraggedElements = allDraggedElements;
      context.differentParents = haveDifferentParents(dragShapes);
    });
    eventBus.on('shape.move.move', LOW_PRIORITY$1, function (event) {
      var context = event.context,
        dragGroup = context.dragGroup,
        target = context.target,
        parent = context.shape.parent,
        canExecute = context.canExecute;
      if (target) {
        if (canExecute === 'attach') {
          setMarker(target, MARKER_ATTACH);
        } else if (context.canExecute && parent && target.id !== parent.id) {
          setMarker(target, MARKER_NEW_PARENT);
        } else {
          setMarker(target, context.canExecute ? MARKER_OK$1 : MARKER_NOT_OK$1);
        }
      }
      translate$1(dragGroup, event.dx, event.dy);
    });
    eventBus.on(['shape.move.out', 'shape.move.cleanup'], function (event) {
      var context = event.context,
        target = context.target;
      if (target) {
        setMarker(target, null);
      }
    });
    eventBus.on('shape.move.cleanup', function (event) {
      var context = event.context,
        allDraggedElements = context.allDraggedElements,
        dragGroup = context.dragGroup;
      forEach$1(allDraggedElements, function (e) {
        canvas.removeMarker(e, MARKER_DRAGGING);
      });
      if (dragGroup) {
        remove$1(dragGroup);
      }
    });
    this.makeDraggable = makeDraggable;
  }
  MovePreview.$inject = ['eventBus', 'canvas', 'styles', 'previewSupport'];
  function removeEdges(elements) {
    var filteredElements = filter(elements, function (element) {
      if (!isConnection(element)) {
        return true;
      } else {
        return find(elements, matchPattern({
          id: element.source.id
        })) && find(elements, matchPattern({
          id: element.target.id
        }));
      }
    });
    return filteredElements;
  }
  function haveDifferentParents(elements) {
    return size(groupBy(elements, function (e) {
      return e.parent && e.parent.id;
    })) !== 1;
  }
  var MoveModule = {
    __depends__: [InteractionEventsModule$1, SelectionModule, Ouline, RulesModule$1, DraggingModule, PreviewSupportModule],
    __init__: ['move', 'movePreview'],
    move: ['type', MoveEvents],
    movePreview: ['type', MovePreview]
  };
  var TOGGLE_SELECTOR = '.djs-palette-toggle',
    ENTRY_SELECTOR = '.entry',
    ELEMENT_SELECTOR = TOGGLE_SELECTOR + ', ' + ENTRY_SELECTOR;
  var PALETTE_PREFIX = 'djs-palette-',
    PALETTE_SHOWN_CLS = 'shown',
    PALETTE_OPEN_CLS = 'open',
    PALETTE_TWO_COLUMN_CLS = 'two-column';
  var DEFAULT_PRIORITY = 1000;
  function Palette(eventBus, canvas) {
    this._eventBus = eventBus;
    this._canvas = canvas;
    var self = this;
    eventBus.on('tool-manager.update', function (event) {
      var tool = event.tool;
      self.updateToolHighlight(tool);
    });
    eventBus.on('i18n.changed', function () {
      self._update();
    });
    eventBus.on('diagram.init', function () {
      self._diagramInitialized = true;
      self._rebuild();
    });
  }
  Palette.$inject = ['eventBus', 'canvas'];
  Palette.prototype.registerProvider = function (priority, provider) {
    if (!provider) {
      provider = priority;
      priority = DEFAULT_PRIORITY;
    }
    this._eventBus.on('palette.getProviders', priority, function (event) {
      event.providers.push(provider);
    });
    this._rebuild();
  };
  Palette.prototype.getEntries = function () {
    var providers = this._getProviders();
    return providers.reduce(addPaletteEntries, {});
  };
  Palette.prototype._rebuild = function () {
    if (!this._diagramInitialized) {
      return;
    }
    var providers = this._getProviders();
    if (!providers.length) {
      return;
    }
    if (!this._container) {
      this._init();
    }
    this._update();
  };
  Palette.prototype._init = function () {
    var self = this;
    var eventBus = this._eventBus;
    var parentContainer = this._getParentContainer();
    var container = this._container = domify$1(Palette.HTML_MARKUP);
    parentContainer.appendChild(container);
    classes$1(parentContainer).add(PALETTE_PREFIX + PALETTE_SHOWN_CLS);
    delegate.bind(container, ELEMENT_SELECTOR, 'click', function (event) {
      var target = event.delegateTarget;
      if (matches(target, TOGGLE_SELECTOR)) {
        return self.toggle();
      }
      self.trigger('click', event);
    });
    event.bind(container, 'mousedown', function (event) {
      event.stopPropagation();
    });
    delegate.bind(container, ENTRY_SELECTOR, 'dragstart', function (event) {
      self.trigger('dragstart', event);
    });
    eventBus.on('canvas.resized', this._layoutChanged, this);
    eventBus.fire('palette.create', {
      container: container
    });
  };
  Palette.prototype._getProviders = function (id) {
    var event = this._eventBus.createEvent({
      type: 'palette.getProviders',
      providers: []
    });
    this._eventBus.fire(event);
    return event.providers;
  };
  Palette.prototype._toggleState = function (state) {
    state = state || {};
    var parent = this._getParentContainer(),
      container = this._container;
    var eventBus = this._eventBus;
    var twoColumn;
    var cls = classes$1(container),
      parentCls = classes$1(parent);
    if ('twoColumn' in state) {
      twoColumn = state.twoColumn;
    } else {
      twoColumn = this._needsCollapse(parent.clientHeight, this._entries || {});
    }
    cls.toggle(PALETTE_TWO_COLUMN_CLS, twoColumn);
    parentCls.toggle(PALETTE_PREFIX + PALETTE_TWO_COLUMN_CLS, twoColumn);
    if ('open' in state) {
      cls.toggle(PALETTE_OPEN_CLS, state.open);
      parentCls.toggle(PALETTE_PREFIX + PALETTE_OPEN_CLS, state.open);
    }
    eventBus.fire('palette.changed', {
      twoColumn: twoColumn,
      open: this.isOpen()
    });
  };
  Palette.prototype._update = function () {
    var entriesContainer = query('.djs-palette-entries', this._container),
      entries = this._entries = this.getEntries();
    clear$1(entriesContainer);
    forEach$1(entries, function (entry, id) {
      var grouping = entry.group || 'default';
      var container = query('[data-group=' + escapeCSS(grouping) + ']', entriesContainer);
      if (!container) {
        container = domify$1('<div class="group"></div>');
        attr$1(container, 'data-group', grouping);
        entriesContainer.appendChild(container);
      }
      var html = entry.html || (entry.separator ? '<hr class="separator" />' : '<div class="entry" draggable="true"></div>');
      var control = domify$1(html);
      container.appendChild(control);
      if (!entry.separator) {
        attr$1(control, 'data-action', id);
        if (entry.title) {
          attr$1(control, 'title', entry.title);
        }
        if (entry.className) {
          addClasses(control, entry.className);
        }
        if (entry.imageUrl) {
          var image = domify$1('<img>');
          attr$1(image, 'src', entry.imageUrl);
          control.appendChild(image);
        }
      }
    });
    this.open();
  };
  Palette.prototype.trigger = function (action, event, autoActivate) {
    var entry,
      originalEvent,
      button = event.delegateTarget || event.target;
    if (!button) {
      return event.preventDefault();
    }
    entry = attr$1(button, 'data-action');
    originalEvent = event.originalEvent || event;
    return this.triggerEntry(entry, action, originalEvent, autoActivate);
  };
  Palette.prototype.triggerEntry = function (entryId, action, event, autoActivate) {
    var entries = this._entries,
      entry,
      handler;
    entry = entries[entryId];
    if (!entry) {
      return;
    }
    handler = entry.action;
    if (this._eventBus.fire('palette.trigger', {
      entry,
      event
    }) === false) {
      return;
    }
    if (isFunction(handler)) {
      if (action === 'click') {
        return handler(event, autoActivate);
      }
    } else {
      if (handler[action]) {
        return handler[action](event, autoActivate);
      }
    }
    event.preventDefault();
  };
  Palette.prototype._layoutChanged = function () {
    this._toggleState({});
  };
  Palette.prototype._needsCollapse = function (availableHeight, entries) {
    var margin = 20 + 10 + 20;
    var entriesHeight = Object.keys(entries).length * 46;
    return availableHeight < entriesHeight + margin;
  };
  Palette.prototype.close = function () {
    this._toggleState({
      open: false,
      twoColumn: false
    });
  };
  Palette.prototype.open = function () {
    this._toggleState({
      open: true
    });
  };
  Palette.prototype.toggle = function () {
    if (this.isOpen()) {
      this.close();
    } else {
      this.open();
    }
  };
  Palette.prototype.isActiveTool = function (tool) {
    return tool && this._activeTool === tool;
  };
  Palette.prototype.updateToolHighlight = function (name) {
    var entriesContainer, toolsContainer;
    if (!this._toolsContainer) {
      entriesContainer = query('.djs-palette-entries', this._container);
      this._toolsContainer = query('[data-group=tools]', entriesContainer);
    }
    toolsContainer = this._toolsContainer;
    forEach$1(toolsContainer.children, function (tool) {
      var actionName = tool.getAttribute('data-action');
      if (!actionName) {
        return;
      }
      var toolClasses = classes$1(tool);
      actionName = actionName.replace('-tool', '');
      if (toolClasses.contains('entry') && actionName === name) {
        toolClasses.add('highlighted-entry');
      } else {
        toolClasses.remove('highlighted-entry');
      }
    });
  };
  Palette.prototype.isOpen = function () {
    return classes$1(this._container).has(PALETTE_OPEN_CLS);
  };
  Palette.prototype._getParentContainer = function () {
    return this._canvas.getContainer();
  };
  Palette.HTML_MARKUP = '<div class="djs-palette">' + '<div class="djs-palette-entries"></div>' + '<div class="djs-palette-toggle"></div>' + '</div>';
  function addClasses(element, classNames) {
    var classes = classes$1(element);
    var actualClassNames = isArray$3(classNames) ? classNames : classNames.split(/\s+/g);
    actualClassNames.forEach(function (cls) {
      classes.add(cls);
    });
  }
  function addPaletteEntries(entries, provider) {
    var entriesOrUpdater = provider.getPaletteEntries();
    if (isFunction(entriesOrUpdater)) {
      return entriesOrUpdater(entries);
    }
    forEach$1(entriesOrUpdater, function (entry, id) {
      entries[id] = entry;
    });
    return entries;
  }
  var PaletteModule$1 = {
    __init__: ['palette'],
    palette: ['type', Palette]
  };
  var LASSO_TOOL_CURSOR = 'crosshair';
  function LassoTool(eventBus, canvas, dragging, elementRegistry, selection, toolManager, mouse) {
    this._selection = selection;
    this._dragging = dragging;
    this._mouse = mouse;
    var self = this;
    var visuals = {
      create: function create(context) {
        var container = canvas.getActiveLayer(),
          frame;
        frame = context.frame = create$1('rect');
        attr(frame, {
          class: 'djs-lasso-overlay',
          width: 1,
          height: 1,
          x: 0,
          y: 0
        });
        append(container, frame);
      },
      update: function update(context) {
        var frame = context.frame,
          bbox = context.bbox;
        attr(frame, {
          x: bbox.x,
          y: bbox.y,
          width: bbox.width,
          height: bbox.height
        });
      },
      remove: function remove(context) {
        if (context.frame) {
          remove$1(context.frame);
        }
      }
    };
    toolManager.registerTool('lasso', {
      tool: 'lasso.selection',
      dragging: 'lasso'
    });
    eventBus.on('lasso.selection.end', function (event) {
      var target = event.originalEvent.target;
      if (!event.hover && !(target instanceof SVGElement)) {
        return;
      }
      eventBus.once('lasso.selection.ended', function () {
        self.activateLasso(event.originalEvent, true);
      });
    });
    eventBus.on('lasso.end', 0, function (event) {
      var context = event.context;
      var bbox = toBBox(event);
      var elements = elementRegistry.filter(function (element) {
        return element;
      });
      var add = hasSecondaryModifier(event);
      self.select(elements, bbox, add ? context.selection : []);
    });
    eventBus.on('lasso.start', function (event) {
      var context = event.context;
      context.bbox = toBBox(event);
      visuals.create(context);
      context.selection = selection.get();
    });
    eventBus.on('lasso.move', function (event) {
      var context = event.context;
      context.bbox = toBBox(event);
      visuals.update(context);
    });
    eventBus.on('lasso.cleanup', function (event) {
      var context = event.context;
      visuals.remove(context);
    });
    eventBus.on('element.mousedown', 1500, function (event) {
      if (!hasSecondaryModifier(event)) {
        return;
      }
      self.activateLasso(event.originalEvent);
      return true;
    });
  }
  LassoTool.$inject = ['eventBus', 'canvas', 'dragging', 'elementRegistry', 'selection', 'toolManager', 'mouse'];
  LassoTool.prototype.activateLasso = function (event, autoActivate) {
    this._dragging.init(event, 'lasso', {
      autoActivate: autoActivate,
      cursor: LASSO_TOOL_CURSOR,
      data: {
        context: {}
      }
    });
  };
  LassoTool.prototype.activateSelection = function (event, autoActivate) {
    this._dragging.init(event, 'lasso.selection', {
      trapClick: false,
      autoActivate: autoActivate,
      cursor: LASSO_TOOL_CURSOR,
      data: {
        context: {}
      },
      keepSelection: true
    });
  };
  LassoTool.prototype.select = function (elements, bbox) {
    var previousSelection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    var selectedElements = getEnclosedElements(elements, bbox);
    this._selection.select([].concat(_toConsumableArray(previousSelection), _toConsumableArray(values(selectedElements))));
  };
  LassoTool.prototype.toggle = function () {
    if (this.isActive()) {
      return this._dragging.cancel();
    }
    var mouseEvent = this._mouse.getLastMoveEvent();
    this.activateSelection(mouseEvent, !!mouseEvent);
  };
  LassoTool.prototype.isActive = function () {
    var context = this._dragging.context();
    return context && /^lasso/.test(context.prefix);
  };
  function toBBox(event) {
    var start = {
      x: event.x - event.dx,
      y: event.y - event.dy
    };
    var end = {
      x: event.x,
      y: event.y
    };
    var bbox;
    if (start.x <= end.x && start.y < end.y || start.x < end.x && start.y <= end.y) {
      bbox = {
        x: start.x,
        y: start.y,
        width: end.x - start.x,
        height: end.y - start.y
      };
    } else if (start.x >= end.x && start.y < end.y || start.x > end.x && start.y <= end.y) {
      bbox = {
        x: end.x,
        y: start.y,
        width: start.x - end.x,
        height: end.y - start.y
      };
    } else if (start.x <= end.x && start.y > end.y || start.x < end.x && start.y >= end.y) {
      bbox = {
        x: start.x,
        y: end.y,
        width: end.x - start.x,
        height: start.y - end.y
      };
    } else if (start.x >= end.x && start.y > end.y || start.x > end.x && start.y >= end.y) {
      bbox = {
        x: end.x,
        y: end.y,
        width: start.x - end.x,
        height: start.y - end.y
      };
    } else {
      bbox = {
        x: end.x,
        y: end.y,
        width: 0,
        height: 0
      };
    }
    return bbox;
  }
  var LassoToolModule = {
    __depends__: [ToolManagerModule, MouseModule],
    __init__: ['lassoTool'],
    lassoTool: ['type', LassoTool]
  };
  var HIGH_PRIORITY$1 = 1500;
  var HAND_CURSOR = 'grab';
  function HandTool(eventBus, canvas, dragging, injector, toolManager, mouse) {
    this._dragging = dragging;
    this._mouse = mouse;
    var self = this,
      keyboard = injector.get('keyboard', false);
    toolManager.registerTool('hand', {
      tool: 'hand',
      dragging: 'hand.move'
    });
    eventBus.on('element.mousedown', HIGH_PRIORITY$1, function (event) {
      if (!hasPrimaryModifier(event)) {
        return;
      }
      self.activateMove(event.originalEvent, true);
      return false;
    });
    keyboard && keyboard.addListener(HIGH_PRIORITY$1, function (e) {
      if (!isSpace(e.keyEvent) || self.isActive()) {
        return;
      }
      var mouseEvent = self._mouse.getLastMoveEvent();
      self.activateMove(mouseEvent, !!mouseEvent);
    }, 'keyboard.keydown');
    keyboard && keyboard.addListener(HIGH_PRIORITY$1, function (e) {
      if (!isSpace(e.keyEvent) || !self.isActive()) {
        return;
      }
      self.toggle();
    }, 'keyboard.keyup');
    eventBus.on('hand.end', function (event) {
      var target = event.originalEvent.target;
      if (!event.hover && !(target instanceof SVGElement)) {
        return false;
      }
      eventBus.once('hand.ended', function () {
        self.activateMove(event.originalEvent, {
          reactivate: true
        });
      });
    });
    eventBus.on('hand.move.move', function (event) {
      var scale = canvas.viewbox().scale;
      canvas.scroll({
        dx: event.dx * scale,
        dy: event.dy * scale
      });
    });
    eventBus.on('hand.move.end', function (event) {
      var context = event.context,
        reactivate = context.reactivate;
      if (!hasPrimaryModifier(event) && reactivate) {
        eventBus.once('hand.move.ended', function (event) {
          self.activateHand(event.originalEvent, true, true);
        });
      }
      return false;
    });
  }
  HandTool.$inject = ['eventBus', 'canvas', 'dragging', 'injector', 'toolManager', 'mouse'];
  HandTool.prototype.activateMove = function (event, autoActivate, context) {
    if (typeof autoActivate === 'object') {
      context = autoActivate;
      autoActivate = false;
    }
    this._dragging.init(event, 'hand.move', {
      autoActivate: autoActivate,
      cursor: HAND_CURSOR,
      data: {
        context: context || {}
      }
    });
  };
  HandTool.prototype.activateHand = function (event, autoActivate, reactivate) {
    this._dragging.init(event, 'hand', {
      trapClick: false,
      autoActivate: autoActivate,
      cursor: HAND_CURSOR,
      data: {
        context: {
          reactivate: reactivate
        }
      }
    });
  };
  HandTool.prototype.toggle = function () {
    if (this.isActive()) {
      return this._dragging.cancel();
    }
    var mouseEvent = this._mouse.getLastMoveEvent();
    this.activateHand(mouseEvent, !!mouseEvent);
  };
  HandTool.prototype.isActive = function () {
    var context = this._dragging.context();
    if (context) {
      return /^(hand|hand\.move)$/.test(context.prefix);
    }
    return false;
  };
  function isSpace(keyEvent) {
    return isKey('Space', keyEvent);
  }
  var HandToolModule = {
    __depends__: [ToolManagerModule, MouseModule],
    __init__: ['handTool'],
    handTool: ['type', HandTool]
  };
  var MARKER_OK = 'connect-ok',
    MARKER_NOT_OK = 'connect-not-ok';
  function GlobalConnect(eventBus, dragging, connect, canvas, toolManager, rules, mouse) {
    var self = this;
    this._dragging = dragging;
    this._rules = rules;
    this._mouse = mouse;
    toolManager.registerTool('global-connect', {
      tool: 'global-connect',
      dragging: 'global-connect.drag'
    });
    eventBus.on('global-connect.hover', function (event) {
      var context = event.context,
        startTarget = event.hover;
      var canStartConnect = context.canStartConnect = self.canStartConnect(startTarget);
      if (canStartConnect === null) {
        return;
      }
      context.startTarget = startTarget;
      canvas.addMarker(startTarget, canStartConnect ? MARKER_OK : MARKER_NOT_OK);
    });
    eventBus.on(['global-connect.out', 'global-connect.cleanup'], function (event) {
      var startTarget = event.context.startTarget,
        canStartConnect = event.context.canStartConnect;
      if (startTarget) {
        canvas.removeMarker(startTarget, canStartConnect ? MARKER_OK : MARKER_NOT_OK);
      }
    });
    eventBus.on(['global-connect.ended'], function (event) {
      var context = event.context,
        startTarget = context.startTarget,
        startPosition = {
          x: event.x,
          y: event.y
        };
      var canStartConnect = self.canStartConnect(startTarget);
      if (!canStartConnect) {
        return;
      }
      eventBus.once('element.out', function () {
        eventBus.once(['connect.ended', 'connect.canceled'], function () {
          eventBus.fire('global-connect.drag.ended');
        });
        connect.start(null, startTarget, startPosition);
      });
      return false;
    });
  }
  GlobalConnect.$inject = ['eventBus', 'dragging', 'connect', 'canvas', 'toolManager', 'rules', 'mouse'];
  GlobalConnect.prototype.start = function (event, autoActivate) {
    this._dragging.init(event, 'global-connect', {
      autoActivate: autoActivate,
      trapClick: false,
      data: {
        context: {}
      }
    });
  };
  GlobalConnect.prototype.toggle = function () {
    if (this.isActive()) {
      return this._dragging.cancel();
    }
    var mouseEvent = this._mouse.getLastMoveEvent();
    return this.start(mouseEvent, !!mouseEvent);
  };
  GlobalConnect.prototype.isActive = function () {
    var context = this._dragging.context();
    return context && /^global-connect/.test(context.prefix);
  };
  GlobalConnect.prototype.canStartConnect = function (startTarget) {
    return this._rules.allowed('connection.start', {
      source: startTarget
    });
  };
  var GlobalConnectModule = {
    __depends__: [ConnectModule, RulesModule$1, DraggingModule, ToolManagerModule, MouseModule],
    globalConnect: ['type', GlobalConnect]
  };
  function PaletteProvider(palette, create, elementFactory, spaceTool, lassoTool, handTool, globalConnect, translate) {
    this._palette = palette;
    this._create = create;
    this._elementFactory = elementFactory;
    this._spaceTool = spaceTool;
    this._lassoTool = lassoTool;
    this._handTool = handTool;
    this._globalConnect = globalConnect;
    this._translate = translate;
    palette.registerProvider(this);
  }
  PaletteProvider.$inject = ['palette', 'create', 'elementFactory', 'spaceTool', 'lassoTool', 'handTool', 'globalConnect', 'translate'];
  PaletteProvider.prototype.getPaletteEntries = function () {
    var actions = {},
      create = this._create,
      elementFactory = this._elementFactory,
      spaceTool = this._spaceTool,
      lassoTool = this._lassoTool,
      handTool = this._handTool,
      globalConnect = this._globalConnect,
      translate = this._translate;
    function createAction(type, group, className, title, options) {
      function createListener(event) {
        var shape = elementFactory.createShape(assign$1({
          type: type
        }, options));
        create.start(event, shape);
      }
      return {
        group: group,
        className: className,
        title: title,
        action: {
          dragstart: createListener,
          click: createListener
        }
      };
    }
    function createSubprocess(event) {
      var subProcess = elementFactory.createShape({
        type: 'bpmn:SubProcess',
        x: 0,
        y: 0,
        isExpanded: true
      });
      var startEvent = elementFactory.createShape({
        type: 'bpmn:StartEvent',
        x: 40,
        y: 82,
        parent: subProcess
      });
      create.start(event, [subProcess, startEvent], {
        hints: {
          autoSelect: [subProcess]
        }
      });
    }
    function createParticipant(event) {
      create.start(event, elementFactory.createParticipantShape());
    }
    assign$1(actions, {
      'hand-tool': {
        group: 'tools',
        className: 'bpmn-icon-hand-tool',
        title: translate('Activate hand tool'),
        action: {
          click: function click(event) {
            handTool.activateHand(event);
          }
        }
      },
      'lasso-tool': {
        group: 'tools',
        className: 'bpmn-icon-lasso-tool',
        title: translate('Activate lasso tool'),
        action: {
          click: function click(event) {
            lassoTool.activateSelection(event);
          }
        }
      },
      'space-tool': {
        group: 'tools',
        className: 'bpmn-icon-space-tool',
        title: translate('Activate create/remove space tool'),
        action: {
          click: function click(event) {
            spaceTool.activateSelection(event);
          }
        }
      },
      'global-connect-tool': {
        group: 'tools',
        className: 'bpmn-icon-connection-multi',
        title: translate('Activate global connect tool'),
        action: {
          click: function click(event) {
            globalConnect.start(event);
          }
        }
      },
      'tool-separator': {
        group: 'tools',
        separator: true
      },
      'create.start-event': createAction('bpmn:StartEvent', 'event', 'bpmn-icon-start-event-none', translate('Create start event')),
      'create.intermediate-event': createAction('bpmn:IntermediateThrowEvent', 'event', 'bpmn-icon-intermediate-event-none', translate('Create intermediate/boundary event')),
      'create.end-event': createAction('bpmn:EndEvent', 'event', 'bpmn-icon-end-event-none', translate('Create end event')),
      'create.exclusive-gateway': createAction('bpmn:ExclusiveGateway', 'gateway', 'bpmn-icon-gateway-none', translate('Create gateway')),
      'create.task': createAction('bpmn:Task', 'activity', 'bpmn-icon-task', translate('Create task')),
      'create.data-object': createAction('bpmn:DataObjectReference', 'data-object', 'bpmn-icon-data-object', translate('Create data object reference')),
      'create.data-store': createAction('bpmn:DataStoreReference', 'data-store', 'bpmn-icon-data-store', translate('Create data store reference')),
      'create.subprocess-expanded': {
        group: 'activity',
        className: 'bpmn-icon-subprocess-expanded',
        title: translate('Create expanded sub-process'),
        action: {
          dragstart: createSubprocess,
          click: createSubprocess
        }
      },
      'create.participant-expanded': {
        group: 'collaboration',
        className: 'bpmn-icon-participant',
        title: translate('Create pool/participant'),
        action: {
          dragstart: createParticipant,
          click: createParticipant
        }
      },
      'create.group': createAction('bpmn:Group', 'artifact', 'bpmn-icon-group', translate('Create group'))
    });
    return actions;
  };
  var PaletteModule = {
    __depends__: [PaletteModule$1, CreateModule, SpaceToolModule, LassoToolModule, HandToolModule, GlobalConnectModule, TranslateModule],
    __init__: ['paletteProvider'],
    paletteProvider: ['type', PaletteProvider]
  };
  var LOW_PRIORITY = 250;
  function BpmnReplacePreview(eventBus, elementRegistry, elementFactory, canvas, previewSupport) {
    CommandInterceptor.call(this, eventBus);
    function replaceVisual(context) {
      var replacements = context.canExecute.replacements;
      forEach$1(replacements, function (replacement) {
        var id = replacement.oldElementId;
        var newElement = {
          type: replacement.newElementType
        };
        if (context.visualReplacements[id]) {
          return;
        }
        var element = elementRegistry.get(id);
        assign$1(newElement, {
          x: element.x,
          y: element.y
        });
        var tempShape = elementFactory.createShape(newElement);
        canvas.addShape(tempShape, element.parent);
        var gfx = query('[data-element-id="' + escapeCSS(element.id) + '"]', context.dragGroup);
        if (gfx) {
          attr(gfx, {
            display: 'none'
          });
        }
        var dragger = previewSupport.addDragger(tempShape, context.dragGroup);
        context.visualReplacements[id] = dragger;
        canvas.removeShape(tempShape);
      });
    }
    function restoreVisual(context) {
      var visualReplacements = context.visualReplacements;
      forEach$1(visualReplacements, function (dragger, id) {
        var originalGfx = query('[data-element-id="' + escapeCSS(id) + '"]', context.dragGroup);
        if (originalGfx) {
          attr(originalGfx, {
            display: 'inline'
          });
        }
        dragger.remove();
        if (visualReplacements[id]) {
          delete visualReplacements[id];
        }
      });
    }
    eventBus.on('shape.move.move', LOW_PRIORITY, function (event) {
      var context = event.context,
        canExecute = context.canExecute;
      if (!context.visualReplacements) {
        context.visualReplacements = {};
      }
      if (canExecute && canExecute.replacements) {
        replaceVisual(context);
      } else {
        restoreVisual(context);
      }
    });
  }
  BpmnReplacePreview.$inject = ['eventBus', 'elementRegistry', 'elementFactory', 'canvas', 'previewSupport'];
  e$2(BpmnReplacePreview, CommandInterceptor);
  var ReplacePreviewModule = {
    __depends__: [PreviewSupportModule],
    __init__: ['bpmnReplacePreview'],
    bpmnReplacePreview: ['type', BpmnReplacePreview]
  };
  var HIGHER_PRIORITY$2 = 1250;
  var BOUNDARY_TO_HOST_THRESHOLD = 40;
  var TARGET_BOUNDS_PADDING = 20,
    TASK_BOUNDS_PADDING = 10;
  var TARGET_CENTER_PADDING = 20;
  var AXES = ['x', 'y'];
  var abs = Math.abs;
  function BpmnConnectSnapping(eventBus) {
    eventBus.on(['connect.hover', 'connect.move', 'connect.end'], HIGHER_PRIORITY$2, function (event) {
      var context = event.context,
        canExecute = context.canExecute,
        start = context.start,
        hover = context.hover,
        source = context.source,
        target = context.target;
      if (event.originalEvent && isCmd(event.originalEvent)) {
        return;
      }
      if (!context.initialConnectionStart) {
        context.initialConnectionStart = context.connectionStart;
      }
      if (canExecute && hover) {
        snapToShape(event, hover, getTargetBoundsPadding(hover));
      }
      if (hover && isAnyType(canExecute, ['bpmn:Association', 'bpmn:DataInputAssociation', 'bpmn:DataOutputAssociation', 'bpmn:SequenceFlow'])) {
        context.connectionStart = mid$2(start);
        if (isAny(hover, ['bpmn:Event', 'bpmn:Gateway'])) {
          snapToPosition(event, mid$2(hover));
        }
        if (isAny(hover, ['bpmn:Task', 'bpmn:SubProcess'])) {
          snapToTargetMid(event, hover);
        }
        if (is(source, 'bpmn:BoundaryEvent') && target === source.host) {
          snapBoundaryEventLoop(event);
        }
      } else if (isType(canExecute, 'bpmn:MessageFlow')) {
        if (is(start, 'bpmn:Event')) {
          context.connectionStart = mid$2(start);
        }
        if (is(hover, 'bpmn:Event')) {
          snapToPosition(event, mid$2(hover));
        }
      } else {
        context.connectionStart = context.initialConnectionStart;
      }
    });
  }
  BpmnConnectSnapping.$inject = ['eventBus'];
  function snapToShape(event, target, padding) {
    AXES.forEach(function (axis) {
      var dimensionForAxis = getDimensionForAxis(axis, target);
      if (event[axis] < target[axis] + padding) {
        setSnapped(event, axis, target[axis] + padding);
      } else if (event[axis] > target[axis] + dimensionForAxis - padding) {
        setSnapped(event, axis, target[axis] + dimensionForAxis - padding);
      }
    });
  }
  function snapToTargetMid(event, target) {
    var targetMid = mid$2(target);
    AXES.forEach(function (axis) {
      if (isMid(event, target, axis)) {
        setSnapped(event, axis, targetMid[axis]);
      }
    });
  }
  function snapBoundaryEventLoop(event) {
    var context = event.context,
      source = context.source,
      target = context.target;
    if (isReverse(context)) {
      return;
    }
    var sourceMid = mid$2(source),
      orientation = getOrientation(sourceMid, target, -10),
      axes = [];
    if (/top|bottom/.test(orientation)) {
      axes.push('x');
    }
    if (/left|right/.test(orientation)) {
      axes.push('y');
    }
    axes.forEach(function (axis) {
      var coordinate = event[axis],
        newCoordinate;
      if (abs(coordinate - sourceMid[axis]) < BOUNDARY_TO_HOST_THRESHOLD) {
        if (coordinate > sourceMid[axis]) {
          newCoordinate = sourceMid[axis] + BOUNDARY_TO_HOST_THRESHOLD;
        } else {
          newCoordinate = sourceMid[axis] - BOUNDARY_TO_HOST_THRESHOLD;
        }
        setSnapped(event, axis, newCoordinate);
      }
    });
  }
  function snapToPosition(event, position) {
    setSnapped(event, 'x', position.x);
    setSnapped(event, 'y', position.y);
  }
  function isType(attrs, type) {
    return attrs && attrs.type === type;
  }
  function isAnyType(attrs, types) {
    return some(types, function (type) {
      return isType(attrs, type);
    });
  }
  function getDimensionForAxis(axis, element) {
    return axis === 'x' ? element.width : element.height;
  }
  function getTargetBoundsPadding(target) {
    if (is(target, 'bpmn:Task')) {
      return TASK_BOUNDS_PADDING;
    } else {
      return TARGET_BOUNDS_PADDING;
    }
  }
  function isMid(event, target, axis) {
    return event[axis] > target[axis] + TARGET_CENTER_PADDING && event[axis] < target[axis] + getDimensionForAxis(axis, target) - TARGET_CENTER_PADDING;
  }
  function isReverse(context) {
    var hover = context.hover,
      source = context.source;
    return hover && source && hover === source;
  }
  function SnapContext() {
    this._targets = {};
    this._snapOrigins = {};
    this._snapLocations = [];
    this._defaultSnaps = {};
  }
  SnapContext.prototype.getSnapOrigin = function (snapLocation) {
    return this._snapOrigins[snapLocation];
  };
  SnapContext.prototype.setSnapOrigin = function (snapLocation, snapOrigin) {
    this._snapOrigins[snapLocation] = snapOrigin;
    if (this._snapLocations.indexOf(snapLocation) === -1) {
      this._snapLocations.push(snapLocation);
    }
  };
  SnapContext.prototype.addDefaultSnap = function (snapLocation, point) {
    var snapValues = this._defaultSnaps[snapLocation];
    if (!snapValues) {
      snapValues = this._defaultSnaps[snapLocation] = [];
    }
    snapValues.push(point);
  };
  SnapContext.prototype.getSnapLocations = function () {
    return this._snapLocations;
  };
  SnapContext.prototype.setSnapLocations = function (snapLocations) {
    this._snapLocations = snapLocations;
  };
  SnapContext.prototype.pointsForTarget = function (target) {
    var targetId = target.id || target;
    var snapPoints = this._targets[targetId];
    if (!snapPoints) {
      snapPoints = this._targets[targetId] = new SnapPoints();
      snapPoints.initDefaults(this._defaultSnaps);
    }
    return snapPoints;
  };
  function SnapPoints() {
    this._snapValues = {};
  }
  SnapPoints.prototype.add = function (snapLocation, point) {
    var snapValues = this._snapValues[snapLocation];
    if (!snapValues) {
      snapValues = this._snapValues[snapLocation] = {
        x: [],
        y: []
      };
    }
    if (snapValues.x.indexOf(point.x) === -1) {
      snapValues.x.push(point.x);
    }
    if (snapValues.y.indexOf(point.y) === -1) {
      snapValues.y.push(point.y);
    }
  };
  SnapPoints.prototype.snap = function (point, snapLocation, axis, tolerance) {
    var snappingValues = this._snapValues[snapLocation];
    return snappingValues && snapTo(point[axis], snappingValues[axis], tolerance);
  };
  SnapPoints.prototype.initDefaults = function (defaultSnaps) {
    var self = this;
    forEach$1(defaultSnaps || {}, function (snapPoints, snapLocation) {
      forEach$1(snapPoints, function (point) {
        self.add(snapLocation, point);
      });
    });
  };
  var HIGHER_PRIORITY$1 = 1250;
  function CreateMoveSnapping(elementRegistry, eventBus, snapping) {
    var self = this;
    this._elementRegistry = elementRegistry;
    eventBus.on(['create.start', 'shape.move.start'], function (event) {
      self.initSnap(event);
    });
    eventBus.on(['create.move', 'create.end', 'shape.move.move', 'shape.move.end'], HIGHER_PRIORITY$1, function (event) {
      var context = event.context,
        shape = context.shape,
        snapContext = context.snapContext,
        target = context.target;
      if (event.originalEvent && isCmd(event.originalEvent)) {
        return;
      }
      if (isSnapped(event) || !target) {
        return;
      }
      var snapPoints = snapContext.pointsForTarget(target);
      if (!snapPoints.initialized) {
        snapPoints = self.addSnapTargetPoints(snapPoints, shape, target);
        snapPoints.initialized = true;
      }
      snapping.snap(event, snapPoints);
    });
    eventBus.on(['create.cleanup', 'shape.move.cleanup'], function () {
      snapping.hide();
    });
  }
  CreateMoveSnapping.$inject = ['elementRegistry', 'eventBus', 'snapping'];
  CreateMoveSnapping.prototype.initSnap = function (event) {
    var elementRegistry = this._elementRegistry;
    var context = event.context,
      shape = context.shape,
      snapContext = context.snapContext;
    if (!snapContext) {
      snapContext = context.snapContext = new SnapContext();
    }
    var shapeMid;
    if (elementRegistry.get(shape.id)) {
      shapeMid = mid$2(shape, event);
    } else {
      shapeMid = {
        x: event.x + mid$2(shape).x,
        y: event.y + mid$2(shape).y
      };
    }
    var shapeTopLeft = {
        x: shapeMid.x - shape.width / 2,
        y: shapeMid.y - shape.height / 2
      },
      shapeBottomRight = {
        x: shapeMid.x + shape.width / 2,
        y: shapeMid.y + shape.height / 2
      };
    snapContext.setSnapOrigin('mid', {
      x: shapeMid.x - event.x,
      y: shapeMid.y - event.y
    });
    if (isLabel(shape)) {
      return snapContext;
    }
    snapContext.setSnapOrigin('top-left', {
      x: shapeTopLeft.x - event.x,
      y: shapeTopLeft.y - event.y
    });
    snapContext.setSnapOrigin('bottom-right', {
      x: shapeBottomRight.x - event.x,
      y: shapeBottomRight.y - event.y
    });
    return snapContext;
  };
  CreateMoveSnapping.prototype.addSnapTargetPoints = function (snapPoints, shape, target) {
    var snapTargets = this.getSnapTargets(shape, target);
    forEach$1(snapTargets, function (snapTarget) {
      if (isLabel(snapTarget)) {
        if (isLabel(shape)) {
          snapPoints.add('mid', mid$2(snapTarget));
        }
        return;
      }
      if (isConnection(snapTarget)) {
        if (snapTarget.waypoints.length < 3) {
          return;
        }
        var waypoints = snapTarget.waypoints.slice(1, -1);
        forEach$1(waypoints, function (waypoint) {
          snapPoints.add('mid', waypoint);
        });
        return;
      }
      snapPoints.add('mid', mid$2(snapTarget));
    });
    if (!isNumber(shape.x) || !isNumber(shape.y)) {
      return snapPoints;
    }
    if (this._elementRegistry.get(shape.id)) {
      snapPoints.add('mid', mid$2(shape));
    }
    return snapPoints;
  };
  CreateMoveSnapping.prototype.getSnapTargets = function (shape, target) {
    return getChildren(target).filter(function (child) {
      return !isHidden$1(child);
    });
  };
  function isHidden$1(element) {
    return !!element.hidden;
  }
  var HIGH_PRIORITY = 1500;
  function BpmnCreateMoveSnapping(eventBus, injector) {
    injector.invoke(CreateMoveSnapping, this);
    eventBus.on(['create.move', 'create.end'], HIGH_PRIORITY, setSnappedIfConstrained);
    eventBus.on(['create.move', 'create.end', 'shape.move.move', 'shape.move.end'], HIGH_PRIORITY, function (event) {
      var context = event.context,
        canExecute = context.canExecute,
        target = context.target;
      var canAttach = canExecute && (canExecute === 'attach' || canExecute.attach);
      if (canAttach && !isSnapped(event)) {
        snapBoundaryEvent(event, target);
      }
    });
  }
  e$2(BpmnCreateMoveSnapping, CreateMoveSnapping);
  BpmnCreateMoveSnapping.$inject = ['eventBus', 'injector'];
  BpmnCreateMoveSnapping.prototype.initSnap = function (event) {
    var snapContext = CreateMoveSnapping.prototype.initSnap.call(this, event);
    var shape = event.shape;
    var isMove = !!this._elementRegistry.get(shape.id);
    forEach$1(shape.outgoing, function (connection) {
      var docking = connection.waypoints[0];
      docking = docking.original || docking;
      snapContext.setSnapOrigin(connection.id + '-docking', getDockingSnapOrigin(docking, isMove, event));
    });
    forEach$1(shape.incoming, function (connection) {
      var docking = connection.waypoints[connection.waypoints.length - 1];
      docking = docking.original || docking;
      snapContext.setSnapOrigin(connection.id + '-docking', getDockingSnapOrigin(docking, isMove, event));
    });
    if (is(shape, 'bpmn:Participant')) {
      snapContext.setSnapLocations(['top-left', 'bottom-right', 'mid']);
    }
    return snapContext;
  };
  BpmnCreateMoveSnapping.prototype.addSnapTargetPoints = function (snapPoints, shape, target) {
    CreateMoveSnapping.prototype.addSnapTargetPoints.call(this, snapPoints, shape, target);
    var snapTargets = this.getSnapTargets(shape, target);
    forEach$1(snapTargets, function (snapTarget) {
      if (isContainer(snapTarget) || areAll([shape, snapTarget], 'bpmn:TextAnnotation')) {
        snapPoints.add('top-left', topLeft(snapTarget));
        snapPoints.add('bottom-right', bottomRight(snapTarget));
      }
    });
    var elementRegistry = this._elementRegistry;
    forEach$1(shape.incoming, function (connection) {
      if (elementRegistry.get(shape.id)) {
        if (!includes(snapTargets, connection.source)) {
          snapPoints.add('mid', getMid(connection.source));
        }
        var docking = connection.waypoints[0];
        snapPoints.add(connection.id + '-docking', docking.original || docking);
      }
    });
    forEach$1(shape.outgoing, function (connection) {
      if (elementRegistry.get(shape.id)) {
        if (!includes(snapTargets, connection.target)) {
          snapPoints.add('mid', getMid(connection.target));
        }
        var docking = connection.waypoints[connection.waypoints.length - 1];
        snapPoints.add(connection.id + '-docking', docking.original || docking);
      }
    });
    if (is(target, 'bpmn:SequenceFlow')) {
      snapPoints = this.addSnapTargetPoints(snapPoints, shape, target.parent);
    }
    return snapPoints;
  };
  BpmnCreateMoveSnapping.prototype.getSnapTargets = function (shape, target) {
    return CreateMoveSnapping.prototype.getSnapTargets.call(this, shape, target).filter(function (snapTarget) {
      return !is(snapTarget, 'bpmn:Lane');
    });
  };
  function snapBoundaryEvent(event, target) {
    var targetTRBL = asTRBL(target);
    var direction = getBoundaryAttachment(event, target);
    var context = event.context,
      shape = context.shape;
    var offset;
    if (shape.parent) {
      offset = {
        x: 0,
        y: 0
      };
    } else {
      offset = getMid(shape);
    }
    if (/top/.test(direction)) {
      setSnapped(event, 'y', targetTRBL.top - offset.y);
    } else if (/bottom/.test(direction)) {
      setSnapped(event, 'y', targetTRBL.bottom - offset.y);
    }
    if (/left/.test(direction)) {
      setSnapped(event, 'x', targetTRBL.left - offset.x);
    } else if (/right/.test(direction)) {
      setSnapped(event, 'x', targetTRBL.right - offset.x);
    }
  }
  function areAll(elements, type) {
    return elements.every(function (el) {
      return is(el, type);
    });
  }
  function isContainer(element) {
    if (is(element, 'bpmn:SubProcess') && isExpanded(element)) {
      return true;
    }
    return is(element, 'bpmn:Participant');
  }
  function setSnappedIfConstrained(event) {
    var context = event.context,
      createConstraints = context.createConstraints;
    if (!createConstraints) {
      return;
    }
    var top = createConstraints.top,
      right = createConstraints.right,
      bottom = createConstraints.bottom,
      left = createConstraints.left;
    if (left && left >= event.x || right && right <= event.x) {
      setSnapped(event, 'x', event.x);
    }
    if (top && top >= event.y || bottom && bottom <= event.y) {
      setSnapped(event, 'y', event.y);
    }
  }
  function includes(array, value) {
    return array.indexOf(value) !== -1;
  }
  function getDockingSnapOrigin(docking, isMove, event) {
    return isMove ? {
      x: docking.x - event.x,
      y: docking.y - event.y
    } : {
      x: docking.x,
      y: docking.y
    };
  }
  var HIGHER_PRIORITY = 1250;
  function ResizeSnapping(eventBus, snapping) {
    var self = this;
    eventBus.on(['resize.start'], function (event) {
      self.initSnap(event);
    });
    eventBus.on(['resize.move', 'resize.end'], HIGHER_PRIORITY, function (event) {
      var context = event.context,
        shape = context.shape,
        parent = shape.parent,
        direction = context.direction,
        snapContext = context.snapContext;
      if (event.originalEvent && isCmd(event.originalEvent)) {
        return;
      }
      if (isSnapped(event)) {
        return;
      }
      var snapPoints = snapContext.pointsForTarget(parent);
      if (!snapPoints.initialized) {
        snapPoints = self.addSnapTargetPoints(snapPoints, shape, parent, direction);
        snapPoints.initialized = true;
      }
      if (isHorizontal(direction)) {
        setSnapped(event, 'x', event.x);
      }
      if (isVertical(direction)) {
        setSnapped(event, 'y', event.y);
      }
      snapping.snap(event, snapPoints);
    });
    eventBus.on(['resize.cleanup'], function () {
      snapping.hide();
    });
  }
  ResizeSnapping.prototype.initSnap = function (event) {
    var context = event.context,
      shape = context.shape,
      direction = context.direction,
      snapContext = context.snapContext;
    if (!snapContext) {
      snapContext = context.snapContext = new SnapContext();
    }
    var snapOrigin = getSnapOrigin(shape, direction);
    snapContext.setSnapOrigin('corner', {
      x: snapOrigin.x - event.x,
      y: snapOrigin.y - event.y
    });
    return snapContext;
  };
  ResizeSnapping.prototype.addSnapTargetPoints = function (snapPoints, shape, target, direction) {
    var snapTargets = this.getSnapTargets(shape, target);
    forEach$1(snapTargets, function (snapTarget) {
      snapPoints.add('corner', bottomRight(snapTarget));
      snapPoints.add('corner', topLeft(snapTarget));
    });
    snapPoints.add('corner', getSnapOrigin(shape, direction));
    return snapPoints;
  };
  ResizeSnapping.$inject = ['eventBus', 'snapping'];
  ResizeSnapping.prototype.getSnapTargets = function (shape, target) {
    return getChildren(target).filter(function (child) {
      return !isAttached(child, shape) && !isConnection(child) && !isHidden(child) && !isLabel(child);
    });
  };
  function getSnapOrigin(shape, direction) {
    var mid = getMid(shape),
      trbl = asTRBL(shape);
    var snapOrigin = {
      x: mid.x,
      y: mid.y
    };
    if (direction.indexOf('n') !== -1) {
      snapOrigin.y = trbl.top;
    } else if (direction.indexOf('s') !== -1) {
      snapOrigin.y = trbl.bottom;
    }
    if (direction.indexOf('e') !== -1) {
      snapOrigin.x = trbl.right;
    } else if (direction.indexOf('w') !== -1) {
      snapOrigin.x = trbl.left;
    }
    return snapOrigin;
  }
  function isAttached(element, host) {
    return element.host === host;
  }
  function isHidden(element) {
    return !!element.hidden;
  }
  function isHorizontal(direction) {
    return direction === 'n' || direction === 's';
  }
  function isVertical(direction) {
    return direction === 'e' || direction === 'w';
  }
  var SNAP_TOLERANCE = 7;
  var SNAP_LINE_HIDE_DELAY = 1000;
  function Snapping(canvas) {
    this._canvas = canvas;
    this._asyncHide = debounce(bind$2(this.hide, this), SNAP_LINE_HIDE_DELAY);
  }
  Snapping.$inject = ['canvas'];
  Snapping.prototype.snap = function (event, snapPoints) {
    var context = event.context,
      snapContext = context.snapContext,
      snapLocations = snapContext.getSnapLocations();
    var snapping = {
      x: isSnapped(event, 'x'),
      y: isSnapped(event, 'y')
    };
    forEach$1(snapLocations, function (location) {
      var snapOrigin = snapContext.getSnapOrigin(location);
      var snapCurrent = {
        x: event.x + snapOrigin.x,
        y: event.y + snapOrigin.y
      };
      forEach$1(['x', 'y'], function (axis) {
        var locationSnapping;
        if (!snapping[axis]) {
          locationSnapping = snapPoints.snap(snapCurrent, location, axis, SNAP_TOLERANCE);
          if (locationSnapping !== undefined) {
            snapping[axis] = {
              value: locationSnapping,
              originValue: locationSnapping - snapOrigin[axis]
            };
          }
        }
      });
      if (snapping.x && snapping.y) {
        return false;
      }
    });
    this.showSnapLine('vertical', snapping.x && snapping.x.value);
    this.showSnapLine('horizontal', snapping.y && snapping.y.value);
    forEach$1(['x', 'y'], function (axis) {
      var axisSnapping = snapping[axis];
      if (isObject(axisSnapping)) {
        setSnapped(event, axis, axisSnapping.originValue);
      }
    });
  };
  Snapping.prototype._createLine = function (orientation) {
    var root = this._canvas.getLayer('snap');
    var line = create$1('path');
    attr(line, {
      d: 'M0,0 L0,0'
    });
    classes(line).add('djs-snap-line');
    append(root, line);
    return {
      update: function update(position) {
        if (!isNumber(position)) {
          attr(line, {
            display: 'none'
          });
        } else {
          if (orientation === 'horizontal') {
            attr(line, {
              d: 'M-100000,' + position + ' L+100000,' + position,
              display: ''
            });
          } else {
            attr(line, {
              d: 'M ' + position + ',-100000 L ' + position + ', +100000',
              display: ''
            });
          }
        }
      }
    };
  };
  Snapping.prototype._createSnapLines = function () {
    this._snapLines = {
      horizontal: this._createLine('horizontal'),
      vertical: this._createLine('vertical')
    };
  };
  Snapping.prototype.showSnapLine = function (orientation, position) {
    var line = this.getSnapLine(orientation);
    if (line) {
      line.update(position);
    }
    this._asyncHide();
  };
  Snapping.prototype.getSnapLine = function (orientation) {
    if (!this._snapLines) {
      this._createSnapLines();
    }
    return this._snapLines[orientation];
  };
  Snapping.prototype.hide = function () {
    forEach$1(this._snapLines, function (snapLine) {
      snapLine.update();
    });
  };
  var SnappingModule$1 = {
    __init__: ['createMoveSnapping', 'resizeSnapping', 'snapping'],
    createMoveSnapping: ['type', CreateMoveSnapping],
    resizeSnapping: ['type', ResizeSnapping],
    snapping: ['type', Snapping]
  };
  var SnappingModule = {
    __depends__: [SnappingModule$1],
    __init__: ['connectSnapping', 'createMoveSnapping'],
    connectSnapping: ['type', BpmnConnectSnapping],
    createMoveSnapping: ['type', BpmnCreateMoveSnapping]
  };
  var SCROLL_TO_ELEMENT_PADDING = 300;
  function SearchPad(canvas, eventBus, selection, translate) {
    this._open = false;
    this._results = {};
    this._eventMaps = [];
    this._cachedRootElement = null;
    this._cachedSelection = null;
    this._cachedViewbox = null;
    this._canvas = canvas;
    this._eventBus = eventBus;
    this._selection = selection;
    this._translate = translate;
    this._container = this._getBoxHtml();
    this._searchInput = query(SearchPad.INPUT_SELECTOR, this._container);
    this._resultsContainer = query(SearchPad.RESULTS_CONTAINER_SELECTOR, this._container);
    this._canvas.getContainer().appendChild(this._container);
    eventBus.on(['canvas.destroy', 'diagram.destroy', 'drag.init', 'elements.changed'], this.close, this);
  }
  SearchPad.$inject = ['canvas', 'eventBus', 'selection', 'translate'];
  SearchPad.prototype._bindEvents = function () {
    var self = this;
    function listen(el, selector, type, fn) {
      self._eventMaps.push({
        el: el,
        type: type,
        listener: delegate.bind(el, selector, type, fn)
      });
    }
    listen(document, 'html', 'click', function (e) {
      self.close(false);
    });
    listen(this._container, SearchPad.INPUT_SELECTOR, 'click', function (e) {
      e.stopPropagation();
      e.delegateTarget.focus();
    });
    listen(this._container, SearchPad.RESULT_SELECTOR, 'mouseover', function (e) {
      e.stopPropagation();
      self._scrollToNode(e.delegateTarget);
      self._preselect(e.delegateTarget);
    });
    listen(this._container, SearchPad.RESULT_SELECTOR, 'click', function (e) {
      e.stopPropagation();
      self._select(e.delegateTarget);
    });
    listen(this._container, SearchPad.INPUT_SELECTOR, 'keydown', function (e) {
      if (isKey('ArrowUp', e)) {
        e.preventDefault();
      }
      if (isKey('ArrowDown', e)) {
        e.preventDefault();
      }
    });
    listen(this._container, SearchPad.INPUT_SELECTOR, 'keyup', function (e) {
      if (isKey('Escape', e)) {
        return self.close();
      }
      if (isKey('Enter', e)) {
        var selected = self._getCurrentResult();
        return selected ? self._select(selected) : self.close(false);
      }
      if (isKey('ArrowUp', e)) {
        return self._scrollToDirection(true);
      }
      if (isKey('ArrowDown', e)) {
        return self._scrollToDirection();
      }
      if (isKey(['ArrowLeft', 'ArrowRight'], e)) {
        return;
      }
      self._search(e.delegateTarget.value);
    });
  };
  SearchPad.prototype._unbindEvents = function () {
    this._eventMaps.forEach(function (m) {
      delegate.unbind(m.el, m.type, m.listener);
    });
  };
  SearchPad.prototype._search = function (pattern) {
    var self = this;
    this._clearResults();
    if (!pattern.trim()) {
      return;
    }
    var searchResults = this._searchProvider.find(pattern);
    searchResults = searchResults.filter(function (searchResult) {
      return !self._canvas.getRootElements().includes(searchResult.element);
    });
    if (!searchResults.length) {
      this._selection.select(null);
      return;
    }
    searchResults.forEach(function (result) {
      var id = result.element.id;
      var node = self._createResultNode(result, id);
      self._results[id] = {
        element: result.element,
        node: node
      };
    });
    var node = query(SearchPad.RESULT_SELECTOR, this._resultsContainer);
    this._scrollToNode(node);
    this._preselect(node);
  };
  SearchPad.prototype._scrollToDirection = function (previous) {
    var selected = this._getCurrentResult();
    if (!selected) {
      return;
    }
    var node = previous ? selected.previousElementSibling : selected.nextElementSibling;
    if (node) {
      this._scrollToNode(node);
      this._preselect(node);
    }
  };
  SearchPad.prototype._scrollToNode = function (node) {
    if (!node || node === this._getCurrentResult()) {
      return;
    }
    var nodeOffset = node.offsetTop;
    var containerScroll = this._resultsContainer.scrollTop;
    var bottomScroll = nodeOffset - this._resultsContainer.clientHeight + node.clientHeight;
    if (nodeOffset < containerScroll) {
      this._resultsContainer.scrollTop = nodeOffset;
    } else if (containerScroll < bottomScroll) {
      this._resultsContainer.scrollTop = bottomScroll;
    }
  };
  SearchPad.prototype._clearResults = function () {
    clear$1(this._resultsContainer);
    this._results = {};
    this._eventBus.fire('searchPad.cleared');
  };
  SearchPad.prototype._getCurrentResult = function () {
    return query(SearchPad.RESULT_SELECTED_SELECTOR, this._resultsContainer);
  };
  SearchPad.prototype._createResultNode = function (result, id) {
    var node = domify$1(SearchPad.RESULT_HTML);
    if (result.primaryTokens.length > 0) {
      createInnerTextNode(node, result.primaryTokens, SearchPad.RESULT_PRIMARY_HTML);
    }
    createInnerTextNode(node, result.secondaryTokens, SearchPad.RESULT_SECONDARY_HTML);
    attr$1(node, SearchPad.RESULT_ID_ATTRIBUTE, id);
    this._resultsContainer.appendChild(node);
    return node;
  };
  SearchPad.prototype.registerProvider = function (provider) {
    this._searchProvider = provider;
  };
  SearchPad.prototype.open = function () {
    if (!this._searchProvider) {
      throw new Error('no search provider registered');
    }
    if (this.isOpen()) {
      return;
    }
    this._cachedRootElement = this._canvas.getRootElement();
    this._cachedSelection = this._selection.get();
    this._cachedViewbox = this._canvas.viewbox();
    this._selection.select(null);
    this._bindEvents();
    this._open = true;
    classes$1(this._canvas.getContainer()).add('djs-search-open');
    classes$1(this._container).add('open');
    this._searchInput.focus();
    this._eventBus.fire('searchPad.opened');
  };
  SearchPad.prototype.close = function () {
    var restoreCached = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    if (!this.isOpen()) {
      return;
    }
    if (restoreCached) {
      if (this._cachedRootElement) {
        this._canvas.setRootElement(this._cachedRootElement);
      }
      if (this._cachedSelection) {
        this._selection.select(this._cachedSelection);
      }
      if (this._cachedViewbox) {
        this._canvas.viewbox(this._cachedViewbox);
      }
      this._eventBus.fire('searchPad.restored');
    }
    this._cachedRootElement = null;
    this._cachedSelection = null;
    this._cachedViewbox = null;
    this._unbindEvents();
    this._open = false;
    classes$1(this._canvas.getContainer()).remove('djs-search-open');
    classes$1(this._container).remove('open');
    this._clearResults();
    this._searchInput.value = '';
    this._searchInput.blur();
    this._eventBus.fire('searchPad.closed');
    this._canvas.restoreFocus();
  };
  SearchPad.prototype.toggle = function () {
    this.isOpen() ? this.close() : this.open();
  };
  SearchPad.prototype.isOpen = function () {
    return this._open;
  };
  SearchPad.prototype._preselect = function (node) {
    var selectedNode = this._getCurrentResult();
    if (node === selectedNode) {
      return;
    }
    if (selectedNode) {
      classes$1(selectedNode).remove(SearchPad.RESULT_SELECTED_CLASS);
    }
    var id = attr$1(node, SearchPad.RESULT_ID_ATTRIBUTE);
    var element = this._results[id].element;
    classes$1(node).add(SearchPad.RESULT_SELECTED_CLASS);
    this._canvas.scrollToElement(element, {
      top: SCROLL_TO_ELEMENT_PADDING
    });
    this._selection.select(element);
    this._eventBus.fire('searchPad.preselected', element);
  };
  SearchPad.prototype._select = function (node) {
    var id = attr$1(node, SearchPad.RESULT_ID_ATTRIBUTE);
    var element = this._results[id].element;
    this._cachedSelection = null;
    this._cachedViewbox = null;
    this.close(false);
    this._canvas.scrollToElement(element, {
      top: SCROLL_TO_ELEMENT_PADDING
    });
    this._selection.select(element);
    this._eventBus.fire('searchPad.selected', element);
  };
  SearchPad.prototype._getBoxHtml = function () {
    var box = domify$1(SearchPad.BOX_HTML);
    var input = query(SearchPad.INPUT_SELECTOR, box);
    if (input) {
      input.setAttribute('aria-label', this._translate('Search in diagram'));
    }
    return box;
  };
  function createInnerTextNode(parentNode, tokens, template) {
    var text = createHtmlText(tokens);
    var childNode = domify$1(template);
    childNode.innerHTML = text;
    parentNode.appendChild(childNode);
  }
  function createHtmlText(tokens) {
    var htmlText = '';
    tokens.forEach(function (t) {
      var text = escapeHTML(t.value || t.matched || t.normal);
      var match = t.match || t.matched;
      if (match) {
        htmlText += '<b class="' + SearchPad.RESULT_HIGHLIGHT_CLASS + '">' + text + '</b>';
      } else {
        htmlText += text;
      }
    });
    return htmlText !== '' ? htmlText : null;
  }
  SearchPad.CONTAINER_SELECTOR = '.djs-search-container';
  SearchPad.INPUT_SELECTOR = '.djs-search-input input';
  SearchPad.RESULTS_CONTAINER_SELECTOR = '.djs-search-results';
  SearchPad.RESULT_SELECTOR = '.djs-search-result';
  SearchPad.RESULT_SELECTED_CLASS = 'djs-search-result-selected';
  SearchPad.RESULT_SELECTED_SELECTOR = '.' + SearchPad.RESULT_SELECTED_CLASS;
  SearchPad.RESULT_ID_ATTRIBUTE = 'data-result-id';
  SearchPad.RESULT_HIGHLIGHT_CLASS = 'djs-search-highlight';
  SearchPad.BOX_HTML = `<div class="djs-search-container djs-scrollable">
  <div class="djs-search-input">
    <svg class="djs-search-icon" width="14" height="14" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path fill-rule="evenodd" clip-rule="evenodd" d="M9.0325 8.5H9.625L13.3675 12.25L12.25 13.3675L8.5 9.625V9.0325L8.2975 8.8225C7.4425 9.5575 6.3325 10 5.125 10C2.4325 10 0.25 7.8175 0.25 5.125C0.25 2.4325 2.4325 0.25 5.125 0.25C7.8175 0.25 10 2.4325 10 5.125C10 6.3325 9.5575 7.4425 8.8225 8.2975L9.0325 8.5ZM1.75 5.125C1.75 6.9925 3.2575 8.5 5.125 8.5C6.9925 8.5 8.5 6.9925 8.5 5.125C8.5 3.2575 6.9925 1.75 5.125 1.75C3.2575 1.75 1.75 3.2575 1.75 5.125Z" fill="#22242A"/>
    </svg>
    <input type="text" spellcheck="false" />
  </div>
  <div class="djs-search-results" />
</div>`;
  SearchPad.RESULT_HTML = '<div class="djs-search-result"></div>';
  SearchPad.RESULT_PRIMARY_HTML = '<div class="djs-search-result-primary"></div>';
  SearchPad.RESULT_SECONDARY_HTML = '<p class="djs-search-result-secondary"></p>';
  var SearchPadModule = {
    __depends__: [TranslateModule, OverlaysModule, SelectionModule],
    searchPad: ['type', SearchPad]
  };
  function BpmnSearchProvider(elementRegistry, searchPad, canvas, search) {
    this._elementRegistry = elementRegistry;
    this._canvas = canvas;
    this._search = search;
    searchPad.registerProvider(this);
  }
  BpmnSearchProvider.$inject = ['elementRegistry', 'searchPad', 'canvas', 'search'];
  BpmnSearchProvider.prototype.find = function (pattern) {
    var rootElements = this._canvas.getRootElements();
    var elements = this._elementRegistry.filter(function (element) {
      return !isLabel(element) && !rootElements.includes(element);
    });
    return this._search(elements.map(function (element) {
      return {
        element,
        label: getLabel(element),
        id: element.id
      };
    }), pattern, {
      keys: ['label', 'id']
    }).map(toSearchPadResult);
  };
  function toSearchPadResult(result) {
    var element = result.item.element,
      tokens = result.tokens;
    return {
      element,
      primaryTokens: tokens.label,
      secondaryTokens: tokens.id
    };
  }
  var SearchModule = {
    __depends__: [SearchPadModule, SearchModule$1],
    __init__: ['bpmnSearch'],
    bpmnSearch: ['type', BpmnSearchProvider]
  };
  var DATA_OBJECT_REFERENCE_OUTLINE_PATH = 'M44.7648 11.3263L36.9892 2.64074C36.0451 1.58628 34.5651 0.988708 33.1904 0.988708H5.98667C3.22688 0.988708 0.989624 3.34892 0.989624 6.26039V55.0235C0.989624 57.9349 3.22688 60.2952 5.98667 60.2952H40.966C43.7257 60.2952 45.963 57.9349 45.963 55.0235V14.9459C45.963 13.5998 45.6407 12.3048 44.7648 11.3263Z';
  var DATA_STORE_REFERENCE_OUTLINE_PATH = 'M1.03845 48.1347C1.03845 49.3511 1.07295 50.758 1.38342 52.064C1.69949 53.3938 2.32428 54.7154 3.56383 55.6428C6.02533 57.4841 10.1161 58.7685 14.8212 59.6067C19.5772 60.4538 25.1388 60.8738 30.6831 60.8738C36.2276 60.8738 41.7891 60.4538 46.545 59.6067C51.2504 58.7687 55.3412 57.4842 57.8028 55.6429C59.0424 54.7156 59.6673 53.3938 59.9834 52.064C60.2938 50.7579 60.3285 49.351 60.3285 48.1344V13.8415C60.3285 12.6249 60.2938 11.218 59.9834 9.91171C59.6673 8.58194 59.0423 7.2602 57.8027 6.33294C55.341 4.49168 51.2503 3.20723 46.545 2.36914C41.7891 1.522 36.2276 1.10204 30.6831 1.10205C25.1388 1.10206 19.5772 1.52206 14.8213 2.36923C10.1162 3.20734 6.02543 4.49183 3.5639 6.33314C2.32433 7.26038 1.69951 8.58206 1.38343 9.91181C1.07295 11.2179 1.03845 12.6247 1.03845 13.8411V48.1347Z';
  var DATA_OBJECT_REFERENCE_STANDARD_SIZE = {
    width: 36,
    height: 50
  };
  var DATA_STORE_REFERENCE_STANDARD_SIZE = {
    width: 50,
    height: 50
  };
  function createPath(path, attrs, OUTLINE_STYLE) {
    return create$1('path', _objectSpread({
      d: path,
      strokeWidth: 2,
      transform: `translate(${attrs.x}, ${attrs.y})`
    }, OUTLINE_STYLE));
  }
  var DEFAULT_OFFSET = 5;
  function OutlineProvider(outline, styles) {
    this._styles = styles;
    outline.registerProvider(this);
  }
  OutlineProvider.$inject = ['outline', 'styles'];
  OutlineProvider.prototype.getOutline = function (element) {
    var OUTLINE_STYLE = this._styles.cls('djs-outline', ['no-fill']);
    var outline;
    if (isLabel(element)) {
      return;
    }
    if (is(element, 'bpmn:Gateway')) {
      outline = create$1('rect');
      assign$1(outline.style, {
        'transform-box': 'fill-box',
        'transform': 'rotate(45deg)',
        'transform-origin': 'center'
      });
      attr(outline, assign$1({
        x: 2,
        y: 2,
        rx: 4,
        width: element.width - 4,
        height: element.height - 4
      }, OUTLINE_STYLE));
    } else if (isAny(element, ['bpmn:Task', 'bpmn:SubProcess', 'bpmn:Group', 'bpmn:CallActivity'])) {
      outline = create$1('rect');
      attr(outline, assign$1({
        x: -5,
        y: -5,
        rx: 14,
        width: element.width + DEFAULT_OFFSET * 2,
        height: element.height + DEFAULT_OFFSET * 2
      }, OUTLINE_STYLE));
    } else if (is(element, 'bpmn:EndEvent')) {
      outline = create$1('circle');
      attr(outline, assign$1({
        cx: element.width / 2,
        cy: element.height / 2,
        r: element.width / 2 + DEFAULT_OFFSET + 1
      }, OUTLINE_STYLE));
    } else if (is(element, 'bpmn:Event')) {
      outline = create$1('circle');
      attr(outline, assign$1({
        cx: element.width / 2,
        cy: element.height / 2,
        r: element.width / 2 + DEFAULT_OFFSET
      }, OUTLINE_STYLE));
    } else if (is(element, 'bpmn:DataObjectReference') && isStandardSize(element, 'bpmn:DataObjectReference')) {
      outline = createPath(DATA_OBJECT_REFERENCE_OUTLINE_PATH, {
        x: -6,
        y: -6
      }, OUTLINE_STYLE);
    } else if (is(element, 'bpmn:DataStoreReference') && isStandardSize(element, 'bpmn:DataStoreReference')) {
      outline = createPath(DATA_STORE_REFERENCE_OUTLINE_PATH, {
        x: -6,
        y: -6
      }, OUTLINE_STYLE);
    }
    return outline;
  };
  OutlineProvider.prototype.updateOutline = function (element, outline) {
    if (isLabel(element)) {
      return;
    }
    if (isAny(element, ['bpmn:SubProcess', 'bpmn:Group'])) {
      attr(outline, {
        width: element.width + DEFAULT_OFFSET * 2,
        height: element.height + DEFAULT_OFFSET * 2
      });
      return true;
    } else if (isAny(element, ['bpmn:Event', 'bpmn:Gateway', 'bpmn:DataStoreReference', 'bpmn:DataObjectReference'])) {
      return true;
    }
    return false;
  };
  function isStandardSize(element, type) {
    var standardSize;
    if (type === 'bpmn:DataObjectReference') {
      standardSize = DATA_OBJECT_REFERENCE_STANDARD_SIZE;
    } else if (type === 'bpmn:DataStoreReference') {
      standardSize = DATA_STORE_REFERENCE_STANDARD_SIZE;
    }
    return element.width === standardSize.width && element.height === standardSize.height;
  }
  var OutlineModule = {
    __depends__: [Ouline],
    __init__: ['outlineProvider'],
    outlineProvider: ['type', OutlineProvider]
  };
  var initialDiagram = '<?xml version="1.0" encoding="UTF-8"?>' + '<bpmn:definitions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" ' + 'xmlns:bpmn="http://www.omg.org/spec/BPMN/20100524/MODEL" ' + 'xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI" ' + 'xmlns:dc="http://www.omg.org/spec/DD/20100524/DC" ' + 'targetNamespace="http://bpmn.io/schema/bpmn" ' + 'id="Definitions_1">' + '<bpmn:process id="Process_1" isExecutable="false">' + '<bpmn:startEvent id="StartEvent_1"/>' + '</bpmn:process>' + '<bpmndi:BPMNDiagram id="BPMNDiagram_1">' + '<bpmndi:BPMNPlane id="BPMNPlane_1" bpmnElement="Process_1">' + '<bpmndi:BPMNShape id="_BPMNShape_StartEvent_2" bpmnElement="StartEvent_1">' + '<dc:Bounds height="36.0" width="36.0" x="173.0" y="102.0"/>' + '</bpmndi:BPMNShape>' + '</bpmndi:BPMNPlane>' + '</bpmndi:BPMNDiagram>' + '</bpmn:definitions>';
  function Modeler(options) {
    BaseModeler.call(this, options);
  }
  e$2(Modeler, BaseModeler);
  Modeler.Viewer = Viewer;
  Modeler.NavigatedViewer = NavigatedViewer;
  Modeler.prototype.createDiagram = function createDiagram() {
    return this.importXML(initialDiagram);
  };
  Modeler.prototype._interactionModules = [KeyboardMoveModule, MoveCanvasModule, ZoomScrollModule];
  Modeler.prototype._modelingModules = [AlignElementsModule, AutoPlaceModule, AutoScrollModule, AutoResizeModule, BendpointsModule, ConnectModule, ConnectionPreviewModule, ContextPadModule, CopyPasteModule, CreateModule, DistributeElementsModule, EditorActionsModule, GridSnappingModule, InteractionEventsModule, KeyboardModule, KeyboardMoveSelectionModule, LabelEditingModule, ModelingModule, ModelingFeedbackModule, MoveModule, PaletteModule, ReplacePreviewModule, ResizeModule, SnappingModule, SearchModule, OutlineModule];
  Modeler.prototype._modules = [].concat(Viewer.prototype._modules, Modeler.prototype._interactionModules, Modeler.prototype._modelingModules);
  return Modeler;
});

/*!
 * jQuery JavaScript Library v3.3.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2018-01-20T17:24Z
 */
(function (global, factory) {
  "use strict";

  if (typeof module === "object" && typeof module.exports === "object") {
    module.exports = global.document ? factory(global, true) : function (w) {
      if (!w.document) {
        throw new Error("jQuery requires a window with a document");
      }
      return factory(w);
    };
  } else {
    factory(global);
  }
})(typeof window !== "undefined" ? window : this, function (window, noGlobal) {
  "use strict";

  var arr = [];
  var document = window.document;
  var getProto = Object.getPrototypeOf;
  var _slice = arr.slice;
  var concat = arr.concat;
  var push = arr.push;
  var indexOf = arr.indexOf;
  var class2type = {};
  var toString = class2type.toString;
  var hasOwn = class2type.hasOwnProperty;
  var fnToString = hasOwn.toString;
  var ObjectFunctionString = fnToString.call(Object);
  var support = {};
  var isFunction = function isFunction(obj) {
    return typeof obj === "function" && typeof obj.nodeType !== "number";
  };
  var isWindow = function isWindow(obj) {
    return obj != null && obj === obj.window;
  };
  var preservedScriptAttributes = {
    type: true,
    src: true,
    noModule: true
  };
  function DOMEval(code, doc, node) {
    doc = doc || document;
    var i,
      script = doc.createElement("script");
    script.text = code;
    if (node) {
      for (i in preservedScriptAttributes) {
        if (node[i]) {
          script[i] = node[i];
        }
      }
    }
    doc.head.appendChild(script).parentNode.removeChild(script);
  }
  function toType(obj) {
    if (obj == null) {
      return obj + "";
    }
    return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
  }
  var version = "3.3.1",
    _jQuery2 = function jQuery(selector, context) {
      return new _jQuery2.fn.init(selector, context);
    },
    rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
  _jQuery2.fn = _jQuery2.prototype = {
    jquery: version,
    constructor: _jQuery2,
    length: 0,
    toArray: function toArray() {
      return _slice.call(this);
    },
    get: function get(num) {
      if (num == null) {
        return _slice.call(this);
      }
      return num < 0 ? this[num + this.length] : this[num];
    },
    pushStack: function pushStack(elems) {
      var ret = _jQuery2.merge(this.constructor(), elems);
      ret.prevObject = this;
      return ret;
    },
    each: function each(callback) {
      return _jQuery2.each(this, callback);
    },
    map: function map(callback) {
      return this.pushStack(_jQuery2.map(this, function (elem, i) {
        return callback.call(elem, i, elem);
      }));
    },
    slice: function slice() {
      return this.pushStack(_slice.apply(this, arguments));
    },
    first: function first() {
      return this.eq(0);
    },
    last: function last() {
      return this.eq(-1);
    },
    eq: function eq(i) {
      var len = this.length,
        j = +i + (i < 0 ? len : 0);
      return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
    },
    end: function end() {
      return this.prevObject || this.constructor();
    },
    push: push,
    sort: arr.sort,
    splice: arr.splice
  };
  _jQuery2.extend = _jQuery2.fn.extend = function () {
    var options,
      name,
      src,
      copy,
      copyIsArray,
      clone,
      target = arguments[0] || {},
      i = 1,
      length = arguments.length,
      deep = false;
    if (typeof target === "boolean") {
      deep = target;
      target = arguments[i] || {};
      i++;
    }
    if (typeof target !== "object" && !isFunction(target)) {
      target = {};
    }
    if (i === length) {
      target = this;
      i--;
    }
    for (; i < length; i++) {
      if ((options = arguments[i]) != null) {
        for (name in options) {
          src = target[name];
          copy = options[name];
          if (target === copy) {
            continue;
          }
          if (deep && copy && (_jQuery2.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && Array.isArray(src) ? src : [];
            } else {
              clone = src && _jQuery2.isPlainObject(src) ? src : {};
            }
            target[name] = _jQuery2.extend(deep, clone, copy);
          } else if (copy !== undefined) {
            target[name] = copy;
          }
        }
      }
    }
    return target;
  };
  _jQuery2.extend({
    expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
    isReady: true,
    error: function error(msg) {
      throw new Error(msg);
    },
    noop: function noop() {},
    isPlainObject: function isPlainObject(obj) {
      var proto, Ctor;
      if (!obj || toString.call(obj) !== "[object Object]") {
        return false;
      }
      proto = getProto(obj);
      if (!proto) {
        return true;
      }
      Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
      return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
    },
    isEmptyObject: function isEmptyObject(obj) {
      var name;
      for (name in obj) {
        return false;
      }
      return true;
    },
    globalEval: function globalEval(code) {
      DOMEval(code);
    },
    each: function each(obj, callback) {
      var length,
        i = 0;
      if (isArrayLike(obj)) {
        length = obj.length;
        for (; i < length; i++) {
          if (callback.call(obj[i], i, obj[i]) === false) {
            break;
          }
        }
      } else {
        for (i in obj) {
          if (callback.call(obj[i], i, obj[i]) === false) {
            break;
          }
        }
      }
      return obj;
    },
    trim: function trim(text) {
      return text == null ? "" : (text + "").replace(rtrim, "");
    },
    makeArray: function makeArray(arr, results) {
      var ret = results || [];
      if (arr != null) {
        if (isArrayLike(Object(arr))) {
          _jQuery2.merge(ret, typeof arr === "string" ? [arr] : arr);
        } else {
          push.call(ret, arr);
        }
      }
      return ret;
    },
    inArray: function inArray(elem, arr, i) {
      return arr == null ? -1 : indexOf.call(arr, elem, i);
    },
    merge: function merge(first, second) {
      var len = +second.length,
        j = 0,
        i = first.length;
      for (; j < len; j++) {
        first[i++] = second[j];
      }
      first.length = i;
      return first;
    },
    grep: function grep(elems, callback, invert) {
      var callbackInverse,
        matches = [],
        i = 0,
        length = elems.length,
        callbackExpect = !invert;
      for (; i < length; i++) {
        callbackInverse = !callback(elems[i], i);
        if (callbackInverse !== callbackExpect) {
          matches.push(elems[i]);
        }
      }
      return matches;
    },
    map: function map(elems, callback, arg) {
      var length,
        value,
        i = 0,
        ret = [];
      if (isArrayLike(elems)) {
        length = elems.length;
        for (; i < length; i++) {
          value = callback(elems[i], i, arg);
          if (value != null) {
            ret.push(value);
          }
        }
      } else {
        for (i in elems) {
          value = callback(elems[i], i, arg);
          if (value != null) {
            ret.push(value);
          }
        }
      }
      return concat.apply([], ret);
    },
    guid: 1,
    support: support
  });
  if (typeof Symbol === "function") {
    _jQuery2.fn[Symbol.iterator] = arr[Symbol.iterator];
  }
  _jQuery2.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (i, name) {
    class2type["[object " + name + "]"] = name.toLowerCase();
  });
  function isArrayLike(obj) {
    var length = !!obj && "length" in obj && obj.length,
      type = toType(obj);
    if (isFunction(obj) || isWindow(obj)) {
      return false;
    }
    return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
  }
  var Sizzle =
  /*!
   * Sizzle CSS Selector Engine v2.3.3
   * https://sizzlejs.com/
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license
   * http://jquery.org/license
   *
   * Date: 2016-08-08
   */
  function (window) {
    var i,
      support,
      Expr,
      getText,
      isXML,
      tokenize,
      compile,
      select,
      outermostContext,
      sortInput,
      hasDuplicate,
      setDocument,
      document,
      docElem,
      documentIsHTML,
      rbuggyQSA,
      rbuggyMatches,
      matches,
      contains,
      expando = "sizzle" + 1 * new Date(),
      preferredDoc = window.document,
      dirruns = 0,
      done = 0,
      classCache = createCache(),
      tokenCache = createCache(),
      compilerCache = createCache(),
      sortOrder = function sortOrder(a, b) {
        if (a === b) {
          hasDuplicate = true;
        }
        return 0;
      },
      hasOwn = {}.hasOwnProperty,
      arr = [],
      pop = arr.pop,
      push_native = arr.push,
      push = arr.push,
      slice = arr.slice,
      indexOf = function indexOf(list, elem) {
        var i = 0,
          len = list.length;
        for (; i < len; i++) {
          if (list[i] === elem) {
            return i;
          }
        }
        return -1;
      },
      booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
      whitespace = "[\\x20\\t\\r\\n\\f]",
      identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",
      attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
      pseudos = ":(" + identifier + ")(?:\\((" + "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + ".*" + ")\\)|)",
      rwhitespace = new RegExp(whitespace + "+", "g"),
      rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
      rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
      rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
      rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),
      rpseudo = new RegExp(pseudos),
      ridentifier = new RegExp("^" + identifier + "$"),
      matchExpr = {
        "ID": new RegExp("^#(" + identifier + ")"),
        "CLASS": new RegExp("^\\.(" + identifier + ")"),
        "TAG": new RegExp("^(" + identifier + "|[*])"),
        "ATTR": new RegExp("^" + attributes),
        "PSEUDO": new RegExp("^" + pseudos),
        "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
        "bool": new RegExp("^(?:" + booleans + ")$", "i"),
        "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
      },
      rinputs = /^(?:input|select|textarea|button)$/i,
      rheader = /^h\d$/i,
      rnative = /^[^{]+\{\s*\[native \w/,
      rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
      rsibling = /[+~]/,
      runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
      funescape = function funescape(_, escaped, escapedWhitespace) {
        var high = "0x" + escaped - 0x10000;
        return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 0x10000) : String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
      },
      rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
      fcssescape = function fcssescape(ch, asCodePoint) {
        if (asCodePoint) {
          if (ch === "\0") {
            return "\uFFFD";
          }
          return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
        }
        return "\\" + ch;
      },
      unloadHandler = function unloadHandler() {
        setDocument();
      },
      disabledAncestor = addCombinator(function (elem) {
        return elem.disabled === true && ("form" in elem || "label" in elem);
      }, {
        dir: "parentNode",
        next: "legend"
      });
    try {
      push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
      arr[preferredDoc.childNodes.length].nodeType;
    } catch (e) {
      push = {
        apply: arr.length ? function (target, els) {
          push_native.apply(target, slice.call(els));
        } : function (target, els) {
          var j = target.length,
            i = 0;
          while (target[j++] = els[i++]) {}
          target.length = j - 1;
        }
      };
    }
    function Sizzle(selector, context, results, seed) {
      var m,
        i,
        elem,
        nid,
        match,
        groups,
        newSelector,
        newContext = context && context.ownerDocument,
        nodeType = context ? context.nodeType : 9;
      results = results || [];
      if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
        return results;
      }
      if (!seed) {
        if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
          setDocument(context);
        }
        context = context || document;
        if (documentIsHTML) {
          if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
            if (m = match[1]) {
              if (nodeType === 9) {
                if (elem = context.getElementById(m)) {
                  if (elem.id === m) {
                    results.push(elem);
                    return results;
                  }
                } else {
                  return results;
                }
              } else {
                if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                  results.push(elem);
                  return results;
                }
              }
            } else if (match[2]) {
              push.apply(results, context.getElementsByTagName(selector));
              return results;
            } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
              push.apply(results, context.getElementsByClassName(m));
              return results;
            }
          }
          if (support.qsa && !compilerCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
            if (nodeType !== 1) {
              newContext = context;
              newSelector = selector;
            } else if (context.nodeName.toLowerCase() !== "object") {
              if (nid = context.getAttribute("id")) {
                nid = nid.replace(rcssescape, fcssescape);
              } else {
                context.setAttribute("id", nid = expando);
              }
              groups = tokenize(selector);
              i = groups.length;
              while (i--) {
                groups[i] = "#" + nid + " " + toSelector(groups[i]);
              }
              newSelector = groups.join(",");
              newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
            }
            if (newSelector) {
              try {
                push.apply(results, newContext.querySelectorAll(newSelector));
                return results;
              } catch (qsaError) {} finally {
                if (nid === expando) {
                  context.removeAttribute("id");
                }
              }
            }
          }
        }
      }
      return select(selector.replace(rtrim, "$1"), context, results, seed);
    }
    function createCache() {
      var keys = [];
      function cache(key, value) {
        if (keys.push(key + " ") > Expr.cacheLength) {
          delete cache[keys.shift()];
        }
        return cache[key + " "] = value;
      }
      return cache;
    }
    function markFunction(fn) {
      fn[expando] = true;
      return fn;
    }
    function assert(fn) {
      var el = document.createElement("fieldset");
      try {
        return !!fn(el);
      } catch (e) {
        return false;
      } finally {
        if (el.parentNode) {
          el.parentNode.removeChild(el);
        }
        el = null;
      }
    }
    function addHandle(attrs, handler) {
      var arr = attrs.split("|"),
        i = arr.length;
      while (i--) {
        Expr.attrHandle[arr[i]] = handler;
      }
    }
    function siblingCheck(a, b) {
      var cur = b && a,
        diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex;
      if (diff) {
        return diff;
      }
      if (cur) {
        while (cur = cur.nextSibling) {
          if (cur === b) {
            return -1;
          }
        }
      }
      return a ? 1 : -1;
    }
    function createInputPseudo(type) {
      return function (elem) {
        var name = elem.nodeName.toLowerCase();
        return name === "input" && elem.type === type;
      };
    }
    function createButtonPseudo(type) {
      return function (elem) {
        var name = elem.nodeName.toLowerCase();
        return (name === "input" || name === "button") && elem.type === type;
      };
    }
    function createDisabledPseudo(disabled) {
      return function (elem) {
        if ("form" in elem) {
          if (elem.parentNode && elem.disabled === false) {
            if ("label" in elem) {
              if ("label" in elem.parentNode) {
                return elem.parentNode.disabled === disabled;
              } else {
                return elem.disabled === disabled;
              }
            }
            return elem.isDisabled === disabled || elem.isDisabled !== !disabled && disabledAncestor(elem) === disabled;
          }
          return elem.disabled === disabled;
        } else if ("label" in elem) {
          return elem.disabled === disabled;
        }
        return false;
      };
    }
    function createPositionalPseudo(fn) {
      return markFunction(function (argument) {
        argument = +argument;
        return markFunction(function (seed, matches) {
          var j,
            matchIndexes = fn([], seed.length, argument),
            i = matchIndexes.length;
          while (i--) {
            if (seed[j = matchIndexes[i]]) {
              seed[j] = !(matches[j] = seed[j]);
            }
          }
        });
      });
    }
    function testContext(context) {
      return context && typeof context.getElementsByTagName !== "undefined" && context;
    }
    support = Sizzle.support = {};
    isXML = Sizzle.isXML = function (elem) {
      var documentElement = elem && (elem.ownerDocument || elem).documentElement;
      return documentElement ? documentElement.nodeName !== "HTML" : false;
    };
    setDocument = Sizzle.setDocument = function (node) {
      var hasCompare,
        subWindow,
        doc = node ? node.ownerDocument || node : preferredDoc;
      if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
        return document;
      }
      document = doc;
      docElem = document.documentElement;
      documentIsHTML = !isXML(document);
      if (preferredDoc !== document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {
        if (subWindow.addEventListener) {
          subWindow.addEventListener("unload", unloadHandler, false);
        } else if (subWindow.attachEvent) {
          subWindow.attachEvent("onunload", unloadHandler);
        }
      }
      support.attributes = assert(function (el) {
        el.className = "i";
        return !el.getAttribute("className");
      });
      support.getElementsByTagName = assert(function (el) {
        el.appendChild(document.createComment(""));
        return !el.getElementsByTagName("*").length;
      });
      support.getElementsByClassName = rnative.test(document.getElementsByClassName);
      support.getById = assert(function (el) {
        docElem.appendChild(el).id = expando;
        return !document.getElementsByName || !document.getElementsByName(expando).length;
      });
      if (support.getById) {
        Expr.filter["ID"] = function (id) {
          var attrId = id.replace(runescape, funescape);
          return function (elem) {
            return elem.getAttribute("id") === attrId;
          };
        };
        Expr.find["ID"] = function (id, context) {
          if (typeof context.getElementById !== "undefined" && documentIsHTML) {
            var elem = context.getElementById(id);
            return elem ? [elem] : [];
          }
        };
      } else {
        Expr.filter["ID"] = function (id) {
          var attrId = id.replace(runescape, funescape);
          return function (elem) {
            var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
            return node && node.value === attrId;
          };
        };
        Expr.find["ID"] = function (id, context) {
          if (typeof context.getElementById !== "undefined" && documentIsHTML) {
            var node,
              i,
              elems,
              elem = context.getElementById(id);
            if (elem) {
              node = elem.getAttributeNode("id");
              if (node && node.value === id) {
                return [elem];
              }
              elems = context.getElementsByName(id);
              i = 0;
              while (elem = elems[i++]) {
                node = elem.getAttributeNode("id");
                if (node && node.value === id) {
                  return [elem];
                }
              }
            }
            return [];
          }
        };
      }
      Expr.find["TAG"] = support.getElementsByTagName ? function (tag, context) {
        if (typeof context.getElementsByTagName !== "undefined") {
          return context.getElementsByTagName(tag);
        } else if (support.qsa) {
          return context.querySelectorAll(tag);
        }
      } : function (tag, context) {
        var elem,
          tmp = [],
          i = 0,
          results = context.getElementsByTagName(tag);
        if (tag === "*") {
          while (elem = results[i++]) {
            if (elem.nodeType === 1) {
              tmp.push(elem);
            }
          }
          return tmp;
        }
        return results;
      };
      Expr.find["CLASS"] = support.getElementsByClassName && function (className, context) {
        if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
          return context.getElementsByClassName(className);
        }
      };
      rbuggyMatches = [];
      rbuggyQSA = [];
      if (support.qsa = rnative.test(document.querySelectorAll)) {
        assert(function (el) {
          docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>";
          if (el.querySelectorAll("[msallowcapture^='']").length) {
            rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
          }
          if (!el.querySelectorAll("[selected]").length) {
            rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
          }
          if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
            rbuggyQSA.push("~=");
          }
          if (!el.querySelectorAll(":checked").length) {
            rbuggyQSA.push(":checked");
          }
          if (!el.querySelectorAll("a#" + expando + "+*").length) {
            rbuggyQSA.push(".#.+[+~]");
          }
        });
        assert(function (el) {
          el.innerHTML = "<a href='' disabled='disabled'></a>" + "<select disabled='disabled'><option/></select>";
          var input = document.createElement("input");
          input.setAttribute("type", "hidden");
          el.appendChild(input).setAttribute("name", "D");
          if (el.querySelectorAll("[name=d]").length) {
            rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
          }
          if (el.querySelectorAll(":enabled").length !== 2) {
            rbuggyQSA.push(":enabled", ":disabled");
          }
          docElem.appendChild(el).disabled = true;
          if (el.querySelectorAll(":disabled").length !== 2) {
            rbuggyQSA.push(":enabled", ":disabled");
          }
          el.querySelectorAll("*,:x");
          rbuggyQSA.push(",.*:");
        });
      }
      if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
        assert(function (el) {
          support.disconnectedMatch = matches.call(el, "*");
          matches.call(el, "[s!='']:x");
          rbuggyMatches.push("!=", pseudos);
        });
      }
      rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
      rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
      hasCompare = rnative.test(docElem.compareDocumentPosition);
      contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
        var adown = a.nodeType === 9 ? a.documentElement : a,
          bup = b && b.parentNode;
        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
      } : function (a, b) {
        if (b) {
          while (b = b.parentNode) {
            if (b === a) {
              return true;
            }
          }
        }
        return false;
      };
      sortOrder = hasCompare ? function (a, b) {
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
        if (compare) {
          return compare;
        }
        compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
        if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
          if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
            return -1;
          }
          if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
            return 1;
          }
          return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
        }
        return compare & 4 ? -1 : 1;
      } : function (a, b) {
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        var cur,
          i = 0,
          aup = a.parentNode,
          bup = b.parentNode,
          ap = [a],
          bp = [b];
        if (!aup || !bup) {
          return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
        } else if (aup === bup) {
          return siblingCheck(a, b);
        }
        cur = a;
        while (cur = cur.parentNode) {
          ap.unshift(cur);
        }
        cur = b;
        while (cur = cur.parentNode) {
          bp.unshift(cur);
        }
        while (ap[i] === bp[i]) {
          i++;
        }
        return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
      };
      return document;
    };
    Sizzle.matches = function (expr, elements) {
      return Sizzle(expr, null, null, elements);
    };
    Sizzle.matchesSelector = function (elem, expr) {
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      }
      expr = expr.replace(rattributeQuotes, "='$1']");
      if (support.matchesSelector && documentIsHTML && !compilerCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
        try {
          var ret = matches.call(elem, expr);
          if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
            return ret;
          }
        } catch (e) {}
      }
      return Sizzle(expr, document, null, [elem]).length > 0;
    };
    Sizzle.contains = function (context, elem) {
      if ((context.ownerDocument || context) !== document) {
        setDocument(context);
      }
      return contains(context, elem);
    };
    Sizzle.attr = function (elem, name) {
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      }
      var fn = Expr.attrHandle[name.toLowerCase()],
        val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
      return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
    };
    Sizzle.escape = function (sel) {
      return (sel + "").replace(rcssescape, fcssescape);
    };
    Sizzle.error = function (msg) {
      throw new Error("Syntax error, unrecognized expression: " + msg);
    };
    Sizzle.uniqueSort = function (results) {
      var elem,
        duplicates = [],
        j = 0,
        i = 0;
      hasDuplicate = !support.detectDuplicates;
      sortInput = !support.sortStable && results.slice(0);
      results.sort(sortOrder);
      if (hasDuplicate) {
        while (elem = results[i++]) {
          if (elem === results[i]) {
            j = duplicates.push(i);
          }
        }
        while (j--) {
          results.splice(duplicates[j], 1);
        }
      }
      sortInput = null;
      return results;
    };
    getText = Sizzle.getText = function (elem) {
      var node,
        ret = "",
        i = 0,
        nodeType = elem.nodeType;
      if (!nodeType) {
        while (node = elem[i++]) {
          ret += getText(node);
        }
      } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
        if (typeof elem.textContent === "string") {
          return elem.textContent;
        } else {
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            ret += getText(elem);
          }
        }
      } else if (nodeType === 3 || nodeType === 4) {
        return elem.nodeValue;
      }
      return ret;
    };
    Expr = Sizzle.selectors = {
      cacheLength: 50,
      createPseudo: markFunction,
      match: matchExpr,
      attrHandle: {},
      find: {},
      relative: {
        ">": {
          dir: "parentNode",
          first: true
        },
        " ": {
          dir: "parentNode"
        },
        "+": {
          dir: "previousSibling",
          first: true
        },
        "~": {
          dir: "previousSibling"
        }
      },
      preFilter: {
        "ATTR": function ATTR(match) {
          match[1] = match[1].replace(runescape, funescape);
          match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
          if (match[2] === "~=") {
            match[3] = " " + match[3] + " ";
          }
          return match.slice(0, 4);
        },
        "CHILD": function CHILD(match) {
          match[1] = match[1].toLowerCase();
          if (match[1].slice(0, 3) === "nth") {
            if (!match[3]) {
              Sizzle.error(match[0]);
            }
            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
            match[5] = +(match[7] + match[8] || match[3] === "odd");
          } else if (match[3]) {
            Sizzle.error(match[0]);
          }
          return match;
        },
        "PSEUDO": function PSEUDO(match) {
          var excess,
            unquoted = !match[6] && match[2];
          if (matchExpr["CHILD"].test(match[0])) {
            return null;
          }
          if (match[3]) {
            match[2] = match[4] || match[5] || "";
          } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
            match[0] = match[0].slice(0, excess);
            match[2] = unquoted.slice(0, excess);
          }
          return match.slice(0, 3);
        }
      },
      filter: {
        "TAG": function TAG(nodeNameSelector) {
          var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
          return nodeNameSelector === "*" ? function () {
            return true;
          } : function (elem) {
            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
          };
        },
        "CLASS": function CLASS(className) {
          var pattern = classCache[className + " "];
          return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function (elem) {
            return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
          });
        },
        "ATTR": function ATTR(name, operator, check) {
          return function (elem) {
            var result = Sizzle.attr(elem, name);
            if (result == null) {
              return operator === "!=";
            }
            if (!operator) {
              return true;
            }
            result += "";
            return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
          };
        },
        "CHILD": function CHILD(type, what, argument, first, last) {
          var simple = type.slice(0, 3) !== "nth",
            forward = type.slice(-4) !== "last",
            ofType = what === "of-type";
          return first === 1 && last === 0 ? function (elem) {
            return !!elem.parentNode;
          } : function (elem, context, xml) {
            var cache,
              uniqueCache,
              outerCache,
              node,
              nodeIndex,
              start,
              dir = simple !== forward ? "nextSibling" : "previousSibling",
              parent = elem.parentNode,
              name = ofType && elem.nodeName.toLowerCase(),
              useCache = !xml && !ofType,
              diff = false;
            if (parent) {
              if (simple) {
                while (dir) {
                  node = elem;
                  while (node = node[dir]) {
                    if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                      return false;
                    }
                  }
                  start = dir = type === "only" && !start && "nextSibling";
                }
                return true;
              }
              start = [forward ? parent.firstChild : parent.lastChild];
              if (forward && useCache) {
                node = parent;
                outerCache = node[expando] || (node[expando] = {});
                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                cache = uniqueCache[type] || [];
                nodeIndex = cache[0] === dirruns && cache[1];
                diff = nodeIndex && cache[2];
                node = nodeIndex && parent.childNodes[nodeIndex];
                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                  if (node.nodeType === 1 && ++diff && node === elem) {
                    uniqueCache[type] = [dirruns, nodeIndex, diff];
                    break;
                  }
                }
              } else {
                if (useCache) {
                  node = elem;
                  outerCache = node[expando] || (node[expando] = {});
                  uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                  cache = uniqueCache[type] || [];
                  nodeIndex = cache[0] === dirruns && cache[1];
                  diff = nodeIndex;
                }
                if (diff === false) {
                  while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                    if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                      if (useCache) {
                        outerCache = node[expando] || (node[expando] = {});
                        uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                        uniqueCache[type] = [dirruns, diff];
                      }
                      if (node === elem) {
                        break;
                      }
                    }
                  }
                }
              }
              diff -= last;
              return diff === first || diff % first === 0 && diff / first >= 0;
            }
          };
        },
        "PSEUDO": function PSEUDO(pseudo, argument) {
          var args,
            fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
          if (fn[expando]) {
            return fn(argument);
          }
          if (fn.length > 1) {
            args = [pseudo, pseudo, "", argument];
            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
              var idx,
                matched = fn(seed, argument),
                i = matched.length;
              while (i--) {
                idx = indexOf(seed, matched[i]);
                seed[idx] = !(matches[idx] = matched[i]);
              }
            }) : function (elem) {
              return fn(elem, 0, args);
            };
          }
          return fn;
        }
      },
      pseudos: {
        "not": markFunction(function (selector) {
          var input = [],
            results = [],
            matcher = compile(selector.replace(rtrim, "$1"));
          return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
            var elem,
              unmatched = matcher(seed, null, xml, []),
              i = seed.length;
            while (i--) {
              if (elem = unmatched[i]) {
                seed[i] = !(matches[i] = elem);
              }
            }
          }) : function (elem, context, xml) {
            input[0] = elem;
            matcher(input, null, xml, results);
            input[0] = null;
            return !results.pop();
          };
        }),
        "has": markFunction(function (selector) {
          return function (elem) {
            return Sizzle(selector, elem).length > 0;
          };
        }),
        "contains": markFunction(function (text) {
          text = text.replace(runescape, funescape);
          return function (elem) {
            return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
          };
        }),
        "lang": markFunction(function (lang) {
          if (!ridentifier.test(lang || "")) {
            Sizzle.error("unsupported lang: " + lang);
          }
          lang = lang.replace(runescape, funescape).toLowerCase();
          return function (elem) {
            var elemLang;
            do {
              if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                elemLang = elemLang.toLowerCase();
                return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
              }
            } while ((elem = elem.parentNode) && elem.nodeType === 1);
            return false;
          };
        }),
        "target": function target(elem) {
          var hash = window.location && window.location.hash;
          return hash && hash.slice(1) === elem.id;
        },
        "root": function root(elem) {
          return elem === docElem;
        },
        "focus": function focus(elem) {
          return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
        },
        "enabled": createDisabledPseudo(false),
        "disabled": createDisabledPseudo(true),
        "checked": function checked(elem) {
          var nodeName = elem.nodeName.toLowerCase();
          return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
        },
        "selected": function selected(elem) {
          if (elem.parentNode) {
            elem.parentNode.selectedIndex;
          }
          return elem.selected === true;
        },
        "empty": function empty(elem) {
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            if (elem.nodeType < 6) {
              return false;
            }
          }
          return true;
        },
        "parent": function parent(elem) {
          return !Expr.pseudos["empty"](elem);
        },
        "header": function header(elem) {
          return rheader.test(elem.nodeName);
        },
        "input": function input(elem) {
          return rinputs.test(elem.nodeName);
        },
        "button": function button(elem) {
          var name = elem.nodeName.toLowerCase();
          return name === "input" && elem.type === "button" || name === "button";
        },
        "text": function text(elem) {
          var attr;
          return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
        },
        "first": createPositionalPseudo(function () {
          return [0];
        }),
        "last": createPositionalPseudo(function (matchIndexes, length) {
          return [length - 1];
        }),
        "eq": createPositionalPseudo(function (matchIndexes, length, argument) {
          return [argument < 0 ? argument + length : argument];
        }),
        "even": createPositionalPseudo(function (matchIndexes, length) {
          var i = 0;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        "odd": createPositionalPseudo(function (matchIndexes, length) {
          var i = 1;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        "lt": createPositionalPseudo(function (matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;
          for (; --i >= 0;) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        "gt": createPositionalPseudo(function (matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;
          for (; ++i < length;) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        })
      }
    };
    Expr.pseudos["nth"] = Expr.pseudos["eq"];
    for (i in {
      radio: true,
      checkbox: true,
      file: true,
      password: true,
      image: true
    }) {
      Expr.pseudos[i] = createInputPseudo(i);
    }
    for (i in {
      submit: true,
      reset: true
    }) {
      Expr.pseudos[i] = createButtonPseudo(i);
    }
    function setFilters() {}
    setFilters.prototype = Expr.filters = Expr.pseudos;
    Expr.setFilters = new setFilters();
    tokenize = Sizzle.tokenize = function (selector, parseOnly) {
      var matched,
        match,
        tokens,
        type,
        soFar,
        groups,
        preFilters,
        cached = tokenCache[selector + " "];
      if (cached) {
        return parseOnly ? 0 : cached.slice(0);
      }
      soFar = selector;
      groups = [];
      preFilters = Expr.preFilter;
      while (soFar) {
        if (!matched || (match = rcomma.exec(soFar))) {
          if (match) {
            soFar = soFar.slice(match[0].length) || soFar;
          }
          groups.push(tokens = []);
        }
        matched = false;
        if (match = rcombinators.exec(soFar)) {
          matched = match.shift();
          tokens.push({
            value: matched,
            type: match[0].replace(rtrim, " ")
          });
          soFar = soFar.slice(matched.length);
        }
        for (type in Expr.filter) {
          if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
            matched = match.shift();
            tokens.push({
              value: matched,
              type: type,
              matches: match
            });
            soFar = soFar.slice(matched.length);
          }
        }
        if (!matched) {
          break;
        }
      }
      return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
    };
    function toSelector(tokens) {
      var i = 0,
        len = tokens.length,
        selector = "";
      for (; i < len; i++) {
        selector += tokens[i].value;
      }
      return selector;
    }
    function addCombinator(matcher, combinator, base) {
      var dir = combinator.dir,
        skip = combinator.next,
        key = skip || dir,
        checkNonElements = base && key === "parentNode",
        doneName = done++;
      return combinator.first ? function (elem, context, xml) {
        while (elem = elem[dir]) {
          if (elem.nodeType === 1 || checkNonElements) {
            return matcher(elem, context, xml);
          }
        }
        return false;
      } : function (elem, context, xml) {
        var oldCache,
          uniqueCache,
          outerCache,
          newCache = [dirruns, doneName];
        if (xml) {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              if (matcher(elem, context, xml)) {
                return true;
              }
            }
          }
        } else {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              outerCache = elem[expando] || (elem[expando] = {});
              uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});
              if (skip && skip === elem.nodeName.toLowerCase()) {
                elem = elem[dir] || elem;
              } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                return newCache[2] = oldCache[2];
              } else {
                uniqueCache[key] = newCache;
                if (newCache[2] = matcher(elem, context, xml)) {
                  return true;
                }
              }
            }
          }
        }
        return false;
      };
    }
    function elementMatcher(matchers) {
      return matchers.length > 1 ? function (elem, context, xml) {
        var i = matchers.length;
        while (i--) {
          if (!matchers[i](elem, context, xml)) {
            return false;
          }
        }
        return true;
      } : matchers[0];
    }
    function multipleContexts(selector, contexts, results) {
      var i = 0,
        len = contexts.length;
      for (; i < len; i++) {
        Sizzle(selector, contexts[i], results);
      }
      return results;
    }
    function condense(unmatched, map, filter, context, xml) {
      var elem,
        newUnmatched = [],
        i = 0,
        len = unmatched.length,
        mapped = map != null;
      for (; i < len; i++) {
        if (elem = unmatched[i]) {
          if (!filter || filter(elem, context, xml)) {
            newUnmatched.push(elem);
            if (mapped) {
              map.push(i);
            }
          }
        }
      }
      return newUnmatched;
    }
    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
      if (postFilter && !postFilter[expando]) {
        postFilter = setMatcher(postFilter);
      }
      if (postFinder && !postFinder[expando]) {
        postFinder = setMatcher(postFinder, postSelector);
      }
      return markFunction(function (seed, results, context, xml) {
        var temp,
          i,
          elem,
          preMap = [],
          postMap = [],
          preexisting = results.length,
          elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
          matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
          matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
        if (matcher) {
          matcher(matcherIn, matcherOut, context, xml);
        }
        if (postFilter) {
          temp = condense(matcherOut, postMap);
          postFilter(temp, [], context, xml);
          i = temp.length;
          while (i--) {
            if (elem = temp[i]) {
              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
            }
          }
        }
        if (seed) {
          if (postFinder || preFilter) {
            if (postFinder) {
              temp = [];
              i = matcherOut.length;
              while (i--) {
                if (elem = matcherOut[i]) {
                  temp.push(matcherIn[i] = elem);
                }
              }
              postFinder(null, matcherOut = [], temp, xml);
            }
            i = matcherOut.length;
            while (i--) {
              if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                seed[temp] = !(results[temp] = elem);
              }
            }
          }
        } else {
          matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
          if (postFinder) {
            postFinder(null, results, matcherOut, xml);
          } else {
            push.apply(results, matcherOut);
          }
        }
      });
    }
    function matcherFromTokens(tokens) {
      var checkContext,
        matcher,
        j,
        len = tokens.length,
        leadingRelative = Expr.relative[tokens[0].type],
        implicitRelative = leadingRelative || Expr.relative[" "],
        i = leadingRelative ? 1 : 0,
        matchContext = addCombinator(function (elem) {
          return elem === checkContext;
        }, implicitRelative, true),
        matchAnyContext = addCombinator(function (elem) {
          return indexOf(checkContext, elem) > -1;
        }, implicitRelative, true),
        matchers = [function (elem, context, xml) {
          var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
          checkContext = null;
          return ret;
        }];
      for (; i < len; i++) {
        if (matcher = Expr.relative[tokens[i].type]) {
          matchers = [addCombinator(elementMatcher(matchers), matcher)];
        } else {
          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
          if (matcher[expando]) {
            j = ++i;
            for (; j < len; j++) {
              if (Expr.relative[tokens[j].type]) {
                break;
              }
            }
            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({
              value: tokens[i - 2].type === " " ? "*" : ""
            })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
          }
          matchers.push(matcher);
        }
      }
      return elementMatcher(matchers);
    }
    function matcherFromGroupMatchers(elementMatchers, setMatchers) {
      var bySet = setMatchers.length > 0,
        byElement = elementMatchers.length > 0,
        superMatcher = function superMatcher(seed, context, xml, results, outermost) {
          var elem,
            j,
            matcher,
            matchedCount = 0,
            i = "0",
            unmatched = seed && [],
            setMatched = [],
            contextBackup = outermostContext,
            elems = seed || byElement && Expr.find["TAG"]("*", outermost),
            dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,
            len = elems.length;
          if (outermost) {
            outermostContext = context === document || context || outermost;
          }
          for (; i !== len && (elem = elems[i]) != null; i++) {
            if (byElement && elem) {
              j = 0;
              if (!context && elem.ownerDocument !== document) {
                setDocument(elem);
                xml = !documentIsHTML;
              }
              while (matcher = elementMatchers[j++]) {
                if (matcher(elem, context || document, xml)) {
                  results.push(elem);
                  break;
                }
              }
              if (outermost) {
                dirruns = dirrunsUnique;
              }
            }
            if (bySet) {
              if (elem = !matcher && elem) {
                matchedCount--;
              }
              if (seed) {
                unmatched.push(elem);
              }
            }
          }
          matchedCount += i;
          if (bySet && i !== matchedCount) {
            j = 0;
            while (matcher = setMatchers[j++]) {
              matcher(unmatched, setMatched, context, xml);
            }
            if (seed) {
              if (matchedCount > 0) {
                while (i--) {
                  if (!(unmatched[i] || setMatched[i])) {
                    setMatched[i] = pop.call(results);
                  }
                }
              }
              setMatched = condense(setMatched);
            }
            push.apply(results, setMatched);
            if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
              Sizzle.uniqueSort(results);
            }
          }
          if (outermost) {
            dirruns = dirrunsUnique;
            outermostContext = contextBackup;
          }
          return unmatched;
        };
      return bySet ? markFunction(superMatcher) : superMatcher;
    }
    compile = Sizzle.compile = function (selector, match) {
      var i,
        setMatchers = [],
        elementMatchers = [],
        cached = compilerCache[selector + " "];
      if (!cached) {
        if (!match) {
          match = tokenize(selector);
        }
        i = match.length;
        while (i--) {
          cached = matcherFromTokens(match[i]);
          if (cached[expando]) {
            setMatchers.push(cached);
          } else {
            elementMatchers.push(cached);
          }
        }
        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
        cached.selector = selector;
      }
      return cached;
    };
    select = Sizzle.select = function (selector, context, results, seed) {
      var i,
        tokens,
        token,
        type,
        find,
        compiled = typeof selector === "function" && selector,
        match = !seed && tokenize(selector = compiled.selector || selector);
      results = results || [];
      if (match.length === 1) {
        tokens = match[0] = match[0].slice(0);
        if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
          context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
          if (!context) {
            return results;
          } else if (compiled) {
            context = context.parentNode;
          }
          selector = selector.slice(tokens.shift().value.length);
        }
        i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
        while (i--) {
          token = tokens[i];
          if (Expr.relative[type = token.type]) {
            break;
          }
          if (find = Expr.find[type]) {
            if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
              tokens.splice(i, 1);
              selector = seed.length && toSelector(tokens);
              if (!selector) {
                push.apply(results, seed);
                return results;
              }
              break;
            }
          }
        }
      }
      (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
      return results;
    };
    support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
    support.detectDuplicates = !!hasDuplicate;
    setDocument();
    support.sortDetached = assert(function (el) {
      return el.compareDocumentPosition(document.createElement("fieldset")) & 1;
    });
    if (!assert(function (el) {
      el.innerHTML = "<a href='#'></a>";
      return el.firstChild.getAttribute("href") === "#";
    })) {
      addHandle("type|href|height|width", function (elem, name, isXML) {
        if (!isXML) {
          return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
        }
      });
    }
    if (!support.attributes || !assert(function (el) {
      el.innerHTML = "<input/>";
      el.firstChild.setAttribute("value", "");
      return el.firstChild.getAttribute("value") === "";
    })) {
      addHandle("value", function (elem, name, isXML) {
        if (!isXML && elem.nodeName.toLowerCase() === "input") {
          return elem.defaultValue;
        }
      });
    }
    if (!assert(function (el) {
      return el.getAttribute("disabled") == null;
    })) {
      addHandle(booleans, function (elem, name, isXML) {
        var val;
        if (!isXML) {
          return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        }
      });
    }
    return Sizzle;
  }(window);
  _jQuery2.find = Sizzle;
  _jQuery2.expr = Sizzle.selectors;
  _jQuery2.expr[":"] = _jQuery2.expr.pseudos;
  _jQuery2.uniqueSort = _jQuery2.unique = Sizzle.uniqueSort;
  _jQuery2.text = Sizzle.getText;
  _jQuery2.isXMLDoc = Sizzle.isXML;
  _jQuery2.contains = Sizzle.contains;
  _jQuery2.escapeSelector = Sizzle.escape;
  var dir = function dir(elem, _dir, until) {
    var matched = [],
      truncate = until !== undefined;
    while ((elem = elem[_dir]) && elem.nodeType !== 9) {
      if (elem.nodeType === 1) {
        if (truncate && _jQuery2(elem).is(until)) {
          break;
        }
        matched.push(elem);
      }
    }
    return matched;
  };
  var _siblings = function siblings(n, elem) {
    var matched = [];
    for (; n; n = n.nextSibling) {
      if (n.nodeType === 1 && n !== elem) {
        matched.push(n);
      }
    }
    return matched;
  };
  var rneedsContext = _jQuery2.expr.match.needsContext;
  function nodeName(elem, name) {
    return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
  }
  ;
  var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
  function winnow(elements, qualifier, not) {
    if (isFunction(qualifier)) {
      return _jQuery2.grep(elements, function (elem, i) {
        return !!qualifier.call(elem, i, elem) !== not;
      });
    }
    if (qualifier.nodeType) {
      return _jQuery2.grep(elements, function (elem) {
        return elem === qualifier !== not;
      });
    }
    if (typeof qualifier !== "string") {
      return _jQuery2.grep(elements, function (elem) {
        return indexOf.call(qualifier, elem) > -1 !== not;
      });
    }
    return _jQuery2.filter(qualifier, elements, not);
  }
  _jQuery2.filter = function (expr, elems, not) {
    var elem = elems[0];
    if (not) {
      expr = ":not(" + expr + ")";
    }
    if (elems.length === 1 && elem.nodeType === 1) {
      return _jQuery2.find.matchesSelector(elem, expr) ? [elem] : [];
    }
    return _jQuery2.find.matches(expr, _jQuery2.grep(elems, function (elem) {
      return elem.nodeType === 1;
    }));
  };
  _jQuery2.fn.extend({
    find: function find(selector) {
      var i,
        ret,
        len = this.length,
        self = this;
      if (typeof selector !== "string") {
        return this.pushStack(_jQuery2(selector).filter(function () {
          for (i = 0; i < len; i++) {
            if (_jQuery2.contains(self[i], this)) {
              return true;
            }
          }
        }));
      }
      ret = this.pushStack([]);
      for (i = 0; i < len; i++) {
        _jQuery2.find(selector, self[i], ret);
      }
      return len > 1 ? _jQuery2.uniqueSort(ret) : ret;
    },
    filter: function filter(selector) {
      return this.pushStack(winnow(this, selector || [], false));
    },
    not: function not(selector) {
      return this.pushStack(winnow(this, selector || [], true));
    },
    is: function is(selector) {
      return !!winnow(this, typeof selector === "string" && rneedsContext.test(selector) ? _jQuery2(selector) : selector || [], false).length;
    }
  });
  var rootjQuery,
    rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
    init = _jQuery2.fn.init = function (selector, context, root) {
      var match, elem;
      if (!selector) {
        return this;
      }
      root = root || rootjQuery;
      if (typeof selector === "string") {
        if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
          match = [null, selector, null];
        } else {
          match = rquickExpr.exec(selector);
        }
        if (match && (match[1] || !context)) {
          if (match[1]) {
            context = context instanceof _jQuery2 ? context[0] : context;
            _jQuery2.merge(this, _jQuery2.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
            if (rsingleTag.test(match[1]) && _jQuery2.isPlainObject(context)) {
              for (match in context) {
                if (isFunction(this[match])) {
                  this[match](context[match]);
                } else {
                  this.attr(match, context[match]);
                }
              }
            }
            return this;
          } else {
            elem = document.getElementById(match[2]);
            if (elem) {
              this[0] = elem;
              this.length = 1;
            }
            return this;
          }
        } else if (!context || context.jquery) {
          return (context || root).find(selector);
        } else {
          return this.constructor(context).find(selector);
        }
      } else if (selector.nodeType) {
        this[0] = selector;
        this.length = 1;
        return this;
      } else if (isFunction(selector)) {
        return root.ready !== undefined ? root.ready(selector) : selector(_jQuery2);
      }
      return _jQuery2.makeArray(selector, this);
    };
  init.prototype = _jQuery2.fn;
  rootjQuery = _jQuery2(document);
  var rparentsprev = /^(?:parents|prev(?:Until|All))/,
    guaranteedUnique = {
      children: true,
      contents: true,
      next: true,
      prev: true
    };
  _jQuery2.fn.extend({
    has: function has(target) {
      var targets = _jQuery2(target, this),
        l = targets.length;
      return this.filter(function () {
        var i = 0;
        for (; i < l; i++) {
          if (_jQuery2.contains(this, targets[i])) {
            return true;
          }
        }
      });
    },
    closest: function closest(selectors, context) {
      var cur,
        i = 0,
        l = this.length,
        matched = [],
        targets = typeof selectors !== "string" && _jQuery2(selectors);
      if (!rneedsContext.test(selectors)) {
        for (; i < l; i++) {
          for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
            if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : cur.nodeType === 1 && _jQuery2.find.matchesSelector(cur, selectors))) {
              matched.push(cur);
              break;
            }
          }
        }
      }
      return this.pushStack(matched.length > 1 ? _jQuery2.uniqueSort(matched) : matched);
    },
    index: function index(elem) {
      if (!elem) {
        return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
      }
      if (typeof elem === "string") {
        return indexOf.call(_jQuery2(elem), this[0]);
      }
      return indexOf.call(this, elem.jquery ? elem[0] : elem);
    },
    add: function add(selector, context) {
      return this.pushStack(_jQuery2.uniqueSort(_jQuery2.merge(this.get(), _jQuery2(selector, context))));
    },
    addBack: function addBack(selector) {
      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
    }
  });
  function sibling(cur, dir) {
    while ((cur = cur[dir]) && cur.nodeType !== 1) {}
    return cur;
  }
  _jQuery2.each({
    parent: function parent(elem) {
      var parent = elem.parentNode;
      return parent && parent.nodeType !== 11 ? parent : null;
    },
    parents: function parents(elem) {
      return dir(elem, "parentNode");
    },
    parentsUntil: function parentsUntil(elem, i, until) {
      return dir(elem, "parentNode", until);
    },
    next: function next(elem) {
      return sibling(elem, "nextSibling");
    },
    prev: function prev(elem) {
      return sibling(elem, "previousSibling");
    },
    nextAll: function nextAll(elem) {
      return dir(elem, "nextSibling");
    },
    prevAll: function prevAll(elem) {
      return dir(elem, "previousSibling");
    },
    nextUntil: function nextUntil(elem, i, until) {
      return dir(elem, "nextSibling", until);
    },
    prevUntil: function prevUntil(elem, i, until) {
      return dir(elem, "previousSibling", until);
    },
    siblings: function siblings(elem) {
      return _siblings((elem.parentNode || {}).firstChild, elem);
    },
    children: function children(elem) {
      return _siblings(elem.firstChild);
    },
    contents: function contents(elem) {
      if (nodeName(elem, "iframe")) {
        return elem.contentDocument;
      }
      if (nodeName(elem, "template")) {
        elem = elem.content || elem;
      }
      return _jQuery2.merge([], elem.childNodes);
    }
  }, function (name, fn) {
    _jQuery2.fn[name] = function (until, selector) {
      var matched = _jQuery2.map(this, fn, until);
      if (name.slice(-5) !== "Until") {
        selector = until;
      }
      if (selector && typeof selector === "string") {
        matched = _jQuery2.filter(selector, matched);
      }
      if (this.length > 1) {
        if (!guaranteedUnique[name]) {
          _jQuery2.uniqueSort(matched);
        }
        if (rparentsprev.test(name)) {
          matched.reverse();
        }
      }
      return this.pushStack(matched);
    };
  });
  var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
  function createOptions(options) {
    var object = {};
    _jQuery2.each(options.match(rnothtmlwhite) || [], function (_, flag) {
      object[flag] = true;
    });
    return object;
  }
  _jQuery2.Callbacks = function (options) {
    options = typeof options === "string" ? createOptions(options) : _jQuery2.extend({}, options);
    var firing,
      memory,
      _fired,
      _locked,
      list = [],
      queue = [],
      firingIndex = -1,
      fire = function fire() {
        _locked = _locked || options.once;
        _fired = firing = true;
        for (; queue.length; firingIndex = -1) {
          memory = queue.shift();
          while (++firingIndex < list.length) {
            if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
              firingIndex = list.length;
              memory = false;
            }
          }
        }
        if (!options.memory) {
          memory = false;
        }
        firing = false;
        if (_locked) {
          if (memory) {
            list = [];
          } else {
            list = "";
          }
        }
      },
      self = {
        add: function add() {
          if (list) {
            if (memory && !firing) {
              firingIndex = list.length - 1;
              queue.push(memory);
            }
            (function add(args) {
              _jQuery2.each(args, function (_, arg) {
                if (isFunction(arg)) {
                  if (!options.unique || !self.has(arg)) {
                    list.push(arg);
                  }
                } else if (arg && arg.length && toType(arg) !== "string") {
                  add(arg);
                }
              });
            })(arguments);
            if (memory && !firing) {
              fire();
            }
          }
          return this;
        },
        remove: function remove() {
          _jQuery2.each(arguments, function (_, arg) {
            var index;
            while ((index = _jQuery2.inArray(arg, list, index)) > -1) {
              list.splice(index, 1);
              if (index <= firingIndex) {
                firingIndex--;
              }
            }
          });
          return this;
        },
        has: function has(fn) {
          return fn ? _jQuery2.inArray(fn, list) > -1 : list.length > 0;
        },
        empty: function empty() {
          if (list) {
            list = [];
          }
          return this;
        },
        disable: function disable() {
          _locked = queue = [];
          list = memory = "";
          return this;
        },
        disabled: function disabled() {
          return !list;
        },
        lock: function lock() {
          _locked = queue = [];
          if (!memory && !firing) {
            list = memory = "";
          }
          return this;
        },
        locked: function locked() {
          return !!_locked;
        },
        fireWith: function fireWith(context, args) {
          if (!_locked) {
            args = args || [];
            args = [context, args.slice ? args.slice() : args];
            queue.push(args);
            if (!firing) {
              fire();
            }
          }
          return this;
        },
        fire: function fire() {
          self.fireWith(this, arguments);
          return this;
        },
        fired: function fired() {
          return !!_fired;
        }
      };
    return self;
  };
  function Identity(v) {
    return v;
  }
  function Thrower(ex) {
    throw ex;
  }
  function adoptValue(value, resolve, reject, noValue) {
    var method;
    try {
      if (value && isFunction(method = value.promise)) {
        method.call(value).done(resolve).fail(reject);
      } else if (value && isFunction(method = value.then)) {
        method.call(value, resolve, reject);
      } else {
        resolve.apply(undefined, [value].slice(noValue));
      }
    } catch (value) {
      reject.apply(undefined, [value]);
    }
  }
  _jQuery2.extend({
    Deferred: function Deferred(func) {
      var tuples = [["notify", "progress", _jQuery2.Callbacks("memory"), _jQuery2.Callbacks("memory"), 2], ["resolve", "done", _jQuery2.Callbacks("once memory"), _jQuery2.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", _jQuery2.Callbacks("once memory"), _jQuery2.Callbacks("once memory"), 1, "rejected"]],
        _state = "pending",
        _promise = {
          state: function state() {
            return _state;
          },
          always: function always() {
            deferred.done(arguments).fail(arguments);
            return this;
          },
          "catch": function _catch(fn) {
            return _promise.then(null, fn);
          },
          pipe: function pipe() {
            var fns = arguments;
            return _jQuery2.Deferred(function (newDefer) {
              _jQuery2.each(tuples, function (i, tuple) {
                var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]];
                deferred[tuple[1]](function () {
                  var returned = fn && fn.apply(this, arguments);
                  if (returned && isFunction(returned.promise)) {
                    returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                  } else {
                    newDefer[tuple[0] + "With"](this, fn ? [returned] : arguments);
                  }
                });
              });
              fns = null;
            }).promise();
          },
          then: function then(onFulfilled, onRejected, onProgress) {
            var maxDepth = 0;
            function resolve(depth, deferred, handler, special) {
              return function () {
                var that = this,
                  args = arguments,
                  mightThrow = function mightThrow() {
                    var returned, then;
                    if (depth < maxDepth) {
                      return;
                    }
                    returned = handler.apply(that, args);
                    if (returned === deferred.promise()) {
                      throw new TypeError("Thenable self-resolution");
                    }
                    then = returned && (typeof returned === "object" || typeof returned === "function") && returned.then;
                    if (isFunction(then)) {
                      if (special) {
                        then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special));
                      } else {
                        maxDepth++;
                        then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));
                      }
                    } else {
                      if (handler !== Identity) {
                        that = undefined;
                        args = [returned];
                      }
                      (special || deferred.resolveWith)(that, args);
                    }
                  },
                  process = special ? mightThrow : function () {
                    try {
                      mightThrow();
                    } catch (e) {
                      if (_jQuery2.Deferred.exceptionHook) {
                        _jQuery2.Deferred.exceptionHook(e, process.stackTrace);
                      }
                      if (depth + 1 >= maxDepth) {
                        if (handler !== Thrower) {
                          that = undefined;
                          args = [e];
                        }
                        deferred.rejectWith(that, args);
                      }
                    }
                  };
                if (depth) {
                  process();
                } else {
                  if (_jQuery2.Deferred.getStackHook) {
                    process.stackTrace = _jQuery2.Deferred.getStackHook();
                  }
                  window.setTimeout(process);
                }
              };
            }
            return _jQuery2.Deferred(function (newDefer) {
              tuples[0][3].add(resolve(0, newDefer, isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith));
              tuples[1][3].add(resolve(0, newDefer, isFunction(onFulfilled) ? onFulfilled : Identity));
              tuples[2][3].add(resolve(0, newDefer, isFunction(onRejected) ? onRejected : Thrower));
            }).promise();
          },
          promise: function promise(obj) {
            return obj != null ? _jQuery2.extend(obj, _promise) : _promise;
          }
        },
        deferred = {};
      _jQuery2.each(tuples, function (i, tuple) {
        var list = tuple[2],
          stateString = tuple[5];
        _promise[tuple[1]] = list.add;
        if (stateString) {
          list.add(function () {
            _state = stateString;
          }, tuples[3 - i][2].disable, tuples[3 - i][3].disable, tuples[0][2].lock, tuples[0][3].lock);
        }
        list.add(tuple[3].fire);
        deferred[tuple[0]] = function () {
          deferred[tuple[0] + "With"](this === deferred ? undefined : this, arguments);
          return this;
        };
        deferred[tuple[0] + "With"] = list.fireWith;
      });
      _promise.promise(deferred);
      if (func) {
        func.call(deferred, deferred);
      }
      return deferred;
    },
    when: function when(singleValue) {
      var remaining = arguments.length,
        i = remaining,
        resolveContexts = Array(i),
        resolveValues = _slice.call(arguments),
        master = _jQuery2.Deferred(),
        updateFunc = function updateFunc(i) {
          return function (value) {
            resolveContexts[i] = this;
            resolveValues[i] = arguments.length > 1 ? _slice.call(arguments) : value;
            if (! --remaining) {
              master.resolveWith(resolveContexts, resolveValues);
            }
          };
        };
      if (remaining <= 1) {
        adoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject, !remaining);
        if (master.state() === "pending" || isFunction(resolveValues[i] && resolveValues[i].then)) {
          return master.then();
        }
      }
      while (i--) {
        adoptValue(resolveValues[i], updateFunc(i), master.reject);
      }
      return master.promise();
    }
  });
  var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
  _jQuery2.Deferred.exceptionHook = function (error, stack) {
    if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {
      window.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack);
    }
  };
  _jQuery2.readyException = function (error) {
    window.setTimeout(function () {
      throw error;
    });
  };
  var readyList = _jQuery2.Deferred();
  _jQuery2.fn.ready = function (fn) {
    readyList.then(fn).catch(function (error) {
      _jQuery2.readyException(error);
    });
    return this;
  };
  _jQuery2.extend({
    isReady: false,
    readyWait: 1,
    ready: function ready(wait) {
      if (wait === true ? --_jQuery2.readyWait : _jQuery2.isReady) {
        return;
      }
      _jQuery2.isReady = true;
      if (wait !== true && --_jQuery2.readyWait > 0) {
        return;
      }
      readyList.resolveWith(document, [_jQuery2]);
    }
  });
  _jQuery2.ready.then = readyList.then;
  function completed() {
    document.removeEventListener("DOMContentLoaded", completed);
    window.removeEventListener("load", completed);
    _jQuery2.ready();
  }
  if (document.readyState === "complete" || document.readyState !== "loading" && !document.documentElement.doScroll) {
    window.setTimeout(_jQuery2.ready);
  } else {
    document.addEventListener("DOMContentLoaded", completed);
    window.addEventListener("load", completed);
  }
  var _access = function access(elems, fn, key, value, chainable, emptyGet, raw) {
    var i = 0,
      len = elems.length,
      bulk = key == null;
    if (toType(key) === "object") {
      chainable = true;
      for (i in key) {
        _access(elems, fn, i, key[i], true, emptyGet, raw);
      }
    } else if (value !== undefined) {
      chainable = true;
      if (!isFunction(value)) {
        raw = true;
      }
      if (bulk) {
        if (raw) {
          fn.call(elems, value);
          fn = null;
        } else {
          bulk = fn;
          fn = function fn(elem, key, value) {
            return bulk.call(_jQuery2(elem), value);
          };
        }
      }
      if (fn) {
        for (; i < len; i++) {
          fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
        }
      }
    }
    if (chainable) {
      return elems;
    }
    if (bulk) {
      return fn.call(elems);
    }
    return len ? fn(elems[0], key) : emptyGet;
  };
  var rmsPrefix = /^-ms-/,
    rdashAlpha = /-([a-z])/g;
  function fcamelCase(all, letter) {
    return letter.toUpperCase();
  }
  function camelCase(string) {
    return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
  }
  var acceptData = function acceptData(owner) {
    return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
  };
  function Data() {
    this.expando = _jQuery2.expando + Data.uid++;
  }
  Data.uid = 1;
  Data.prototype = {
    cache: function cache(owner) {
      var value = owner[this.expando];
      if (!value) {
        value = {};
        if (acceptData(owner)) {
          if (owner.nodeType) {
            owner[this.expando] = value;
          } else {
            Object.defineProperty(owner, this.expando, {
              value: value,
              configurable: true
            });
          }
        }
      }
      return value;
    },
    set: function set(owner, data, value) {
      var prop,
        cache = this.cache(owner);
      if (typeof data === "string") {
        cache[camelCase(data)] = value;
      } else {
        for (prop in data) {
          cache[camelCase(prop)] = data[prop];
        }
      }
      return cache;
    },
    get: function get(owner, key) {
      return key === undefined ? this.cache(owner) : owner[this.expando] && owner[this.expando][camelCase(key)];
    },
    access: function access(owner, key, value) {
      if (key === undefined || key && typeof key === "string" && value === undefined) {
        return this.get(owner, key);
      }
      this.set(owner, key, value);
      return value !== undefined ? value : key;
    },
    remove: function remove(owner, key) {
      var i,
        cache = owner[this.expando];
      if (cache === undefined) {
        return;
      }
      if (key !== undefined) {
        if (Array.isArray(key)) {
          key = key.map(camelCase);
        } else {
          key = camelCase(key);
          key = key in cache ? [key] : key.match(rnothtmlwhite) || [];
        }
        i = key.length;
        while (i--) {
          delete cache[key[i]];
        }
      }
      if (key === undefined || _jQuery2.isEmptyObject(cache)) {
        if (owner.nodeType) {
          owner[this.expando] = undefined;
        } else {
          delete owner[this.expando];
        }
      }
    },
    hasData: function hasData(owner) {
      var cache = owner[this.expando];
      return cache !== undefined && !_jQuery2.isEmptyObject(cache);
    }
  };
  var dataPriv = new Data();
  var dataUser = new Data();
  var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
    rmultiDash = /[A-Z]/g;
  function getData(data) {
    if (data === "true") {
      return true;
    }
    if (data === "false") {
      return false;
    }
    if (data === "null") {
      return null;
    }
    if (data === +data + "") {
      return +data;
    }
    if (rbrace.test(data)) {
      return JSON.parse(data);
    }
    return data;
  }
  function dataAttr(elem, key, data) {
    var name;
    if (data === undefined && elem.nodeType === 1) {
      name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
      data = elem.getAttribute(name);
      if (typeof data === "string") {
        try {
          data = getData(data);
        } catch (e) {}
        dataUser.set(elem, key, data);
      } else {
        data = undefined;
      }
    }
    return data;
  }
  _jQuery2.extend({
    hasData: function hasData(elem) {
      return dataUser.hasData(elem) || dataPriv.hasData(elem);
    },
    data: function data(elem, name, _data) {
      return dataUser.access(elem, name, _data);
    },
    removeData: function removeData(elem, name) {
      dataUser.remove(elem, name);
    },
    _data: function _data(elem, name, data) {
      return dataPriv.access(elem, name, data);
    },
    _removeData: function _removeData(elem, name) {
      dataPriv.remove(elem, name);
    }
  });
  _jQuery2.fn.extend({
    data: function data(key, value) {
      var i,
        name,
        data,
        elem = this[0],
        attrs = elem && elem.attributes;
      if (key === undefined) {
        if (this.length) {
          data = dataUser.get(elem);
          if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
            i = attrs.length;
            while (i--) {
              if (attrs[i]) {
                name = attrs[i].name;
                if (name.indexOf("data-") === 0) {
                  name = camelCase(name.slice(5));
                  dataAttr(elem, name, data[name]);
                }
              }
            }
            dataPriv.set(elem, "hasDataAttrs", true);
          }
        }
        return data;
      }
      if (typeof key === "object") {
        return this.each(function () {
          dataUser.set(this, key);
        });
      }
      return _access(this, function (value) {
        var data;
        if (elem && value === undefined) {
          data = dataUser.get(elem, key);
          if (data !== undefined) {
            return data;
          }
          data = dataAttr(elem, key);
          if (data !== undefined) {
            return data;
          }
          return;
        }
        this.each(function () {
          dataUser.set(this, key, value);
        });
      }, null, value, arguments.length > 1, null, true);
    },
    removeData: function removeData(key) {
      return this.each(function () {
        dataUser.remove(this, key);
      });
    }
  });
  _jQuery2.extend({
    queue: function queue(elem, type, data) {
      var queue;
      if (elem) {
        type = (type || "fx") + "queue";
        queue = dataPriv.get(elem, type);
        if (data) {
          if (!queue || Array.isArray(data)) {
            queue = dataPriv.access(elem, type, _jQuery2.makeArray(data));
          } else {
            queue.push(data);
          }
        }
        return queue || [];
      }
    },
    dequeue: function dequeue(elem, type) {
      type = type || "fx";
      var queue = _jQuery2.queue(elem, type),
        startLength = queue.length,
        fn = queue.shift(),
        hooks = _jQuery2._queueHooks(elem, type),
        next = function next() {
          _jQuery2.dequeue(elem, type);
        };
      if (fn === "inprogress") {
        fn = queue.shift();
        startLength--;
      }
      if (fn) {
        if (type === "fx") {
          queue.unshift("inprogress");
        }
        delete hooks.stop;
        fn.call(elem, next, hooks);
      }
      if (!startLength && hooks) {
        hooks.empty.fire();
      }
    },
    _queueHooks: function _queueHooks(elem, type) {
      var key = type + "queueHooks";
      return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
        empty: _jQuery2.Callbacks("once memory").add(function () {
          dataPriv.remove(elem, [type + "queue", key]);
        })
      });
    }
  });
  _jQuery2.fn.extend({
    queue: function queue(type, data) {
      var setter = 2;
      if (typeof type !== "string") {
        data = type;
        type = "fx";
        setter--;
      }
      if (arguments.length < setter) {
        return _jQuery2.queue(this[0], type);
      }
      return data === undefined ? this : this.each(function () {
        var queue = _jQuery2.queue(this, type, data);
        _jQuery2._queueHooks(this, type);
        if (type === "fx" && queue[0] !== "inprogress") {
          _jQuery2.dequeue(this, type);
        }
      });
    },
    dequeue: function dequeue(type) {
      return this.each(function () {
        _jQuery2.dequeue(this, type);
      });
    },
    clearQueue: function clearQueue(type) {
      return this.queue(type || "fx", []);
    },
    promise: function promise(type, obj) {
      var tmp,
        count = 1,
        defer = _jQuery2.Deferred(),
        elements = this,
        i = this.length,
        resolve = function resolve() {
          if (! --count) {
            defer.resolveWith(elements, [elements]);
          }
        };
      if (typeof type !== "string") {
        obj = type;
        type = undefined;
      }
      type = type || "fx";
      while (i--) {
        tmp = dataPriv.get(elements[i], type + "queueHooks");
        if (tmp && tmp.empty) {
          count++;
          tmp.empty.add(resolve);
        }
      }
      resolve();
      return defer.promise(obj);
    }
  });
  var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
  var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
  var cssExpand = ["Top", "Right", "Bottom", "Left"];
  var isHiddenWithinTree = function isHiddenWithinTree(elem, el) {
    elem = el || elem;
    return elem.style.display === "none" || elem.style.display === "" && _jQuery2.contains(elem.ownerDocument, elem) && _jQuery2.css(elem, "display") === "none";
  };
  var swap = function swap(elem, options, callback, args) {
    var ret,
      name,
      old = {};
    for (name in options) {
      old[name] = elem.style[name];
      elem.style[name] = options[name];
    }
    ret = callback.apply(elem, args || []);
    for (name in options) {
      elem.style[name] = old[name];
    }
    return ret;
  };
  function adjustCSS(elem, prop, valueParts, tween) {
    var adjusted,
      scale,
      maxIterations = 20,
      currentValue = tween ? function () {
        return tween.cur();
      } : function () {
        return _jQuery2.css(elem, prop, "");
      },
      initial = currentValue(),
      unit = valueParts && valueParts[3] || (_jQuery2.cssNumber[prop] ? "" : "px"),
      initialInUnit = (_jQuery2.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(_jQuery2.css(elem, prop));
    if (initialInUnit && initialInUnit[3] !== unit) {
      initial = initial / 2;
      unit = unit || initialInUnit[3];
      initialInUnit = +initial || 1;
      while (maxIterations--) {
        _jQuery2.style(elem, prop, initialInUnit + unit);
        if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
          maxIterations = 0;
        }
        initialInUnit = initialInUnit / scale;
      }
      initialInUnit = initialInUnit * 2;
      _jQuery2.style(elem, prop, initialInUnit + unit);
      valueParts = valueParts || [];
    }
    if (valueParts) {
      initialInUnit = +initialInUnit || +initial || 0;
      adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
      if (tween) {
        tween.unit = unit;
        tween.start = initialInUnit;
        tween.end = adjusted;
      }
    }
    return adjusted;
  }
  var defaultDisplayMap = {};
  function getDefaultDisplay(elem) {
    var temp,
      doc = elem.ownerDocument,
      nodeName = elem.nodeName,
      display = defaultDisplayMap[nodeName];
    if (display) {
      return display;
    }
    temp = doc.body.appendChild(doc.createElement(nodeName));
    display = _jQuery2.css(temp, "display");
    temp.parentNode.removeChild(temp);
    if (display === "none") {
      display = "block";
    }
    defaultDisplayMap[nodeName] = display;
    return display;
  }
  function showHide(elements, show) {
    var display,
      elem,
      values = [],
      index = 0,
      length = elements.length;
    for (; index < length; index++) {
      elem = elements[index];
      if (!elem.style) {
        continue;
      }
      display = elem.style.display;
      if (show) {
        if (display === "none") {
          values[index] = dataPriv.get(elem, "display") || null;
          if (!values[index]) {
            elem.style.display = "";
          }
        }
        if (elem.style.display === "" && isHiddenWithinTree(elem)) {
          values[index] = getDefaultDisplay(elem);
        }
      } else {
        if (display !== "none") {
          values[index] = "none";
          dataPriv.set(elem, "display", display);
        }
      }
    }
    for (index = 0; index < length; index++) {
      if (values[index] != null) {
        elements[index].style.display = values[index];
      }
    }
    return elements;
  }
  _jQuery2.fn.extend({
    show: function show() {
      return showHide(this, true);
    },
    hide: function hide() {
      return showHide(this);
    },
    toggle: function toggle(state) {
      if (typeof state === "boolean") {
        return state ? this.show() : this.hide();
      }
      return this.each(function () {
        if (isHiddenWithinTree(this)) {
          _jQuery2(this).show();
        } else {
          _jQuery2(this).hide();
        }
      });
    }
  });
  var rcheckableType = /^(?:checkbox|radio)$/i;
  var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]+)/i;
  var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;
  var wrapMap = {
    option: [1, "<select multiple='multiple'>", "</select>"],
    thead: [1, "<table>", "</table>"],
    col: [2, "<table><colgroup>", "</colgroup></table>"],
    tr: [2, "<table><tbody>", "</tbody></table>"],
    td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
    _default: [0, "", ""]
  };
  wrapMap.optgroup = wrapMap.option;
  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
  wrapMap.th = wrapMap.td;
  function getAll(context, tag) {
    var ret;
    if (typeof context.getElementsByTagName !== "undefined") {
      ret = context.getElementsByTagName(tag || "*");
    } else if (typeof context.querySelectorAll !== "undefined") {
      ret = context.querySelectorAll(tag || "*");
    } else {
      ret = [];
    }
    if (tag === undefined || tag && nodeName(context, tag)) {
      return _jQuery2.merge([context], ret);
    }
    return ret;
  }
  function setGlobalEval(elems, refElements) {
    var i = 0,
      l = elems.length;
    for (; i < l; i++) {
      dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
    }
  }
  var rhtml = /<|&#?\w+;/;
  function buildFragment(elems, context, scripts, selection, ignored) {
    var elem,
      tmp,
      tag,
      wrap,
      contains,
      j,
      fragment = context.createDocumentFragment(),
      nodes = [],
      i = 0,
      l = elems.length;
    for (; i < l; i++) {
      elem = elems[i];
      if (elem || elem === 0) {
        if (toType(elem) === "object") {
          _jQuery2.merge(nodes, elem.nodeType ? [elem] : elem);
        } else if (!rhtml.test(elem)) {
          nodes.push(context.createTextNode(elem));
        } else {
          tmp = tmp || fragment.appendChild(context.createElement("div"));
          tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
          wrap = wrapMap[tag] || wrapMap._default;
          tmp.innerHTML = wrap[1] + _jQuery2.htmlPrefilter(elem) + wrap[2];
          j = wrap[0];
          while (j--) {
            tmp = tmp.lastChild;
          }
          _jQuery2.merge(nodes, tmp.childNodes);
          tmp = fragment.firstChild;
          tmp.textContent = "";
        }
      }
    }
    fragment.textContent = "";
    i = 0;
    while (elem = nodes[i++]) {
      if (selection && _jQuery2.inArray(elem, selection) > -1) {
        if (ignored) {
          ignored.push(elem);
        }
        continue;
      }
      contains = _jQuery2.contains(elem.ownerDocument, elem);
      tmp = getAll(fragment.appendChild(elem), "script");
      if (contains) {
        setGlobalEval(tmp);
      }
      if (scripts) {
        j = 0;
        while (elem = tmp[j++]) {
          if (rscriptType.test(elem.type || "")) {
            scripts.push(elem);
          }
        }
      }
    }
    return fragment;
  }
  (function () {
    var fragment = document.createDocumentFragment(),
      div = fragment.appendChild(document.createElement("div")),
      input = document.createElement("input");
    input.setAttribute("type", "radio");
    input.setAttribute("checked", "checked");
    input.setAttribute("name", "t");
    div.appendChild(input);
    support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
    div.innerHTML = "<textarea>x</textarea>";
    support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
  })();
  var documentElement = document.documentElement;
  var rkeyEvent = /^key/,
    rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
    rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
  function returnTrue() {
    return true;
  }
  function returnFalse() {
    return false;
  }
  function safeActiveElement() {
    try {
      return document.activeElement;
    } catch (err) {}
  }
  function _on(elem, types, selector, data, fn, one) {
    var origFn, type;
    if (typeof types === "object") {
      if (typeof selector !== "string") {
        data = data || selector;
        selector = undefined;
      }
      for (type in types) {
        _on(elem, type, selector, data, types[type], one);
      }
      return elem;
    }
    if (data == null && fn == null) {
      fn = selector;
      data = selector = undefined;
    } else if (fn == null) {
      if (typeof selector === "string") {
        fn = data;
        data = undefined;
      } else {
        fn = data;
        data = selector;
        selector = undefined;
      }
    }
    if (fn === false) {
      fn = returnFalse;
    } else if (!fn) {
      return elem;
    }
    if (one === 1) {
      origFn = fn;
      fn = function fn(event) {
        _jQuery2().off(event);
        return origFn.apply(this, arguments);
      };
      fn.guid = origFn.guid || (origFn.guid = _jQuery2.guid++);
    }
    return elem.each(function () {
      _jQuery2.event.add(this, types, fn, data, selector);
    });
  }
  _jQuery2.event = {
    global: {},
    add: function add(elem, types, handler, data, selector) {
      var handleObjIn,
        eventHandle,
        tmp,
        events,
        t,
        handleObj,
        special,
        handlers,
        type,
        namespaces,
        origType,
        elemData = dataPriv.get(elem);
      if (!elemData) {
        return;
      }
      if (handler.handler) {
        handleObjIn = handler;
        handler = handleObjIn.handler;
        selector = handleObjIn.selector;
      }
      if (selector) {
        _jQuery2.find.matchesSelector(documentElement, selector);
      }
      if (!handler.guid) {
        handler.guid = _jQuery2.guid++;
      }
      if (!(events = elemData.events)) {
        events = elemData.events = {};
      }
      if (!(eventHandle = elemData.handle)) {
        eventHandle = elemData.handle = function (e) {
          return typeof _jQuery2 !== "undefined" && _jQuery2.event.triggered !== e.type ? _jQuery2.event.dispatch.apply(elem, arguments) : undefined;
        };
      }
      types = (types || "").match(rnothtmlwhite) || [""];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort();
        if (!type) {
          continue;
        }
        special = _jQuery2.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        special = _jQuery2.event.special[type] || {};
        handleObj = _jQuery2.extend({
          type: type,
          origType: origType,
          data: data,
          handler: handler,
          guid: handler.guid,
          selector: selector,
          needsContext: selector && _jQuery2.expr.match.needsContext.test(selector),
          namespace: namespaces.join(".")
        }, handleObjIn);
        if (!(handlers = events[type])) {
          handlers = events[type] = [];
          handlers.delegateCount = 0;
          if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
            if (elem.addEventListener) {
              elem.addEventListener(type, eventHandle);
            }
          }
        }
        if (special.add) {
          special.add.call(elem, handleObj);
          if (!handleObj.handler.guid) {
            handleObj.handler.guid = handler.guid;
          }
        }
        if (selector) {
          handlers.splice(handlers.delegateCount++, 0, handleObj);
        } else {
          handlers.push(handleObj);
        }
        _jQuery2.event.global[type] = true;
      }
    },
    remove: function remove(elem, types, handler, selector, mappedTypes) {
      var j,
        origCount,
        tmp,
        events,
        t,
        handleObj,
        special,
        handlers,
        type,
        namespaces,
        origType,
        elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
      if (!elemData || !(events = elemData.events)) {
        return;
      }
      types = (types || "").match(rnothtmlwhite) || [""];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort();
        if (!type) {
          for (type in events) {
            _jQuery2.event.remove(elem, type + types[t], handler, selector, true);
          }
          continue;
        }
        special = _jQuery2.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        handlers = events[type] || [];
        tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
        origCount = j = handlers.length;
        while (j--) {
          handleObj = handlers[j];
          if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
            handlers.splice(j, 1);
            if (handleObj.selector) {
              handlers.delegateCount--;
            }
            if (special.remove) {
              special.remove.call(elem, handleObj);
            }
          }
        }
        if (origCount && !handlers.length) {
          if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
            _jQuery2.removeEvent(elem, type, elemData.handle);
          }
          delete events[type];
        }
      }
      if (_jQuery2.isEmptyObject(events)) {
        dataPriv.remove(elem, "handle events");
      }
    },
    dispatch: function dispatch(nativeEvent) {
      var event = _jQuery2.event.fix(nativeEvent);
      var i,
        j,
        ret,
        matched,
        handleObj,
        handlerQueue,
        args = new Array(arguments.length),
        handlers = (dataPriv.get(this, "events") || {})[event.type] || [],
        special = _jQuery2.event.special[event.type] || {};
      args[0] = event;
      for (i = 1; i < arguments.length; i++) {
        args[i] = arguments[i];
      }
      event.delegateTarget = this;
      if (special.preDispatch && special.preDispatch.call(this, event) === false) {
        return;
      }
      handlerQueue = _jQuery2.event.handlers.call(this, event, handlers);
      i = 0;
      while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
        event.currentTarget = matched.elem;
        j = 0;
        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
          if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {
            event.handleObj = handleObj;
            event.data = handleObj.data;
            ret = ((_jQuery2.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
            if (ret !== undefined) {
              if ((event.result = ret) === false) {
                event.preventDefault();
                event.stopPropagation();
              }
            }
          }
        }
      }
      if (special.postDispatch) {
        special.postDispatch.call(this, event);
      }
      return event.result;
    },
    handlers: function handlers(event, _handlers) {
      var i,
        handleObj,
        sel,
        matchedHandlers,
        matchedSelectors,
        handlerQueue = [],
        delegateCount = _handlers.delegateCount,
        cur = event.target;
      if (delegateCount && cur.nodeType && !(event.type === "click" && event.button >= 1)) {
        for (; cur !== this; cur = cur.parentNode || this) {
          if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
            matchedHandlers = [];
            matchedSelectors = {};
            for (i = 0; i < delegateCount; i++) {
              handleObj = _handlers[i];
              sel = handleObj.selector + " ";
              if (matchedSelectors[sel] === undefined) {
                matchedSelectors[sel] = handleObj.needsContext ? _jQuery2(sel, this).index(cur) > -1 : _jQuery2.find(sel, this, null, [cur]).length;
              }
              if (matchedSelectors[sel]) {
                matchedHandlers.push(handleObj);
              }
            }
            if (matchedHandlers.length) {
              handlerQueue.push({
                elem: cur,
                handlers: matchedHandlers
              });
            }
          }
        }
      }
      cur = this;
      if (delegateCount < _handlers.length) {
        handlerQueue.push({
          elem: cur,
          handlers: _handlers.slice(delegateCount)
        });
      }
      return handlerQueue;
    },
    addProp: function addProp(name, hook) {
      Object.defineProperty(_jQuery2.Event.prototype, name, {
        enumerable: true,
        configurable: true,
        get: isFunction(hook) ? function () {
          if (this.originalEvent) {
            return hook(this.originalEvent);
          }
        } : function () {
          if (this.originalEvent) {
            return this.originalEvent[name];
          }
        },
        set: function set(value) {
          Object.defineProperty(this, name, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: value
          });
        }
      });
    },
    fix: function fix(originalEvent) {
      return originalEvent[_jQuery2.expando] ? originalEvent : new _jQuery2.Event(originalEvent);
    },
    special: {
      load: {
        noBubble: true
      },
      focus: {
        trigger: function trigger() {
          if (this !== safeActiveElement() && this.focus) {
            this.focus();
            return false;
          }
        },
        delegateType: "focusin"
      },
      blur: {
        trigger: function trigger() {
          if (this === safeActiveElement() && this.blur) {
            this.blur();
            return false;
          }
        },
        delegateType: "focusout"
      },
      click: {
        trigger: function trigger() {
          if (this.type === "checkbox" && this.click && nodeName(this, "input")) {
            this.click();
            return false;
          }
        },
        _default: function _default(event) {
          return nodeName(event.target, "a");
        }
      },
      beforeunload: {
        postDispatch: function postDispatch(event) {
          if (event.result !== undefined && event.originalEvent) {
            event.originalEvent.returnValue = event.result;
          }
        }
      }
    }
  };
  _jQuery2.removeEvent = function (elem, type, handle) {
    if (elem.removeEventListener) {
      elem.removeEventListener(type, handle);
    }
  };
  _jQuery2.Event = function (src, props) {
    if (!(this instanceof _jQuery2.Event)) {
      return new _jQuery2.Event(src, props);
    }
    if (src && src.type) {
      this.originalEvent = src;
      this.type = src.type;
      this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && src.returnValue === false ? returnTrue : returnFalse;
      this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
      this.currentTarget = src.currentTarget;
      this.relatedTarget = src.relatedTarget;
    } else {
      this.type = src;
    }
    if (props) {
      _jQuery2.extend(this, props);
    }
    this.timeStamp = src && src.timeStamp || Date.now();
    this[_jQuery2.expando] = true;
  };
  _jQuery2.Event.prototype = {
    constructor: _jQuery2.Event,
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse,
    isSimulated: false,
    preventDefault: function preventDefault() {
      var e = this.originalEvent;
      this.isDefaultPrevented = returnTrue;
      if (e && !this.isSimulated) {
        e.preventDefault();
      }
    },
    stopPropagation: function stopPropagation() {
      var e = this.originalEvent;
      this.isPropagationStopped = returnTrue;
      if (e && !this.isSimulated) {
        e.stopPropagation();
      }
    },
    stopImmediatePropagation: function stopImmediatePropagation() {
      var e = this.originalEvent;
      this.isImmediatePropagationStopped = returnTrue;
      if (e && !this.isSimulated) {
        e.stopImmediatePropagation();
      }
      this.stopPropagation();
    }
  };
  _jQuery2.each({
    altKey: true,
    bubbles: true,
    cancelable: true,
    changedTouches: true,
    ctrlKey: true,
    detail: true,
    eventPhase: true,
    metaKey: true,
    pageX: true,
    pageY: true,
    shiftKey: true,
    view: true,
    "char": true,
    charCode: true,
    key: true,
    keyCode: true,
    button: true,
    buttons: true,
    clientX: true,
    clientY: true,
    offsetX: true,
    offsetY: true,
    pointerId: true,
    pointerType: true,
    screenX: true,
    screenY: true,
    targetTouches: true,
    toElement: true,
    touches: true,
    which: function which(event) {
      var button = event.button;
      if (event.which == null && rkeyEvent.test(event.type)) {
        return event.charCode != null ? event.charCode : event.keyCode;
      }
      if (!event.which && button !== undefined && rmouseEvent.test(event.type)) {
        if (button & 1) {
          return 1;
        }
        if (button & 2) {
          return 3;
        }
        if (button & 4) {
          return 2;
        }
        return 0;
      }
      return event.which;
    }
  }, _jQuery2.event.addProp);
  _jQuery2.each({
    mouseenter: "mouseover",
    mouseleave: "mouseout",
    pointerenter: "pointerover",
    pointerleave: "pointerout"
  }, function (orig, fix) {
    _jQuery2.event.special[orig] = {
      delegateType: fix,
      bindType: fix,
      handle: function handle(event) {
        var ret,
          target = this,
          related = event.relatedTarget,
          handleObj = event.handleObj;
        if (!related || related !== target && !_jQuery2.contains(target, related)) {
          event.type = handleObj.origType;
          ret = handleObj.handler.apply(this, arguments);
          event.type = fix;
        }
        return ret;
      }
    };
  });
  _jQuery2.fn.extend({
    on: function on(types, selector, data, fn) {
      return _on(this, types, selector, data, fn);
    },
    one: function one(types, selector, data, fn) {
      return _on(this, types, selector, data, fn, 1);
    },
    off: function off(types, selector, fn) {
      var handleObj, type;
      if (types && types.preventDefault && types.handleObj) {
        handleObj = types.handleObj;
        _jQuery2(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
        return this;
      }
      if (typeof types === "object") {
        for (type in types) {
          this.off(type, selector, types[type]);
        }
        return this;
      }
      if (selector === false || typeof selector === "function") {
        fn = selector;
        selector = undefined;
      }
      if (fn === false) {
        fn = returnFalse;
      }
      return this.each(function () {
        _jQuery2.event.remove(this, types, fn, selector);
      });
    }
  });
  var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,
    rnoInnerhtml = /<script|<style|<link/i,
    rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
    rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
  function manipulationTarget(elem, content) {
    if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
      return _jQuery2(elem).children("tbody")[0] || elem;
    }
    return elem;
  }
  function disableScript(elem) {
    elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
    return elem;
  }
  function restoreScript(elem) {
    if ((elem.type || "").slice(0, 5) === "true/") {
      elem.type = elem.type.slice(5);
    } else {
      elem.removeAttribute("type");
    }
    return elem;
  }
  function cloneCopyEvent(src, dest) {
    var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
    if (dest.nodeType !== 1) {
      return;
    }
    if (dataPriv.hasData(src)) {
      pdataOld = dataPriv.access(src);
      pdataCur = dataPriv.set(dest, pdataOld);
      events = pdataOld.events;
      if (events) {
        delete pdataCur.handle;
        pdataCur.events = {};
        for (type in events) {
          for (i = 0, l = events[type].length; i < l; i++) {
            _jQuery2.event.add(dest, type, events[type][i]);
          }
        }
      }
    }
    if (dataUser.hasData(src)) {
      udataOld = dataUser.access(src);
      udataCur = _jQuery2.extend({}, udataOld);
      dataUser.set(dest, udataCur);
    }
  }
  function fixInput(src, dest) {
    var nodeName = dest.nodeName.toLowerCase();
    if (nodeName === "input" && rcheckableType.test(src.type)) {
      dest.checked = src.checked;
    } else if (nodeName === "input" || nodeName === "textarea") {
      dest.defaultValue = src.defaultValue;
    }
  }
  function domManip(collection, args, callback, ignored) {
    args = concat.apply([], args);
    var fragment,
      first,
      scripts,
      hasScripts,
      node,
      doc,
      i = 0,
      l = collection.length,
      iNoClone = l - 1,
      value = args[0],
      valueIsFunction = isFunction(value);
    if (valueIsFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
      return collection.each(function (index) {
        var self = collection.eq(index);
        if (valueIsFunction) {
          args[0] = value.call(this, index, self.html());
        }
        domManip(self, args, callback, ignored);
      });
    }
    if (l) {
      fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
      first = fragment.firstChild;
      if (fragment.childNodes.length === 1) {
        fragment = first;
      }
      if (first || ignored) {
        scripts = _jQuery2.map(getAll(fragment, "script"), disableScript);
        hasScripts = scripts.length;
        for (; i < l; i++) {
          node = fragment;
          if (i !== iNoClone) {
            node = _jQuery2.clone(node, true, true);
            if (hasScripts) {
              _jQuery2.merge(scripts, getAll(node, "script"));
            }
          }
          callback.call(collection[i], node, i);
        }
        if (hasScripts) {
          doc = scripts[scripts.length - 1].ownerDocument;
          _jQuery2.map(scripts, restoreScript);
          for (i = 0; i < hasScripts; i++) {
            node = scripts[i];
            if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && _jQuery2.contains(doc, node)) {
              if (node.src && (node.type || "").toLowerCase() !== "module") {
                if (_jQuery2._evalUrl) {
                  _jQuery2._evalUrl(node.src);
                }
              } else {
                DOMEval(node.textContent.replace(rcleanScript, ""), doc, node);
              }
            }
          }
        }
      }
    }
    return collection;
  }
  function _remove(elem, selector, keepData) {
    var node,
      nodes = selector ? _jQuery2.filter(selector, elem) : elem,
      i = 0;
    for (; (node = nodes[i]) != null; i++) {
      if (!keepData && node.nodeType === 1) {
        _jQuery2.cleanData(getAll(node));
      }
      if (node.parentNode) {
        if (keepData && _jQuery2.contains(node.ownerDocument, node)) {
          setGlobalEval(getAll(node, "script"));
        }
        node.parentNode.removeChild(node);
      }
    }
    return elem;
  }
  _jQuery2.extend({
    htmlPrefilter: function htmlPrefilter(html) {
      return html.replace(rxhtmlTag, "<$1></$2>");
    },
    clone: function clone(elem, dataAndEvents, deepDataAndEvents) {
      var i,
        l,
        srcElements,
        destElements,
        clone = elem.cloneNode(true),
        inPage = _jQuery2.contains(elem.ownerDocument, elem);
      if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !_jQuery2.isXMLDoc(elem)) {
        destElements = getAll(clone);
        srcElements = getAll(elem);
        for (i = 0, l = srcElements.length; i < l; i++) {
          fixInput(srcElements[i], destElements[i]);
        }
      }
      if (dataAndEvents) {
        if (deepDataAndEvents) {
          srcElements = srcElements || getAll(elem);
          destElements = destElements || getAll(clone);
          for (i = 0, l = srcElements.length; i < l; i++) {
            cloneCopyEvent(srcElements[i], destElements[i]);
          }
        } else {
          cloneCopyEvent(elem, clone);
        }
      }
      destElements = getAll(clone, "script");
      if (destElements.length > 0) {
        setGlobalEval(destElements, !inPage && getAll(elem, "script"));
      }
      return clone;
    },
    cleanData: function cleanData(elems) {
      var data,
        elem,
        type,
        special = _jQuery2.event.special,
        i = 0;
      for (; (elem = elems[i]) !== undefined; i++) {
        if (acceptData(elem)) {
          if (data = elem[dataPriv.expando]) {
            if (data.events) {
              for (type in data.events) {
                if (special[type]) {
                  _jQuery2.event.remove(elem, type);
                } else {
                  _jQuery2.removeEvent(elem, type, data.handle);
                }
              }
            }
            elem[dataPriv.expando] = undefined;
          }
          if (elem[dataUser.expando]) {
            elem[dataUser.expando] = undefined;
          }
        }
      }
    }
  });
  _jQuery2.fn.extend({
    detach: function detach(selector) {
      return _remove(this, selector, true);
    },
    remove: function remove(selector) {
      return _remove(this, selector);
    },
    text: function text(value) {
      return _access(this, function (value) {
        return value === undefined ? _jQuery2.text(this) : this.empty().each(function () {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            this.textContent = value;
          }
        });
      }, null, value, arguments.length);
    },
    append: function append() {
      return domManip(this, arguments, function (elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.appendChild(elem);
        }
      });
    },
    prepend: function prepend() {
      return domManip(this, arguments, function (elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.insertBefore(elem, target.firstChild);
        }
      });
    },
    before: function before() {
      return domManip(this, arguments, function (elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this);
        }
      });
    },
    after: function after() {
      return domManip(this, arguments, function (elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this.nextSibling);
        }
      });
    },
    empty: function empty() {
      var elem,
        i = 0;
      for (; (elem = this[i]) != null; i++) {
        if (elem.nodeType === 1) {
          _jQuery2.cleanData(getAll(elem, false));
          elem.textContent = "";
        }
      }
      return this;
    },
    clone: function clone(dataAndEvents, deepDataAndEvents) {
      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
      return this.map(function () {
        return _jQuery2.clone(this, dataAndEvents, deepDataAndEvents);
      });
    },
    html: function html(value) {
      return _access(this, function (value) {
        var elem = this[0] || {},
          i = 0,
          l = this.length;
        if (value === undefined && elem.nodeType === 1) {
          return elem.innerHTML;
        }
        if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
          value = _jQuery2.htmlPrefilter(value);
          try {
            for (; i < l; i++) {
              elem = this[i] || {};
              if (elem.nodeType === 1) {
                _jQuery2.cleanData(getAll(elem, false));
                elem.innerHTML = value;
              }
            }
            elem = 0;
          } catch (e) {}
        }
        if (elem) {
          this.empty().append(value);
        }
      }, null, value, arguments.length);
    },
    replaceWith: function replaceWith() {
      var ignored = [];
      return domManip(this, arguments, function (elem) {
        var parent = this.parentNode;
        if (_jQuery2.inArray(this, ignored) < 0) {
          _jQuery2.cleanData(getAll(this));
          if (parent) {
            parent.replaceChild(elem, this);
          }
        }
      }, ignored);
    }
  });
  _jQuery2.each({
    appendTo: "append",
    prependTo: "prepend",
    insertBefore: "before",
    insertAfter: "after",
    replaceAll: "replaceWith"
  }, function (name, original) {
    _jQuery2.fn[name] = function (selector) {
      var elems,
        ret = [],
        insert = _jQuery2(selector),
        last = insert.length - 1,
        i = 0;
      for (; i <= last; i++) {
        elems = i === last ? this : this.clone(true);
        _jQuery2(insert[i])[original](elems);
        push.apply(ret, elems.get());
      }
      return this.pushStack(ret);
    };
  });
  var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
  var getStyles = function getStyles(elem) {
    var view = elem.ownerDocument.defaultView;
    if (!view || !view.opener) {
      view = window;
    }
    return view.getComputedStyle(elem);
  };
  var rboxStyle = new RegExp(cssExpand.join("|"), "i");
  (function () {
    function computeStyleTests() {
      if (!div) {
        return;
      }
      container.style.cssText = "position:absolute;left:-11111px;width:60px;" + "margin-top:1px;padding:0;border:0";
      div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;" + "margin:auto;border:1px;padding:1px;" + "width:60%;top:1%";
      documentElement.appendChild(container).appendChild(div);
      var divStyle = window.getComputedStyle(div);
      pixelPositionVal = divStyle.top !== "1%";
      reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;
      div.style.right = "60%";
      pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;
      boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;
      div.style.position = "absolute";
      scrollboxSizeVal = div.offsetWidth === 36 || "absolute";
      documentElement.removeChild(container);
      div = null;
    }
    function roundPixelMeasures(measure) {
      return Math.round(parseFloat(measure));
    }
    var pixelPositionVal,
      boxSizingReliableVal,
      scrollboxSizeVal,
      pixelBoxStylesVal,
      reliableMarginLeftVal,
      container = document.createElement("div"),
      div = document.createElement("div");
    if (!div.style) {
      return;
    }
    div.style.backgroundClip = "content-box";
    div.cloneNode(true).style.backgroundClip = "";
    support.clearCloneStyle = div.style.backgroundClip === "content-box";
    _jQuery2.extend(support, {
      boxSizingReliable: function boxSizingReliable() {
        computeStyleTests();
        return boxSizingReliableVal;
      },
      pixelBoxStyles: function pixelBoxStyles() {
        computeStyleTests();
        return pixelBoxStylesVal;
      },
      pixelPosition: function pixelPosition() {
        computeStyleTests();
        return pixelPositionVal;
      },
      reliableMarginLeft: function reliableMarginLeft() {
        computeStyleTests();
        return reliableMarginLeftVal;
      },
      scrollboxSize: function scrollboxSize() {
        computeStyleTests();
        return scrollboxSizeVal;
      }
    });
  })();
  function curCSS(elem, name, computed) {
    var width,
      minWidth,
      maxWidth,
      ret,
      style = elem.style;
    computed = computed || getStyles(elem);
    if (computed) {
      ret = computed.getPropertyValue(name) || computed[name];
      if (ret === "" && !_jQuery2.contains(elem.ownerDocument, elem)) {
        ret = _jQuery2.style(elem, name);
      }
      if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
        width = style.width;
        minWidth = style.minWidth;
        maxWidth = style.maxWidth;
        style.minWidth = style.maxWidth = style.width = ret;
        ret = computed.width;
        style.width = width;
        style.minWidth = minWidth;
        style.maxWidth = maxWidth;
      }
    }
    return ret !== undefined ? ret + "" : ret;
  }
  function addGetHookIf(conditionFn, hookFn) {
    return {
      get: function get() {
        if (conditionFn()) {
          delete this.get;
          return;
        }
        return (this.get = hookFn).apply(this, arguments);
      }
    };
  }
  var rdisplayswap = /^(none|table(?!-c[ea]).+)/,
    rcustomProp = /^--/,
    cssShow = {
      position: "absolute",
      visibility: "hidden",
      display: "block"
    },
    cssNormalTransform = {
      letterSpacing: "0",
      fontWeight: "400"
    },
    cssPrefixes = ["Webkit", "Moz", "ms"],
    emptyStyle = document.createElement("div").style;
  function vendorPropName(name) {
    if (name in emptyStyle) {
      return name;
    }
    var capName = name[0].toUpperCase() + name.slice(1),
      i = cssPrefixes.length;
    while (i--) {
      name = cssPrefixes[i] + capName;
      if (name in emptyStyle) {
        return name;
      }
    }
  }
  function finalPropName(name) {
    var ret = _jQuery2.cssProps[name];
    if (!ret) {
      ret = _jQuery2.cssProps[name] = vendorPropName(name) || name;
    }
    return ret;
  }
  function setPositiveNumber(elem, value, subtract) {
    var matches = rcssNum.exec(value);
    return matches ? Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
  }
  function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
    var i = dimension === "width" ? 1 : 0,
      extra = 0,
      delta = 0;
    if (box === (isBorderBox ? "border" : "content")) {
      return 0;
    }
    for (; i < 4; i += 2) {
      if (box === "margin") {
        delta += _jQuery2.css(elem, box + cssExpand[i], true, styles);
      }
      if (!isBorderBox) {
        delta += _jQuery2.css(elem, "padding" + cssExpand[i], true, styles);
        if (box !== "padding") {
          delta += _jQuery2.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        } else {
          extra += _jQuery2.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        }
      } else {
        if (box === "content") {
          delta -= _jQuery2.css(elem, "padding" + cssExpand[i], true, styles);
        }
        if (box !== "margin") {
          delta -= _jQuery2.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        }
      }
    }
    if (!isBorderBox && computedVal >= 0) {
      delta += Math.max(0, Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5));
    }
    return delta;
  }
  function getWidthOrHeight(elem, dimension, extra) {
    var styles = getStyles(elem),
      val = curCSS(elem, dimension, styles),
      isBorderBox = _jQuery2.css(elem, "boxSizing", false, styles) === "border-box",
      valueIsBorderBox = isBorderBox;
    if (rnumnonpx.test(val)) {
      if (!extra) {
        return val;
      }
      val = "auto";
    }
    valueIsBorderBox = valueIsBorderBox && (support.boxSizingReliable() || val === elem.style[dimension]);
    if (val === "auto" || !parseFloat(val) && _jQuery2.css(elem, "display", false, styles) === "inline") {
      val = elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)];
      valueIsBorderBox = true;
    }
    val = parseFloat(val) || 0;
    return val + boxModelAdjustment(elem, dimension, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles, val) + "px";
  }
  _jQuery2.extend({
    cssHooks: {
      opacity: {
        get: function get(elem, computed) {
          if (computed) {
            var ret = curCSS(elem, "opacity");
            return ret === "" ? "1" : ret;
          }
        }
      }
    },
    cssNumber: {
      "animationIterationCount": true,
      "columnCount": true,
      "fillOpacity": true,
      "flexGrow": true,
      "flexShrink": true,
      "fontWeight": true,
      "lineHeight": true,
      "opacity": true,
      "order": true,
      "orphans": true,
      "widows": true,
      "zIndex": true,
      "zoom": true
    },
    cssProps: {},
    style: function style(elem, name, value, extra) {
      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
        return;
      }
      var ret,
        type,
        hooks,
        origName = camelCase(name),
        isCustomProp = rcustomProp.test(name),
        style = elem.style;
      if (!isCustomProp) {
        name = finalPropName(origName);
      }
      hooks = _jQuery2.cssHooks[name] || _jQuery2.cssHooks[origName];
      if (value !== undefined) {
        type = typeof value;
        if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
          value = adjustCSS(elem, name, ret);
          type = "number";
        }
        if (value == null || value !== value) {
          return;
        }
        if (type === "number") {
          value += ret && ret[3] || (_jQuery2.cssNumber[origName] ? "" : "px");
        }
        if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
          style[name] = "inherit";
        }
        if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
          if (isCustomProp) {
            style.setProperty(name, value);
          } else {
            style[name] = value;
          }
        }
      } else {
        if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
          return ret;
        }
        return style[name];
      }
    },
    css: function css(elem, name, extra, styles) {
      var val,
        num,
        hooks,
        origName = camelCase(name),
        isCustomProp = rcustomProp.test(name);
      if (!isCustomProp) {
        name = finalPropName(origName);
      }
      hooks = _jQuery2.cssHooks[name] || _jQuery2.cssHooks[origName];
      if (hooks && "get" in hooks) {
        val = hooks.get(elem, true, extra);
      }
      if (val === undefined) {
        val = curCSS(elem, name, styles);
      }
      if (val === "normal" && name in cssNormalTransform) {
        val = cssNormalTransform[name];
      }
      if (extra === "" || extra) {
        num = parseFloat(val);
        return extra === true || isFinite(num) ? num || 0 : val;
      }
      return val;
    }
  });
  _jQuery2.each(["height", "width"], function (i, dimension) {
    _jQuery2.cssHooks[dimension] = {
      get: function get(elem, computed, extra) {
        if (computed) {
          return rdisplayswap.test(_jQuery2.css(elem, "display")) && (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function () {
            return getWidthOrHeight(elem, dimension, extra);
          }) : getWidthOrHeight(elem, dimension, extra);
        }
      },
      set: function set(elem, value, extra) {
        var matches,
          styles = getStyles(elem),
          isBorderBox = _jQuery2.css(elem, "boxSizing", false, styles) === "border-box",
          subtract = extra && boxModelAdjustment(elem, dimension, extra, isBorderBox, styles);
        if (isBorderBox && support.scrollboxSize() === styles.position) {
          subtract -= Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5);
        }
        if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
          elem.style[dimension] = value;
          value = _jQuery2.css(elem, dimension);
        }
        return setPositiveNumber(elem, value, subtract);
      }
    };
  });
  _jQuery2.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {
    if (computed) {
      return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, {
        marginLeft: 0
      }, function () {
        return elem.getBoundingClientRect().left;
      })) + "px";
    }
  });
  _jQuery2.each({
    margin: "",
    padding: "",
    border: "Width"
  }, function (prefix, suffix) {
    _jQuery2.cssHooks[prefix + suffix] = {
      expand: function expand(value) {
        var i = 0,
          expanded = {},
          parts = typeof value === "string" ? value.split(" ") : [value];
        for (; i < 4; i++) {
          expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
        }
        return expanded;
      }
    };
    if (prefix !== "margin") {
      _jQuery2.cssHooks[prefix + suffix].set = setPositiveNumber;
    }
  });
  _jQuery2.fn.extend({
    css: function css(name, value) {
      return _access(this, function (elem, name, value) {
        var styles,
          len,
          map = {},
          i = 0;
        if (Array.isArray(name)) {
          styles = getStyles(elem);
          len = name.length;
          for (; i < len; i++) {
            map[name[i]] = _jQuery2.css(elem, name[i], false, styles);
          }
          return map;
        }
        return value !== undefined ? _jQuery2.style(elem, name, value) : _jQuery2.css(elem, name);
      }, name, value, arguments.length > 1);
    }
  });
  function Tween(elem, options, prop, end, easing) {
    return new Tween.prototype.init(elem, options, prop, end, easing);
  }
  _jQuery2.Tween = Tween;
  Tween.prototype = {
    constructor: Tween,
    init: function init(elem, options, prop, end, easing, unit) {
      this.elem = elem;
      this.prop = prop;
      this.easing = easing || _jQuery2.easing._default;
      this.options = options;
      this.start = this.now = this.cur();
      this.end = end;
      this.unit = unit || (_jQuery2.cssNumber[prop] ? "" : "px");
    },
    cur: function cur() {
      var hooks = Tween.propHooks[this.prop];
      return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
    },
    run: function run(percent) {
      var eased,
        hooks = Tween.propHooks[this.prop];
      if (this.options.duration) {
        this.pos = eased = _jQuery2.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
      } else {
        this.pos = eased = percent;
      }
      this.now = (this.end - this.start) * eased + this.start;
      if (this.options.step) {
        this.options.step.call(this.elem, this.now, this);
      }
      if (hooks && hooks.set) {
        hooks.set(this);
      } else {
        Tween.propHooks._default.set(this);
      }
      return this;
    }
  };
  Tween.prototype.init.prototype = Tween.prototype;
  Tween.propHooks = {
    _default: {
      get: function get(tween) {
        var result;
        if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
          return tween.elem[tween.prop];
        }
        result = _jQuery2.css(tween.elem, tween.prop, "");
        return !result || result === "auto" ? 0 : result;
      },
      set: function set(tween) {
        if (_jQuery2.fx.step[tween.prop]) {
          _jQuery2.fx.step[tween.prop](tween);
        } else if (tween.elem.nodeType === 1 && (tween.elem.style[_jQuery2.cssProps[tween.prop]] != null || _jQuery2.cssHooks[tween.prop])) {
          _jQuery2.style(tween.elem, tween.prop, tween.now + tween.unit);
        } else {
          tween.elem[tween.prop] = tween.now;
        }
      }
    }
  };
  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
    set: function set(tween) {
      if (tween.elem.nodeType && tween.elem.parentNode) {
        tween.elem[tween.prop] = tween.now;
      }
    }
  };
  _jQuery2.easing = {
    linear: function linear(p) {
      return p;
    },
    swing: function swing(p) {
      return 0.5 - Math.cos(p * Math.PI) / 2;
    },
    _default: "swing"
  };
  _jQuery2.fx = Tween.prototype.init;
  _jQuery2.fx.step = {};
  var fxNow,
    inProgress,
    rfxtypes = /^(?:toggle|show|hide)$/,
    rrun = /queueHooks$/;
  function schedule() {
    if (inProgress) {
      if (document.hidden === false && window.requestAnimationFrame) {
        window.requestAnimationFrame(schedule);
      } else {
        window.setTimeout(schedule, _jQuery2.fx.interval);
      }
      _jQuery2.fx.tick();
    }
  }
  function createFxNow() {
    window.setTimeout(function () {
      fxNow = undefined;
    });
    return fxNow = Date.now();
  }
  function genFx(type, includeWidth) {
    var which,
      i = 0,
      attrs = {
        height: type
      };
    includeWidth = includeWidth ? 1 : 0;
    for (; i < 4; i += 2 - includeWidth) {
      which = cssExpand[i];
      attrs["margin" + which] = attrs["padding" + which] = type;
    }
    if (includeWidth) {
      attrs.opacity = attrs.width = type;
    }
    return attrs;
  }
  function createTween(value, prop, animation) {
    var tween,
      collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
      index = 0,
      length = collection.length;
    for (; index < length; index++) {
      if (tween = collection[index].call(animation, prop, value)) {
        return tween;
      }
    }
  }
  function defaultPrefilter(elem, props, opts) {
    var prop,
      value,
      toggle,
      hooks,
      oldfire,
      propTween,
      restoreDisplay,
      display,
      isBox = "width" in props || "height" in props,
      anim = this,
      orig = {},
      style = elem.style,
      hidden = elem.nodeType && isHiddenWithinTree(elem),
      dataShow = dataPriv.get(elem, "fxshow");
    if (!opts.queue) {
      hooks = _jQuery2._queueHooks(elem, "fx");
      if (hooks.unqueued == null) {
        hooks.unqueued = 0;
        oldfire = hooks.empty.fire;
        hooks.empty.fire = function () {
          if (!hooks.unqueued) {
            oldfire();
          }
        };
      }
      hooks.unqueued++;
      anim.always(function () {
        anim.always(function () {
          hooks.unqueued--;
          if (!_jQuery2.queue(elem, "fx").length) {
            hooks.empty.fire();
          }
        });
      });
    }
    for (prop in props) {
      value = props[prop];
      if (rfxtypes.test(value)) {
        delete props[prop];
        toggle = toggle || value === "toggle";
        if (value === (hidden ? "hide" : "show")) {
          if (value === "show" && dataShow && dataShow[prop] !== undefined) {
            hidden = true;
          } else {
            continue;
          }
        }
        orig[prop] = dataShow && dataShow[prop] || _jQuery2.style(elem, prop);
      }
    }
    propTween = !_jQuery2.isEmptyObject(props);
    if (!propTween && _jQuery2.isEmptyObject(orig)) {
      return;
    }
    if (isBox && elem.nodeType === 1) {
      opts.overflow = [style.overflow, style.overflowX, style.overflowY];
      restoreDisplay = dataShow && dataShow.display;
      if (restoreDisplay == null) {
        restoreDisplay = dataPriv.get(elem, "display");
      }
      display = _jQuery2.css(elem, "display");
      if (display === "none") {
        if (restoreDisplay) {
          display = restoreDisplay;
        } else {
          showHide([elem], true);
          restoreDisplay = elem.style.display || restoreDisplay;
          display = _jQuery2.css(elem, "display");
          showHide([elem]);
        }
      }
      if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
        if (_jQuery2.css(elem, "float") === "none") {
          if (!propTween) {
            anim.done(function () {
              style.display = restoreDisplay;
            });
            if (restoreDisplay == null) {
              display = style.display;
              restoreDisplay = display === "none" ? "" : display;
            }
          }
          style.display = "inline-block";
        }
      }
    }
    if (opts.overflow) {
      style.overflow = "hidden";
      anim.always(function () {
        style.overflow = opts.overflow[0];
        style.overflowX = opts.overflow[1];
        style.overflowY = opts.overflow[2];
      });
    }
    propTween = false;
    for (prop in orig) {
      if (!propTween) {
        if (dataShow) {
          if ("hidden" in dataShow) {
            hidden = dataShow.hidden;
          }
        } else {
          dataShow = dataPriv.access(elem, "fxshow", {
            display: restoreDisplay
          });
        }
        if (toggle) {
          dataShow.hidden = !hidden;
        }
        if (hidden) {
          showHide([elem], true);
        }
        anim.done(function () {
          if (!hidden) {
            showHide([elem]);
          }
          dataPriv.remove(elem, "fxshow");
          for (prop in orig) {
            _jQuery2.style(elem, prop, orig[prop]);
          }
        });
      }
      propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
      if (!(prop in dataShow)) {
        dataShow[prop] = propTween.start;
        if (hidden) {
          propTween.end = propTween.start;
          propTween.start = 0;
        }
      }
    }
  }
  function propFilter(props, specialEasing) {
    var index, name, easing, value, hooks;
    for (index in props) {
      name = camelCase(index);
      easing = specialEasing[name];
      value = props[index];
      if (Array.isArray(value)) {
        easing = value[1];
        value = props[index] = value[0];
      }
      if (index !== name) {
        props[name] = value;
        delete props[index];
      }
      hooks = _jQuery2.cssHooks[name];
      if (hooks && "expand" in hooks) {
        value = hooks.expand(value);
        delete props[name];
        for (index in value) {
          if (!(index in props)) {
            props[index] = value[index];
            specialEasing[index] = easing;
          }
        }
      } else {
        specialEasing[name] = easing;
      }
    }
  }
  function Animation(elem, properties, options) {
    var result,
      stopped,
      index = 0,
      length = Animation.prefilters.length,
      deferred = _jQuery2.Deferred().always(function () {
        delete tick.elem;
      }),
      tick = function tick() {
        if (stopped) {
          return false;
        }
        var currentTime = fxNow || createFxNow(),
          remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
          temp = remaining / animation.duration || 0,
          percent = 1 - temp,
          index = 0,
          length = animation.tweens.length;
        for (; index < length; index++) {
          animation.tweens[index].run(percent);
        }
        deferred.notifyWith(elem, [animation, percent, remaining]);
        if (percent < 1 && length) {
          return remaining;
        }
        if (!length) {
          deferred.notifyWith(elem, [animation, 1, 0]);
        }
        deferred.resolveWith(elem, [animation]);
        return false;
      },
      animation = deferred.promise({
        elem: elem,
        props: _jQuery2.extend({}, properties),
        opts: _jQuery2.extend(true, {
          specialEasing: {},
          easing: _jQuery2.easing._default
        }, options),
        originalProperties: properties,
        originalOptions: options,
        startTime: fxNow || createFxNow(),
        duration: options.duration,
        tweens: [],
        createTween: function createTween(prop, end) {
          var tween = _jQuery2.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
          animation.tweens.push(tween);
          return tween;
        },
        stop: function stop(gotoEnd) {
          var index = 0,
            length = gotoEnd ? animation.tweens.length : 0;
          if (stopped) {
            return this;
          }
          stopped = true;
          for (; index < length; index++) {
            animation.tweens[index].run(1);
          }
          if (gotoEnd) {
            deferred.notifyWith(elem, [animation, 1, 0]);
            deferred.resolveWith(elem, [animation, gotoEnd]);
          } else {
            deferred.rejectWith(elem, [animation, gotoEnd]);
          }
          return this;
        }
      }),
      props = animation.props;
    propFilter(props, animation.opts.specialEasing);
    for (; index < length; index++) {
      result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
      if (result) {
        if (isFunction(result.stop)) {
          _jQuery2._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
        }
        return result;
      }
    }
    _jQuery2.map(props, createTween, animation);
    if (isFunction(animation.opts.start)) {
      animation.opts.start.call(elem, animation);
    }
    animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
    _jQuery2.fx.timer(_jQuery2.extend(tick, {
      elem: elem,
      anim: animation,
      queue: animation.opts.queue
    }));
    return animation;
  }
  _jQuery2.Animation = _jQuery2.extend(Animation, {
    tweeners: {
      "*": [function (prop, value) {
        var tween = this.createTween(prop, value);
        adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
        return tween;
      }]
    },
    tweener: function tweener(props, callback) {
      if (isFunction(props)) {
        callback = props;
        props = ["*"];
      } else {
        props = props.match(rnothtmlwhite);
      }
      var prop,
        index = 0,
        length = props.length;
      for (; index < length; index++) {
        prop = props[index];
        Animation.tweeners[prop] = Animation.tweeners[prop] || [];
        Animation.tweeners[prop].unshift(callback);
      }
    },
    prefilters: [defaultPrefilter],
    prefilter: function prefilter(callback, prepend) {
      if (prepend) {
        Animation.prefilters.unshift(callback);
      } else {
        Animation.prefilters.push(callback);
      }
    }
  });
  _jQuery2.speed = function (speed, easing, fn) {
    var opt = speed && typeof speed === "object" ? _jQuery2.extend({}, speed) : {
      complete: fn || !fn && easing || isFunction(speed) && speed,
      duration: speed,
      easing: fn && easing || easing && !isFunction(easing) && easing
    };
    if (_jQuery2.fx.off) {
      opt.duration = 0;
    } else {
      if (typeof opt.duration !== "number") {
        if (opt.duration in _jQuery2.fx.speeds) {
          opt.duration = _jQuery2.fx.speeds[opt.duration];
        } else {
          opt.duration = _jQuery2.fx.speeds._default;
        }
      }
    }
    if (opt.queue == null || opt.queue === true) {
      opt.queue = "fx";
    }
    opt.old = opt.complete;
    opt.complete = function () {
      if (isFunction(opt.old)) {
        opt.old.call(this);
      }
      if (opt.queue) {
        _jQuery2.dequeue(this, opt.queue);
      }
    };
    return opt;
  };
  _jQuery2.fn.extend({
    fadeTo: function fadeTo(speed, to, easing, callback) {
      return this.filter(isHiddenWithinTree).css("opacity", 0).show().end().animate({
        opacity: to
      }, speed, easing, callback);
    },
    animate: function animate(prop, speed, easing, callback) {
      var empty = _jQuery2.isEmptyObject(prop),
        optall = _jQuery2.speed(speed, easing, callback),
        doAnimation = function doAnimation() {
          var anim = Animation(this, _jQuery2.extend({}, prop), optall);
          if (empty || dataPriv.get(this, "finish")) {
            anim.stop(true);
          }
        };
      doAnimation.finish = doAnimation;
      return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
    },
    stop: function stop(type, clearQueue, gotoEnd) {
      var stopQueue = function stopQueue(hooks) {
        var stop = hooks.stop;
        delete hooks.stop;
        stop(gotoEnd);
      };
      if (typeof type !== "string") {
        gotoEnd = clearQueue;
        clearQueue = type;
        type = undefined;
      }
      if (clearQueue && type !== false) {
        this.queue(type || "fx", []);
      }
      return this.each(function () {
        var dequeue = true,
          index = type != null && type + "queueHooks",
          timers = _jQuery2.timers,
          data = dataPriv.get(this);
        if (index) {
          if (data[index] && data[index].stop) {
            stopQueue(data[index]);
          }
        } else {
          for (index in data) {
            if (data[index] && data[index].stop && rrun.test(index)) {
              stopQueue(data[index]);
            }
          }
        }
        for (index = timers.length; index--;) {
          if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
            timers[index].anim.stop(gotoEnd);
            dequeue = false;
            timers.splice(index, 1);
          }
        }
        if (dequeue || !gotoEnd) {
          _jQuery2.dequeue(this, type);
        }
      });
    },
    finish: function finish(type) {
      if (type !== false) {
        type = type || "fx";
      }
      return this.each(function () {
        var index,
          data = dataPriv.get(this),
          queue = data[type + "queue"],
          hooks = data[type + "queueHooks"],
          timers = _jQuery2.timers,
          length = queue ? queue.length : 0;
        data.finish = true;
        _jQuery2.queue(this, type, []);
        if (hooks && hooks.stop) {
          hooks.stop.call(this, true);
        }
        for (index = timers.length; index--;) {
          if (timers[index].elem === this && timers[index].queue === type) {
            timers[index].anim.stop(true);
            timers.splice(index, 1);
          }
        }
        for (index = 0; index < length; index++) {
          if (queue[index] && queue[index].finish) {
            queue[index].finish.call(this);
          }
        }
        delete data.finish;
      });
    }
  });
  _jQuery2.each(["toggle", "show", "hide"], function (i, name) {
    var cssFn = _jQuery2.fn[name];
    _jQuery2.fn[name] = function (speed, easing, callback) {
      return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
    };
  });
  _jQuery2.each({
    slideDown: genFx("show"),
    slideUp: genFx("hide"),
    slideToggle: genFx("toggle"),
    fadeIn: {
      opacity: "show"
    },
    fadeOut: {
      opacity: "hide"
    },
    fadeToggle: {
      opacity: "toggle"
    }
  }, function (name, props) {
    _jQuery2.fn[name] = function (speed, easing, callback) {
      return this.animate(props, speed, easing, callback);
    };
  });
  _jQuery2.timers = [];
  _jQuery2.fx.tick = function () {
    var timer,
      i = 0,
      timers = _jQuery2.timers;
    fxNow = Date.now();
    for (; i < timers.length; i++) {
      timer = timers[i];
      if (!timer() && timers[i] === timer) {
        timers.splice(i--, 1);
      }
    }
    if (!timers.length) {
      _jQuery2.fx.stop();
    }
    fxNow = undefined;
  };
  _jQuery2.fx.timer = function (timer) {
    _jQuery2.timers.push(timer);
    _jQuery2.fx.start();
  };
  _jQuery2.fx.interval = 13;
  _jQuery2.fx.start = function () {
    if (inProgress) {
      return;
    }
    inProgress = true;
    schedule();
  };
  _jQuery2.fx.stop = function () {
    inProgress = null;
  };
  _jQuery2.fx.speeds = {
    slow: 600,
    fast: 200,
    _default: 400
  };
  _jQuery2.fn.delay = function (time, type) {
    time = _jQuery2.fx ? _jQuery2.fx.speeds[time] || time : time;
    type = type || "fx";
    return this.queue(type, function (next, hooks) {
      var timeout = window.setTimeout(next, time);
      hooks.stop = function () {
        window.clearTimeout(timeout);
      };
    });
  };
  (function () {
    var input = document.createElement("input"),
      select = document.createElement("select"),
      opt = select.appendChild(document.createElement("option"));
    input.type = "checkbox";
    support.checkOn = input.value !== "";
    support.optSelected = opt.selected;
    input = document.createElement("input");
    input.value = "t";
    input.type = "radio";
    support.radioValue = input.value === "t";
  })();
  var boolHook,
    attrHandle = _jQuery2.expr.attrHandle;
  _jQuery2.fn.extend({
    attr: function attr(name, value) {
      return _access(this, _jQuery2.attr, name, value, arguments.length > 1);
    },
    removeAttr: function removeAttr(name) {
      return this.each(function () {
        _jQuery2.removeAttr(this, name);
      });
    }
  });
  _jQuery2.extend({
    attr: function attr(elem, name, value) {
      var ret,
        hooks,
        nType = elem.nodeType;
      if (nType === 3 || nType === 8 || nType === 2) {
        return;
      }
      if (typeof elem.getAttribute === "undefined") {
        return _jQuery2.prop(elem, name, value);
      }
      if (nType !== 1 || !_jQuery2.isXMLDoc(elem)) {
        hooks = _jQuery2.attrHooks[name.toLowerCase()] || (_jQuery2.expr.match.bool.test(name) ? boolHook : undefined);
      }
      if (value !== undefined) {
        if (value === null) {
          _jQuery2.removeAttr(elem, name);
          return;
        }
        if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        }
        elem.setAttribute(name, value + "");
        return value;
      }
      if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      }
      ret = _jQuery2.find.attr(elem, name);
      return ret == null ? undefined : ret;
    },
    attrHooks: {
      type: {
        set: function set(elem, value) {
          if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
            var val = elem.value;
            elem.setAttribute("type", value);
            if (val) {
              elem.value = val;
            }
            return value;
          }
        }
      }
    },
    removeAttr: function removeAttr(elem, value) {
      var name,
        i = 0,
        attrNames = value && value.match(rnothtmlwhite);
      if (attrNames && elem.nodeType === 1) {
        while (name = attrNames[i++]) {
          elem.removeAttribute(name);
        }
      }
    }
  });
  boolHook = {
    set: function set(elem, value, name) {
      if (value === false) {
        _jQuery2.removeAttr(elem, name);
      } else {
        elem.setAttribute(name, name);
      }
      return name;
    }
  };
  _jQuery2.each(_jQuery2.expr.match.bool.source.match(/\w+/g), function (i, name) {
    var getter = attrHandle[name] || _jQuery2.find.attr;
    attrHandle[name] = function (elem, name, isXML) {
      var ret,
        handle,
        lowercaseName = name.toLowerCase();
      if (!isXML) {
        handle = attrHandle[lowercaseName];
        attrHandle[lowercaseName] = ret;
        ret = getter(elem, name, isXML) != null ? lowercaseName : null;
        attrHandle[lowercaseName] = handle;
      }
      return ret;
    };
  });
  var rfocusable = /^(?:input|select|textarea|button)$/i,
    rclickable = /^(?:a|area)$/i;
  _jQuery2.fn.extend({
    prop: function prop(name, value) {
      return _access(this, _jQuery2.prop, name, value, arguments.length > 1);
    },
    removeProp: function removeProp(name) {
      return this.each(function () {
        delete this[_jQuery2.propFix[name] || name];
      });
    }
  });
  _jQuery2.extend({
    prop: function prop(elem, name, value) {
      var ret,
        hooks,
        nType = elem.nodeType;
      if (nType === 3 || nType === 8 || nType === 2) {
        return;
      }
      if (nType !== 1 || !_jQuery2.isXMLDoc(elem)) {
        name = _jQuery2.propFix[name] || name;
        hooks = _jQuery2.propHooks[name];
      }
      if (value !== undefined) {
        if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        }
        return elem[name] = value;
      }
      if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      }
      return elem[name];
    },
    propHooks: {
      tabIndex: {
        get: function get(elem) {
          var tabindex = _jQuery2.find.attr(elem, "tabindex");
          if (tabindex) {
            return parseInt(tabindex, 10);
          }
          if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
            return 0;
          }
          return -1;
        }
      }
    },
    propFix: {
      "for": "htmlFor",
      "class": "className"
    }
  });
  if (!support.optSelected) {
    _jQuery2.propHooks.selected = {
      get: function get(elem) {
        var parent = elem.parentNode;
        if (parent && parent.parentNode) {
          parent.parentNode.selectedIndex;
        }
        return null;
      },
      set: function set(elem) {
        var parent = elem.parentNode;
        if (parent) {
          parent.selectedIndex;
          if (parent.parentNode) {
            parent.parentNode.selectedIndex;
          }
        }
      }
    };
  }
  _jQuery2.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
    _jQuery2.propFix[this.toLowerCase()] = this;
  });
  function stripAndCollapse(value) {
    var tokens = value.match(rnothtmlwhite) || [];
    return tokens.join(" ");
  }
  function getClass(elem) {
    return elem.getAttribute && elem.getAttribute("class") || "";
  }
  function classesToArray(value) {
    if (Array.isArray(value)) {
      return value;
    }
    if (typeof value === "string") {
      return value.match(rnothtmlwhite) || [];
    }
    return [];
  }
  _jQuery2.fn.extend({
    addClass: function addClass(value) {
      var classes,
        elem,
        cur,
        curValue,
        clazz,
        j,
        finalValue,
        i = 0;
      if (isFunction(value)) {
        return this.each(function (j) {
          _jQuery2(this).addClass(value.call(this, j, getClass(this)));
        });
      }
      classes = classesToArray(value);
      if (classes.length) {
        while (elem = this[i++]) {
          curValue = getClass(elem);
          cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
          if (cur) {
            j = 0;
            while (clazz = classes[j++]) {
              if (cur.indexOf(" " + clazz + " ") < 0) {
                cur += clazz + " ";
              }
            }
            finalValue = stripAndCollapse(cur);
            if (curValue !== finalValue) {
              elem.setAttribute("class", finalValue);
            }
          }
        }
      }
      return this;
    },
    removeClass: function removeClass(value) {
      var classes,
        elem,
        cur,
        curValue,
        clazz,
        j,
        finalValue,
        i = 0;
      if (isFunction(value)) {
        return this.each(function (j) {
          _jQuery2(this).removeClass(value.call(this, j, getClass(this)));
        });
      }
      if (!arguments.length) {
        return this.attr("class", "");
      }
      classes = classesToArray(value);
      if (classes.length) {
        while (elem = this[i++]) {
          curValue = getClass(elem);
          cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
          if (cur) {
            j = 0;
            while (clazz = classes[j++]) {
              while (cur.indexOf(" " + clazz + " ") > -1) {
                cur = cur.replace(" " + clazz + " ", " ");
              }
            }
            finalValue = stripAndCollapse(cur);
            if (curValue !== finalValue) {
              elem.setAttribute("class", finalValue);
            }
          }
        }
      }
      return this;
    },
    toggleClass: function toggleClass(value, stateVal) {
      var type = typeof value,
        isValidValue = type === "string" || Array.isArray(value);
      if (typeof stateVal === "boolean" && isValidValue) {
        return stateVal ? this.addClass(value) : this.removeClass(value);
      }
      if (isFunction(value)) {
        return this.each(function (i) {
          _jQuery2(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
        });
      }
      return this.each(function () {
        var className, i, self, classNames;
        if (isValidValue) {
          i = 0;
          self = _jQuery2(this);
          classNames = classesToArray(value);
          while (className = classNames[i++]) {
            if (self.hasClass(className)) {
              self.removeClass(className);
            } else {
              self.addClass(className);
            }
          }
        } else if (value === undefined || type === "boolean") {
          className = getClass(this);
          if (className) {
            dataPriv.set(this, "__className__", className);
          }
          if (this.setAttribute) {
            this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
          }
        }
      });
    },
    hasClass: function hasClass(selector) {
      var className,
        elem,
        i = 0;
      className = " " + selector + " ";
      while (elem = this[i++]) {
        if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
          return true;
        }
      }
      return false;
    }
  });
  var rreturn = /\r/g;
  _jQuery2.fn.extend({
    val: function val(value) {
      var hooks,
        ret,
        valueIsFunction,
        elem = this[0];
      if (!arguments.length) {
        if (elem) {
          hooks = _jQuery2.valHooks[elem.type] || _jQuery2.valHooks[elem.nodeName.toLowerCase()];
          if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
            return ret;
          }
          ret = elem.value;
          if (typeof ret === "string") {
            return ret.replace(rreturn, "");
          }
          return ret == null ? "" : ret;
        }
        return;
      }
      valueIsFunction = isFunction(value);
      return this.each(function (i) {
        var val;
        if (this.nodeType !== 1) {
          return;
        }
        if (valueIsFunction) {
          val = value.call(this, i, _jQuery2(this).val());
        } else {
          val = value;
        }
        if (val == null) {
          val = "";
        } else if (typeof val === "number") {
          val += "";
        } else if (Array.isArray(val)) {
          val = _jQuery2.map(val, function (value) {
            return value == null ? "" : value + "";
          });
        }
        hooks = _jQuery2.valHooks[this.type] || _jQuery2.valHooks[this.nodeName.toLowerCase()];
        if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
          this.value = val;
        }
      });
    }
  });
  _jQuery2.extend({
    valHooks: {
      option: {
        get: function get(elem) {
          var val = _jQuery2.find.attr(elem, "value");
          return val != null ? val : stripAndCollapse(_jQuery2.text(elem));
        }
      },
      select: {
        get: function get(elem) {
          var value,
            option,
            i,
            options = elem.options,
            index = elem.selectedIndex,
            one = elem.type === "select-one",
            values = one ? null : [],
            max = one ? index + 1 : options.length;
          if (index < 0) {
            i = max;
          } else {
            i = one ? index : 0;
          }
          for (; i < max; i++) {
            option = options[i];
            if ((option.selected || i === index) && !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
              value = _jQuery2(option).val();
              if (one) {
                return value;
              }
              values.push(value);
            }
          }
          return values;
        },
        set: function set(elem, value) {
          var optionSet,
            option,
            options = elem.options,
            values = _jQuery2.makeArray(value),
            i = options.length;
          while (i--) {
            option = options[i];
            if (option.selected = _jQuery2.inArray(_jQuery2.valHooks.option.get(option), values) > -1) {
              optionSet = true;
            }
          }
          if (!optionSet) {
            elem.selectedIndex = -1;
          }
          return values;
        }
      }
    }
  });
  _jQuery2.each(["radio", "checkbox"], function () {
    _jQuery2.valHooks[this] = {
      set: function set(elem, value) {
        if (Array.isArray(value)) {
          return elem.checked = _jQuery2.inArray(_jQuery2(elem).val(), value) > -1;
        }
      }
    };
    if (!support.checkOn) {
      _jQuery2.valHooks[this].get = function (elem) {
        return elem.getAttribute("value") === null ? "on" : elem.value;
      };
    }
  });
  support.focusin = "onfocusin" in window;
  var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
    stopPropagationCallback = function stopPropagationCallback(e) {
      e.stopPropagation();
    };
  _jQuery2.extend(_jQuery2.event, {
    trigger: function trigger(event, data, elem, onlyHandlers) {
      var i,
        cur,
        tmp,
        bubbleType,
        ontype,
        handle,
        special,
        lastElement,
        eventPath = [elem || document],
        type = hasOwn.call(event, "type") ? event.type : event,
        namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
      cur = lastElement = tmp = elem = elem || document;
      if (elem.nodeType === 3 || elem.nodeType === 8) {
        return;
      }
      if (rfocusMorph.test(type + _jQuery2.event.triggered)) {
        return;
      }
      if (type.indexOf(".") > -1) {
        namespaces = type.split(".");
        type = namespaces.shift();
        namespaces.sort();
      }
      ontype = type.indexOf(":") < 0 && "on" + type;
      event = event[_jQuery2.expando] ? event : new _jQuery2.Event(type, typeof event === "object" && event);
      event.isTrigger = onlyHandlers ? 2 : 3;
      event.namespace = namespaces.join(".");
      event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
      event.result = undefined;
      if (!event.target) {
        event.target = elem;
      }
      data = data == null ? [event] : _jQuery2.makeArray(data, [event]);
      special = _jQuery2.event.special[type] || {};
      if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
        return;
      }
      if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
        bubbleType = special.delegateType || type;
        if (!rfocusMorph.test(bubbleType + type)) {
          cur = cur.parentNode;
        }
        for (; cur; cur = cur.parentNode) {
          eventPath.push(cur);
          tmp = cur;
        }
        if (tmp === (elem.ownerDocument || document)) {
          eventPath.push(tmp.defaultView || tmp.parentWindow || window);
        }
      }
      i = 0;
      while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
        lastElement = cur;
        event.type = i > 1 ? bubbleType : special.bindType || type;
        handle = (dataPriv.get(cur, "events") || {})[event.type] && dataPriv.get(cur, "handle");
        if (handle) {
          handle.apply(cur, data);
        }
        handle = ontype && cur[ontype];
        if (handle && handle.apply && acceptData(cur)) {
          event.result = handle.apply(cur, data);
          if (event.result === false) {
            event.preventDefault();
          }
        }
      }
      event.type = type;
      if (!onlyHandlers && !event.isDefaultPrevented()) {
        if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
          if (ontype && isFunction(elem[type]) && !isWindow(elem)) {
            tmp = elem[ontype];
            if (tmp) {
              elem[ontype] = null;
            }
            _jQuery2.event.triggered = type;
            if (event.isPropagationStopped()) {
              lastElement.addEventListener(type, stopPropagationCallback);
            }
            elem[type]();
            if (event.isPropagationStopped()) {
              lastElement.removeEventListener(type, stopPropagationCallback);
            }
            _jQuery2.event.triggered = undefined;
            if (tmp) {
              elem[ontype] = tmp;
            }
          }
        }
      }
      return event.result;
    },
    simulate: function simulate(type, elem, event) {
      var e = _jQuery2.extend(new _jQuery2.Event(), event, {
        type: type,
        isSimulated: true
      });
      _jQuery2.event.trigger(e, null, elem);
    }
  });
  _jQuery2.fn.extend({
    trigger: function trigger(type, data) {
      return this.each(function () {
        _jQuery2.event.trigger(type, data, this);
      });
    },
    triggerHandler: function triggerHandler(type, data) {
      var elem = this[0];
      if (elem) {
        return _jQuery2.event.trigger(type, data, elem, true);
      }
    }
  });
  if (!support.focusin) {
    _jQuery2.each({
      focus: "focusin",
      blur: "focusout"
    }, function (orig, fix) {
      var handler = function handler(event) {
        _jQuery2.event.simulate(fix, event.target, _jQuery2.event.fix(event));
      };
      _jQuery2.event.special[fix] = {
        setup: function setup() {
          var doc = this.ownerDocument || this,
            attaches = dataPriv.access(doc, fix);
          if (!attaches) {
            doc.addEventListener(orig, handler, true);
          }
          dataPriv.access(doc, fix, (attaches || 0) + 1);
        },
        teardown: function teardown() {
          var doc = this.ownerDocument || this,
            attaches = dataPriv.access(doc, fix) - 1;
          if (!attaches) {
            doc.removeEventListener(orig, handler, true);
            dataPriv.remove(doc, fix);
          } else {
            dataPriv.access(doc, fix, attaches);
          }
        }
      };
    });
  }
  var location = window.location;
  var nonce = Date.now();
  var rquery = /\?/;
  _jQuery2.parseXML = function (data) {
    var xml;
    if (!data || typeof data !== "string") {
      return null;
    }
    try {
      xml = new window.DOMParser().parseFromString(data, "text/xml");
    } catch (e) {
      xml = undefined;
    }
    if (!xml || xml.getElementsByTagName("parsererror").length) {
      _jQuery2.error("Invalid XML: " + data);
    }
    return xml;
  };
  var rbracket = /\[\]$/,
    rCRLF = /\r?\n/g,
    rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
    rsubmittable = /^(?:input|select|textarea|keygen)/i;
  function buildParams(prefix, obj, traditional, add) {
    var name;
    if (Array.isArray(obj)) {
      _jQuery2.each(obj, function (i, v) {
        if (traditional || rbracket.test(prefix)) {
          add(prefix, v);
        } else {
          buildParams(prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]", v, traditional, add);
        }
      });
    } else if (!traditional && toType(obj) === "object") {
      for (name in obj) {
        buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
      }
    } else {
      add(prefix, obj);
    }
  }
  _jQuery2.param = function (a, traditional) {
    var prefix,
      s = [],
      add = function add(key, valueOrFunction) {
        var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
        s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
      };
    if (Array.isArray(a) || a.jquery && !_jQuery2.isPlainObject(a)) {
      _jQuery2.each(a, function () {
        add(this.name, this.value);
      });
    } else {
      for (prefix in a) {
        buildParams(prefix, a[prefix], traditional, add);
      }
    }
    return s.join("&");
  };
  _jQuery2.fn.extend({
    serialize: function serialize() {
      return _jQuery2.param(this.serializeArray());
    },
    serializeArray: function serializeArray() {
      return this.map(function () {
        var elements = _jQuery2.prop(this, "elements");
        return elements ? _jQuery2.makeArray(elements) : this;
      }).filter(function () {
        var type = this.type;
        return this.name && !_jQuery2(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
      }).map(function (i, elem) {
        var val = _jQuery2(this).val();
        if (val == null) {
          return null;
        }
        if (Array.isArray(val)) {
          return _jQuery2.map(val, function (val) {
            return {
              name: elem.name,
              value: val.replace(rCRLF, "\r\n")
            };
          });
        }
        return {
          name: elem.name,
          value: val.replace(rCRLF, "\r\n")
        };
      }).get();
    }
  });
  var r20 = /%20/g,
    rhash = /#.*$/,
    rantiCache = /([?&])_=[^&]*/,
    rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
    rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
    rnoContent = /^(?:GET|HEAD)$/,
    rprotocol = /^\/\//,
    prefilters = {},
    transports = {},
    allTypes = "*/".concat("*"),
    originAnchor = document.createElement("a");
  originAnchor.href = location.href;
  function addToPrefiltersOrTransports(structure) {
    return function (dataTypeExpression, func) {
      if (typeof dataTypeExpression !== "string") {
        func = dataTypeExpression;
        dataTypeExpression = "*";
      }
      var dataType,
        i = 0,
        dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
      if (isFunction(func)) {
        while (dataType = dataTypes[i++]) {
          if (dataType[0] === "+") {
            dataType = dataType.slice(1) || "*";
            (structure[dataType] = structure[dataType] || []).unshift(func);
          } else {
            (structure[dataType] = structure[dataType] || []).push(func);
          }
        }
      }
    };
  }
  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
    var inspected = {},
      seekingTransport = structure === transports;
    function inspect(dataType) {
      var selected;
      inspected[dataType] = true;
      _jQuery2.each(structure[dataType] || [], function (_, prefilterOrFactory) {
        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
        if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
          options.dataTypes.unshift(dataTypeOrTransport);
          inspect(dataTypeOrTransport);
          return false;
        } else if (seekingTransport) {
          return !(selected = dataTypeOrTransport);
        }
      });
      return selected;
    }
    return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
  }
  function ajaxExtend(target, src) {
    var key,
      deep,
      flatOptions = _jQuery2.ajaxSettings.flatOptions || {};
    for (key in src) {
      if (src[key] !== undefined) {
        (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
      }
    }
    if (deep) {
      _jQuery2.extend(true, target, deep);
    }
    return target;
  }
  function ajaxHandleResponses(s, jqXHR, responses) {
    var ct,
      type,
      finalDataType,
      firstDataType,
      contents = s.contents,
      dataTypes = s.dataTypes;
    while (dataTypes[0] === "*") {
      dataTypes.shift();
      if (ct === undefined) {
        ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
      }
    }
    if (ct) {
      for (type in contents) {
        if (contents[type] && contents[type].test(ct)) {
          dataTypes.unshift(type);
          break;
        }
      }
    }
    if (dataTypes[0] in responses) {
      finalDataType = dataTypes[0];
    } else {
      for (type in responses) {
        if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
          finalDataType = type;
          break;
        }
        if (!firstDataType) {
          firstDataType = type;
        }
      }
      finalDataType = finalDataType || firstDataType;
    }
    if (finalDataType) {
      if (finalDataType !== dataTypes[0]) {
        dataTypes.unshift(finalDataType);
      }
      return responses[finalDataType];
    }
  }
  function ajaxConvert(s, response, jqXHR, isSuccess) {
    var conv2,
      current,
      conv,
      tmp,
      prev,
      converters = {},
      dataTypes = s.dataTypes.slice();
    if (dataTypes[1]) {
      for (conv in s.converters) {
        converters[conv.toLowerCase()] = s.converters[conv];
      }
    }
    current = dataTypes.shift();
    while (current) {
      if (s.responseFields[current]) {
        jqXHR[s.responseFields[current]] = response;
      }
      if (!prev && isSuccess && s.dataFilter) {
        response = s.dataFilter(response, s.dataType);
      }
      prev = current;
      current = dataTypes.shift();
      if (current) {
        if (current === "*") {
          current = prev;
        } else if (prev !== "*" && prev !== current) {
          conv = converters[prev + " " + current] || converters["* " + current];
          if (!conv) {
            for (conv2 in converters) {
              tmp = conv2.split(" ");
              if (tmp[1] === current) {
                conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                if (conv) {
                  if (conv === true) {
                    conv = converters[conv2];
                  } else if (converters[conv2] !== true) {
                    current = tmp[0];
                    dataTypes.unshift(tmp[1]);
                  }
                  break;
                }
              }
            }
          }
          if (conv !== true) {
            if (conv && s.throws) {
              response = conv(response);
            } else {
              try {
                response = conv(response);
              } catch (e) {
                return {
                  state: "parsererror",
                  error: conv ? e : "No conversion from " + prev + " to " + current
                };
              }
            }
          }
        }
      }
    }
    return {
      state: "success",
      data: response
    };
  }
  _jQuery2.extend({
    active: 0,
    lastModified: {},
    etag: {},
    ajaxSettings: {
      url: location.href,
      type: "GET",
      isLocal: rlocalProtocol.test(location.protocol),
      global: true,
      processData: true,
      async: true,
      contentType: "application/x-www-form-urlencoded; charset=UTF-8",
      accepts: {
        "*": allTypes,
        text: "text/plain",
        html: "text/html",
        xml: "application/xml, text/xml",
        json: "application/json, text/javascript"
      },
      contents: {
        xml: /\bxml\b/,
        html: /\bhtml/,
        json: /\bjson\b/
      },
      responseFields: {
        xml: "responseXML",
        text: "responseText",
        json: "responseJSON"
      },
      converters: {
        "* text": String,
        "text html": true,
        "text json": JSON.parse,
        "text xml": _jQuery2.parseXML
      },
      flatOptions: {
        url: true,
        context: true
      }
    },
    ajaxSetup: function ajaxSetup(target, settings) {
      return settings ? ajaxExtend(ajaxExtend(target, _jQuery2.ajaxSettings), settings) : ajaxExtend(_jQuery2.ajaxSettings, target);
    },
    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
    ajaxTransport: addToPrefiltersOrTransports(transports),
    ajax: function ajax(url, options) {
      if (typeof url === "object") {
        options = url;
        url = undefined;
      }
      options = options || {};
      var transport,
        cacheURL,
        responseHeadersString,
        responseHeaders,
        timeoutTimer,
        urlAnchor,
        completed,
        fireGlobals,
        i,
        uncached,
        s = _jQuery2.ajaxSetup({}, options),
        callbackContext = s.context || s,
        globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? _jQuery2(callbackContext) : _jQuery2.event,
        deferred = _jQuery2.Deferred(),
        completeDeferred = _jQuery2.Callbacks("once memory"),
        _statusCode = s.statusCode || {},
        requestHeaders = {},
        requestHeadersNames = {},
        strAbort = "canceled",
        jqXHR = {
          readyState: 0,
          getResponseHeader: function getResponseHeader(key) {
            var match;
            if (completed) {
              if (!responseHeaders) {
                responseHeaders = {};
                while (match = rheaders.exec(responseHeadersString)) {
                  responseHeaders[match[1].toLowerCase()] = match[2];
                }
              }
              match = responseHeaders[key.toLowerCase()];
            }
            return match == null ? null : match;
          },
          getAllResponseHeaders: function getAllResponseHeaders() {
            return completed ? responseHeadersString : null;
          },
          setRequestHeader: function setRequestHeader(name, value) {
            if (completed == null) {
              name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
              requestHeaders[name] = value;
            }
            return this;
          },
          overrideMimeType: function overrideMimeType(type) {
            if (completed == null) {
              s.mimeType = type;
            }
            return this;
          },
          statusCode: function statusCode(map) {
            var code;
            if (map) {
              if (completed) {
                jqXHR.always(map[jqXHR.status]);
              } else {
                for (code in map) {
                  _statusCode[code] = [_statusCode[code], map[code]];
                }
              }
            }
            return this;
          },
          abort: function abort(statusText) {
            var finalText = statusText || strAbort;
            if (transport) {
              transport.abort(finalText);
            }
            done(0, finalText);
            return this;
          }
        };
      deferred.promise(jqXHR);
      s.url = ((url || s.url || location.href) + "").replace(rprotocol, location.protocol + "//");
      s.type = options.method || options.type || s.method || s.type;
      s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];
      if (s.crossDomain == null) {
        urlAnchor = document.createElement("a");
        try {
          urlAnchor.href = s.url;
          urlAnchor.href = urlAnchor.href;
          s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
        } catch (e) {
          s.crossDomain = true;
        }
      }
      if (s.data && s.processData && typeof s.data !== "string") {
        s.data = _jQuery2.param(s.data, s.traditional);
      }
      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
      if (completed) {
        return jqXHR;
      }
      fireGlobals = _jQuery2.event && s.global;
      if (fireGlobals && _jQuery2.active++ === 0) {
        _jQuery2.event.trigger("ajaxStart");
      }
      s.type = s.type.toUpperCase();
      s.hasContent = !rnoContent.test(s.type);
      cacheURL = s.url.replace(rhash, "");
      if (!s.hasContent) {
        uncached = s.url.slice(cacheURL.length);
        if (s.data && (s.processData || typeof s.data === "string")) {
          cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data;
          delete s.data;
        }
        if (s.cache === false) {
          cacheURL = cacheURL.replace(rantiCache, "$1");
          uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++ + uncached;
        }
        s.url = cacheURL + uncached;
      } else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
        s.data = s.data.replace(r20, "+");
      }
      if (s.ifModified) {
        if (_jQuery2.lastModified[cacheURL]) {
          jqXHR.setRequestHeader("If-Modified-Since", _jQuery2.lastModified[cacheURL]);
        }
        if (_jQuery2.etag[cacheURL]) {
          jqXHR.setRequestHeader("If-None-Match", _jQuery2.etag[cacheURL]);
        }
      }
      if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
        jqXHR.setRequestHeader("Content-Type", s.contentType);
      }
      jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
      for (i in s.headers) {
        jqXHR.setRequestHeader(i, s.headers[i]);
      }
      if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {
        return jqXHR.abort();
      }
      strAbort = "abort";
      completeDeferred.add(s.complete);
      jqXHR.done(s.success);
      jqXHR.fail(s.error);
      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
      if (!transport) {
        done(-1, "No Transport");
      } else {
        jqXHR.readyState = 1;
        if (fireGlobals) {
          globalEventContext.trigger("ajaxSend", [jqXHR, s]);
        }
        if (completed) {
          return jqXHR;
        }
        if (s.async && s.timeout > 0) {
          timeoutTimer = window.setTimeout(function () {
            jqXHR.abort("timeout");
          }, s.timeout);
        }
        try {
          completed = false;
          transport.send(requestHeaders, done);
        } catch (e) {
          if (completed) {
            throw e;
          }
          done(-1, e);
        }
      }
      function done(status, nativeStatusText, responses, headers) {
        var isSuccess,
          success,
          error,
          response,
          modified,
          statusText = nativeStatusText;
        if (completed) {
          return;
        }
        completed = true;
        if (timeoutTimer) {
          window.clearTimeout(timeoutTimer);
        }
        transport = undefined;
        responseHeadersString = headers || "";
        jqXHR.readyState = status > 0 ? 4 : 0;
        isSuccess = status >= 200 && status < 300 || status === 304;
        if (responses) {
          response = ajaxHandleResponses(s, jqXHR, responses);
        }
        response = ajaxConvert(s, response, jqXHR, isSuccess);
        if (isSuccess) {
          if (s.ifModified) {
            modified = jqXHR.getResponseHeader("Last-Modified");
            if (modified) {
              _jQuery2.lastModified[cacheURL] = modified;
            }
            modified = jqXHR.getResponseHeader("etag");
            if (modified) {
              _jQuery2.etag[cacheURL] = modified;
            }
          }
          if (status === 204 || s.type === "HEAD") {
            statusText = "nocontent";
          } else if (status === 304) {
            statusText = "notmodified";
          } else {
            statusText = response.state;
            success = response.data;
            error = response.error;
            isSuccess = !error;
          }
        } else {
          error = statusText;
          if (status || !statusText) {
            statusText = "error";
            if (status < 0) {
              status = 0;
            }
          }
        }
        jqXHR.status = status;
        jqXHR.statusText = (nativeStatusText || statusText) + "";
        if (isSuccess) {
          deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
        } else {
          deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
        }
        jqXHR.statusCode(_statusCode);
        _statusCode = undefined;
        if (fireGlobals) {
          globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
        }
        completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
        if (fireGlobals) {
          globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
          if (! --_jQuery2.active) {
            _jQuery2.event.trigger("ajaxStop");
          }
        }
      }
      return jqXHR;
    },
    getJSON: function getJSON(url, data, callback) {
      return _jQuery2.get(url, data, callback, "json");
    },
    getScript: function getScript(url, callback) {
      return _jQuery2.get(url, undefined, callback, "script");
    }
  });
  _jQuery2.each(["get", "post"], function (i, method) {
    _jQuery2[method] = function (url, data, callback, type) {
      if (isFunction(data)) {
        type = type || callback;
        callback = data;
        data = undefined;
      }
      return _jQuery2.ajax(_jQuery2.extend({
        url: url,
        type: method,
        dataType: type,
        data: data,
        success: callback
      }, _jQuery2.isPlainObject(url) && url));
    };
  });
  _jQuery2._evalUrl = function (url) {
    return _jQuery2.ajax({
      url: url,
      type: "GET",
      dataType: "script",
      cache: true,
      async: false,
      global: false,
      "throws": true
    });
  };
  _jQuery2.fn.extend({
    wrapAll: function wrapAll(html) {
      var wrap;
      if (this[0]) {
        if (isFunction(html)) {
          html = html.call(this[0]);
        }
        wrap = _jQuery2(html, this[0].ownerDocument).eq(0).clone(true);
        if (this[0].parentNode) {
          wrap.insertBefore(this[0]);
        }
        wrap.map(function () {
          var elem = this;
          while (elem.firstElementChild) {
            elem = elem.firstElementChild;
          }
          return elem;
        }).append(this);
      }
      return this;
    },
    wrapInner: function wrapInner(html) {
      if (isFunction(html)) {
        return this.each(function (i) {
          _jQuery2(this).wrapInner(html.call(this, i));
        });
      }
      return this.each(function () {
        var self = _jQuery2(this),
          contents = self.contents();
        if (contents.length) {
          contents.wrapAll(html);
        } else {
          self.append(html);
        }
      });
    },
    wrap: function wrap(html) {
      var htmlIsFunction = isFunction(html);
      return this.each(function (i) {
        _jQuery2(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
      });
    },
    unwrap: function unwrap(selector) {
      this.parent(selector).not("body").each(function () {
        _jQuery2(this).replaceWith(this.childNodes);
      });
      return this;
    }
  });
  _jQuery2.expr.pseudos.hidden = function (elem) {
    return !_jQuery2.expr.pseudos.visible(elem);
  };
  _jQuery2.expr.pseudos.visible = function (elem) {
    return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
  };
  _jQuery2.ajaxSettings.xhr = function () {
    try {
      return new window.XMLHttpRequest();
    } catch (e) {}
  };
  var xhrSuccessStatus = {
      0: 200,
      1223: 204
    },
    xhrSupported = _jQuery2.ajaxSettings.xhr();
  support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
  support.ajax = xhrSupported = !!xhrSupported;
  _jQuery2.ajaxTransport(function (options) {
    var _callback, errorCallback;
    if (support.cors || xhrSupported && !options.crossDomain) {
      return {
        send: function send(headers, complete) {
          var i,
            xhr = options.xhr();
          xhr.open(options.type, options.url, options.async, options.username, options.password);
          if (options.xhrFields) {
            for (i in options.xhrFields) {
              xhr[i] = options.xhrFields[i];
            }
          }
          if (options.mimeType && xhr.overrideMimeType) {
            xhr.overrideMimeType(options.mimeType);
          }
          if (!options.crossDomain && !headers["X-Requested-With"]) {
            headers["X-Requested-With"] = "XMLHttpRequest";
          }
          for (i in headers) {
            xhr.setRequestHeader(i, headers[i]);
          }
          _callback = function callback(type) {
            return function () {
              if (_callback) {
                _callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;
                if (type === "abort") {
                  xhr.abort();
                } else if (type === "error") {
                  if (typeof xhr.status !== "number") {
                    complete(0, "error");
                  } else {
                    complete(xhr.status, xhr.statusText);
                  }
                } else {
                  complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? {
                    binary: xhr.response
                  } : {
                    text: xhr.responseText
                  }, xhr.getAllResponseHeaders());
                }
              }
            };
          };
          xhr.onload = _callback();
          errorCallback = xhr.onerror = xhr.ontimeout = _callback("error");
          if (xhr.onabort !== undefined) {
            xhr.onabort = errorCallback;
          } else {
            xhr.onreadystatechange = function () {
              if (xhr.readyState === 4) {
                window.setTimeout(function () {
                  if (_callback) {
                    errorCallback();
                  }
                });
              }
            };
          }
          _callback = _callback("abort");
          try {
            xhr.send(options.hasContent && options.data || null);
          } catch (e) {
            if (_callback) {
              throw e;
            }
          }
        },
        abort: function abort() {
          if (_callback) {
            _callback();
          }
        }
      };
    }
  });
  _jQuery2.ajaxPrefilter(function (s) {
    if (s.crossDomain) {
      s.contents.script = false;
    }
  });
  _jQuery2.ajaxSetup({
    accepts: {
      script: "text/javascript, application/javascript, " + "application/ecmascript, application/x-ecmascript"
    },
    contents: {
      script: /\b(?:java|ecma)script\b/
    },
    converters: {
      "text script": function text_script(text) {
        _jQuery2.globalEval(text);
        return text;
      }
    }
  });
  _jQuery2.ajaxPrefilter("script", function (s) {
    if (s.cache === undefined) {
      s.cache = false;
    }
    if (s.crossDomain) {
      s.type = "GET";
    }
  });
  _jQuery2.ajaxTransport("script", function (s) {
    if (s.crossDomain) {
      var script, _callback2;
      return {
        send: function send(_, complete) {
          script = _jQuery2("<script>").prop({
            charset: s.scriptCharset,
            src: s.url
          }).on("load error", _callback2 = function callback(evt) {
            script.remove();
            _callback2 = null;
            if (evt) {
              complete(evt.type === "error" ? 404 : 200, evt.type);
            }
          });
          document.head.appendChild(script[0]);
        },
        abort: function abort() {
          if (_callback2) {
            _callback2();
          }
        }
      };
    }
  });
  var oldCallbacks = [],
    rjsonp = /(=)\?(?=&|$)|\?\?/;
  _jQuery2.ajaxSetup({
    jsonp: "callback",
    jsonpCallback: function jsonpCallback() {
      var callback = oldCallbacks.pop() || _jQuery2.expando + "_" + nonce++;
      this[callback] = true;
      return callback;
    }
  });
  _jQuery2.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {
    var callbackName,
      overwritten,
      responseContainer,
      jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");
    if (jsonProp || s.dataTypes[0] === "jsonp") {
      callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
      if (jsonProp) {
        s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
      } else if (s.jsonp !== false) {
        s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
      }
      s.converters["script json"] = function () {
        if (!responseContainer) {
          _jQuery2.error(callbackName + " was not called");
        }
        return responseContainer[0];
      };
      s.dataTypes[0] = "json";
      overwritten = window[callbackName];
      window[callbackName] = function () {
        responseContainer = arguments;
      };
      jqXHR.always(function () {
        if (overwritten === undefined) {
          _jQuery2(window).removeProp(callbackName);
        } else {
          window[callbackName] = overwritten;
        }
        if (s[callbackName]) {
          s.jsonpCallback = originalSettings.jsonpCallback;
          oldCallbacks.push(callbackName);
        }
        if (responseContainer && isFunction(overwritten)) {
          overwritten(responseContainer[0]);
        }
        responseContainer = overwritten = undefined;
      });
      return "script";
    }
  });
  support.createHTMLDocument = function () {
    var body = document.implementation.createHTMLDocument("").body;
    body.innerHTML = "<form></form><form></form>";
    return body.childNodes.length === 2;
  }();
  _jQuery2.parseHTML = function (data, context, keepScripts) {
    if (typeof data !== "string") {
      return [];
    }
    if (typeof context === "boolean") {
      keepScripts = context;
      context = false;
    }
    var base, parsed, scripts;
    if (!context) {
      if (support.createHTMLDocument) {
        context = document.implementation.createHTMLDocument("");
        base = context.createElement("base");
        base.href = document.location.href;
        context.head.appendChild(base);
      } else {
        context = document;
      }
    }
    parsed = rsingleTag.exec(data);
    scripts = !keepScripts && [];
    if (parsed) {
      return [context.createElement(parsed[1])];
    }
    parsed = buildFragment([data], context, scripts);
    if (scripts && scripts.length) {
      _jQuery2(scripts).remove();
    }
    return _jQuery2.merge([], parsed.childNodes);
  };
  _jQuery2.fn.load = function (url, params, callback) {
    var selector,
      type,
      response,
      self = this,
      off = url.indexOf(" ");
    if (off > -1) {
      selector = stripAndCollapse(url.slice(off));
      url = url.slice(0, off);
    }
    if (isFunction(params)) {
      callback = params;
      params = undefined;
    } else if (params && typeof params === "object") {
      type = "POST";
    }
    if (self.length > 0) {
      _jQuery2.ajax({
        url: url,
        type: type || "GET",
        dataType: "html",
        data: params
      }).done(function (responseText) {
        response = arguments;
        self.html(selector ? _jQuery2("<div>").append(_jQuery2.parseHTML(responseText)).find(selector) : responseText);
      }).always(callback && function (jqXHR, status) {
        self.each(function () {
          callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
        });
      });
    }
    return this;
  };
  _jQuery2.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (i, type) {
    _jQuery2.fn[type] = function (fn) {
      return this.on(type, fn);
    };
  });
  _jQuery2.expr.pseudos.animated = function (elem) {
    return _jQuery2.grep(_jQuery2.timers, function (fn) {
      return elem === fn.elem;
    }).length;
  };
  _jQuery2.offset = {
    setOffset: function setOffset(elem, options, i) {
      var curPosition,
        curLeft,
        curCSSTop,
        curTop,
        curOffset,
        curCSSLeft,
        calculatePosition,
        position = _jQuery2.css(elem, "position"),
        curElem = _jQuery2(elem),
        props = {};
      if (position === "static") {
        elem.style.position = "relative";
      }
      curOffset = curElem.offset();
      curCSSTop = _jQuery2.css(elem, "top");
      curCSSLeft = _jQuery2.css(elem, "left");
      calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
      if (calculatePosition) {
        curPosition = curElem.position();
        curTop = curPosition.top;
        curLeft = curPosition.left;
      } else {
        curTop = parseFloat(curCSSTop) || 0;
        curLeft = parseFloat(curCSSLeft) || 0;
      }
      if (isFunction(options)) {
        options = options.call(elem, i, _jQuery2.extend({}, curOffset));
      }
      if (options.top != null) {
        props.top = options.top - curOffset.top + curTop;
      }
      if (options.left != null) {
        props.left = options.left - curOffset.left + curLeft;
      }
      if ("using" in options) {
        options.using.call(elem, props);
      } else {
        curElem.css(props);
      }
    }
  };
  _jQuery2.fn.extend({
    offset: function offset(options) {
      if (arguments.length) {
        return options === undefined ? this : this.each(function (i) {
          _jQuery2.offset.setOffset(this, options, i);
        });
      }
      var rect,
        win,
        elem = this[0];
      if (!elem) {
        return;
      }
      if (!elem.getClientRects().length) {
        return {
          top: 0,
          left: 0
        };
      }
      rect = elem.getBoundingClientRect();
      win = elem.ownerDocument.defaultView;
      return {
        top: rect.top + win.pageYOffset,
        left: rect.left + win.pageXOffset
      };
    },
    position: function position() {
      if (!this[0]) {
        return;
      }
      var offsetParent,
        offset,
        doc,
        elem = this[0],
        parentOffset = {
          top: 0,
          left: 0
        };
      if (_jQuery2.css(elem, "position") === "fixed") {
        offset = elem.getBoundingClientRect();
      } else {
        offset = this.offset();
        doc = elem.ownerDocument;
        offsetParent = elem.offsetParent || doc.documentElement;
        while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && _jQuery2.css(offsetParent, "position") === "static") {
          offsetParent = offsetParent.parentNode;
        }
        if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
          parentOffset = _jQuery2(offsetParent).offset();
          parentOffset.top += _jQuery2.css(offsetParent, "borderTopWidth", true);
          parentOffset.left += _jQuery2.css(offsetParent, "borderLeftWidth", true);
        }
      }
      return {
        top: offset.top - parentOffset.top - _jQuery2.css(elem, "marginTop", true),
        left: offset.left - parentOffset.left - _jQuery2.css(elem, "marginLeft", true)
      };
    },
    offsetParent: function offsetParent() {
      return this.map(function () {
        var offsetParent = this.offsetParent;
        while (offsetParent && _jQuery2.css(offsetParent, "position") === "static") {
          offsetParent = offsetParent.offsetParent;
        }
        return offsetParent || documentElement;
      });
    }
  });
  _jQuery2.each({
    scrollLeft: "pageXOffset",
    scrollTop: "pageYOffset"
  }, function (method, prop) {
    var top = "pageYOffset" === prop;
    _jQuery2.fn[method] = function (val) {
      return _access(this, function (elem, method, val) {
        var win;
        if (isWindow(elem)) {
          win = elem;
        } else if (elem.nodeType === 9) {
          win = elem.defaultView;
        }
        if (val === undefined) {
          return win ? win[prop] : elem[method];
        }
        if (win) {
          win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
        } else {
          elem[method] = val;
        }
      }, method, val, arguments.length);
    };
  });
  _jQuery2.each(["top", "left"], function (i, prop) {
    _jQuery2.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
      if (computed) {
        computed = curCSS(elem, prop);
        return rnumnonpx.test(computed) ? _jQuery2(elem).position()[prop] + "px" : computed;
      }
    });
  });
  _jQuery2.each({
    Height: "height",
    Width: "width"
  }, function (name, type) {
    _jQuery2.each({
      padding: "inner" + name,
      content: type,
      "": "outer" + name
    }, function (defaultExtra, funcName) {
      _jQuery2.fn[funcName] = function (margin, value) {
        var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
          extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
        return _access(this, function (elem, type, value) {
          var doc;
          if (isWindow(elem)) {
            return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
          }
          if (elem.nodeType === 9) {
            doc = elem.documentElement;
            return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
          }
          return value === undefined ? _jQuery2.css(elem, type, extra) : _jQuery2.style(elem, type, value, extra);
        }, type, chainable ? margin : undefined, chainable);
      };
    });
  });
  _jQuery2.each(("blur focus focusin focusout resize scroll click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup contextmenu").split(" "), function (i, name) {
    _jQuery2.fn[name] = function (data, fn) {
      return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
    };
  });
  _jQuery2.fn.extend({
    hover: function hover(fnOver, fnOut) {
      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
    }
  });
  _jQuery2.fn.extend({
    bind: function bind(types, data, fn) {
      return this.on(types, null, data, fn);
    },
    unbind: function unbind(types, fn) {
      return this.off(types, null, fn);
    },
    delegate: function delegate(selector, types, data, fn) {
      return this.on(types, selector, data, fn);
    },
    undelegate: function undelegate(selector, types, fn) {
      return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
    }
  });
  _jQuery2.proxy = function (fn, context) {
    var tmp, args, proxy;
    if (typeof context === "string") {
      tmp = fn[context];
      context = fn;
      fn = tmp;
    }
    if (!isFunction(fn)) {
      return undefined;
    }
    args = _slice.call(arguments, 2);
    proxy = function proxy() {
      return fn.apply(context || this, args.concat(_slice.call(arguments)));
    };
    proxy.guid = fn.guid = fn.guid || _jQuery2.guid++;
    return proxy;
  };
  _jQuery2.holdReady = function (hold) {
    if (hold) {
      _jQuery2.readyWait++;
    } else {
      _jQuery2.ready(true);
    }
  };
  _jQuery2.isArray = Array.isArray;
  _jQuery2.parseJSON = JSON.parse;
  _jQuery2.nodeName = nodeName;
  _jQuery2.isFunction = isFunction;
  _jQuery2.isWindow = isWindow;
  _jQuery2.camelCase = camelCase;
  _jQuery2.type = toType;
  _jQuery2.now = Date.now;
  _jQuery2.isNumeric = function (obj) {
    var type = _jQuery2.type(obj);
    return (type === "number" || type === "string") && !isNaN(obj - parseFloat(obj));
  };
  if (typeof define === "function" && define.amd) {
    define("jquery", [], function () {
      return _jQuery2;
    });
  }
  var _jQuery = window.jQuery,
    _$ = window.$;
  _jQuery2.noConflict = function (deep) {
    if (window.$ === _jQuery2) {
      window.$ = _$;
    }
    if (deep && window.jQuery === _jQuery2) {
      window.jQuery = _jQuery;
    }
    return _jQuery2;
  };
  if (!noGlobal) {
    window.jQuery = window.$ = _jQuery2;
  }
  return _jQuery2;
});
(function () {
  'use strict';

  function asyncGeneratorStep(n, t, e, r, o, a, c) {
    try {
      var i = n[a](c),
        u = i.value;
    } catch (n) {
      return void e(n);
    }
    i.done ? t(u) : Promise.resolve(u).then(r, o);
  }
  function _asyncToGenerator(n) {
    return function () {
      var t = this,
        e = arguments;
      return new Promise(function (r, o) {
        var a = n.apply(t, e);
        function _next(n) {
          asyncGeneratorStep(a, r, o, _next, _throw, "next", n);
        }
        function _throw(n) {
          asyncGeneratorStep(a, r, o, _next, _throw, "throw", n);
        }
        _next(void 0);
      });
    };
  }
  function _regenerator() {
    /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */
    var e,
      t,
      r = "function" == typeof Symbol ? Symbol : {},
      n = r.iterator || "@@iterator",
      o = r.toStringTag || "@@toStringTag";
    function i(r, n, o, i) {
      var c = n && n.prototype instanceof Generator ? n : Generator,
        u = Object.create(c.prototype);
      return _regeneratorDefine3(u, "_invoke", function (r, n, o) {
        var i,
          c,
          u,
          f = 0,
          p = o || [],
          y = false,
          G = {
            p: 0,
            n: 0,
            v: e,
            a: d,
            f: d.bind(e, 4),
            d: function d(t, r) {
              return i = t, c = 0, u = e, G.n = r, a;
            }
          };
        function d(r, n) {
          for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) {
            var o,
              i = p[t],
              d = G.p,
              l = i[2];
            r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0));
          }
          if (o || r > 1) return a;
          throw y = true, n;
        }
        return function (o, p, l) {
          if (f > 1) throw TypeError("Generator is already running");
          for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) {
            i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u);
            try {
              if (f = 2, i) {
                if (c || (o = "next"), t = i[o]) {
                  if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object");
                  if (!t.done) return t;
                  u = t.value, c < 2 && (c = 0);
                } else 1 === c && (t = i.return) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1);
                i = e;
              } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break;
            } catch (t) {
              i = e, c = 1, u = t;
            } finally {
              f = 1;
            }
          }
          return {
            value: t,
            done: y
          };
        };
      }(r, o, i), true), u;
    }
    var a = {};
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}
    t = Object.getPrototypeOf;
    var c = [][n] ? t(t([][n]())) : (_regeneratorDefine3(t = {}, n, function () {
        return this;
      }), t),
      u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c);
    function f(e) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine3(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e;
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine3(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine3(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine3(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine3(u), _regeneratorDefine3(u, o, "Generator"), _regeneratorDefine3(u, n, function () {
      return this;
    }), _regeneratorDefine3(u, "toString", function () {
      return "[object Generator]";
    }), (_regenerator = function _regenerator() {
      return {
        w: i,
        m: f
      };
    })();
  }
  function _regeneratorDefine3(e, r, n, t) {
    var i = Object.defineProperty;
    try {
      i({}, "", {});
    } catch (e) {
      i = 0;
    }
    _regeneratorDefine3 = function _regeneratorDefine(e, r, n, t) {
      function o(r, n) {
        _regeneratorDefine3(e, r, function (e) {
          return this._invoke(r, n, e);
        });
      }
      r ? i ? i(e, r, {
        value: n,
        enumerable: !t,
        configurable: !t,
        writable: !t
      }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2));
    }, _regeneratorDefine3(e, r, n, t);
  }
  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};
  var es_symbol = {};
  var es_symbol_constructor = {};
  var globalThis_1;
  var hasRequiredGlobalThis;
  function requireGlobalThis() {
    if (hasRequiredGlobalThis) return globalThis_1;
    hasRequiredGlobalThis = 1;
    var check = function check(it) {
      return it && it.Math === Math && it;
    };
    globalThis_1 = check(typeof globalThis == 'object' && globalThis) || check(typeof window == 'object' && window) || check(typeof self == 'object' && self) || check(typeof commonjsGlobal == 'object' && commonjsGlobal) || check(typeof globalThis_1 == 'object' && globalThis_1) || function () {
      return this;
    }() || Function('return this')();
    return globalThis_1;
  }
  var objectGetOwnPropertyDescriptor = {};
  var fails;
  var hasRequiredFails;
  function requireFails() {
    if (hasRequiredFails) return fails;
    hasRequiredFails = 1;
    fails = function fails(exec) {
      try {
        return !!exec();
      } catch (error) {
        return true;
      }
    };
    return fails;
  }
  var descriptors;
  var hasRequiredDescriptors;
  function requireDescriptors() {
    if (hasRequiredDescriptors) return descriptors;
    hasRequiredDescriptors = 1;
    var fails = requireFails();
    descriptors = !fails(function () {
      return Object.defineProperty({}, 1, {
        get: function get() {
          return 7;
        }
      })[1] !== 7;
    });
    return descriptors;
  }
  var functionBindNative;
  var hasRequiredFunctionBindNative;
  function requireFunctionBindNative() {
    if (hasRequiredFunctionBindNative) return functionBindNative;
    hasRequiredFunctionBindNative = 1;
    var fails = requireFails();
    functionBindNative = !fails(function () {
      var test = function () {}.bind();
      return typeof test != 'function' || test.hasOwnProperty('prototype');
    });
    return functionBindNative;
  }
  var functionCall;
  var hasRequiredFunctionCall;
  function requireFunctionCall() {
    if (hasRequiredFunctionCall) return functionCall;
    hasRequiredFunctionCall = 1;
    var NATIVE_BIND = requireFunctionBindNative();
    var call = Function.prototype.call;
    functionCall = NATIVE_BIND ? call.bind(call) : function () {
      return call.apply(call, arguments);
    };
    return functionCall;
  }
  var objectPropertyIsEnumerable = {};
  var hasRequiredObjectPropertyIsEnumerable;
  function requireObjectPropertyIsEnumerable() {
    if (hasRequiredObjectPropertyIsEnumerable) return objectPropertyIsEnumerable;
    hasRequiredObjectPropertyIsEnumerable = 1;
    var $propertyIsEnumerable = {}.propertyIsEnumerable;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({
      1: 2
    }, 1);
    objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
      var descriptor = getOwnPropertyDescriptor(this, V);
      return !!descriptor && descriptor.enumerable;
    } : $propertyIsEnumerable;
    return objectPropertyIsEnumerable;
  }
  var createPropertyDescriptor;
  var hasRequiredCreatePropertyDescriptor;
  function requireCreatePropertyDescriptor() {
    if (hasRequiredCreatePropertyDescriptor) return createPropertyDescriptor;
    hasRequiredCreatePropertyDescriptor = 1;
    createPropertyDescriptor = function createPropertyDescriptor(bitmap, value) {
      return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value: value
      };
    };
    return createPropertyDescriptor;
  }
  var functionUncurryThis;
  var hasRequiredFunctionUncurryThis;
  function requireFunctionUncurryThis() {
    if (hasRequiredFunctionUncurryThis) return functionUncurryThis;
    hasRequiredFunctionUncurryThis = 1;
    var NATIVE_BIND = requireFunctionBindNative();
    var FunctionPrototype = Function.prototype;
    var call = FunctionPrototype.call;
    var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);
    functionUncurryThis = NATIVE_BIND ? uncurryThisWithBind : function (fn) {
      return function () {
        return call.apply(fn, arguments);
      };
    };
    return functionUncurryThis;
  }
  var classofRaw;
  var hasRequiredClassofRaw;
  function requireClassofRaw() {
    if (hasRequiredClassofRaw) return classofRaw;
    hasRequiredClassofRaw = 1;
    var uncurryThis = requireFunctionUncurryThis();
    var toString = uncurryThis({}.toString);
    var stringSlice = uncurryThis(''.slice);
    classofRaw = function classofRaw(it) {
      return stringSlice(toString(it), 8, -1);
    };
    return classofRaw;
  }
  var indexedObject;
  var hasRequiredIndexedObject;
  function requireIndexedObject() {
    if (hasRequiredIndexedObject) return indexedObject;
    hasRequiredIndexedObject = 1;
    var uncurryThis = requireFunctionUncurryThis();
    var fails = requireFails();
    var classof = requireClassofRaw();
    var $Object = Object;
    var split = uncurryThis(''.split);
    indexedObject = fails(function () {
      return !$Object('z').propertyIsEnumerable(0);
    }) ? function (it) {
      return classof(it) === 'String' ? split(it, '') : $Object(it);
    } : $Object;
    return indexedObject;
  }
  var isNullOrUndefined;
  var hasRequiredIsNullOrUndefined;
  function requireIsNullOrUndefined() {
    if (hasRequiredIsNullOrUndefined) return isNullOrUndefined;
    hasRequiredIsNullOrUndefined = 1;
    isNullOrUndefined = function isNullOrUndefined(it) {
      return it === null || it === undefined;
    };
    return isNullOrUndefined;
  }
  var requireObjectCoercible;
  var hasRequiredRequireObjectCoercible;
  function requireRequireObjectCoercible() {
    if (hasRequiredRequireObjectCoercible) return requireObjectCoercible;
    hasRequiredRequireObjectCoercible = 1;
    var isNullOrUndefined = requireIsNullOrUndefined();
    var $TypeError = TypeError;
    requireObjectCoercible = function requireObjectCoercible(it) {
      if (isNullOrUndefined(it)) throw new $TypeError("Can't call method on " + it);
      return it;
    };
    return requireObjectCoercible;
  }
  var toIndexedObject;
  var hasRequiredToIndexedObject;
  function requireToIndexedObject() {
    if (hasRequiredToIndexedObject) return toIndexedObject;
    hasRequiredToIndexedObject = 1;
    var IndexedObject = requireIndexedObject();
    var requireObjectCoercible = requireRequireObjectCoercible();
    toIndexedObject = function toIndexedObject(it) {
      return IndexedObject(requireObjectCoercible(it));
    };
    return toIndexedObject;
  }
  var isCallable;
  var hasRequiredIsCallable;
  function requireIsCallable() {
    if (hasRequiredIsCallable) return isCallable;
    hasRequiredIsCallable = 1;
    var documentAll = typeof document == 'object' && document.all;
    isCallable = typeof documentAll == 'undefined' && documentAll !== undefined ? function (argument) {
      return typeof argument == 'function' || argument === documentAll;
    } : function (argument) {
      return typeof argument == 'function';
    };
    return isCallable;
  }
  var isObject;
  var hasRequiredIsObject;
  function requireIsObject() {
    if (hasRequiredIsObject) return isObject;
    hasRequiredIsObject = 1;
    var isCallable = requireIsCallable();
    isObject = function isObject(it) {
      return typeof it == 'object' ? it !== null : isCallable(it);
    };
    return isObject;
  }
  var getBuiltIn;
  var hasRequiredGetBuiltIn;
  function requireGetBuiltIn() {
    if (hasRequiredGetBuiltIn) return getBuiltIn;
    hasRequiredGetBuiltIn = 1;
    var globalThis = requireGlobalThis();
    var isCallable = requireIsCallable();
    var aFunction = function aFunction(argument) {
      return isCallable(argument) ? argument : undefined;
    };
    getBuiltIn = function getBuiltIn(namespace, method) {
      return arguments.length < 2 ? aFunction(globalThis[namespace]) : globalThis[namespace] && globalThis[namespace][method];
    };
    return getBuiltIn;
  }
  var objectIsPrototypeOf;
  var hasRequiredObjectIsPrototypeOf;
  function requireObjectIsPrototypeOf() {
    if (hasRequiredObjectIsPrototypeOf) return objectIsPrototypeOf;
    hasRequiredObjectIsPrototypeOf = 1;
    var uncurryThis = requireFunctionUncurryThis();
    objectIsPrototypeOf = uncurryThis({}.isPrototypeOf);
    return objectIsPrototypeOf;
  }
  var environmentUserAgent;
  var hasRequiredEnvironmentUserAgent;
  function requireEnvironmentUserAgent() {
    if (hasRequiredEnvironmentUserAgent) return environmentUserAgent;
    hasRequiredEnvironmentUserAgent = 1;
    var globalThis = requireGlobalThis();
    var navigator = globalThis.navigator;
    var userAgent = navigator && navigator.userAgent;
    environmentUserAgent = userAgent ? String(userAgent) : '';
    return environmentUserAgent;
  }
  var environmentV8Version;
  var hasRequiredEnvironmentV8Version;
  function requireEnvironmentV8Version() {
    if (hasRequiredEnvironmentV8Version) return environmentV8Version;
    hasRequiredEnvironmentV8Version = 1;
    var globalThis = requireGlobalThis();
    var userAgent = requireEnvironmentUserAgent();
    var process = globalThis.process;
    var Deno = globalThis.Deno;
    var versions = process && process.versions || Deno && Deno.version;
    var v8 = versions && versions.v8;
    var match, version;
    if (v8) {
      match = v8.split('.');
      version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
    }
    if (!version && userAgent) {
      match = userAgent.match(/Edge\/(\d+)/);
      if (!match || match[1] >= 74) {
        match = userAgent.match(/Chrome\/(\d+)/);
        if (match) version = +match[1];
      }
    }
    environmentV8Version = version;
    return environmentV8Version;
  }
  var symbolConstructorDetection;
  var hasRequiredSymbolConstructorDetection;
  function requireSymbolConstructorDetection() {
    if (hasRequiredSymbolConstructorDetection) return symbolConstructorDetection;
    hasRequiredSymbolConstructorDetection = 1;
    var V8_VERSION = requireEnvironmentV8Version();
    var fails = requireFails();
    var globalThis = requireGlobalThis();
    var $String = globalThis.String;
    symbolConstructorDetection = !!Object.getOwnPropertySymbols && !fails(function () {
      var symbol = Symbol('symbol detection');
      return !$String(symbol) || !(Object(symbol) instanceof Symbol) || !Symbol.sham && V8_VERSION && V8_VERSION < 41;
    });
    return symbolConstructorDetection;
  }
  var useSymbolAsUid;
  var hasRequiredUseSymbolAsUid;
  function requireUseSymbolAsUid() {
    if (hasRequiredUseSymbolAsUid) return useSymbolAsUid;
    hasRequiredUseSymbolAsUid = 1;
    var NATIVE_SYMBOL = requireSymbolConstructorDetection();
    useSymbolAsUid = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == 'symbol';
    return useSymbolAsUid;
  }
  var isSymbol;
  var hasRequiredIsSymbol;
  function requireIsSymbol() {
    if (hasRequiredIsSymbol) return isSymbol;
    hasRequiredIsSymbol = 1;
    var getBuiltIn = requireGetBuiltIn();
    var isCallable = requireIsCallable();
    var isPrototypeOf = requireObjectIsPrototypeOf();
    var USE_SYMBOL_AS_UID = requireUseSymbolAsUid();
    var $Object = Object;
    isSymbol = USE_SYMBOL_AS_UID ? function (it) {
      return typeof it == 'symbol';
    } : function (it) {
      var $Symbol = getBuiltIn('Symbol');
      return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
    };
    return isSymbol;
  }
  var tryToString;
  var hasRequiredTryToString;
  function requireTryToString() {
    if (hasRequiredTryToString) return tryToString;
    hasRequiredTryToString = 1;
    var $String = String;
    tryToString = function tryToString(argument) {
      try {
        return $String(argument);
      } catch (error) {
        return 'Object';
      }
    };
    return tryToString;
  }
  var aCallable;
  var hasRequiredACallable;
  function requireACallable() {
    if (hasRequiredACallable) return aCallable;
    hasRequiredACallable = 1;
    var isCallable = requireIsCallable();
    var tryToString = requireTryToString();
    var $TypeError = TypeError;
    aCallable = function aCallable(argument) {
      if (isCallable(argument)) return argument;
      throw new $TypeError(tryToString(argument) + ' is not a function');
    };
    return aCallable;
  }
  var getMethod;
  var hasRequiredGetMethod;
  function requireGetMethod() {
    if (hasRequiredGetMethod) return getMethod;
    hasRequiredGetMethod = 1;
    var aCallable = requireACallable();
    var isNullOrUndefined = requireIsNullOrUndefined();
    getMethod = function getMethod(V, P) {
      var func = V[P];
      return isNullOrUndefined(func) ? undefined : aCallable(func);
    };
    return getMethod;
  }
  var ordinaryToPrimitive;
  var hasRequiredOrdinaryToPrimitive;
  function requireOrdinaryToPrimitive() {
    if (hasRequiredOrdinaryToPrimitive) return ordinaryToPrimitive;
    hasRequiredOrdinaryToPrimitive = 1;
    var call = requireFunctionCall();
    var isCallable = requireIsCallable();
    var isObject = requireIsObject();
    var $TypeError = TypeError;
    ordinaryToPrimitive = function ordinaryToPrimitive(input, pref) {
      var fn, val;
      if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
      if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
      if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
      throw new $TypeError("Can't convert object to primitive value");
    };
    return ordinaryToPrimitive;
  }
  var sharedStore = {
    exports: {}
  };
  var isPure;
  var hasRequiredIsPure;
  function requireIsPure() {
    if (hasRequiredIsPure) return isPure;
    hasRequiredIsPure = 1;
    isPure = false;
    return isPure;
  }
  var defineGlobalProperty;
  var hasRequiredDefineGlobalProperty;
  function requireDefineGlobalProperty() {
    if (hasRequiredDefineGlobalProperty) return defineGlobalProperty;
    hasRequiredDefineGlobalProperty = 1;
    var globalThis = requireGlobalThis();
    var defineProperty = Object.defineProperty;
    defineGlobalProperty = function defineGlobalProperty(key, value) {
      try {
        defineProperty(globalThis, key, {
          value: value,
          configurable: true,
          writable: true
        });
      } catch (error) {
        globalThis[key] = value;
      }
      return value;
    };
    return defineGlobalProperty;
  }
  var hasRequiredSharedStore;
  function requireSharedStore() {
    if (hasRequiredSharedStore) return sharedStore.exports;
    hasRequiredSharedStore = 1;
    var IS_PURE = requireIsPure();
    var globalThis = requireGlobalThis();
    var defineGlobalProperty = requireDefineGlobalProperty();
    var SHARED = '__core-js_shared__';
    var store = sharedStore.exports = globalThis[SHARED] || defineGlobalProperty(SHARED, {});
    (store.versions || (store.versions = [])).push({
      version: '3.45.1',
      mode: IS_PURE ? 'pure' : 'global',
      copyright: '© 2014-2025 Denis Pushkarev (zloirock.ru)',
      license: 'https://github.com/zloirock/core-js/blob/v3.45.1/LICENSE',
      source: 'https://github.com/zloirock/core-js'
    });
    return sharedStore.exports;
  }
  var shared;
  var hasRequiredShared;
  function requireShared() {
    if (hasRequiredShared) return shared;
    hasRequiredShared = 1;
    var store = requireSharedStore();
    shared = function shared(key, value) {
      return store[key] || (store[key] = value || {});
    };
    return shared;
  }
  var toObject;
  var hasRequiredToObject;
  function requireToObject() {
    if (hasRequiredToObject) return toObject;
    hasRequiredToObject = 1;
    var requireObjectCoercible = requireRequireObjectCoercible();
    var $Object = Object;
    toObject = function toObject(argument) {
      return $Object(requireObjectCoercible(argument));
    };
    return toObject;
  }
  var hasOwnProperty_1;
  var hasRequiredHasOwnProperty;
  function requireHasOwnProperty() {
    if (hasRequiredHasOwnProperty) return hasOwnProperty_1;
    hasRequiredHasOwnProperty = 1;
    var uncurryThis = requireFunctionUncurryThis();
    var toObject = requireToObject();
    var hasOwnProperty = uncurryThis({}.hasOwnProperty);
    hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {
      return hasOwnProperty(toObject(it), key);
    };
    return hasOwnProperty_1;
  }
  var uid;
  var hasRequiredUid;
  function requireUid() {
    if (hasRequiredUid) return uid;
    hasRequiredUid = 1;
    var uncurryThis = requireFunctionUncurryThis();
    var id = 0;
    var postfix = Math.random();
    var toString = uncurryThis(1.1.toString);
    uid = function uid(key) {
      return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);
    };
    return uid;
  }
  var wellKnownSymbol;
  var hasRequiredWellKnownSymbol;
  function requireWellKnownSymbol() {
    if (hasRequiredWellKnownSymbol) return wellKnownSymbol;
    hasRequiredWellKnownSymbol = 1;
    var globalThis = requireGlobalThis();
    var shared = requireShared();
    var hasOwn = requireHasOwnProperty();
    var uid = requireUid();
    var NATIVE_SYMBOL = requireSymbolConstructorDetection();
    var USE_SYMBOL_AS_UID = requireUseSymbolAsUid();
    var Symbol = globalThis.Symbol;
    var WellKnownSymbolsStore = shared('wks');
    var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol['for'] || Symbol : Symbol && Symbol.withoutSetter || uid;
    wellKnownSymbol = function wellKnownSymbol(name) {
      if (!hasOwn(WellKnownSymbolsStore, name)) {
        WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol, name) ? Symbol[name] : createWellKnownSymbol('Symbol.' + name);
      }
      return WellKnownSymbolsStore[name];
    };
    return wellKnownSymbol;
  }
  var toPrimitive;
  var hasRequiredToPrimitive;
  function requireToPrimitive() {
    if (hasRequiredToPrimitive) return toPrimitive;
    hasRequiredToPrimitive = 1;
    var call = requireFunctionCall();
    var isObject = requireIsObject();
    var isSymbol = requireIsSymbol();
    var getMethod = requireGetMethod();
    var ordinaryToPrimitive = requireOrdinaryToPrimitive();
    var wellKnownSymbol = requireWellKnownSymbol();
    var $TypeError = TypeError;
    var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
    toPrimitive = function toPrimitive(input, pref) {
      if (!isObject(input) || isSymbol(input)) return input;
      var exoticToPrim = getMethod(input, TO_PRIMITIVE);
      var result;
      if (exoticToPrim) {
        if (pref === undefined) pref = 'default';
        result = call(exoticToPrim, input, pref);
        if (!isObject(result) || isSymbol(result)) return result;
        throw new $TypeError("Can't convert object to primitive value");
      }
      if (pref === undefined) pref = 'number';
      return ordinaryToPrimitive(input, pref);
    };
    return toPrimitive;
  }
  var toPropertyKey;
  var hasRequiredToPropertyKey;
  function requireToPropertyKey() {
    if (hasRequiredToPropertyKey) return toPropertyKey;
    hasRequiredToPropertyKey = 1;
    var toPrimitive = requireToPrimitive();
    var isSymbol = requireIsSymbol();
    toPropertyKey = function toPropertyKey(argument) {
      var key = toPrimitive(argument, 'string');
      return isSymbol(key) ? key : key + '';
    };
    return toPropertyKey;
  }
  var documentCreateElement;
  var hasRequiredDocumentCreateElement;
  function requireDocumentCreateElement() {
    if (hasRequiredDocumentCreateElement) return documentCreateElement;
    hasRequiredDocumentCreateElement = 1;
    var globalThis = requireGlobalThis();
    var isObject = requireIsObject();
    var document = globalThis.document;
    var EXISTS = isObject(document) && isObject(document.createElement);
    documentCreateElement = function documentCreateElement(it) {
      return EXISTS ? document.createElement(it) : {};
    };
    return documentCreateElement;
  }
  var ie8DomDefine;
  var hasRequiredIe8DomDefine;
  function requireIe8DomDefine() {
    if (hasRequiredIe8DomDefine) return ie8DomDefine;
    hasRequiredIe8DomDefine = 1;
    var DESCRIPTORS = requireDescriptors();
    var fails = requireFails();
    var createElement = requireDocumentCreateElement();
    ie8DomDefine = !DESCRIPTORS && !fails(function () {
      return Object.defineProperty(createElement('div'), 'a', {
        get: function get() {
          return 7;
        }
      }).a !== 7;
    });
    return ie8DomDefine;
  }
  var hasRequiredObjectGetOwnPropertyDescriptor;
  function requireObjectGetOwnPropertyDescriptor() {
    if (hasRequiredObjectGetOwnPropertyDescriptor) return objectGetOwnPropertyDescriptor;
    hasRequiredObjectGetOwnPropertyDescriptor = 1;
    var DESCRIPTORS = requireDescriptors();
    var call = requireFunctionCall();
    var propertyIsEnumerableModule = requireObjectPropertyIsEnumerable();
    var createPropertyDescriptor = requireCreatePropertyDescriptor();
    var toIndexedObject = requireToIndexedObject();
    var toPropertyKey = requireToPropertyKey();
    var hasOwn = requireHasOwnProperty();
    var IE8_DOM_DEFINE = requireIe8DomDefine();
    var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    objectGetOwnPropertyDescriptor.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
      O = toIndexedObject(O);
      P = toPropertyKey(P);
      if (IE8_DOM_DEFINE) try {
        return $getOwnPropertyDescriptor(O, P);
      } catch (error) {}
      if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
    };
    return objectGetOwnPropertyDescriptor;
  }
  var objectDefineProperty = {};
  var v8PrototypeDefineBug;
  var hasRequiredV8PrototypeDefineBug;
  function requireV8PrototypeDefineBug() {
    if (hasRequiredV8PrototypeDefineBug) return v8PrototypeDefineBug;
    hasRequiredV8PrototypeDefineBug = 1;
    var DESCRIPTORS = requireDescriptors();
    var fails = requireFails();
    v8PrototypeDefineBug = DESCRIPTORS && fails(function () {
      return Object.defineProperty(function () {}, 'prototype', {
        value: 42,
        writable: false
      }).prototype !== 42;
    });
    return v8PrototypeDefineBug;
  }
  var anObject;
  var hasRequiredAnObject;
  function requireAnObject() {
    if (hasRequiredAnObject) return anObject;
    hasRequiredAnObject = 1;
    var isObject = requireIsObject();
    var $String = String;
    var $TypeError = TypeError;
    anObject = function anObject(argument) {
      if (isObject(argument)) return argument;
      throw new $TypeError($String(argument) + ' is not an object');
    };
    return anObject;
  }
  var hasRequiredObjectDefineProperty;
  function requireObjectDefineProperty() {
    if (hasRequiredObjectDefineProperty) return objectDefineProperty;
    hasRequiredObjectDefineProperty = 1;
    var DESCRIPTORS = requireDescriptors();
    var IE8_DOM_DEFINE = requireIe8DomDefine();
    var V8_PROTOTYPE_DEFINE_BUG = requireV8PrototypeDefineBug();
    var anObject = requireAnObject();
    var toPropertyKey = requireToPropertyKey();
    var $TypeError = TypeError;
    var $defineProperty = Object.defineProperty;
    var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var ENUMERABLE = 'enumerable';
    var CONFIGURABLE = 'configurable';
    var WRITABLE = 'writable';
    objectDefineProperty.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
      anObject(O);
      P = toPropertyKey(P);
      anObject(Attributes);
      if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
        var current = $getOwnPropertyDescriptor(O, P);
        if (current && current[WRITABLE]) {
          O[P] = Attributes.value;
          Attributes = {
            configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
            enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
            writable: false
          };
        }
      }
      return $defineProperty(O, P, Attributes);
    } : $defineProperty : function defineProperty(O, P, Attributes) {
      anObject(O);
      P = toPropertyKey(P);
      anObject(Attributes);
      if (IE8_DOM_DEFINE) try {
        return $defineProperty(O, P, Attributes);
      } catch (error) {}
      if ('get' in Attributes || 'set' in Attributes) throw new $TypeError('Accessors not supported');
      if ('value' in Attributes) O[P] = Attributes.value;
      return O;
    };
    return objectDefineProperty;
  }
  var createNonEnumerableProperty;
  var hasRequiredCreateNonEnumerableProperty;
  function requireCreateNonEnumerableProperty() {
    if (hasRequiredCreateNonEnumerableProperty) return createNonEnumerableProperty;
    hasRequiredCreateNonEnumerableProperty = 1;
    var DESCRIPTORS = requireDescriptors();
    var definePropertyModule = requireObjectDefineProperty();
    var createPropertyDescriptor = requireCreatePropertyDescriptor();
    createNonEnumerableProperty = DESCRIPTORS ? function (object, key, value) {
      return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
    } : function (object, key, value) {
      object[key] = value;
      return object;
    };
    return createNonEnumerableProperty;
  }
  var makeBuiltIn = {
    exports: {}
  };
  var functionName;
  var hasRequiredFunctionName;
  function requireFunctionName() {
    if (hasRequiredFunctionName) return functionName;
    hasRequiredFunctionName = 1;
    var DESCRIPTORS = requireDescriptors();
    var hasOwn = requireHasOwnProperty();
    var FunctionPrototype = Function.prototype;
    var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
    var EXISTS = hasOwn(FunctionPrototype, 'name');
    var PROPER = EXISTS && function something() {}.name === 'something';
    var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable);
    functionName = {
      EXISTS: EXISTS,
      PROPER: PROPER,
      CONFIGURABLE: CONFIGURABLE
    };
    return functionName;
  }
  var inspectSource;
  var hasRequiredInspectSource;
  function requireInspectSource() {
    if (hasRequiredInspectSource) return inspectSource;
    hasRequiredInspectSource = 1;
    var uncurryThis = requireFunctionUncurryThis();
    var isCallable = requireIsCallable();
    var store = requireSharedStore();
    var functionToString = uncurryThis(Function.toString);
    if (!isCallable(store.inspectSource)) {
      store.inspectSource = function (it) {
        return functionToString(it);
      };
    }
    inspectSource = store.inspectSource;
    return inspectSource;
  }
  var weakMapBasicDetection;
  var hasRequiredWeakMapBasicDetection;
  function requireWeakMapBasicDetection() {
    if (hasRequiredWeakMapBasicDetection) return weakMapBasicDetection;
    hasRequiredWeakMapBasicDetection = 1;
    var globalThis = requireGlobalThis();
    var isCallable = requireIsCallable();
    var WeakMap = globalThis.WeakMap;
    weakMapBasicDetection = isCallable(WeakMap) && /native code/.test(String(WeakMap));
    return weakMapBasicDetection;
  }
  var sharedKey;
  var hasRequiredSharedKey;
  function requireSharedKey() {
    if (hasRequiredSharedKey) return sharedKey;
    hasRequiredSharedKey = 1;
    var shared = requireShared();
    var uid = requireUid();
    var keys = shared('keys');
    sharedKey = function sharedKey(key) {
      return keys[key] || (keys[key] = uid(key));
    };
    return sharedKey;
  }
  var hiddenKeys;
  var hasRequiredHiddenKeys;
  function requireHiddenKeys() {
    if (hasRequiredHiddenKeys) return hiddenKeys;
    hasRequiredHiddenKeys = 1;
    hiddenKeys = {};
    return hiddenKeys;
  }
  var internalState;
  var hasRequiredInternalState;
  function requireInternalState() {
    if (hasRequiredInternalState) return internalState;
    hasRequiredInternalState = 1;
    var NATIVE_WEAK_MAP = requireWeakMapBasicDetection();
    var globalThis = requireGlobalThis();
    var isObject = requireIsObject();
    var createNonEnumerableProperty = requireCreateNonEnumerableProperty();
    var hasOwn = requireHasOwnProperty();
    var shared = requireSharedStore();
    var sharedKey = requireSharedKey();
    var hiddenKeys = requireHiddenKeys();
    var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
    var TypeError = globalThis.TypeError;
    var WeakMap = globalThis.WeakMap;
    var set, get, has;
    var enforce = function enforce(it) {
      return has(it) ? get(it) : set(it, {});
    };
    var getterFor = function getterFor(TYPE) {
      return function (it) {
        var state;
        if (!isObject(it) || (state = get(it)).type !== TYPE) {
          throw new TypeError('Incompatible receiver, ' + TYPE + ' required');
        }
        return state;
      };
    };
    if (NATIVE_WEAK_MAP || shared.state) {
      var store = shared.state || (shared.state = new WeakMap());
      store.get = store.get;
      store.has = store.has;
      store.set = store.set;
      set = function set(it, metadata) {
        if (store.has(it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        store.set(it, metadata);
        return metadata;
      };
      get = function get(it) {
        return store.get(it) || {};
      };
      has = function has(it) {
        return store.has(it);
      };
    } else {
      var STATE = sharedKey('state');
      hiddenKeys[STATE] = true;
      set = function set(it, metadata) {
        if (hasOwn(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        createNonEnumerableProperty(it, STATE, metadata);
        return metadata;
      };
      get = function get(it) {
        return hasOwn(it, STATE) ? it[STATE] : {};
      };
      has = function has(it) {
        return hasOwn(it, STATE);
      };
    }
    internalState = {
      set: set,
      get: get,
      has: has,
      enforce: enforce,
      getterFor: getterFor
    };
    return internalState;
  }
  var hasRequiredMakeBuiltIn;
  function requireMakeBuiltIn() {
    if (hasRequiredMakeBuiltIn) return makeBuiltIn.exports;
    hasRequiredMakeBuiltIn = 1;
    var uncurryThis = requireFunctionUncurryThis();
    var fails = requireFails();
    var isCallable = requireIsCallable();
    var hasOwn = requireHasOwnProperty();
    var DESCRIPTORS = requireDescriptors();
    var CONFIGURABLE_FUNCTION_NAME = requireFunctionName().CONFIGURABLE;
    var inspectSource = requireInspectSource();
    var InternalStateModule = requireInternalState();
    var enforceInternalState = InternalStateModule.enforce;
    var getInternalState = InternalStateModule.get;
    var $String = String;
    var defineProperty = Object.defineProperty;
    var stringSlice = uncurryThis(''.slice);
    var replace = uncurryThis(''.replace);
    var join = uncurryThis([].join);
    var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function () {
      return defineProperty(function () {}, 'length', {
        value: 8
      }).length !== 8;
    });
    var TEMPLATE = String(String).split('String');
    var makeBuiltIn$1 = makeBuiltIn.exports = function (value, name, options) {
      if (stringSlice($String(name), 0, 7) === 'Symbol(') {
        name = '[' + replace($String(name), /^Symbol\(([^)]*)\).*$/, '$1') + ']';
      }
      if (options && options.getter) name = 'get ' + name;
      if (options && options.setter) name = 'set ' + name;
      if (!hasOwn(value, 'name') || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {
        if (DESCRIPTORS) defineProperty(value, 'name', {
          value: name,
          configurable: true
        });else value.name = name;
      }
      if (CONFIGURABLE_LENGTH && options && hasOwn(options, 'arity') && value.length !== options.arity) {
        defineProperty(value, 'length', {
          value: options.arity
        });
      }
      try {
        if (options && hasOwn(options, 'constructor') && options.constructor) {
          if (DESCRIPTORS) defineProperty(value, 'prototype', {
            writable: false
          });
        } else if (value.prototype) value.prototype = undefined;
      } catch (error) {}
      var state = enforceInternalState(value);
      if (!hasOwn(state, 'source')) {
        state.source = join(TEMPLATE, typeof name == 'string' ? name : '');
      }
      return value;
    };
    Function.prototype.toString = makeBuiltIn$1(function toString() {
      return isCallable(this) && getInternalState(this).source || inspectSource(this);
    }, 'toString');
    return makeBuiltIn.exports;
  }
  var defineBuiltIn;
  var hasRequiredDefineBuiltIn;
  function requireDefineBuiltIn() {
    if (hasRequiredDefineBuiltIn) return defineBuiltIn;
    hasRequiredDefineBuiltIn = 1;
    var isCallable = requireIsCallable();
    var definePropertyModule = requireObjectDefineProperty();
    var makeBuiltIn = requireMakeBuiltIn();
    var defineGlobalProperty = requireDefineGlobalProperty();
    defineBuiltIn = function defineBuiltIn(O, key, value, options) {
      if (!options) options = {};
      var simple = options.enumerable;
      var name = options.name !== undefined ? options.name : key;
      if (isCallable(value)) makeBuiltIn(value, name, options);
      if (options.global) {
        if (simple) O[key] = value;else defineGlobalProperty(key, value);
      } else {
        try {
          if (!options.unsafe) delete O[key];else if (O[key]) simple = true;
        } catch (error) {}
        if (simple) O[key] = value;else definePropertyModule.f(O, key, {
          value: value,
          enumerable: false,
          configurable: !options.nonConfigurable,
          writable: !options.nonWritable
        });
      }
      return O;
    };
    return defineBuiltIn;
  }
  var objectGetOwnPropertyNames = {};
  var mathTrunc;
  var hasRequiredMathTrunc;
  function requireMathTrunc() {
    if (hasRequiredMathTrunc) return mathTrunc;
    hasRequiredMathTrunc = 1;
    var ceil = Math.ceil;
    var floor = Math.floor;
    mathTrunc = Math.trunc || function trunc(x) {
      var n = +x;
      return (n > 0 ? floor : ceil)(n);
    };
    return mathTrunc;
  }
  var toIntegerOrInfinity;
  var hasRequiredToIntegerOrInfinity;
  function requireToIntegerOrInfinity() {
    if (hasRequiredToIntegerOrInfinity) return toIntegerOrInfinity;
    hasRequiredToIntegerOrInfinity = 1;
    var trunc = requireMathTrunc();
    toIntegerOrInfinity = function toIntegerOrInfinity(argument) {
      var number = +argument;
      return number !== number || number === 0 ? 0 : trunc(number);
    };
    return toIntegerOrInfinity;
  }
  var toAbsoluteIndex;
  var hasRequiredToAbsoluteIndex;
  function requireToAbsoluteIndex() {
    if (hasRequiredToAbsoluteIndex) return toAbsoluteIndex;
    hasRequiredToAbsoluteIndex = 1;
    var toIntegerOrInfinity = requireToIntegerOrInfinity();
    var max = Math.max;
    var min = Math.min;
    toAbsoluteIndex = function toAbsoluteIndex(index, length) {
      var integer = toIntegerOrInfinity(index);
      return integer < 0 ? max(integer + length, 0) : min(integer, length);
    };
    return toAbsoluteIndex;
  }
  var toLength;
  var hasRequiredToLength;
  function requireToLength() {
    if (hasRequiredToLength) return toLength;
    hasRequiredToLength = 1;
    var toIntegerOrInfinity = requireToIntegerOrInfinity();
    var min = Math.min;
    toLength = function toLength(argument) {
      var len = toIntegerOrInfinity(argument);
      return len > 0 ? min(len, 0x1FFFFFFFFFFFFF) : 0;
    };
    return toLength;
  }
  var lengthOfArrayLike;
  var hasRequiredLengthOfArrayLike;
  function requireLengthOfArrayLike() {
    if (hasRequiredLengthOfArrayLike) return lengthOfArrayLike;
    hasRequiredLengthOfArrayLike = 1;
    var toLength = requireToLength();
    lengthOfArrayLike = function lengthOfArrayLike(obj) {
      return toLength(obj.length);
    };
    return lengthOfArrayLike;
  }
  var arrayIncludes;
  var hasRequiredArrayIncludes;
  function requireArrayIncludes() {
    if (hasRequiredArrayIncludes) return arrayIncludes;
    hasRequiredArrayIncludes = 1;
    var toIndexedObject = requireToIndexedObject();
    var toAbsoluteIndex = requireToAbsoluteIndex();
    var lengthOfArrayLike = requireLengthOfArrayLike();
    var createMethod = function createMethod(IS_INCLUDES) {
      return function ($this, el, fromIndex) {
        var O = toIndexedObject($this);
        var length = lengthOfArrayLike(O);
        if (length === 0) return !IS_INCLUDES && -1;
        var index = toAbsoluteIndex(fromIndex, length);
        var value;
        if (IS_INCLUDES && el !== el) while (length > index) {
          value = O[index++];
          if (value !== value) return true;
        } else for (; length > index; index++) {
          if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
        }
        return !IS_INCLUDES && -1;
      };
    };
    arrayIncludes = {
      includes: createMethod(true),
      indexOf: createMethod(false)
    };
    return arrayIncludes;
  }
  var objectKeysInternal;
  var hasRequiredObjectKeysInternal;
  function requireObjectKeysInternal() {
    if (hasRequiredObjectKeysInternal) return objectKeysInternal;
    hasRequiredObjectKeysInternal = 1;
    var uncurryThis = requireFunctionUncurryThis();
    var hasOwn = requireHasOwnProperty();
    var toIndexedObject = requireToIndexedObject();
    var indexOf = requireArrayIncludes().indexOf;
    var hiddenKeys = requireHiddenKeys();
    var push = uncurryThis([].push);
    objectKeysInternal = function objectKeysInternal(object, names) {
      var O = toIndexedObject(object);
      var i = 0;
      var result = [];
      var key;
      for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
      while (names.length > i) if (hasOwn(O, key = names[i++])) {
        ~indexOf(result, key) || push(result, key);
      }
      return result;
    };
    return objectKeysInternal;
  }
  var enumBugKeys;
  var hasRequiredEnumBugKeys;
  function requireEnumBugKeys() {
    if (hasRequiredEnumBugKeys) return enumBugKeys;
    hasRequiredEnumBugKeys = 1;
    enumBugKeys = ['constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf'];
    return enumBugKeys;
  }
  var hasRequiredObjectGetOwnPropertyNames;
  function requireObjectGetOwnPropertyNames() {
    if (hasRequiredObjectGetOwnPropertyNames) return objectGetOwnPropertyNames;
    hasRequiredObjectGetOwnPropertyNames = 1;
    var internalObjectKeys = requireObjectKeysInternal();
    var enumBugKeys = requireEnumBugKeys();
    var hiddenKeys = enumBugKeys.concat('length', 'prototype');
    objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
      return internalObjectKeys(O, hiddenKeys);
    };
    return objectGetOwnPropertyNames;
  }
  var objectGetOwnPropertySymbols = {};
  var hasRequiredObjectGetOwnPropertySymbols;
  function requireObjectGetOwnPropertySymbols() {
    if (hasRequiredObjectGetOwnPropertySymbols) return objectGetOwnPropertySymbols;
    hasRequiredObjectGetOwnPropertySymbols = 1;
    objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;
    return objectGetOwnPropertySymbols;
  }
  var ownKeys;
  var hasRequiredOwnKeys;
  function requireOwnKeys() {
    if (hasRequiredOwnKeys) return ownKeys;
    hasRequiredOwnKeys = 1;
    var getBuiltIn = requireGetBuiltIn();
    var uncurryThis = requireFunctionUncurryThis();
    var getOwnPropertyNamesModule = requireObjectGetOwnPropertyNames();
    var getOwnPropertySymbolsModule = requireObjectGetOwnPropertySymbols();
    var anObject = requireAnObject();
    var concat = uncurryThis([].concat);
    ownKeys = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
      var keys = getOwnPropertyNamesModule.f(anObject(it));
      var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
      return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
    };
    return ownKeys;
  }
  var copyConstructorProperties;
  var hasRequiredCopyConstructorProperties;
  function requireCopyConstructorProperties() {
    if (hasRequiredCopyConstructorProperties) return copyConstructorProperties;
    hasRequiredCopyConstructorProperties = 1;
    var hasOwn = requireHasOwnProperty();
    var ownKeys = requireOwnKeys();
    var getOwnPropertyDescriptorModule = requireObjectGetOwnPropertyDescriptor();
    var definePropertyModule = requireObjectDefineProperty();
    copyConstructorProperties = function copyConstructorProperties(target, source, exceptions) {
      var keys = ownKeys(source);
      var defineProperty = definePropertyModule.f;
      var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
          defineProperty(target, key, getOwnPropertyDescriptor(source, key));
        }
      }
    };
    return copyConstructorProperties;
  }
  var isForced_1;
  var hasRequiredIsForced;
  function requireIsForced() {
    if (hasRequiredIsForced) return isForced_1;
    hasRequiredIsForced = 1;
    var fails = requireFails();
    var isCallable = requireIsCallable();
    var replacement = /#|\.prototype\./;
    var isForced = function isForced(feature, detection) {
      var value = data[normalize(feature)];
      return value === POLYFILL ? true : value === NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;
    };
    var normalize = isForced.normalize = function (string) {
      return String(string).replace(replacement, '.').toLowerCase();
    };
    var data = isForced.data = {};
    var NATIVE = isForced.NATIVE = 'N';
    var POLYFILL = isForced.POLYFILL = 'P';
    isForced_1 = isForced;
    return isForced_1;
  }
  var _export;
  var hasRequired_export;
  function require_export() {
    if (hasRequired_export) return _export;
    hasRequired_export = 1;
    var globalThis = requireGlobalThis();
    var getOwnPropertyDescriptor = requireObjectGetOwnPropertyDescriptor().f;
    var createNonEnumerableProperty = requireCreateNonEnumerableProperty();
    var defineBuiltIn = requireDefineBuiltIn();
    var defineGlobalProperty = requireDefineGlobalProperty();
    var copyConstructorProperties = requireCopyConstructorProperties();
    var isForced = requireIsForced();
    _export = function _export(options, source) {
      var TARGET = options.target;
      var GLOBAL = options.global;
      var STATIC = options.stat;
      var FORCED, target, key, targetProperty, sourceProperty, descriptor;
      if (GLOBAL) {
        target = globalThis;
      } else if (STATIC) {
        target = globalThis[TARGET] || defineGlobalProperty(TARGET, {});
      } else {
        target = globalThis[TARGET] && globalThis[TARGET].prototype;
      }
      if (target) for (key in source) {
        sourceProperty = source[key];
        if (options.dontCallGetSet) {
          descriptor = getOwnPropertyDescriptor(target, key);
          targetProperty = descriptor && descriptor.value;
        } else targetProperty = target[key];
        FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
        if (!FORCED && targetProperty !== undefined) {
          if (typeof sourceProperty == typeof targetProperty) continue;
          copyConstructorProperties(sourceProperty, targetProperty);
        }
        if (options.sham || targetProperty && targetProperty.sham) {
          createNonEnumerableProperty(sourceProperty, 'sham', true);
        }
        defineBuiltIn(target, key, sourceProperty, options);
      }
    };
    return _export;
  }
  var toStringTagSupport;
  var hasRequiredToStringTagSupport;
  function requireToStringTagSupport() {
    if (hasRequiredToStringTagSupport) return toStringTagSupport;
    hasRequiredToStringTagSupport = 1;
    var wellKnownSymbol = requireWellKnownSymbol();
    var TO_STRING_TAG = wellKnownSymbol('toStringTag');
    var test = {};
    test[TO_STRING_TAG] = 'z';
    toStringTagSupport = String(test) === '[object z]';
    return toStringTagSupport;
  }
  var classof;
  var hasRequiredClassof;
  function requireClassof() {
    if (hasRequiredClassof) return classof;
    hasRequiredClassof = 1;
    var TO_STRING_TAG_SUPPORT = requireToStringTagSupport();
    var isCallable = requireIsCallable();
    var classofRaw = requireClassofRaw();
    var wellKnownSymbol = requireWellKnownSymbol();
    var TO_STRING_TAG = wellKnownSymbol('toStringTag');
    var $Object = Object;
    var CORRECT_ARGUMENTS = classofRaw(function () {
      return arguments;
    }()) === 'Arguments';
    var tryGet = function tryGet(it, key) {
      try {
        return it[key];
      } catch (error) {}
    };
    classof = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
      var O, tag, result;
      return it === undefined ? 'Undefined' : it === null ? 'Null' : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) === 'Object' && isCallable(O.callee) ? 'Arguments' : result;
    };
    return classof;
  }
  var toString;
  var hasRequiredToString;
  function requireToString() {
    if (hasRequiredToString) return toString;
    hasRequiredToString = 1;
    var classof = requireClassof();
    var $String = String;
    toString = function toString(argument) {
      if (classof(argument) === 'Symbol') throw new TypeError('Cannot convert a Symbol value to a string');
      return $String(argument);
    };
    return toString;
  }
  var objectDefineProperties = {};
  var objectKeys;
  var hasRequiredObjectKeys;
  function requireObjectKeys() {
    if (hasRequiredObjectKeys) return objectKeys;
    hasRequiredObjectKeys = 1;
    var internalObjectKeys = requireObjectKeysInternal();
    var enumBugKeys = requireEnumBugKeys();
    objectKeys = Object.keys || function keys(O) {
      return internalObjectKeys(O, enumBugKeys);
    };
    return objectKeys;
  }
  var hasRequiredObjectDefineProperties;
  function requireObjectDefineProperties() {
    if (hasRequiredObjectDefineProperties) return objectDefineProperties;
    hasRequiredObjectDefineProperties = 1;
    var DESCRIPTORS = requireDescriptors();
    var V8_PROTOTYPE_DEFINE_BUG = requireV8PrototypeDefineBug();
    var definePropertyModule = requireObjectDefineProperty();
    var anObject = requireAnObject();
    var toIndexedObject = requireToIndexedObject();
    var objectKeys = requireObjectKeys();
    objectDefineProperties.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
      anObject(O);
      var props = toIndexedObject(Properties);
      var keys = objectKeys(Properties);
      var length = keys.length;
      var index = 0;
      var key;
      while (length > index) definePropertyModule.f(O, key = keys[index++], props[key]);
      return O;
    };
    return objectDefineProperties;
  }
  var html;
  var hasRequiredHtml;
  function requireHtml() {
    if (hasRequiredHtml) return html;
    hasRequiredHtml = 1;
    var getBuiltIn = requireGetBuiltIn();
    html = getBuiltIn('document', 'documentElement');
    return html;
  }
  var objectCreate;
  var hasRequiredObjectCreate;
  function requireObjectCreate() {
    if (hasRequiredObjectCreate) return objectCreate;
    hasRequiredObjectCreate = 1;
    var anObject = requireAnObject();
    var definePropertiesModule = requireObjectDefineProperties();
    var enumBugKeys = requireEnumBugKeys();
    var hiddenKeys = requireHiddenKeys();
    var html = requireHtml();
    var documentCreateElement = requireDocumentCreateElement();
    var sharedKey = requireSharedKey();
    var GT = '>';
    var LT = '<';
    var PROTOTYPE = 'prototype';
    var SCRIPT = 'script';
    var IE_PROTO = sharedKey('IE_PROTO');
    var EmptyConstructor = function EmptyConstructor() {};
    var scriptTag = function scriptTag(content) {
      return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
    };
    var NullProtoObjectViaActiveX = function NullProtoObjectViaActiveX(activeXDocument) {
      activeXDocument.write(scriptTag(''));
      activeXDocument.close();
      var temp = activeXDocument.parentWindow.Object;
      activeXDocument = null;
      return temp;
    };
    var NullProtoObjectViaIFrame = function NullProtoObjectViaIFrame() {
      var iframe = documentCreateElement('iframe');
      var JS = 'java' + SCRIPT + ':';
      var iframeDocument;
      iframe.style.display = 'none';
      html.appendChild(iframe);
      iframe.src = String(JS);
      iframeDocument = iframe.contentWindow.document;
      iframeDocument.open();
      iframeDocument.write(scriptTag('document.F=Object'));
      iframeDocument.close();
      return iframeDocument.F;
    };
    var activeXDocument;
    var _NullProtoObject = function NullProtoObject() {
      try {
        activeXDocument = new ActiveXObject('htmlfile');
      } catch (error) {}
      _NullProtoObject = typeof document != 'undefined' ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
      var length = enumBugKeys.length;
      while (length--) delete _NullProtoObject[PROTOTYPE][enumBugKeys[length]];
      return _NullProtoObject();
    };
    hiddenKeys[IE_PROTO] = true;
    objectCreate = Object.create || function create(O, Properties) {
      var result;
      if (O !== null) {
        EmptyConstructor[PROTOTYPE] = anObject(O);
        result = new EmptyConstructor();
        EmptyConstructor[PROTOTYPE] = null;
        result[IE_PROTO] = O;
      } else result = _NullProtoObject();
      return Properties === undefined ? result : definePropertiesModule.f(result, Properties);
    };
    return objectCreate;
  }
  var objectGetOwnPropertyNamesExternal = {};
  var arraySlice;
  var hasRequiredArraySlice;
  function requireArraySlice() {
    if (hasRequiredArraySlice) return arraySlice;
    hasRequiredArraySlice = 1;
    var uncurryThis = requireFunctionUncurryThis();
    arraySlice = uncurryThis([].slice);
    return arraySlice;
  }
  var hasRequiredObjectGetOwnPropertyNamesExternal;
  function requireObjectGetOwnPropertyNamesExternal() {
    if (hasRequiredObjectGetOwnPropertyNamesExternal) return objectGetOwnPropertyNamesExternal;
    hasRequiredObjectGetOwnPropertyNamesExternal = 1;
    var classof = requireClassofRaw();
    var toIndexedObject = requireToIndexedObject();
    var $getOwnPropertyNames = requireObjectGetOwnPropertyNames().f;
    var arraySlice = requireArraySlice();
    var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
    var getWindowNames = function getWindowNames(it) {
      try {
        return $getOwnPropertyNames(it);
      } catch (error) {
        return arraySlice(windowNames);
      }
    };
    objectGetOwnPropertyNamesExternal.f = function getOwnPropertyNames(it) {
      return windowNames && classof(it) === 'Window' ? getWindowNames(it) : $getOwnPropertyNames(toIndexedObject(it));
    };
    return objectGetOwnPropertyNamesExternal;
  }
  var defineBuiltInAccessor;
  var hasRequiredDefineBuiltInAccessor;
  function requireDefineBuiltInAccessor() {
    if (hasRequiredDefineBuiltInAccessor) return defineBuiltInAccessor;
    hasRequiredDefineBuiltInAccessor = 1;
    var makeBuiltIn = requireMakeBuiltIn();
    var defineProperty = requireObjectDefineProperty();
    defineBuiltInAccessor = function defineBuiltInAccessor(target, name, descriptor) {
      if (descriptor.get) makeBuiltIn(descriptor.get, name, {
        getter: true
      });
      if (descriptor.set) makeBuiltIn(descriptor.set, name, {
        setter: true
      });
      return defineProperty.f(target, name, descriptor);
    };
    return defineBuiltInAccessor;
  }
  var wellKnownSymbolWrapped = {};
  var hasRequiredWellKnownSymbolWrapped;
  function requireWellKnownSymbolWrapped() {
    if (hasRequiredWellKnownSymbolWrapped) return wellKnownSymbolWrapped;
    hasRequiredWellKnownSymbolWrapped = 1;
    var wellKnownSymbol = requireWellKnownSymbol();
    wellKnownSymbolWrapped.f = wellKnownSymbol;
    return wellKnownSymbolWrapped;
  }
  var path;
  var hasRequiredPath;
  function requirePath() {
    if (hasRequiredPath) return path;
    hasRequiredPath = 1;
    var globalThis = requireGlobalThis();
    path = globalThis;
    return path;
  }
  var wellKnownSymbolDefine;
  var hasRequiredWellKnownSymbolDefine;
  function requireWellKnownSymbolDefine() {
    if (hasRequiredWellKnownSymbolDefine) return wellKnownSymbolDefine;
    hasRequiredWellKnownSymbolDefine = 1;
    var path = requirePath();
    var hasOwn = requireHasOwnProperty();
    var wrappedWellKnownSymbolModule = requireWellKnownSymbolWrapped();
    var defineProperty = requireObjectDefineProperty().f;
    wellKnownSymbolDefine = function wellKnownSymbolDefine(NAME) {
      var Symbol = path.Symbol || (path.Symbol = {});
      if (!hasOwn(Symbol, NAME)) defineProperty(Symbol, NAME, {
        value: wrappedWellKnownSymbolModule.f(NAME)
      });
    };
    return wellKnownSymbolDefine;
  }
  var symbolDefineToPrimitive;
  var hasRequiredSymbolDefineToPrimitive;
  function requireSymbolDefineToPrimitive() {
    if (hasRequiredSymbolDefineToPrimitive) return symbolDefineToPrimitive;
    hasRequiredSymbolDefineToPrimitive = 1;
    var call = requireFunctionCall();
    var getBuiltIn = requireGetBuiltIn();
    var wellKnownSymbol = requireWellKnownSymbol();
    var defineBuiltIn = requireDefineBuiltIn();
    symbolDefineToPrimitive = function symbolDefineToPrimitive() {
      var Symbol = getBuiltIn('Symbol');
      var SymbolPrototype = Symbol && Symbol.prototype;
      var valueOf = SymbolPrototype && SymbolPrototype.valueOf;
      var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
      if (SymbolPrototype && !SymbolPrototype[TO_PRIMITIVE]) {
        defineBuiltIn(SymbolPrototype, TO_PRIMITIVE, function (hint) {
          return call(valueOf, this);
        }, {
          arity: 1
        });
      }
    };
    return symbolDefineToPrimitive;
  }
  var setToStringTag;
  var hasRequiredSetToStringTag;
  function requireSetToStringTag() {
    if (hasRequiredSetToStringTag) return setToStringTag;
    hasRequiredSetToStringTag = 1;
    var defineProperty = requireObjectDefineProperty().f;
    var hasOwn = requireHasOwnProperty();
    var wellKnownSymbol = requireWellKnownSymbol();
    var TO_STRING_TAG = wellKnownSymbol('toStringTag');
    setToStringTag = function setToStringTag(target, TAG, STATIC) {
      if (target && !STATIC) target = target.prototype;
      if (target && !hasOwn(target, TO_STRING_TAG)) {
        defineProperty(target, TO_STRING_TAG, {
          configurable: true,
          value: TAG
        });
      }
    };
    return setToStringTag;
  }
  var functionUncurryThisClause;
  var hasRequiredFunctionUncurryThisClause;
  function requireFunctionUncurryThisClause() {
    if (hasRequiredFunctionUncurryThisClause) return functionUncurryThisClause;
    hasRequiredFunctionUncurryThisClause = 1;
    var classofRaw = requireClassofRaw();
    var uncurryThis = requireFunctionUncurryThis();
    functionUncurryThisClause = function functionUncurryThisClause(fn) {
      if (classofRaw(fn) === 'Function') return uncurryThis(fn);
    };
    return functionUncurryThisClause;
  }
  var functionBindContext;
  var hasRequiredFunctionBindContext;
  function requireFunctionBindContext() {
    if (hasRequiredFunctionBindContext) return functionBindContext;
    hasRequiredFunctionBindContext = 1;
    var uncurryThis = requireFunctionUncurryThisClause();
    var aCallable = requireACallable();
    var NATIVE_BIND = requireFunctionBindNative();
    var bind = uncurryThis(uncurryThis.bind);
    functionBindContext = function functionBindContext(fn, that) {
      aCallable(fn);
      return that === undefined ? fn : NATIVE_BIND ? bind(fn, that) : function () {
        return fn.apply(that, arguments);
      };
    };
    return functionBindContext;
  }
  var isArray;
  var hasRequiredIsArray;
  function requireIsArray() {
    if (hasRequiredIsArray) return isArray;
    hasRequiredIsArray = 1;
    var classof = requireClassofRaw();
    isArray = Array.isArray || function isArray(argument) {
      return classof(argument) === 'Array';
    };
    return isArray;
  }
  var isConstructor;
  var hasRequiredIsConstructor;
  function requireIsConstructor() {
    if (hasRequiredIsConstructor) return isConstructor;
    hasRequiredIsConstructor = 1;
    var uncurryThis = requireFunctionUncurryThis();
    var fails = requireFails();
    var isCallable = requireIsCallable();
    var classof = requireClassof();
    var getBuiltIn = requireGetBuiltIn();
    var inspectSource = requireInspectSource();
    var noop = function noop() {};
    var construct = getBuiltIn('Reflect', 'construct');
    var constructorRegExp = /^\s*(?:class|function)\b/;
    var exec = uncurryThis(constructorRegExp.exec);
    var INCORRECT_TO_STRING = !constructorRegExp.test(noop);
    var isConstructorModern = function isConstructor(argument) {
      if (!isCallable(argument)) return false;
      try {
        construct(noop, [], argument);
        return true;
      } catch (error) {
        return false;
      }
    };
    var isConstructorLegacy = function isConstructor(argument) {
      if (!isCallable(argument)) return false;
      switch (classof(argument)) {
        case 'AsyncFunction':
        case 'GeneratorFunction':
        case 'AsyncGeneratorFunction':
          return false;
      }
      try {
        return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
      } catch (error) {
        return true;
      }
    };
    isConstructorLegacy.sham = true;
    isConstructor = !construct || fails(function () {
      var called;
      return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function () {
        called = true;
      }) || called;
    }) ? isConstructorLegacy : isConstructorModern;
    return isConstructor;
  }
  var arraySpeciesConstructor;
  var hasRequiredArraySpeciesConstructor;
  function requireArraySpeciesConstructor() {
    if (hasRequiredArraySpeciesConstructor) return arraySpeciesConstructor;
    hasRequiredArraySpeciesConstructor = 1;
    var isArray = requireIsArray();
    var isConstructor = requireIsConstructor();
    var isObject = requireIsObject();
    var wellKnownSymbol = requireWellKnownSymbol();
    var SPECIES = wellKnownSymbol('species');
    var $Array = Array;
    arraySpeciesConstructor = function arraySpeciesConstructor(originalArray) {
      var C;
      if (isArray(originalArray)) {
        C = originalArray.constructor;
        if (isConstructor(C) && (C === $Array || isArray(C.prototype))) C = undefined;else if (isObject(C)) {
          C = C[SPECIES];
          if (C === null) C = undefined;
        }
      }
      return C === undefined ? $Array : C;
    };
    return arraySpeciesConstructor;
  }
  var arraySpeciesCreate;
  var hasRequiredArraySpeciesCreate;
  function requireArraySpeciesCreate() {
    if (hasRequiredArraySpeciesCreate) return arraySpeciesCreate;
    hasRequiredArraySpeciesCreate = 1;
    var arraySpeciesConstructor = requireArraySpeciesConstructor();
    arraySpeciesCreate = function arraySpeciesCreate(originalArray, length) {
      return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
    };
    return arraySpeciesCreate;
  }
  var arrayIteration;
  var hasRequiredArrayIteration;
  function requireArrayIteration() {
    if (hasRequiredArrayIteration) return arrayIteration;
    hasRequiredArrayIteration = 1;
    var bind = requireFunctionBindContext();
    var uncurryThis = requireFunctionUncurryThis();
    var IndexedObject = requireIndexedObject();
    var toObject = requireToObject();
    var lengthOfArrayLike = requireLengthOfArrayLike();
    var arraySpeciesCreate = requireArraySpeciesCreate();
    var push = uncurryThis([].push);
    var createMethod = function createMethod(TYPE) {
      var IS_MAP = TYPE === 1;
      var IS_FILTER = TYPE === 2;
      var IS_SOME = TYPE === 3;
      var IS_EVERY = TYPE === 4;
      var IS_FIND_INDEX = TYPE === 6;
      var IS_FILTER_REJECT = TYPE === 7;
      var NO_HOLES = TYPE === 5 || IS_FIND_INDEX;
      return function ($this, callbackfn, that, specificCreate) {
        var O = toObject($this);
        var self = IndexedObject(O);
        var length = lengthOfArrayLike(self);
        var boundFunction = bind(callbackfn, that);
        var index = 0;
        var create = specificCreate || arraySpeciesCreate;
        var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;
        var value, result;
        for (; length > index; index++) if (NO_HOLES || index in self) {
          value = self[index];
          result = boundFunction(value, index, O);
          if (TYPE) {
            if (IS_MAP) target[index] = result;else if (result) switch (TYPE) {
              case 3:
                return true;
              case 5:
                return value;
              case 6:
                return index;
              case 2:
                push(target, value);
            } else switch (TYPE) {
              case 4:
                return false;
              case 7:
                push(target, value);
            }
          }
        }
        return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
      };
    };
    arrayIteration = {
      forEach: createMethod(0),
      map: createMethod(1),
      filter: createMethod(2),
      some: createMethod(3),
      every: createMethod(4),
      find: createMethod(5),
      findIndex: createMethod(6),
      filterReject: createMethod(7)
    };
    return arrayIteration;
  }
  var hasRequiredEs_symbol_constructor;
  function requireEs_symbol_constructor() {
    if (hasRequiredEs_symbol_constructor) return es_symbol_constructor;
    hasRequiredEs_symbol_constructor = 1;
    var $ = require_export();
    var globalThis = requireGlobalThis();
    var call = requireFunctionCall();
    var uncurryThis = requireFunctionUncurryThis();
    var IS_PURE = requireIsPure();
    var DESCRIPTORS = requireDescriptors();
    var NATIVE_SYMBOL = requireSymbolConstructorDetection();
    var fails = requireFails();
    var hasOwn = requireHasOwnProperty();
    var isPrototypeOf = requireObjectIsPrototypeOf();
    var anObject = requireAnObject();
    var toIndexedObject = requireToIndexedObject();
    var toPropertyKey = requireToPropertyKey();
    var $toString = requireToString();
    var createPropertyDescriptor = requireCreatePropertyDescriptor();
    var nativeObjectCreate = requireObjectCreate();
    var objectKeys = requireObjectKeys();
    var getOwnPropertyNamesModule = requireObjectGetOwnPropertyNames();
    var getOwnPropertyNamesExternal = requireObjectGetOwnPropertyNamesExternal();
    var getOwnPropertySymbolsModule = requireObjectGetOwnPropertySymbols();
    var getOwnPropertyDescriptorModule = requireObjectGetOwnPropertyDescriptor();
    var definePropertyModule = requireObjectDefineProperty();
    var definePropertiesModule = requireObjectDefineProperties();
    var propertyIsEnumerableModule = requireObjectPropertyIsEnumerable();
    var defineBuiltIn = requireDefineBuiltIn();
    var defineBuiltInAccessor = requireDefineBuiltInAccessor();
    var shared = requireShared();
    var sharedKey = requireSharedKey();
    var hiddenKeys = requireHiddenKeys();
    var uid = requireUid();
    var wellKnownSymbol = requireWellKnownSymbol();
    var wrappedWellKnownSymbolModule = requireWellKnownSymbolWrapped();
    var defineWellKnownSymbol = requireWellKnownSymbolDefine();
    var defineSymbolToPrimitive = requireSymbolDefineToPrimitive();
    var setToStringTag = requireSetToStringTag();
    var InternalStateModule = requireInternalState();
    var $forEach = requireArrayIteration().forEach;
    var HIDDEN = sharedKey('hidden');
    var SYMBOL = 'Symbol';
    var PROTOTYPE = 'prototype';
    var setInternalState = InternalStateModule.set;
    var getInternalState = InternalStateModule.getterFor(SYMBOL);
    var ObjectPrototype = Object[PROTOTYPE];
    var $Symbol = globalThis.Symbol;
    var SymbolPrototype = $Symbol && $Symbol[PROTOTYPE];
    var RangeError = globalThis.RangeError;
    var TypeError = globalThis.TypeError;
    var QObject = globalThis.QObject;
    var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
    var nativeDefineProperty = definePropertyModule.f;
    var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
    var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
    var push = uncurryThis([].push);
    var AllSymbols = shared('symbols');
    var ObjectPrototypeSymbols = shared('op-symbols');
    var WellKnownSymbolsStore = shared('wks');
    var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
    var fallbackDefineProperty = function fallbackDefineProperty(O, P, Attributes) {
      var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
      if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
      nativeDefineProperty(O, P, Attributes);
      if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
        nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
      }
    };
    var setSymbolDescriptor = DESCRIPTORS && fails(function () {
      return nativeObjectCreate(nativeDefineProperty({}, 'a', {
        get: function get() {
          return nativeDefineProperty(this, 'a', {
            value: 7
          }).a;
        }
      })).a !== 7;
    }) ? fallbackDefineProperty : nativeDefineProperty;
    var wrap = function wrap(tag, description) {
      var symbol = AllSymbols[tag] = nativeObjectCreate(SymbolPrototype);
      setInternalState(symbol, {
        type: SYMBOL,
        tag: tag,
        description: description
      });
      if (!DESCRIPTORS) symbol.description = description;
      return symbol;
    };
    var $defineProperty = function defineProperty(O, P, Attributes) {
      if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
      anObject(O);
      var key = toPropertyKey(P);
      anObject(Attributes);
      if (hasOwn(AllSymbols, key)) {
        if (!Attributes.enumerable) {
          if (!hasOwn(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, nativeObjectCreate(null)));
          O[HIDDEN][key] = true;
        } else {
          if (hasOwn(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
          Attributes = nativeObjectCreate(Attributes, {
            enumerable: createPropertyDescriptor(0, false)
          });
        }
        return setSymbolDescriptor(O, key, Attributes);
      }
      return nativeDefineProperty(O, key, Attributes);
    };
    var $defineProperties = function defineProperties(O, Properties) {
      anObject(O);
      var properties = toIndexedObject(Properties);
      var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
      $forEach(keys, function (key) {
        if (!DESCRIPTORS || call($propertyIsEnumerable, properties, key)) $defineProperty(O, key, properties[key]);
      });
      return O;
    };
    var $create = function create(O, Properties) {
      return Properties === undefined ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
    };
    var $propertyIsEnumerable = function propertyIsEnumerable(V) {
      var P = toPropertyKey(V);
      var enumerable = call(nativePropertyIsEnumerable, this, P);
      if (this === ObjectPrototype && hasOwn(AllSymbols, P) && !hasOwn(ObjectPrototypeSymbols, P)) return false;
      return enumerable || !hasOwn(this, P) || !hasOwn(AllSymbols, P) || hasOwn(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
    };
    var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
      var it = toIndexedObject(O);
      var key = toPropertyKey(P);
      if (it === ObjectPrototype && hasOwn(AllSymbols, key) && !hasOwn(ObjectPrototypeSymbols, key)) return;
      var descriptor = nativeGetOwnPropertyDescriptor(it, key);
      if (descriptor && hasOwn(AllSymbols, key) && !(hasOwn(it, HIDDEN) && it[HIDDEN][key])) {
        descriptor.enumerable = true;
      }
      return descriptor;
    };
    var $getOwnPropertyNames = function getOwnPropertyNames(O) {
      var names = nativeGetOwnPropertyNames(toIndexedObject(O));
      var result = [];
      $forEach(names, function (key) {
        if (!hasOwn(AllSymbols, key) && !hasOwn(hiddenKeys, key)) push(result, key);
      });
      return result;
    };
    var $getOwnPropertySymbols = function $getOwnPropertySymbols(O) {
      var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
      var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
      var result = [];
      $forEach(names, function (key) {
        if (hasOwn(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwn(ObjectPrototype, key))) {
          push(result, AllSymbols[key]);
        }
      });
      return result;
    };
    if (!NATIVE_SYMBOL) {
      $Symbol = function Symbol() {
        if (isPrototypeOf(SymbolPrototype, this)) throw new TypeError('Symbol is not a constructor');
        var description = !arguments.length || arguments[0] === undefined ? undefined : $toString(arguments[0]);
        var tag = uid(description);
        var _setter = function setter(value) {
          var $this = this === undefined ? globalThis : this;
          if ($this === ObjectPrototype) call(_setter, ObjectPrototypeSymbols, value);
          if (hasOwn($this, HIDDEN) && hasOwn($this[HIDDEN], tag)) $this[HIDDEN][tag] = false;
          var descriptor = createPropertyDescriptor(1, value);
          try {
            setSymbolDescriptor($this, tag, descriptor);
          } catch (error) {
            if (!(error instanceof RangeError)) throw error;
            fallbackDefineProperty($this, tag, descriptor);
          }
        };
        if (DESCRIPTORS && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, {
          configurable: true,
          set: _setter
        });
        return wrap(tag, description);
      };
      SymbolPrototype = $Symbol[PROTOTYPE];
      defineBuiltIn(SymbolPrototype, 'toString', function toString() {
        return getInternalState(this).tag;
      });
      defineBuiltIn($Symbol, 'withoutSetter', function (description) {
        return wrap(uid(description), description);
      });
      propertyIsEnumerableModule.f = $propertyIsEnumerable;
      definePropertyModule.f = $defineProperty;
      definePropertiesModule.f = $defineProperties;
      getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
      getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
      getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;
      wrappedWellKnownSymbolModule.f = function (name) {
        return wrap(wellKnownSymbol(name), name);
      };
      if (DESCRIPTORS) {
        defineBuiltInAccessor(SymbolPrototype, 'description', {
          configurable: true,
          get: function description() {
            return getInternalState(this).description;
          }
        });
        if (!IS_PURE) {
          defineBuiltIn(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, {
            unsafe: true
          });
        }
      }
    }
    $({
      global: true,
      constructor: true,
      wrap: true,
      forced: !NATIVE_SYMBOL,
      sham: !NATIVE_SYMBOL
    }, {
      Symbol: $Symbol
    });
    $forEach(objectKeys(WellKnownSymbolsStore), function (name) {
      defineWellKnownSymbol(name);
    });
    $({
      target: SYMBOL,
      stat: true,
      forced: !NATIVE_SYMBOL
    }, {
      useSetter: function useSetter() {
        USE_SETTER = true;
      },
      useSimple: function useSimple() {
        USE_SETTER = false;
      }
    });
    $({
      target: 'Object',
      stat: true,
      forced: !NATIVE_SYMBOL,
      sham: !DESCRIPTORS
    }, {
      create: $create,
      defineProperty: $defineProperty,
      defineProperties: $defineProperties,
      getOwnPropertyDescriptor: $getOwnPropertyDescriptor
    });
    $({
      target: 'Object',
      stat: true,
      forced: !NATIVE_SYMBOL
    }, {
      getOwnPropertyNames: $getOwnPropertyNames
    });
    defineSymbolToPrimitive();
    setToStringTag($Symbol, SYMBOL);
    hiddenKeys[HIDDEN] = true;
    return es_symbol_constructor;
  }
  var es_symbol_for = {};
  var symbolRegistryDetection;
  var hasRequiredSymbolRegistryDetection;
  function requireSymbolRegistryDetection() {
    if (hasRequiredSymbolRegistryDetection) return symbolRegistryDetection;
    hasRequiredSymbolRegistryDetection = 1;
    var NATIVE_SYMBOL = requireSymbolConstructorDetection();
    symbolRegistryDetection = NATIVE_SYMBOL && !!Symbol['for'] && !!Symbol.keyFor;
    return symbolRegistryDetection;
  }
  var hasRequiredEs_symbol_for;
  function requireEs_symbol_for() {
    if (hasRequiredEs_symbol_for) return es_symbol_for;
    hasRequiredEs_symbol_for = 1;
    var $ = require_export();
    var getBuiltIn = requireGetBuiltIn();
    var hasOwn = requireHasOwnProperty();
    var toString = requireToString();
    var shared = requireShared();
    var NATIVE_SYMBOL_REGISTRY = requireSymbolRegistryDetection();
    var StringToSymbolRegistry = shared('string-to-symbol-registry');
    var SymbolToStringRegistry = shared('symbol-to-string-registry');
    $({
      target: 'Symbol',
      stat: true,
      forced: !NATIVE_SYMBOL_REGISTRY
    }, {
      'for': function _for(key) {
        var string = toString(key);
        if (hasOwn(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
        var symbol = getBuiltIn('Symbol')(string);
        StringToSymbolRegistry[string] = symbol;
        SymbolToStringRegistry[symbol] = string;
        return symbol;
      }
    });
    return es_symbol_for;
  }
  var es_symbol_keyFor = {};
  var hasRequiredEs_symbol_keyFor;
  function requireEs_symbol_keyFor() {
    if (hasRequiredEs_symbol_keyFor) return es_symbol_keyFor;
    hasRequiredEs_symbol_keyFor = 1;
    var $ = require_export();
    var hasOwn = requireHasOwnProperty();
    var isSymbol = requireIsSymbol();
    var tryToString = requireTryToString();
    var shared = requireShared();
    var NATIVE_SYMBOL_REGISTRY = requireSymbolRegistryDetection();
    var SymbolToStringRegistry = shared('symbol-to-string-registry');
    $({
      target: 'Symbol',
      stat: true,
      forced: !NATIVE_SYMBOL_REGISTRY
    }, {
      keyFor: function keyFor(sym) {
        if (!isSymbol(sym)) throw new TypeError(tryToString(sym) + ' is not a symbol');
        if (hasOwn(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
      }
    });
    return es_symbol_keyFor;
  }
  var es_json_stringify = {};
  var functionApply;
  var hasRequiredFunctionApply;
  function requireFunctionApply() {
    if (hasRequiredFunctionApply) return functionApply;
    hasRequiredFunctionApply = 1;
    var NATIVE_BIND = requireFunctionBindNative();
    var FunctionPrototype = Function.prototype;
    var apply = FunctionPrototype.apply;
    var call = FunctionPrototype.call;
    functionApply = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function () {
      return call.apply(apply, arguments);
    });
    return functionApply;
  }
  var getJsonReplacerFunction;
  var hasRequiredGetJsonReplacerFunction;
  function requireGetJsonReplacerFunction() {
    if (hasRequiredGetJsonReplacerFunction) return getJsonReplacerFunction;
    hasRequiredGetJsonReplacerFunction = 1;
    var uncurryThis = requireFunctionUncurryThis();
    var isArray = requireIsArray();
    var isCallable = requireIsCallable();
    var classof = requireClassofRaw();
    var toString = requireToString();
    var push = uncurryThis([].push);
    getJsonReplacerFunction = function getJsonReplacerFunction(replacer) {
      if (isCallable(replacer)) return replacer;
      if (!isArray(replacer)) return;
      var rawLength = replacer.length;
      var keys = [];
      for (var i = 0; i < rawLength; i++) {
        var element = replacer[i];
        if (typeof element == 'string') push(keys, element);else if (typeof element == 'number' || classof(element) === 'Number' || classof(element) === 'String') push(keys, toString(element));
      }
      var keysLength = keys.length;
      var root = true;
      return function (key, value) {
        if (root) {
          root = false;
          return value;
        }
        if (isArray(this)) return value;
        for (var j = 0; j < keysLength; j++) if (keys[j] === key) return value;
      };
    };
    return getJsonReplacerFunction;
  }
  var hasRequiredEs_json_stringify;
  function requireEs_json_stringify() {
    if (hasRequiredEs_json_stringify) return es_json_stringify;
    hasRequiredEs_json_stringify = 1;
    var $ = require_export();
    var getBuiltIn = requireGetBuiltIn();
    var apply = requireFunctionApply();
    var call = requireFunctionCall();
    var uncurryThis = requireFunctionUncurryThis();
    var fails = requireFails();
    var isCallable = requireIsCallable();
    var isSymbol = requireIsSymbol();
    var arraySlice = requireArraySlice();
    var getReplacerFunction = requireGetJsonReplacerFunction();
    var NATIVE_SYMBOL = requireSymbolConstructorDetection();
    var $String = String;
    var $stringify = getBuiltIn('JSON', 'stringify');
    var exec = uncurryThis(/./.exec);
    var charAt = uncurryThis(''.charAt);
    var charCodeAt = uncurryThis(''.charCodeAt);
    var replace = uncurryThis(''.replace);
    var numberToString = uncurryThis(1.1.toString);
    var tester = /[\uD800-\uDFFF]/g;
    var low = /^[\uD800-\uDBFF]$/;
    var hi = /^[\uDC00-\uDFFF]$/;
    var WRONG_SYMBOLS_CONVERSION = !NATIVE_SYMBOL || fails(function () {
      var symbol = getBuiltIn('Symbol')('stringify detection');
      return $stringify([symbol]) !== '[null]' || $stringify({
        a: symbol
      }) !== '{}' || $stringify(Object(symbol)) !== '{}';
    });
    var ILL_FORMED_UNICODE = fails(function () {
      return $stringify('\uDF06\uD834') !== '"\\udf06\\ud834"' || $stringify('\uDEAD') !== '"\\udead"';
    });
    var stringifyWithSymbolsFix = function stringifyWithSymbolsFix(it, replacer) {
      var args = arraySlice(arguments);
      var $replacer = getReplacerFunction(replacer);
      if (!isCallable($replacer) && (it === undefined || isSymbol(it))) return;
      args[1] = function (key, value) {
        if (isCallable($replacer)) value = call($replacer, this, $String(key), value);
        if (!isSymbol(value)) return value;
      };
      return apply($stringify, null, args);
    };
    var fixIllFormed = function fixIllFormed(match, offset, string) {
      var prev = charAt(string, offset - 1);
      var next = charAt(string, offset + 1);
      if (exec(low, match) && !exec(hi, next) || exec(hi, match) && !exec(low, prev)) {
        return '\\u' + numberToString(charCodeAt(match, 0), 16);
      }
      return match;
    };
    if ($stringify) {
      $({
        target: 'JSON',
        stat: true,
        arity: 3,
        forced: WRONG_SYMBOLS_CONVERSION || ILL_FORMED_UNICODE
      }, {
        stringify: function stringify(it, replacer, space) {
          var args = arraySlice(arguments);
          var result = apply(WRONG_SYMBOLS_CONVERSION ? stringifyWithSymbolsFix : $stringify, null, args);
          return ILL_FORMED_UNICODE && typeof result == 'string' ? replace(result, tester, fixIllFormed) : result;
        }
      });
    }
    return es_json_stringify;
  }
  var es_object_getOwnPropertySymbols = {};
  var hasRequiredEs_object_getOwnPropertySymbols;
  function requireEs_object_getOwnPropertySymbols() {
    if (hasRequiredEs_object_getOwnPropertySymbols) return es_object_getOwnPropertySymbols;
    hasRequiredEs_object_getOwnPropertySymbols = 1;
    var $ = require_export();
    var NATIVE_SYMBOL = requireSymbolConstructorDetection();
    var fails = requireFails();
    var getOwnPropertySymbolsModule = requireObjectGetOwnPropertySymbols();
    var toObject = requireToObject();
    var FORCED = !NATIVE_SYMBOL || fails(function () {
      getOwnPropertySymbolsModule.f(1);
    });
    $({
      target: 'Object',
      stat: true,
      forced: FORCED
    }, {
      getOwnPropertySymbols: function getOwnPropertySymbols(it) {
        var $getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
        return $getOwnPropertySymbols ? $getOwnPropertySymbols(toObject(it)) : [];
      }
    });
    return es_object_getOwnPropertySymbols;
  }
  var hasRequiredEs_symbol;
  function requireEs_symbol() {
    if (hasRequiredEs_symbol) return es_symbol;
    hasRequiredEs_symbol = 1;
    requireEs_symbol_constructor();
    requireEs_symbol_for();
    requireEs_symbol_keyFor();
    requireEs_json_stringify();
    requireEs_object_getOwnPropertySymbols();
    return es_symbol;
  }
  var es_symbol_description = {};
  var hasRequiredEs_symbol_description;
  function requireEs_symbol_description() {
    if (hasRequiredEs_symbol_description) return es_symbol_description;
    hasRequiredEs_symbol_description = 1;
    var $ = require_export();
    var DESCRIPTORS = requireDescriptors();
    var globalThis = requireGlobalThis();
    var uncurryThis = requireFunctionUncurryThis();
    var hasOwn = requireHasOwnProperty();
    var isCallable = requireIsCallable();
    var isPrototypeOf = requireObjectIsPrototypeOf();
    var toString = requireToString();
    var defineBuiltInAccessor = requireDefineBuiltInAccessor();
    var copyConstructorProperties = requireCopyConstructorProperties();
    var NativeSymbol = globalThis.Symbol;
    var SymbolPrototype = NativeSymbol && NativeSymbol.prototype;
    if (DESCRIPTORS && isCallable(NativeSymbol) && (!('description' in SymbolPrototype) || NativeSymbol().description !== undefined)) {
      var EmptyStringDescriptionStore = {};
      var SymbolWrapper = function Symbol() {
        var description = arguments.length < 1 || arguments[0] === undefined ? undefined : toString(arguments[0]);
        var result = isPrototypeOf(SymbolPrototype, this) ? new NativeSymbol(description) : description === undefined ? NativeSymbol() : NativeSymbol(description);
        if (description === '') EmptyStringDescriptionStore[result] = true;
        return result;
      };
      copyConstructorProperties(SymbolWrapper, NativeSymbol);
      SymbolWrapper.prototype = SymbolPrototype;
      SymbolPrototype.constructor = SymbolWrapper;
      var NATIVE_SYMBOL = String(NativeSymbol('description detection')) === 'Symbol(description detection)';
      var thisSymbolValue = uncurryThis(SymbolPrototype.valueOf);
      var symbolDescriptiveString = uncurryThis(SymbolPrototype.toString);
      var regexp = /^Symbol\((.*)\)[^)]+$/;
      var replace = uncurryThis(''.replace);
      var stringSlice = uncurryThis(''.slice);
      defineBuiltInAccessor(SymbolPrototype, 'description', {
        configurable: true,
        get: function description() {
          var symbol = thisSymbolValue(this);
          if (hasOwn(EmptyStringDescriptionStore, symbol)) return '';
          var string = symbolDescriptiveString(symbol);
          var desc = NATIVE_SYMBOL ? stringSlice(string, 7, -1) : replace(string, regexp, '$1');
          return desc === '' ? undefined : desc;
        }
      });
      $({
        global: true,
        constructor: true,
        forced: true
      }, {
        Symbol: SymbolWrapper
      });
    }
    return es_symbol_description;
  }
  var es_symbol_asyncDispose = {};
  var hasRequiredEs_symbol_asyncDispose;
  function requireEs_symbol_asyncDispose() {
    if (hasRequiredEs_symbol_asyncDispose) return es_symbol_asyncDispose;
    hasRequiredEs_symbol_asyncDispose = 1;
    var globalThis = requireGlobalThis();
    var defineWellKnownSymbol = requireWellKnownSymbolDefine();
    var defineProperty = requireObjectDefineProperty().f;
    var getOwnPropertyDescriptor = requireObjectGetOwnPropertyDescriptor().f;
    var Symbol = globalThis.Symbol;
    defineWellKnownSymbol('asyncDispose');
    if (Symbol) {
      var descriptor = getOwnPropertyDescriptor(Symbol, 'asyncDispose');
      if (descriptor.enumerable && descriptor.configurable && descriptor.writable) {
        defineProperty(Symbol, 'asyncDispose', {
          value: descriptor.value,
          enumerable: false,
          configurable: false,
          writable: false
        });
      }
    }
    return es_symbol_asyncDispose;
  }
  var es_symbol_asyncIterator = {};
  var hasRequiredEs_symbol_asyncIterator;
  function requireEs_symbol_asyncIterator() {
    if (hasRequiredEs_symbol_asyncIterator) return es_symbol_asyncIterator;
    hasRequiredEs_symbol_asyncIterator = 1;
    var defineWellKnownSymbol = requireWellKnownSymbolDefine();
    defineWellKnownSymbol('asyncIterator');
    return es_symbol_asyncIterator;
  }
  var es_symbol_dispose = {};
  var hasRequiredEs_symbol_dispose;
  function requireEs_symbol_dispose() {
    if (hasRequiredEs_symbol_dispose) return es_symbol_dispose;
    hasRequiredEs_symbol_dispose = 1;
    var globalThis = requireGlobalThis();
    var defineWellKnownSymbol = requireWellKnownSymbolDefine();
    var defineProperty = requireObjectDefineProperty().f;
    var getOwnPropertyDescriptor = requireObjectGetOwnPropertyDescriptor().f;
    var Symbol = globalThis.Symbol;
    defineWellKnownSymbol('dispose');
    if (Symbol) {
      var descriptor = getOwnPropertyDescriptor(Symbol, 'dispose');
      if (descriptor.enumerable && descriptor.configurable && descriptor.writable) {
        defineProperty(Symbol, 'dispose', {
          value: descriptor.value,
          enumerable: false,
          configurable: false,
          writable: false
        });
      }
    }
    return es_symbol_dispose;
  }
  var es_symbol_hasInstance = {};
  var hasRequiredEs_symbol_hasInstance;
  function requireEs_symbol_hasInstance() {
    if (hasRequiredEs_symbol_hasInstance) return es_symbol_hasInstance;
    hasRequiredEs_symbol_hasInstance = 1;
    var defineWellKnownSymbol = requireWellKnownSymbolDefine();
    defineWellKnownSymbol('hasInstance');
    return es_symbol_hasInstance;
  }
  var es_symbol_isConcatSpreadable = {};
  var hasRequiredEs_symbol_isConcatSpreadable;
  function requireEs_symbol_isConcatSpreadable() {
    if (hasRequiredEs_symbol_isConcatSpreadable) return es_symbol_isConcatSpreadable;
    hasRequiredEs_symbol_isConcatSpreadable = 1;
    var defineWellKnownSymbol = requireWellKnownSymbolDefine();
    defineWellKnownSymbol('isConcatSpreadable');
    return es_symbol_isConcatSpreadable;
  }
  var es_symbol_iterator = {};
  var hasRequiredEs_symbol_iterator;
  function requireEs_symbol_iterator() {
    if (hasRequiredEs_symbol_iterator) return es_symbol_iterator;
    hasRequiredEs_symbol_iterator = 1;
    var defineWellKnownSymbol = requireWellKnownSymbolDefine();
    defineWellKnownSymbol('iterator');
    return es_symbol_iterator;
  }
  var es_symbol_match = {};
  var hasRequiredEs_symbol_match;
  function requireEs_symbol_match() {
    if (hasRequiredEs_symbol_match) return es_symbol_match;
    hasRequiredEs_symbol_match = 1;
    var defineWellKnownSymbol = requireWellKnownSymbolDefine();
    defineWellKnownSymbol('match');
    return es_symbol_match;
  }
  var es_symbol_matchAll = {};
  var hasRequiredEs_symbol_matchAll;
  function requireEs_symbol_matchAll() {
    if (hasRequiredEs_symbol_matchAll) return es_symbol_matchAll;
    hasRequiredEs_symbol_matchAll = 1;
    var defineWellKnownSymbol = requireWellKnownSymbolDefine();
    defineWellKnownSymbol('matchAll');
    return es_symbol_matchAll;
  }
  var es_symbol_replace = {};
  var hasRequiredEs_symbol_replace;
  function requireEs_symbol_replace() {
    if (hasRequiredEs_symbol_replace) return es_symbol_replace;
    hasRequiredEs_symbol_replace = 1;
    var defineWellKnownSymbol = requireWellKnownSymbolDefine();
    defineWellKnownSymbol('replace');
    return es_symbol_replace;
  }
  var es_symbol_search = {};
  var hasRequiredEs_symbol_search;
  function requireEs_symbol_search() {
    if (hasRequiredEs_symbol_search) return es_symbol_search;
    hasRequiredEs_symbol_search = 1;
    var defineWellKnownSymbol = requireWellKnownSymbolDefine();
    defineWellKnownSymbol('search');
    return es_symbol_search;
  }
  var es_symbol_species = {};
  var hasRequiredEs_symbol_species;
  function requireEs_symbol_species() {
    if (hasRequiredEs_symbol_species) return es_symbol_species;
    hasRequiredEs_symbol_species = 1;
    var defineWellKnownSymbol = requireWellKnownSymbolDefine();
    defineWellKnownSymbol('species');
    return es_symbol_species;
  }
  var es_symbol_split = {};
  var hasRequiredEs_symbol_split;
  function requireEs_symbol_split() {
    if (hasRequiredEs_symbol_split) return es_symbol_split;
    hasRequiredEs_symbol_split = 1;
    var defineWellKnownSymbol = requireWellKnownSymbolDefine();
    defineWellKnownSymbol('split');
    return es_symbol_split;
  }
  var es_symbol_toPrimitive = {};
  var hasRequiredEs_symbol_toPrimitive;
  function requireEs_symbol_toPrimitive() {
    if (hasRequiredEs_symbol_toPrimitive) return es_symbol_toPrimitive;
    hasRequiredEs_symbol_toPrimitive = 1;
    var defineWellKnownSymbol = requireWellKnownSymbolDefine();
    var defineSymbolToPrimitive = requireSymbolDefineToPrimitive();
    defineWellKnownSymbol('toPrimitive');
    defineSymbolToPrimitive();
    return es_symbol_toPrimitive;
  }
  var es_symbol_toStringTag = {};
  var hasRequiredEs_symbol_toStringTag;
  function requireEs_symbol_toStringTag() {
    if (hasRequiredEs_symbol_toStringTag) return es_symbol_toStringTag;
    hasRequiredEs_symbol_toStringTag = 1;
    var getBuiltIn = requireGetBuiltIn();
    var defineWellKnownSymbol = requireWellKnownSymbolDefine();
    var setToStringTag = requireSetToStringTag();
    defineWellKnownSymbol('toStringTag');
    setToStringTag(getBuiltIn('Symbol'), 'Symbol');
    return es_symbol_toStringTag;
  }
  var es_symbol_unscopables = {};
  var hasRequiredEs_symbol_unscopables;
  function requireEs_symbol_unscopables() {
    if (hasRequiredEs_symbol_unscopables) return es_symbol_unscopables;
    hasRequiredEs_symbol_unscopables = 1;
    var defineWellKnownSymbol = requireWellKnownSymbolDefine();
    defineWellKnownSymbol('unscopables');
    return es_symbol_unscopables;
  }
  var es_error_cause = {};
  var functionUncurryThisAccessor;
  var hasRequiredFunctionUncurryThisAccessor;
  function requireFunctionUncurryThisAccessor() {
    if (hasRequiredFunctionUncurryThisAccessor) return functionUncurryThisAccessor;
    hasRequiredFunctionUncurryThisAccessor = 1;
    var uncurryThis = requireFunctionUncurryThis();
    var aCallable = requireACallable();
    functionUncurryThisAccessor = function functionUncurryThisAccessor(object, key, method) {
      try {
        return uncurryThis(aCallable(Object.getOwnPropertyDescriptor(object, key)[method]));
      } catch (error) {}
    };
    return functionUncurryThisAccessor;
  }
  var isPossiblePrototype;
  var hasRequiredIsPossiblePrototype;
  function requireIsPossiblePrototype() {
    if (hasRequiredIsPossiblePrototype) return isPossiblePrototype;
    hasRequiredIsPossiblePrototype = 1;
    var isObject = requireIsObject();
    isPossiblePrototype = function isPossiblePrototype(argument) {
      return isObject(argument) || argument === null;
    };
    return isPossiblePrototype;
  }
  var aPossiblePrototype;
  var hasRequiredAPossiblePrototype;
  function requireAPossiblePrototype() {
    if (hasRequiredAPossiblePrototype) return aPossiblePrototype;
    hasRequiredAPossiblePrototype = 1;
    var isPossiblePrototype = requireIsPossiblePrototype();
    var $String = String;
    var $TypeError = TypeError;
    aPossiblePrototype = function aPossiblePrototype(argument) {
      if (isPossiblePrototype(argument)) return argument;
      throw new $TypeError("Can't set " + $String(argument) + ' as a prototype');
    };
    return aPossiblePrototype;
  }
  var objectSetPrototypeOf;
  var hasRequiredObjectSetPrototypeOf;
  function requireObjectSetPrototypeOf() {
    if (hasRequiredObjectSetPrototypeOf) return objectSetPrototypeOf;
    hasRequiredObjectSetPrototypeOf = 1;
    var uncurryThisAccessor = requireFunctionUncurryThisAccessor();
    var isObject = requireIsObject();
    var requireObjectCoercible = requireRequireObjectCoercible();
    var aPossiblePrototype = requireAPossiblePrototype();
    objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
      var CORRECT_SETTER = false;
      var test = {};
      var setter;
      try {
        setter = uncurryThisAccessor(Object.prototype, '__proto__', 'set');
        setter(test, []);
        CORRECT_SETTER = test instanceof Array;
      } catch (error) {}
      return function setPrototypeOf(O, proto) {
        requireObjectCoercible(O);
        aPossiblePrototype(proto);
        if (!isObject(O)) return O;
        if (CORRECT_SETTER) setter(O, proto);else O.__proto__ = proto;
        return O;
      };
    }() : undefined);
    return objectSetPrototypeOf;
  }
  var proxyAccessor;
  var hasRequiredProxyAccessor;
  function requireProxyAccessor() {
    if (hasRequiredProxyAccessor) return proxyAccessor;
    hasRequiredProxyAccessor = 1;
    var defineProperty = requireObjectDefineProperty().f;
    proxyAccessor = function proxyAccessor(Target, Source, key) {
      key in Target || defineProperty(Target, key, {
        configurable: true,
        get: function get() {
          return Source[key];
        },
        set: function set(it) {
          Source[key] = it;
        }
      });
    };
    return proxyAccessor;
  }
  var inheritIfRequired;
  var hasRequiredInheritIfRequired;
  function requireInheritIfRequired() {
    if (hasRequiredInheritIfRequired) return inheritIfRequired;
    hasRequiredInheritIfRequired = 1;
    var isCallable = requireIsCallable();
    var isObject = requireIsObject();
    var setPrototypeOf = requireObjectSetPrototypeOf();
    inheritIfRequired = function inheritIfRequired($this, dummy, Wrapper) {
      var NewTarget, NewTargetPrototype;
      if (setPrototypeOf && isCallable(NewTarget = dummy.constructor) && NewTarget !== Wrapper && isObject(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype) setPrototypeOf($this, NewTargetPrototype);
      return $this;
    };
    return inheritIfRequired;
  }
  var normalizeStringArgument;
  var hasRequiredNormalizeStringArgument;
  function requireNormalizeStringArgument() {
    if (hasRequiredNormalizeStringArgument) return normalizeStringArgument;
    hasRequiredNormalizeStringArgument = 1;
    var toString = requireToString();
    normalizeStringArgument = function normalizeStringArgument(argument, $default) {
      return argument === undefined ? arguments.length < 2 ? '' : $default : toString(argument);
    };
    return normalizeStringArgument;
  }
  var installErrorCause;
  var hasRequiredInstallErrorCause;
  function requireInstallErrorCause() {
    if (hasRequiredInstallErrorCause) return installErrorCause;
    hasRequiredInstallErrorCause = 1;
    var isObject = requireIsObject();
    var createNonEnumerableProperty = requireCreateNonEnumerableProperty();
    installErrorCause = function installErrorCause(O, options) {
      if (isObject(options) && 'cause' in options) {
        createNonEnumerableProperty(O, 'cause', options.cause);
      }
    };
    return installErrorCause;
  }
  var errorStackClear;
  var hasRequiredErrorStackClear;
  function requireErrorStackClear() {
    if (hasRequiredErrorStackClear) return errorStackClear;
    hasRequiredErrorStackClear = 1;
    var uncurryThis = requireFunctionUncurryThis();
    var $Error = Error;
    var replace = uncurryThis(''.replace);
    var TEST = function (arg) {
      return String(new $Error(arg).stack);
    }('zxcasd');
    var V8_OR_CHAKRA_STACK_ENTRY = /\n\s*at [^:]*:[^\n]*/;
    var IS_V8_OR_CHAKRA_STACK = V8_OR_CHAKRA_STACK_ENTRY.test(TEST);
    errorStackClear = function errorStackClear(stack, dropEntries) {
      if (IS_V8_OR_CHAKRA_STACK && typeof stack == 'string' && !$Error.prepareStackTrace) {
        while (dropEntries--) stack = replace(stack, V8_OR_CHAKRA_STACK_ENTRY, '');
      }
      return stack;
    };
    return errorStackClear;
  }
  var errorStackInstallable;
  var hasRequiredErrorStackInstallable;
  function requireErrorStackInstallable() {
    if (hasRequiredErrorStackInstallable) return errorStackInstallable;
    hasRequiredErrorStackInstallable = 1;
    var fails = requireFails();
    var createPropertyDescriptor = requireCreatePropertyDescriptor();
    errorStackInstallable = !fails(function () {
      var error = new Error('a');
      if (!('stack' in error)) return true;
      Object.defineProperty(error, 'stack', createPropertyDescriptor(1, 7));
      return error.stack !== 7;
    });
    return errorStackInstallable;
  }
  var errorStackInstall;
  var hasRequiredErrorStackInstall;
  function requireErrorStackInstall() {
    if (hasRequiredErrorStackInstall) return errorStackInstall;
    hasRequiredErrorStackInstall = 1;
    var createNonEnumerableProperty = requireCreateNonEnumerableProperty();
    var clearErrorStack = requireErrorStackClear();
    var ERROR_STACK_INSTALLABLE = requireErrorStackInstallable();
    var captureStackTrace = Error.captureStackTrace;
    errorStackInstall = function errorStackInstall(error, C, stack, dropEntries) {
      if (ERROR_STACK_INSTALLABLE) {
        if (captureStackTrace) captureStackTrace(error, C);else createNonEnumerableProperty(error, 'stack', clearErrorStack(stack, dropEntries));
      }
    };
    return errorStackInstall;
  }
  var wrapErrorConstructorWithCause;
  var hasRequiredWrapErrorConstructorWithCause;
  function requireWrapErrorConstructorWithCause() {
    if (hasRequiredWrapErrorConstructorWithCause) return wrapErrorConstructorWithCause;
    hasRequiredWrapErrorConstructorWithCause = 1;
    var getBuiltIn = requireGetBuiltIn();
    var hasOwn = requireHasOwnProperty();
    var createNonEnumerableProperty = requireCreateNonEnumerableProperty();
    var isPrototypeOf = requireObjectIsPrototypeOf();
    var setPrototypeOf = requireObjectSetPrototypeOf();
    var copyConstructorProperties = requireCopyConstructorProperties();
    var proxyAccessor = requireProxyAccessor();
    var inheritIfRequired = requireInheritIfRequired();
    var normalizeStringArgument = requireNormalizeStringArgument();
    var installErrorCause = requireInstallErrorCause();
    var installErrorStack = requireErrorStackInstall();
    var DESCRIPTORS = requireDescriptors();
    var IS_PURE = requireIsPure();
    wrapErrorConstructorWithCause = function wrapErrorConstructorWithCause(FULL_NAME, wrapper, FORCED, IS_AGGREGATE_ERROR) {
      var STACK_TRACE_LIMIT = 'stackTraceLimit';
      var OPTIONS_POSITION = IS_AGGREGATE_ERROR ? 2 : 1;
      var path = FULL_NAME.split('.');
      var ERROR_NAME = path[path.length - 1];
      var OriginalError = getBuiltIn.apply(null, path);
      if (!OriginalError) return;
      var OriginalErrorPrototype = OriginalError.prototype;
      if (!IS_PURE && hasOwn(OriginalErrorPrototype, 'cause')) delete OriginalErrorPrototype.cause;
      if (!FORCED) return OriginalError;
      var BaseError = getBuiltIn('Error');
      var WrappedError = wrapper(function (a, b) {
        var message = normalizeStringArgument(IS_AGGREGATE_ERROR ? b : a, undefined);
        var result = IS_AGGREGATE_ERROR ? new OriginalError(a) : new OriginalError();
        if (message !== undefined) createNonEnumerableProperty(result, 'message', message);
        installErrorStack(result, WrappedError, result.stack, 2);
        if (this && isPrototypeOf(OriginalErrorPrototype, this)) inheritIfRequired(result, this, WrappedError);
        if (arguments.length > OPTIONS_POSITION) installErrorCause(result, arguments[OPTIONS_POSITION]);
        return result;
      });
      WrappedError.prototype = OriginalErrorPrototype;
      if (ERROR_NAME !== 'Error') {
        if (setPrototypeOf) setPrototypeOf(WrappedError, BaseError);else copyConstructorProperties(WrappedError, BaseError, {
          name: true
        });
      } else if (DESCRIPTORS && STACK_TRACE_LIMIT in OriginalError) {
        proxyAccessor(WrappedError, OriginalError, STACK_TRACE_LIMIT);
        proxyAccessor(WrappedError, OriginalError, 'prepareStackTrace');
      }
      copyConstructorProperties(WrappedError, OriginalError);
      if (!IS_PURE) try {
        if (OriginalErrorPrototype.name !== ERROR_NAME) {
          createNonEnumerableProperty(OriginalErrorPrototype, 'name', ERROR_NAME);
        }
        OriginalErrorPrototype.constructor = WrappedError;
      } catch (error) {}
      return WrappedError;
    };
    return wrapErrorConstructorWithCause;
  }
  var hasRequiredEs_error_cause;
  function requireEs_error_cause() {
    if (hasRequiredEs_error_cause) return es_error_cause;
    hasRequiredEs_error_cause = 1;
    var $ = require_export();
    var globalThis = requireGlobalThis();
    var apply = requireFunctionApply();
    var wrapErrorConstructorWithCause = requireWrapErrorConstructorWithCause();
    var WEB_ASSEMBLY = 'WebAssembly';
    var WebAssembly = globalThis[WEB_ASSEMBLY];
    var FORCED = new Error('e', {
      cause: 7
    }).cause !== 7;
    var exportGlobalErrorCauseWrapper = function exportGlobalErrorCauseWrapper(ERROR_NAME, wrapper) {
      var O = {};
      O[ERROR_NAME] = wrapErrorConstructorWithCause(ERROR_NAME, wrapper, FORCED);
      $({
        global: true,
        constructor: true,
        arity: 1,
        forced: FORCED
      }, O);
    };
    var exportWebAssemblyErrorCauseWrapper = function exportWebAssemblyErrorCauseWrapper(ERROR_NAME, wrapper) {
      if (WebAssembly && WebAssembly[ERROR_NAME]) {
        var O = {};
        O[ERROR_NAME] = wrapErrorConstructorWithCause(WEB_ASSEMBLY + '.' + ERROR_NAME, wrapper, FORCED);
        $({
          target: WEB_ASSEMBLY,
          stat: true,
          constructor: true,
          arity: 1,
          forced: FORCED
        }, O);
      }
    };
    exportGlobalErrorCauseWrapper('Error', function (init) {
      return function Error(message) {
        return apply(init, this, arguments);
      };
    });
    exportGlobalErrorCauseWrapper('EvalError', function (init) {
      return function EvalError(message) {
        return apply(init, this, arguments);
      };
    });
    exportGlobalErrorCauseWrapper('RangeError', function (init) {
      return function RangeError(message) {
        return apply(init, this, arguments);
      };
    });
    exportGlobalErrorCauseWrapper('ReferenceError', function (init) {
      return function ReferenceError(message) {
        return apply(init, this, arguments);
      };
    });
    exportGlobalErrorCauseWrapper('SyntaxError', function (init) {
      return function SyntaxError(message) {
        return apply(init, this, arguments);
      };
    });
    exportGlobalErrorCauseWrapper('TypeError', function (init) {
      return function TypeError(message) {
        return apply(init, this, arguments);
      };
    });
    exportGlobalErrorCauseWrapper('URIError', function (init) {
      return function URIError(message) {
        return apply(init, this, arguments);
      };
    });
    exportWebAssemblyErrorCauseWrapper('CompileError', function (init) {
      return function CompileError(message) {
        return apply(init, this, arguments);
      };
    });
    exportWebAssemblyErrorCauseWrapper('LinkError', function (init) {
      return function LinkError(message) {
        return apply(init, this, arguments);
      };
    });
    exportWebAssemblyErrorCauseWrapper('RuntimeError', function (init) {
      return function RuntimeError(message) {
        return apply(init, this, arguments);
      };
    });
    return es_error_cause;
  }
  var es_error_isError = {};
  var hasRequiredEs_error_isError;
  function requireEs_error_isError() {
    if (hasRequiredEs_error_isError) return es_error_isError;
    hasRequiredEs_error_isError = 1;
    var $ = require_export();
    var getBuiltIn = requireGetBuiltIn();
    var isObject = requireIsObject();
    var classof = requireClassof();
    var fails = requireFails();
    var ERROR = 'Error';
    var DOM_EXCEPTION = 'DOMException';
    var PROTOTYPE_SETTING_AVAILABLE = Object.setPrototypeOf || {}.__proto__;
    var DOMException = getBuiltIn(DOM_EXCEPTION);
    var $Error = Error;
    var $isError = $Error.isError;
    var FORCED = !$isError || !PROTOTYPE_SETTING_AVAILABLE || fails(function () {
      return DOMException && !$isError(new DOMException(DOM_EXCEPTION)) || !$isError(new $Error(ERROR, {
        cause: function cause() {}
      })) || $isError(getBuiltIn('Object', 'create')($Error.prototype));
    });
    $({
      target: 'Error',
      stat: true,
      sham: true,
      forced: FORCED
    }, {
      isError: function isError(arg) {
        if (!isObject(arg)) return false;
        var tag = classof(arg);
        return tag === ERROR || tag === DOM_EXCEPTION;
      }
    });
    return es_error_isError;
  }
  var es_error_toString = {};
  var errorToString;
  var hasRequiredErrorToString;
  function requireErrorToString() {
    if (hasRequiredErrorToString) return errorToString;
    hasRequiredErrorToString = 1;
    var DESCRIPTORS = requireDescriptors();
    var fails = requireFails();
    var anObject = requireAnObject();
    var normalizeStringArgument = requireNormalizeStringArgument();
    var nativeErrorToString = Error.prototype.toString;
    var INCORRECT_TO_STRING = fails(function () {
      if (DESCRIPTORS) {
        var object = Object.create(Object.defineProperty({}, 'name', {
          get: function get() {
            return this === object;
          }
        }));
        if (nativeErrorToString.call(object) !== 'true') return true;
      }
      return nativeErrorToString.call({
        message: 1,
        name: 2
      }) !== '2: 1' || nativeErrorToString.call({}) !== 'Error';
    });
    errorToString = INCORRECT_TO_STRING ? function toString() {
      var O = anObject(this);
      var name = normalizeStringArgument(O.name, 'Error');
      var message = normalizeStringArgument(O.message);
      return !name ? message : !message ? name : name + ': ' + message;
    } : nativeErrorToString;
    return errorToString;
  }
  var hasRequiredEs_error_toString;
  function requireEs_error_toString() {
    if (hasRequiredEs_error_toString) return es_error_toString;
    hasRequiredEs_error_toString = 1;
    var defineBuiltIn = requireDefineBuiltIn();
    var errorToString = requireErrorToString();
    var ErrorPrototype = Error.prototype;
    if (ErrorPrototype.toString !== errorToString) {
      defineBuiltIn(ErrorPrototype, 'toString', errorToString);
    }
    return es_error_toString;
  }
  var es_aggregateError = {};
  var es_aggregateError_constructor = {};
  var correctPrototypeGetter;
  var hasRequiredCorrectPrototypeGetter;
  function requireCorrectPrototypeGetter() {
    if (hasRequiredCorrectPrototypeGetter) return correctPrototypeGetter;
    hasRequiredCorrectPrototypeGetter = 1;
    var fails = requireFails();
    correctPrototypeGetter = !fails(function () {
      function F() {}
      F.prototype.constructor = null;
      return Object.getPrototypeOf(new F()) !== F.prototype;
    });
    return correctPrototypeGetter;
  }
  var objectGetPrototypeOf;
  var hasRequiredObjectGetPrototypeOf;
  function requireObjectGetPrototypeOf() {
    if (hasRequiredObjectGetPrototypeOf) return objectGetPrototypeOf;
    hasRequiredObjectGetPrototypeOf = 1;
    var hasOwn = requireHasOwnProperty();
    var isCallable = requireIsCallable();
    var toObject = requireToObject();
    var sharedKey = requireSharedKey();
    var CORRECT_PROTOTYPE_GETTER = requireCorrectPrototypeGetter();
    var IE_PROTO = sharedKey('IE_PROTO');
    var $Object = Object;
    var ObjectPrototype = $Object.prototype;
    objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function (O) {
      var object = toObject(O);
      if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];
      var constructor = object.constructor;
      if (isCallable(constructor) && object instanceof constructor) {
        return constructor.prototype;
      }
      return object instanceof $Object ? ObjectPrototype : null;
    };
    return objectGetPrototypeOf;
  }
  var iterators;
  var hasRequiredIterators;
  function requireIterators() {
    if (hasRequiredIterators) return iterators;
    hasRequiredIterators = 1;
    iterators = {};
    return iterators;
  }
  var isArrayIteratorMethod;
  var hasRequiredIsArrayIteratorMethod;
  function requireIsArrayIteratorMethod() {
    if (hasRequiredIsArrayIteratorMethod) return isArrayIteratorMethod;
    hasRequiredIsArrayIteratorMethod = 1;
    var wellKnownSymbol = requireWellKnownSymbol();
    var Iterators = requireIterators();
    var ITERATOR = wellKnownSymbol('iterator');
    var ArrayPrototype = Array.prototype;
    isArrayIteratorMethod = function isArrayIteratorMethod(it) {
      return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
    };
    return isArrayIteratorMethod;
  }
  var getIteratorMethod;
  var hasRequiredGetIteratorMethod;
  function requireGetIteratorMethod() {
    if (hasRequiredGetIteratorMethod) return getIteratorMethod;
    hasRequiredGetIteratorMethod = 1;
    var classof = requireClassof();
    var getMethod = requireGetMethod();
    var isNullOrUndefined = requireIsNullOrUndefined();
    var Iterators = requireIterators();
    var wellKnownSymbol = requireWellKnownSymbol();
    var ITERATOR = wellKnownSymbol('iterator');
    getIteratorMethod = function getIteratorMethod(it) {
      if (!isNullOrUndefined(it)) return getMethod(it, ITERATOR) || getMethod(it, '@@iterator') || Iterators[classof(it)];
    };
    return getIteratorMethod;
  }
  var getIterator;
  var hasRequiredGetIterator;
  function requireGetIterator() {
    if (hasRequiredGetIterator) return getIterator;
    hasRequiredGetIterator = 1;
    var call = requireFunctionCall();
    var aCallable = requireACallable();
    var anObject = requireAnObject();
    var tryToString = requireTryToString();
    var getIteratorMethod = requireGetIteratorMethod();
    var $TypeError = TypeError;
    getIterator = function getIterator(argument, usingIterator) {
      var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
      if (aCallable(iteratorMethod)) return anObject(call(iteratorMethod, argument));
      throw new $TypeError(tryToString(argument) + ' is not iterable');
    };
    return getIterator;
  }
  var iteratorClose;
  var hasRequiredIteratorClose;
  function requireIteratorClose() {
    if (hasRequiredIteratorClose) return iteratorClose;
    hasRequiredIteratorClose = 1;
    var call = requireFunctionCall();
    var anObject = requireAnObject();
    var getMethod = requireGetMethod();
    iteratorClose = function iteratorClose(iterator, kind, value) {
      var innerResult, innerError;
      anObject(iterator);
      try {
        innerResult = getMethod(iterator, 'return');
        if (!innerResult) {
          if (kind === 'throw') throw value;
          return value;
        }
        innerResult = call(innerResult, iterator);
      } catch (error) {
        innerError = true;
        innerResult = error;
      }
      if (kind === 'throw') throw value;
      if (innerError) throw innerResult;
      anObject(innerResult);
      return value;
    };
    return iteratorClose;
  }
  var iterate;
  var hasRequiredIterate;
  function requireIterate() {
    if (hasRequiredIterate) return iterate;
    hasRequiredIterate = 1;
    var bind = requireFunctionBindContext();
    var call = requireFunctionCall();
    var anObject = requireAnObject();
    var tryToString = requireTryToString();
    var isArrayIteratorMethod = requireIsArrayIteratorMethod();
    var lengthOfArrayLike = requireLengthOfArrayLike();
    var isPrototypeOf = requireObjectIsPrototypeOf();
    var getIterator = requireGetIterator();
    var getIteratorMethod = requireGetIteratorMethod();
    var iteratorClose = requireIteratorClose();
    var $TypeError = TypeError;
    var Result = function Result(stopped, result) {
      this.stopped = stopped;
      this.result = result;
    };
    var ResultPrototype = Result.prototype;
    iterate = function iterate(iterable, unboundFunction, options) {
      var that = options && options.that;
      var AS_ENTRIES = !!(options && options.AS_ENTRIES);
      var IS_RECORD = !!(options && options.IS_RECORD);
      var IS_ITERATOR = !!(options && options.IS_ITERATOR);
      var INTERRUPTED = !!(options && options.INTERRUPTED);
      var fn = bind(unboundFunction, that);
      var iterator, iterFn, index, length, result, next, step;
      var stop = function stop(condition) {
        if (iterator) iteratorClose(iterator, 'normal');
        return new Result(true, condition);
      };
      var callFn = function callFn(value) {
        if (AS_ENTRIES) {
          anObject(value);
          return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
        }
        return INTERRUPTED ? fn(value, stop) : fn(value);
      };
      if (IS_RECORD) {
        iterator = iterable.iterator;
      } else if (IS_ITERATOR) {
        iterator = iterable;
      } else {
        iterFn = getIteratorMethod(iterable);
        if (!iterFn) throw new $TypeError(tryToString(iterable) + ' is not iterable');
        if (isArrayIteratorMethod(iterFn)) {
          for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {
            result = callFn(iterable[index]);
            if (result && isPrototypeOf(ResultPrototype, result)) return result;
          }
          return new Result(false);
        }
        iterator = getIterator(iterable, iterFn);
      }
      next = IS_RECORD ? iterable.next : iterator.next;
      while (!(step = call(next, iterator)).done) {
        try {
          result = callFn(step.value);
        } catch (error) {
          iteratorClose(iterator, 'throw', error);
        }
        if (typeof result == 'object' && result && isPrototypeOf(ResultPrototype, result)) return result;
      }
      return new Result(false);
    };
    return iterate;
  }
  var hasRequiredEs_aggregateError_constructor;
  function requireEs_aggregateError_constructor() {
    if (hasRequiredEs_aggregateError_constructor) return es_aggregateError_constructor;
    hasRequiredEs_aggregateError_constructor = 1;
    var $ = require_export();
    var isPrototypeOf = requireObjectIsPrototypeOf();
    var getPrototypeOf = requireObjectGetPrototypeOf();
    var setPrototypeOf = requireObjectSetPrototypeOf();
    var copyConstructorProperties = requireCopyConstructorProperties();
    var create = requireObjectCreate();
    var createNonEnumerableProperty = requireCreateNonEnumerableProperty();
    var createPropertyDescriptor = requireCreatePropertyDescriptor();
    var installErrorCause = requireInstallErrorCause();
    var installErrorStack = requireErrorStackInstall();
    var iterate = requireIterate();
    var normalizeStringArgument = requireNormalizeStringArgument();
    var wellKnownSymbol = requireWellKnownSymbol();
    var TO_STRING_TAG = wellKnownSymbol('toStringTag');
    var $Error = Error;
    var push = [].push;
    var $AggregateError = function AggregateError(errors, message) {
      var isInstance = isPrototypeOf(AggregateErrorPrototype, this);
      var that;
      if (setPrototypeOf) {
        that = setPrototypeOf(new $Error(), isInstance ? getPrototypeOf(this) : AggregateErrorPrototype);
      } else {
        that = isInstance ? this : create(AggregateErrorPrototype);
        createNonEnumerableProperty(that, TO_STRING_TAG, 'Error');
      }
      if (message !== undefined) createNonEnumerableProperty(that, 'message', normalizeStringArgument(message));
      installErrorStack(that, $AggregateError, that.stack, 1);
      if (arguments.length > 2) installErrorCause(that, arguments[2]);
      var errorsArray = [];
      iterate(errors, push, {
        that: errorsArray
      });
      createNonEnumerableProperty(that, 'errors', errorsArray);
      return that;
    };
    if (setPrototypeOf) setPrototypeOf($AggregateError, $Error);else copyConstructorProperties($AggregateError, $Error, {
      name: true
    });
    var AggregateErrorPrototype = $AggregateError.prototype = create($Error.prototype, {
      constructor: createPropertyDescriptor(1, $AggregateError),
      message: createPropertyDescriptor(1, ''),
      name: createPropertyDescriptor(1, 'AggregateError')
    });
    $({
      global: true,
      constructor: true,
      arity: 2
    }, {
      AggregateError: $AggregateError
    });
    return es_aggregateError_constructor;
  }
  var hasRequiredEs_aggregateError;
  function requireEs_aggregateError() {
    if (hasRequiredEs_aggregateError) return es_aggregateError;
    hasRequiredEs_aggregateError = 1;
    requireEs_aggregateError_constructor();
    return es_aggregateError;
  }
  var es_aggregateError_cause = {};
  var hasRequiredEs_aggregateError_cause;
  function requireEs_aggregateError_cause() {
    if (hasRequiredEs_aggregateError_cause) return es_aggregateError_cause;
    hasRequiredEs_aggregateError_cause = 1;
    var $ = require_export();
    var getBuiltIn = requireGetBuiltIn();
    var apply = requireFunctionApply();
    var fails = requireFails();
    var wrapErrorConstructorWithCause = requireWrapErrorConstructorWithCause();
    var AGGREGATE_ERROR = 'AggregateError';
    var $AggregateError = getBuiltIn(AGGREGATE_ERROR);
    var FORCED = !fails(function () {
      return $AggregateError([1]).errors[0] !== 1;
    }) && fails(function () {
      return $AggregateError([1], AGGREGATE_ERROR, {
        cause: 7
      }).cause !== 7;
    });
    $({
      global: true,
      constructor: true,
      arity: 2,
      forced: FORCED
    }, {
      AggregateError: wrapErrorConstructorWithCause(AGGREGATE_ERROR, function (init) {
        return function AggregateError(errors, message) {
          return apply(init, this, arguments);
        };
      }, FORCED, true)
    });
    return es_aggregateError_cause;
  }
  var es_suppressedError_constructor = {};
  var hasRequiredEs_suppressedError_constructor;
  function requireEs_suppressedError_constructor() {
    if (hasRequiredEs_suppressedError_constructor) return es_suppressedError_constructor;
    hasRequiredEs_suppressedError_constructor = 1;
    var $ = require_export();
    var globalThis = requireGlobalThis();
    var isPrototypeOf = requireObjectIsPrototypeOf();
    var getPrototypeOf = requireObjectGetPrototypeOf();
    var setPrototypeOf = requireObjectSetPrototypeOf();
    var copyConstructorProperties = requireCopyConstructorProperties();
    var create = requireObjectCreate();
    var createNonEnumerableProperty = requireCreateNonEnumerableProperty();
    var createPropertyDescriptor = requireCreatePropertyDescriptor();
    var installErrorStack = requireErrorStackInstall();
    var normalizeStringArgument = requireNormalizeStringArgument();
    var wellKnownSymbol = requireWellKnownSymbol();
    var fails = requireFails();
    var IS_PURE = requireIsPure();
    var NativeSuppressedError = globalThis.SuppressedError;
    var TO_STRING_TAG = wellKnownSymbol('toStringTag');
    var $Error = Error;
    var WRONG_ARITY = !!NativeSuppressedError && NativeSuppressedError.length !== 3;
    var EXTRA_ARGS_SUPPORT = !!NativeSuppressedError && fails(function () {
      return new NativeSuppressedError(1, 2, 3, {
        cause: 4
      }).cause === 4;
    });
    var PATCH = WRONG_ARITY || EXTRA_ARGS_SUPPORT;
    var $SuppressedError = function SuppressedError(error, suppressed, message) {
      var isInstance = isPrototypeOf(SuppressedErrorPrototype, this);
      var that;
      if (setPrototypeOf) {
        that = PATCH && (!isInstance || getPrototypeOf(this) === SuppressedErrorPrototype) ? new NativeSuppressedError() : setPrototypeOf(new $Error(), isInstance ? getPrototypeOf(this) : SuppressedErrorPrototype);
      } else {
        that = isInstance ? this : create(SuppressedErrorPrototype);
        createNonEnumerableProperty(that, TO_STRING_TAG, 'Error');
      }
      if (message !== undefined) createNonEnumerableProperty(that, 'message', normalizeStringArgument(message));
      installErrorStack(that, $SuppressedError, that.stack, 1);
      createNonEnumerableProperty(that, 'error', error);
      createNonEnumerableProperty(that, 'suppressed', suppressed);
      return that;
    };
    if (setPrototypeOf) setPrototypeOf($SuppressedError, $Error);else copyConstructorProperties($SuppressedError, $Error, {
      name: true
    });
    var SuppressedErrorPrototype = $SuppressedError.prototype = PATCH ? NativeSuppressedError.prototype : create($Error.prototype, {
      constructor: createPropertyDescriptor(1, $SuppressedError),
      message: createPropertyDescriptor(1, ''),
      name: createPropertyDescriptor(1, 'SuppressedError')
    });
    if (PATCH && !IS_PURE) SuppressedErrorPrototype.constructor = $SuppressedError;
    $({
      global: true,
      constructor: true,
      arity: 3,
      forced: PATCH
    }, {
      SuppressedError: $SuppressedError
    });
    return es_suppressedError_constructor;
  }
  var es_array_at = {};
  var addToUnscopables;
  var hasRequiredAddToUnscopables;
  function requireAddToUnscopables() {
    if (hasRequiredAddToUnscopables) return addToUnscopables;
    hasRequiredAddToUnscopables = 1;
    var wellKnownSymbol = requireWellKnownSymbol();
    var create = requireObjectCreate();
    var defineProperty = requireObjectDefineProperty().f;
    var UNSCOPABLES = wellKnownSymbol('unscopables');
    var ArrayPrototype = Array.prototype;
    if (ArrayPrototype[UNSCOPABLES] === undefined) {
      defineProperty(ArrayPrototype, UNSCOPABLES, {
        configurable: true,
        value: create(null)
      });
    }
    addToUnscopables = function addToUnscopables(key) {
      ArrayPrototype[UNSCOPABLES][key] = true;
    };
    return addToUnscopables;
  }
  var hasRequiredEs_array_at;
  function requireEs_array_at() {
    if (hasRequiredEs_array_at) return es_array_at;
    hasRequiredEs_array_at = 1;
    var $ = require_export();
    var toObject = requireToObject();
    var lengthOfArrayLike = requireLengthOfArrayLike();
    var toIntegerOrInfinity = requireToIntegerOrInfinity();
    var addToUnscopables = requireAddToUnscopables();
    $({
      target: 'Array',
      proto: true
    }, {
      at: function at(index) {
        var O = toObject(this);
        var len = lengthOfArrayLike(O);
        var relativeIndex = toIntegerOrInfinity(index);
        var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
        return k < 0 || k >= len ? undefined : O[k];
      }
    });
    addToUnscopables('at');
    return es_array_at;
  }
  var es_array_concat = {};
  var doesNotExceedSafeInteger;
  var hasRequiredDoesNotExceedSafeInteger;
  function requireDoesNotExceedSafeInteger() {
    if (hasRequiredDoesNotExceedSafeInteger) return doesNotExceedSafeInteger;
    hasRequiredDoesNotExceedSafeInteger = 1;
    var $TypeError = TypeError;
    var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
    doesNotExceedSafeInteger = function doesNotExceedSafeInteger(it) {
      if (it > MAX_SAFE_INTEGER) throw $TypeError('Maximum allowed index exceeded');
      return it;
    };
    return doesNotExceedSafeInteger;
  }
  var createProperty;
  var hasRequiredCreateProperty;
  function requireCreateProperty() {
    if (hasRequiredCreateProperty) return createProperty;
    hasRequiredCreateProperty = 1;
    var DESCRIPTORS = requireDescriptors();
    var definePropertyModule = requireObjectDefineProperty();
    var createPropertyDescriptor = requireCreatePropertyDescriptor();
    createProperty = function createProperty(object, key, value) {
      if (DESCRIPTORS) definePropertyModule.f(object, key, createPropertyDescriptor(0, value));else object[key] = value;
    };
    return createProperty;
  }
  var arrayMethodHasSpeciesSupport;
  var hasRequiredArrayMethodHasSpeciesSupport;
  function requireArrayMethodHasSpeciesSupport() {
    if (hasRequiredArrayMethodHasSpeciesSupport) return arrayMethodHasSpeciesSupport;
    hasRequiredArrayMethodHasSpeciesSupport = 1;
    var fails = requireFails();
    var wellKnownSymbol = requireWellKnownSymbol();
    var V8_VERSION = requireEnvironmentV8Version();
    var SPECIES = wellKnownSymbol('species');
    arrayMethodHasSpeciesSupport = function arrayMethodHasSpeciesSupport(METHOD_NAME) {
      return V8_VERSION >= 51 || !fails(function () {
        var array = [];
        var constructor = array.constructor = {};
        constructor[SPECIES] = function () {
          return {
            foo: 1
          };
        };
        return array[METHOD_NAME](Boolean).foo !== 1;
      });
    };
    return arrayMethodHasSpeciesSupport;
  }
  var hasRequiredEs_array_concat;
  function requireEs_array_concat() {
    if (hasRequiredEs_array_concat) return es_array_concat;
    hasRequiredEs_array_concat = 1;
    var $ = require_export();
    var fails = requireFails();
    var isArray = requireIsArray();
    var isObject = requireIsObject();
    var toObject = requireToObject();
    var lengthOfArrayLike = requireLengthOfArrayLike();
    var doesNotExceedSafeInteger = requireDoesNotExceedSafeInteger();
    var createProperty = requireCreateProperty();
    var arraySpeciesCreate = requireArraySpeciesCreate();
    var arrayMethodHasSpeciesSupport = requireArrayMethodHasSpeciesSupport();
    var wellKnownSymbol = requireWellKnownSymbol();
    var V8_VERSION = requireEnvironmentV8Version();
    var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');
    var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function () {
      var array = [];
      array[IS_CONCAT_SPREADABLE] = false;
      return array.concat()[0] !== array;
    });
    var isConcatSpreadable = function isConcatSpreadable(O) {
      if (!isObject(O)) return false;
      var spreadable = O[IS_CONCAT_SPREADABLE];
      return spreadable !== undefined ? !!spreadable : isArray(O);
    };
    var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !arrayMethodHasSpeciesSupport('concat');
    $({
      target: 'Array',
      proto: true,
      arity: 1,
      forced: FORCED
    }, {
      concat: function concat(arg) {
        var O = toObject(this);
        var A = arraySpeciesCreate(O, 0);
        var n = 0;
        var i, k, length, len, E;
        for (i = -1, length = arguments.length; i < length; i++) {
          E = i === -1 ? O : arguments[i];
          if (isConcatSpreadable(E)) {
            len = lengthOfArrayLike(E);
            doesNotExceedSafeInteger(n + len);
            for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
          } else {
            doesNotExceedSafeInteger(n + 1);
            createProperty(A, n++, E);
          }
        }
        A.length = n;
        return A;
      }
    });
    return es_array_concat;
  }
  var es_array_copyWithin = {};
  var deletePropertyOrThrow;
  var hasRequiredDeletePropertyOrThrow;
  function requireDeletePropertyOrThrow() {
    if (hasRequiredDeletePropertyOrThrow) return deletePropertyOrThrow;
    hasRequiredDeletePropertyOrThrow = 1;
    var tryToString = requireTryToString();
    var $TypeError = TypeError;
    deletePropertyOrThrow = function deletePropertyOrThrow(O, P) {
      if (!delete O[P]) throw new $TypeError('Cannot delete property ' + tryToString(P) + ' of ' + tryToString(O));
    };
    return deletePropertyOrThrow;
  }
  var arrayCopyWithin;
  var hasRequiredArrayCopyWithin;
  function requireArrayCopyWithin() {
    if (hasRequiredArrayCopyWithin) return arrayCopyWithin;
    hasRequiredArrayCopyWithin = 1;
    var toObject = requireToObject();
    var toAbsoluteIndex = requireToAbsoluteIndex();
    var lengthOfArrayLike = requireLengthOfArrayLike();
    var deletePropertyOrThrow = requireDeletePropertyOrThrow();
    var min = Math.min;
    arrayCopyWithin = [].copyWithin || function copyWithin(target, start) {
      var O = toObject(this);
      var len = lengthOfArrayLike(O);
      var to = toAbsoluteIndex(target, len);
      var from = toAbsoluteIndex(start, len);
      var end = arguments.length > 2 ? arguments[2] : undefined;
      var count = min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
      var inc = 1;
      if (from < to && to < from + count) {
        inc = -1;
        from += count - 1;
        to += count - 1;
      }
      while (count-- > 0) {
        if (from in O) O[to] = O[from];else deletePropertyOrThrow(O, to);
        to += inc;
        from += inc;
      }
      return O;
    };
    return arrayCopyWithin;
  }
  var hasRequiredEs_array_copyWithin;
  function requireEs_array_copyWithin() {
    if (hasRequiredEs_array_copyWithin) return es_array_copyWithin;
    hasRequiredEs_array_copyWithin = 1;
    var $ = require_export();
    var copyWithin = requireArrayCopyWithin();
    var addToUnscopables = requireAddToUnscopables();
    $({
      target: 'Array',
      proto: true
    }, {
      copyWithin: copyWithin
    });
    addToUnscopables('copyWithin');
    return es_array_copyWithin;
  }
  var es_array_every = {};
  var arrayMethodIsStrict;
  var hasRequiredArrayMethodIsStrict;
  function requireArrayMethodIsStrict() {
    if (hasRequiredArrayMethodIsStrict) return arrayMethodIsStrict;
    hasRequiredArrayMethodIsStrict = 1;
    var fails = requireFails();
    arrayMethodIsStrict = function arrayMethodIsStrict(METHOD_NAME, argument) {
      var method = [][METHOD_NAME];
      return !!method && fails(function () {
        method.call(null, argument || function () {
          return 1;
        }, 1);
      });
    };
    return arrayMethodIsStrict;
  }
  var hasRequiredEs_array_every;
  function requireEs_array_every() {
    if (hasRequiredEs_array_every) return es_array_every;
    hasRequiredEs_array_every = 1;
    var $ = require_export();
    var $every = requireArrayIteration().every;
    var arrayMethodIsStrict = requireArrayMethodIsStrict();
    var STRICT_METHOD = arrayMethodIsStrict('every');
    $({
      target: 'Array',
      proto: true,
      forced: !STRICT_METHOD
    }, {
      every: function every(callbackfn) {
        return $every(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
      }
    });
    return es_array_every;
  }
  var es_array_fill = {};
  var arrayFill;
  var hasRequiredArrayFill;
  function requireArrayFill() {
    if (hasRequiredArrayFill) return arrayFill;
    hasRequiredArrayFill = 1;
    var toObject = requireToObject();
    var toAbsoluteIndex = requireToAbsoluteIndex();
    var lengthOfArrayLike = requireLengthOfArrayLike();
    arrayFill = function fill(value) {
      var O = toObject(this);
      var length = lengthOfArrayLike(O);
      var argumentsLength = arguments.length;
      var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
      var end = argumentsLength > 2 ? arguments[2] : undefined;
      var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
      while (endPos > index) O[index++] = value;
      return O;
    };
    return arrayFill;
  }
  var hasRequiredEs_array_fill;
  function requireEs_array_fill() {
    if (hasRequiredEs_array_fill) return es_array_fill;
    hasRequiredEs_array_fill = 1;
    var $ = require_export();
    var fill = requireArrayFill();
    var addToUnscopables = requireAddToUnscopables();
    $({
      target: 'Array',
      proto: true
    }, {
      fill: fill
    });
    addToUnscopables('fill');
    return es_array_fill;
  }
  var es_array_filter = {};
  var hasRequiredEs_array_filter;
  function requireEs_array_filter() {
    if (hasRequiredEs_array_filter) return es_array_filter;
    hasRequiredEs_array_filter = 1;
    var $ = require_export();
    var $filter = requireArrayIteration().filter;
    var arrayMethodHasSpeciesSupport = requireArrayMethodHasSpeciesSupport();
    var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter');
    $({
      target: 'Array',
      proto: true,
      forced: !HAS_SPECIES_SUPPORT
    }, {
      filter: function filter(callbackfn) {
        return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
      }
    });
    return es_array_filter;
  }
  var es_array_find = {};
  var hasRequiredEs_array_find;
  function requireEs_array_find() {
    if (hasRequiredEs_array_find) return es_array_find;
    hasRequiredEs_array_find = 1;
    var $ = require_export();
    var $find = requireArrayIteration().find;
    var addToUnscopables = requireAddToUnscopables();
    var FIND = 'find';
    var SKIPS_HOLES = true;
    if (FIND in []) Array(1)[FIND](function () {
      SKIPS_HOLES = false;
    });
    $({
      target: 'Array',
      proto: true,
      forced: SKIPS_HOLES
    }, {
      find: function find(callbackfn) {
        return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
      }
    });
    addToUnscopables(FIND);
    return es_array_find;
  }
  var es_array_findIndex = {};
  var hasRequiredEs_array_findIndex;
  function requireEs_array_findIndex() {
    if (hasRequiredEs_array_findIndex) return es_array_findIndex;
    hasRequiredEs_array_findIndex = 1;
    var $ = require_export();
    var $findIndex = requireArrayIteration().findIndex;
    var addToUnscopables = requireAddToUnscopables();
    var FIND_INDEX = 'findIndex';
    var SKIPS_HOLES = true;
    if (FIND_INDEX in []) Array(1)[FIND_INDEX](function () {
      SKIPS_HOLES = false;
    });
    $({
      target: 'Array',
      proto: true,
      forced: SKIPS_HOLES
    }, {
      findIndex: function findIndex(callbackfn) {
        return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
      }
    });
    addToUnscopables(FIND_INDEX);
    return es_array_findIndex;
  }
  var es_array_findLast = {};
  var arrayIterationFromLast;
  var hasRequiredArrayIterationFromLast;
  function requireArrayIterationFromLast() {
    if (hasRequiredArrayIterationFromLast) return arrayIterationFromLast;
    hasRequiredArrayIterationFromLast = 1;
    var bind = requireFunctionBindContext();
    var IndexedObject = requireIndexedObject();
    var toObject = requireToObject();
    var lengthOfArrayLike = requireLengthOfArrayLike();
    var createMethod = function createMethod(TYPE) {
      var IS_FIND_LAST_INDEX = TYPE === 1;
      return function ($this, callbackfn, that) {
        var O = toObject($this);
        var self = IndexedObject(O);
        var index = lengthOfArrayLike(self);
        var boundFunction = bind(callbackfn, that);
        var value, result;
        while (index-- > 0) {
          value = self[index];
          result = boundFunction(value, index, O);
          if (result) switch (TYPE) {
            case 0:
              return value;
            case 1:
              return index;
          }
        }
        return IS_FIND_LAST_INDEX ? -1 : undefined;
      };
    };
    arrayIterationFromLast = {
      findLast: createMethod(0),
      findLastIndex: createMethod(1)
    };
    return arrayIterationFromLast;
  }
  var hasRequiredEs_array_findLast;
  function requireEs_array_findLast() {
    if (hasRequiredEs_array_findLast) return es_array_findLast;
    hasRequiredEs_array_findLast = 1;
    var $ = require_export();
    var $findLast = requireArrayIterationFromLast().findLast;
    var addToUnscopables = requireAddToUnscopables();
    $({
      target: 'Array',
      proto: true
    }, {
      findLast: function findLast(callbackfn) {
        return $findLast(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
      }
    });
    addToUnscopables('findLast');
    return es_array_findLast;
  }
  var es_array_findLastIndex = {};
  var hasRequiredEs_array_findLastIndex;
  function requireEs_array_findLastIndex() {
    if (hasRequiredEs_array_findLastIndex) return es_array_findLastIndex;
    hasRequiredEs_array_findLastIndex = 1;
    var $ = require_export();
    var $findLastIndex = requireArrayIterationFromLast().findLastIndex;
    var addToUnscopables = requireAddToUnscopables();
    $({
      target: 'Array',
      proto: true
    }, {
      findLastIndex: function findLastIndex(callbackfn) {
        return $findLastIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
      }
    });
    addToUnscopables('findLastIndex');
    return es_array_findLastIndex;
  }
  var es_array_flat = {};
  var flattenIntoArray_1;
  var hasRequiredFlattenIntoArray;
  function requireFlattenIntoArray() {
    if (hasRequiredFlattenIntoArray) return flattenIntoArray_1;
    hasRequiredFlattenIntoArray = 1;
    var isArray = requireIsArray();
    var lengthOfArrayLike = requireLengthOfArrayLike();
    var doesNotExceedSafeInteger = requireDoesNotExceedSafeInteger();
    var bind = requireFunctionBindContext();
    var _flattenIntoArray = function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
      var targetIndex = start;
      var sourceIndex = 0;
      var mapFn = mapper ? bind(mapper, thisArg) : false;
      var element, elementLen;
      while (sourceIndex < sourceLen) {
        if (sourceIndex in source) {
          element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];
          if (depth > 0 && isArray(element)) {
            elementLen = lengthOfArrayLike(element);
            targetIndex = _flattenIntoArray(target, original, element, elementLen, targetIndex, depth - 1) - 1;
          } else {
            doesNotExceedSafeInteger(targetIndex + 1);
            target[targetIndex] = element;
          }
          targetIndex++;
        }
        sourceIndex++;
      }
      return targetIndex;
    };
    flattenIntoArray_1 = _flattenIntoArray;
    return flattenIntoArray_1;
  }
  var hasRequiredEs_array_flat;
  function requireEs_array_flat() {
    if (hasRequiredEs_array_flat) return es_array_flat;
    hasRequiredEs_array_flat = 1;
    var $ = require_export();
    var flattenIntoArray = requireFlattenIntoArray();
    var toObject = requireToObject();
    var lengthOfArrayLike = requireLengthOfArrayLike();
    var toIntegerOrInfinity = requireToIntegerOrInfinity();
    var arraySpeciesCreate = requireArraySpeciesCreate();
    $({
      target: 'Array',
      proto: true
    }, {
      flat: function flat() {
        var depthArg = arguments.length ? arguments[0] : undefined;
        var O = toObject(this);
        var sourceLen = lengthOfArrayLike(O);
        var A = arraySpeciesCreate(O, 0);
        A.length = flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toIntegerOrInfinity(depthArg));
        return A;
      }
    });
    return es_array_flat;
  }
  var es_array_flatMap = {};
  var hasRequiredEs_array_flatMap;
  function requireEs_array_flatMap() {
    if (hasRequiredEs_array_flatMap) return es_array_flatMap;
    hasRequiredEs_array_flatMap = 1;
    var $ = require_export();
    var flattenIntoArray = requireFlattenIntoArray();
    var aCallable = requireACallable();
    var toObject = requireToObject();
    var lengthOfArrayLike = requireLengthOfArrayLike();
    var arraySpeciesCreate = requireArraySpeciesCreate();
    $({
      target: 'Array',
      proto: true
    }, {
      flatMap: function flatMap(callbackfn) {
        var O = toObject(this);
        var sourceLen = lengthOfArrayLike(O);
        var A;
        aCallable(callbackfn);
        A = arraySpeciesCreate(O, 0);
        A.length = flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        return A;
      }
    });
    return es_array_flatMap;
  }
  var es_array_forEach = {};
  var arrayForEach;
  var hasRequiredArrayForEach;
  function requireArrayForEach() {
    if (hasRequiredArrayForEach) return arrayForEach;
    hasRequiredArrayForEach = 1;
    var $forEach = requireArrayIteration().forEach;
    var arrayMethodIsStrict = requireArrayMethodIsStrict();
    var STRICT_METHOD = arrayMethodIsStrict('forEach');
    arrayForEach = !STRICT_METHOD ? function forEach(callbackfn) {
      return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    } : [].forEach;
    return arrayForEach;
  }
  var hasRequiredEs_array_forEach;
  function requireEs_array_forEach() {
    if (hasRequiredEs_array_forEach) return es_array_forEach;
    hasRequiredEs_array_forEach = 1;
    var $ = require_export();
    var forEach = requireArrayForEach();
    $({
      target: 'Array',
      proto: true,
      forced: [].forEach !== forEach
    }, {
      forEach: forEach
    });
    return es_array_forEach;
  }
  var es_array_from = {};
  var callWithSafeIterationClosing;
  var hasRequiredCallWithSafeIterationClosing;
  function requireCallWithSafeIterationClosing() {
    if (hasRequiredCallWithSafeIterationClosing) return callWithSafeIterationClosing;
    hasRequiredCallWithSafeIterationClosing = 1;
    var anObject = requireAnObject();
    var iteratorClose = requireIteratorClose();
    callWithSafeIterationClosing = function callWithSafeIterationClosing(iterator, fn, value, ENTRIES) {
      try {
        return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
      } catch (error) {
        iteratorClose(iterator, 'throw', error);
      }
    };
    return callWithSafeIterationClosing;
  }
  var arrayFrom;
  var hasRequiredArrayFrom;
  function requireArrayFrom() {
    if (hasRequiredArrayFrom) return arrayFrom;
    hasRequiredArrayFrom = 1;
    var bind = requireFunctionBindContext();
    var call = requireFunctionCall();
    var toObject = requireToObject();
    var callWithSafeIterationClosing = requireCallWithSafeIterationClosing();
    var isArrayIteratorMethod = requireIsArrayIteratorMethod();
    var isConstructor = requireIsConstructor();
    var lengthOfArrayLike = requireLengthOfArrayLike();
    var createProperty = requireCreateProperty();
    var getIterator = requireGetIterator();
    var getIteratorMethod = requireGetIteratorMethod();
    var $Array = Array;
    arrayFrom = function from(arrayLike) {
      var O = toObject(arrayLike);
      var IS_CONSTRUCTOR = isConstructor(this);
      var argumentsLength = arguments.length;
      var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
      var mapping = mapfn !== undefined;
      if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : undefined);
      var iteratorMethod = getIteratorMethod(O);
      var index = 0;
      var length, result, step, iterator, next, value;
      if (iteratorMethod && !(this === $Array && isArrayIteratorMethod(iteratorMethod))) {
        result = IS_CONSTRUCTOR ? new this() : [];
        iterator = getIterator(O, iteratorMethod);
        next = iterator.next;
        for (; !(step = call(next, iterator)).done; index++) {
          value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
          createProperty(result, index, value);
        }
      } else {
        length = lengthOfArrayLike(O);
        result = IS_CONSTRUCTOR ? new this(length) : $Array(length);
        for (; length > index; index++) {
          value = mapping ? mapfn(O[index], index) : O[index];
          createProperty(result, index, value);
        }
      }
      result.length = index;
      return result;
    };
    return arrayFrom;
  }
  var checkCorrectnessOfIteration;
  var hasRequiredCheckCorrectnessOfIteration;
  function requireCheckCorrectnessOfIteration() {
    if (hasRequiredCheckCorrectnessOfIteration) return checkCorrectnessOfIteration;
    hasRequiredCheckCorrectnessOfIteration = 1;
    var wellKnownSymbol = requireWellKnownSymbol();
    var ITERATOR = wellKnownSymbol('iterator');
    var SAFE_CLOSING = false;
    try {
      var called = 0;
      var iteratorWithReturn = {
        next: function next() {
          return {
            done: !!called++
          };
        },
        'return': function _return() {
          SAFE_CLOSING = true;
        }
      };
      iteratorWithReturn[ITERATOR] = function () {
        return this;
      };
      Array.from(iteratorWithReturn, function () {
        throw 2;
      });
    } catch (error) {}
    checkCorrectnessOfIteration = function checkCorrectnessOfIteration(exec, SKIP_CLOSING) {
      try {
        if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
      } catch (error) {
        return false;
      }
      var ITERATION_SUPPORT = false;
      try {
        var object = {};
        object[ITERATOR] = function () {
          return {
            next: function next() {
              return {
                done: ITERATION_SUPPORT = true
              };
            }
          };
        };
        exec(object);
      } catch (error) {}
      return ITERATION_SUPPORT;
    };
    return checkCorrectnessOfIteration;
  }
  var hasRequiredEs_array_from;
  function requireEs_array_from() {
    if (hasRequiredEs_array_from) return es_array_from;
    hasRequiredEs_array_from = 1;
    var $ = require_export();
    var from = requireArrayFrom();
    var checkCorrectnessOfIteration = requireCheckCorrectnessOfIteration();
    var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {
      Array.from(iterable);
    });
    $({
      target: 'Array',
      stat: true,
      forced: INCORRECT_ITERATION
    }, {
      from: from
    });
    return es_array_from;
  }
  var es_array_includes = {};
  var hasRequiredEs_array_includes;
  function requireEs_array_includes() {
    if (hasRequiredEs_array_includes) return es_array_includes;
    hasRequiredEs_array_includes = 1;
    var $ = require_export();
    var $includes = requireArrayIncludes().includes;
    var fails = requireFails();
    var addToUnscopables = requireAddToUnscopables();
    var BROKEN_ON_SPARSE = fails(function () {
      return !Array(1).includes();
    });
    $({
      target: 'Array',
      proto: true,
      forced: BROKEN_ON_SPARSE
    }, {
      includes: function includes(el) {
        return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
      }
    });
    addToUnscopables('includes');
    return es_array_includes;
  }
  var es_array_indexOf = {};
  var hasRequiredEs_array_indexOf;
  function requireEs_array_indexOf() {
    if (hasRequiredEs_array_indexOf) return es_array_indexOf;
    hasRequiredEs_array_indexOf = 1;
    var $ = require_export();
    var uncurryThis = requireFunctionUncurryThisClause();
    var $indexOf = requireArrayIncludes().indexOf;
    var arrayMethodIsStrict = requireArrayMethodIsStrict();
    var nativeIndexOf = uncurryThis([].indexOf);
    var NEGATIVE_ZERO = !!nativeIndexOf && 1 / nativeIndexOf([1], 1, -0) < 0;
    var FORCED = NEGATIVE_ZERO || !arrayMethodIsStrict('indexOf');
    $({
      target: 'Array',
      proto: true,
      forced: FORCED
    }, {
      indexOf: function indexOf(searchElement) {
        var fromIndex = arguments.length > 1 ? arguments[1] : undefined;
        return NEGATIVE_ZERO ? nativeIndexOf(this, searchElement, fromIndex) || 0 : $indexOf(this, searchElement, fromIndex);
      }
    });
    return es_array_indexOf;
  }
  var es_array_isArray = {};
  var hasRequiredEs_array_isArray;
  function requireEs_array_isArray() {
    if (hasRequiredEs_array_isArray) return es_array_isArray;
    hasRequiredEs_array_isArray = 1;
    var $ = require_export();
    var isArray = requireIsArray();
    $({
      target: 'Array',
      stat: true
    }, {
      isArray: isArray
    });
    return es_array_isArray;
  }
  var iteratorsCore;
  var hasRequiredIteratorsCore;
  function requireIteratorsCore() {
    if (hasRequiredIteratorsCore) return iteratorsCore;
    hasRequiredIteratorsCore = 1;
    var fails = requireFails();
    var isCallable = requireIsCallable();
    var isObject = requireIsObject();
    var create = requireObjectCreate();
    var getPrototypeOf = requireObjectGetPrototypeOf();
    var defineBuiltIn = requireDefineBuiltIn();
    var wellKnownSymbol = requireWellKnownSymbol();
    var IS_PURE = requireIsPure();
    var ITERATOR = wellKnownSymbol('iterator');
    var BUGGY_SAFARI_ITERATORS = false;
    var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;
    if ([].keys) {
      arrayIterator = [].keys();
      if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;else {
        PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
        if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
      }
    }
    var NEW_ITERATOR_PROTOTYPE = !isObject(IteratorPrototype) || fails(function () {
      var test = {};
      return IteratorPrototype[ITERATOR].call(test) !== test;
    });
    if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};else if (IS_PURE) IteratorPrototype = create(IteratorPrototype);
    if (!isCallable(IteratorPrototype[ITERATOR])) {
      defineBuiltIn(IteratorPrototype, ITERATOR, function () {
        return this;
      });
    }
    iteratorsCore = {
      IteratorPrototype: IteratorPrototype,
      BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
    };
    return iteratorsCore;
  }
  var iteratorCreateConstructor;
  var hasRequiredIteratorCreateConstructor;
  function requireIteratorCreateConstructor() {
    if (hasRequiredIteratorCreateConstructor) return iteratorCreateConstructor;
    hasRequiredIteratorCreateConstructor = 1;
    var IteratorPrototype = requireIteratorsCore().IteratorPrototype;
    var create = requireObjectCreate();
    var createPropertyDescriptor = requireCreatePropertyDescriptor();
    var setToStringTag = requireSetToStringTag();
    var Iterators = requireIterators();
    var returnThis = function returnThis() {
      return this;
    };
    iteratorCreateConstructor = function iteratorCreateConstructor(IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
      var TO_STRING_TAG = NAME + ' Iterator';
      IteratorConstructor.prototype = create(IteratorPrototype, {
        next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next)
      });
      setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
      Iterators[TO_STRING_TAG] = returnThis;
      return IteratorConstructor;
    };
    return iteratorCreateConstructor;
  }
  var iteratorDefine;
  var hasRequiredIteratorDefine;
  function requireIteratorDefine() {
    if (hasRequiredIteratorDefine) return iteratorDefine;
    hasRequiredIteratorDefine = 1;
    var $ = require_export();
    var call = requireFunctionCall();
    var IS_PURE = requireIsPure();
    var FunctionName = requireFunctionName();
    var isCallable = requireIsCallable();
    var createIteratorConstructor = requireIteratorCreateConstructor();
    var getPrototypeOf = requireObjectGetPrototypeOf();
    var setPrototypeOf = requireObjectSetPrototypeOf();
    var setToStringTag = requireSetToStringTag();
    var createNonEnumerableProperty = requireCreateNonEnumerableProperty();
    var defineBuiltIn = requireDefineBuiltIn();
    var wellKnownSymbol = requireWellKnownSymbol();
    var Iterators = requireIterators();
    var IteratorsCore = requireIteratorsCore();
    var PROPER_FUNCTION_NAME = FunctionName.PROPER;
    var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
    var IteratorPrototype = IteratorsCore.IteratorPrototype;
    var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
    var ITERATOR = wellKnownSymbol('iterator');
    var KEYS = 'keys';
    var VALUES = 'values';
    var ENTRIES = 'entries';
    var returnThis = function returnThis() {
      return this;
    };
    iteratorDefine = function iteratorDefine(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
      createIteratorConstructor(IteratorConstructor, NAME, next);
      var getIterationMethod = function getIterationMethod(KIND) {
        if (KIND === DEFAULT && defaultIterator) return defaultIterator;
        if (!BUGGY_SAFARI_ITERATORS && KIND && KIND in IterablePrototype) return IterablePrototype[KIND];
        switch (KIND) {
          case KEYS:
            return function keys() {
              return new IteratorConstructor(this, KIND);
            };
          case VALUES:
            return function values() {
              return new IteratorConstructor(this, KIND);
            };
          case ENTRIES:
            return function entries() {
              return new IteratorConstructor(this, KIND);
            };
        }
        return function () {
          return new IteratorConstructor(this);
        };
      };
      var TO_STRING_TAG = NAME + ' Iterator';
      var INCORRECT_VALUES_NAME = false;
      var IterablePrototype = Iterable.prototype;
      var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype['@@iterator'] || DEFAULT && IterablePrototype[DEFAULT];
      var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
      var anyNativeIterator = NAME === 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
      var CurrentIteratorPrototype, methods, KEY;
      if (anyNativeIterator) {
        CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
        if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
          if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
            if (setPrototypeOf) {
              setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
            } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {
              defineBuiltIn(CurrentIteratorPrototype, ITERATOR, returnThis);
            }
          }
          setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
          if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
        }
      }
      if (PROPER_FUNCTION_NAME && DEFAULT === VALUES && nativeIterator && nativeIterator.name !== VALUES) {
        if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
          createNonEnumerableProperty(IterablePrototype, 'name', VALUES);
        } else {
          INCORRECT_VALUES_NAME = true;
          defaultIterator = function values() {
            return call(nativeIterator, this);
          };
        }
      }
      if (DEFAULT) {
        methods = {
          values: getIterationMethod(VALUES),
          keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
          entries: getIterationMethod(ENTRIES)
        };
        if (FORCED) for (KEY in methods) {
          if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
            defineBuiltIn(IterablePrototype, KEY, methods[KEY]);
          }
        } else $({
          target: NAME,
          proto: true,
          forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME
        }, methods);
      }
      if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
        defineBuiltIn(IterablePrototype, ITERATOR, defaultIterator, {
          name: DEFAULT
        });
      }
      Iterators[NAME] = defaultIterator;
      return methods;
    };
    return iteratorDefine;
  }
  var createIterResultObject;
  var hasRequiredCreateIterResultObject;
  function requireCreateIterResultObject() {
    if (hasRequiredCreateIterResultObject) return createIterResultObject;
    hasRequiredCreateIterResultObject = 1;
    createIterResultObject = function createIterResultObject(value, done) {
      return {
        value: value,
        done: done
      };
    };
    return createIterResultObject;
  }
  var es_array_iterator;
  var hasRequiredEs_array_iterator;
  function requireEs_array_iterator() {
    if (hasRequiredEs_array_iterator) return es_array_iterator;
    hasRequiredEs_array_iterator = 1;
    var toIndexedObject = requireToIndexedObject();
    var addToUnscopables = requireAddToUnscopables();
    var Iterators = requireIterators();
    var InternalStateModule = requireInternalState();
    var defineProperty = requireObjectDefineProperty().f;
    var defineIterator = requireIteratorDefine();
    var createIterResultObject = requireCreateIterResultObject();
    var IS_PURE = requireIsPure();
    var DESCRIPTORS = requireDescriptors();
    var ARRAY_ITERATOR = 'Array Iterator';
    var setInternalState = InternalStateModule.set;
    var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
    es_array_iterator = defineIterator(Array, 'Array', function (iterated, kind) {
      setInternalState(this, {
        type: ARRAY_ITERATOR,
        target: toIndexedObject(iterated),
        index: 0,
        kind: kind
      });
    }, function () {
      var state = getInternalState(this);
      var target = state.target;
      var index = state.index++;
      if (!target || index >= target.length) {
        state.target = null;
        return createIterResultObject(undefined, true);
      }
      switch (state.kind) {
        case 'keys':
          return createIterResultObject(index, false);
        case 'values':
          return createIterResultObject(target[index], false);
      }
      return createIterResultObject([index, target[index]], false);
    }, 'values');
    var values = Iterators.Arguments = Iterators.Array;
    addToUnscopables('keys');
    addToUnscopables('values');
    addToUnscopables('entries');
    if (!IS_PURE && DESCRIPTORS && values.name !== 'values') try {
      defineProperty(values, 'name', {
        value: 'values'
      });
    } catch (error) {}
    return es_array_iterator;
  }
  var es_array_join = {};
  var hasRequiredEs_array_join;
  function requireEs_array_join() {
    if (hasRequiredEs_array_join) return es_array_join;
    hasRequiredEs_array_join = 1;
    var $ = require_export();
    var uncurryThis = requireFunctionUncurryThis();
    var IndexedObject = requireIndexedObject();
    var toIndexedObject = requireToIndexedObject();
    var arrayMethodIsStrict = requireArrayMethodIsStrict();
    var nativeJoin = uncurryThis([].join);
    var ES3_STRINGS = IndexedObject !== Object;
    var FORCED = ES3_STRINGS || !arrayMethodIsStrict('join', ',');
    $({
      target: 'Array',
      proto: true,
      forced: FORCED
    }, {
      join: function join(separator) {
        return nativeJoin(toIndexedObject(this), separator === undefined ? ',' : separator);
      }
    });
    return es_array_join;
  }
  var es_array_lastIndexOf = {};
  var arrayLastIndexOf;
  var hasRequiredArrayLastIndexOf;
  function requireArrayLastIndexOf() {
    if (hasRequiredArrayLastIndexOf) return arrayLastIndexOf;
    hasRequiredArrayLastIndexOf = 1;
    var apply = requireFunctionApply();
    var toIndexedObject = requireToIndexedObject();
    var toIntegerOrInfinity = requireToIntegerOrInfinity();
    var lengthOfArrayLike = requireLengthOfArrayLike();
    var arrayMethodIsStrict = requireArrayMethodIsStrict();
    var min = Math.min;
    var $lastIndexOf = [].lastIndexOf;
    var NEGATIVE_ZERO = !!$lastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
    var STRICT_METHOD = arrayMethodIsStrict('lastIndexOf');
    var FORCED = NEGATIVE_ZERO || !STRICT_METHOD;
    arrayLastIndexOf = FORCED ? function lastIndexOf(searchElement) {
      if (NEGATIVE_ZERO) return apply($lastIndexOf, this, arguments) || 0;
      var O = toIndexedObject(this);
      var length = lengthOfArrayLike(O);
      if (length === 0) return -1;
      var index = length - 1;
      if (arguments.length > 1) index = min(index, toIntegerOrInfinity(arguments[1]));
      if (index < 0) index = length + index;
      for (; index >= 0; index--) if (index in O && O[index] === searchElement) return index || 0;
      return -1;
    } : $lastIndexOf;
    return arrayLastIndexOf;
  }
  var hasRequiredEs_array_lastIndexOf;
  function requireEs_array_lastIndexOf() {
    if (hasRequiredEs_array_lastIndexOf) return es_array_lastIndexOf;
    hasRequiredEs_array_lastIndexOf = 1;
    var $ = require_export();
    var lastIndexOf = requireArrayLastIndexOf();
    $({
      target: 'Array',
      proto: true,
      forced: lastIndexOf !== [].lastIndexOf
    }, {
      lastIndexOf: lastIndexOf
    });
    return es_array_lastIndexOf;
  }
  var es_array_map = {};
  var hasRequiredEs_array_map;
  function requireEs_array_map() {
    if (hasRequiredEs_array_map) return es_array_map;
    hasRequiredEs_array_map = 1;
    var $ = require_export();
    var $map = requireArrayIteration().map;
    var arrayMethodHasSpeciesSupport = requireArrayMethodHasSpeciesSupport();
    var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('map');
    $({
      target: 'Array',
      proto: true,
      forced: !HAS_SPECIES_SUPPORT
    }, {
      map: function map(callbackfn) {
        return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
      }
    });
    return es_array_map;
  }
  var es_array_of = {};
  var hasRequiredEs_array_of;
  function requireEs_array_of() {
    if (hasRequiredEs_array_of) return es_array_of;
    hasRequiredEs_array_of = 1;
    var $ = require_export();
    var fails = requireFails();
    var isConstructor = requireIsConstructor();
    var createProperty = requireCreateProperty();
    var $Array = Array;
    var ISNT_GENERIC = fails(function () {
      function F() {}
      return !($Array.of.call(F) instanceof F);
    });
    $({
      target: 'Array',
      stat: true,
      forced: ISNT_GENERIC
    }, {
      of: function of() {
        var index = 0;
        var argumentsLength = arguments.length;
        var result = new (isConstructor(this) ? this : $Array)(argumentsLength);
        while (argumentsLength > index) createProperty(result, index, arguments[index++]);
        result.length = argumentsLength;
        return result;
      }
    });
    return es_array_of;
  }
  var es_array_push = {};
  var arraySetLength;
  var hasRequiredArraySetLength;
  function requireArraySetLength() {
    if (hasRequiredArraySetLength) return arraySetLength;
    hasRequiredArraySetLength = 1;
    var DESCRIPTORS = requireDescriptors();
    var isArray = requireIsArray();
    var $TypeError = TypeError;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var SILENT_ON_NON_WRITABLE_LENGTH_SET = DESCRIPTORS && !function () {
      if (this !== undefined) return true;
      try {
        Object.defineProperty([], 'length', {
          writable: false
        }).length = 1;
      } catch (error) {
        return error instanceof TypeError;
      }
    }();
    arraySetLength = SILENT_ON_NON_WRITABLE_LENGTH_SET ? function (O, length) {
      if (isArray(O) && !getOwnPropertyDescriptor(O, 'length').writable) {
        throw new $TypeError('Cannot set read only .length');
      }
      return O.length = length;
    } : function (O, length) {
      return O.length = length;
    };
    return arraySetLength;
  }
  var hasRequiredEs_array_push;
  function requireEs_array_push() {
    if (hasRequiredEs_array_push) return es_array_push;
    hasRequiredEs_array_push = 1;
    var $ = require_export();
    var toObject = requireToObject();
    var lengthOfArrayLike = requireLengthOfArrayLike();
    var setArrayLength = requireArraySetLength();
    var doesNotExceedSafeInteger = requireDoesNotExceedSafeInteger();
    var fails = requireFails();
    var INCORRECT_TO_LENGTH = fails(function () {
      return [].push.call({
        length: 0x100000000
      }, 1) !== 4294967297;
    });
    var properErrorOnNonWritableLength = function properErrorOnNonWritableLength() {
      try {
        Object.defineProperty([], 'length', {
          writable: false
        }).push();
      } catch (error) {
        return error instanceof TypeError;
      }
    };
    var FORCED = INCORRECT_TO_LENGTH || !properErrorOnNonWritableLength();
    $({
      target: 'Array',
      proto: true,
      arity: 1,
      forced: FORCED
    }, {
      push: function push(item) {
        var O = toObject(this);
        var len = lengthOfArrayLike(O);
        var argCount = arguments.length;
        doesNotExceedSafeInteger(len + argCount);
        for (var i = 0; i < argCount; i++) {
          O[len] = arguments[i];
          len++;
        }
        setArrayLength(O, len);
        return len;
      }
    });
    return es_array_push;
  }
  var es_array_reduce = {};
  var arrayReduce;
  var hasRequiredArrayReduce;
  function requireArrayReduce() {
    if (hasRequiredArrayReduce) return arrayReduce;
    hasRequiredArrayReduce = 1;
    var aCallable = requireACallable();
    var toObject = requireToObject();
    var IndexedObject = requireIndexedObject();
    var lengthOfArrayLike = requireLengthOfArrayLike();
    var $TypeError = TypeError;
    var REDUCE_EMPTY = 'Reduce of empty array with no initial value';
    var createMethod = function createMethod(IS_RIGHT) {
      return function (that, callbackfn, argumentsLength, memo) {
        var O = toObject(that);
        var self = IndexedObject(O);
        var length = lengthOfArrayLike(O);
        aCallable(callbackfn);
        if (length === 0 && argumentsLength < 2) throw new $TypeError(REDUCE_EMPTY);
        var index = IS_RIGHT ? length - 1 : 0;
        var i = IS_RIGHT ? -1 : 1;
        if (argumentsLength < 2) while (true) {
          if (index in self) {
            memo = self[index];
            index += i;
            break;
          }
          index += i;
          if (IS_RIGHT ? index < 0 : length <= index) {
            throw new $TypeError(REDUCE_EMPTY);
          }
        }
        for (; IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {
          memo = callbackfn(memo, self[index], index, O);
        }
        return memo;
      };
    };
    arrayReduce = {
      left: createMethod(false),
      right: createMethod(true)
    };
    return arrayReduce;
  }
  var environment;
  var hasRequiredEnvironment;
  function requireEnvironment() {
    if (hasRequiredEnvironment) return environment;
    hasRequiredEnvironment = 1;
    var globalThis = requireGlobalThis();
    var userAgent = requireEnvironmentUserAgent();
    var classof = requireClassofRaw();
    var userAgentStartsWith = function userAgentStartsWith(string) {
      return userAgent.slice(0, string.length) === string;
    };
    environment = function () {
      if (userAgentStartsWith('Bun/')) return 'BUN';
      if (userAgentStartsWith('Cloudflare-Workers')) return 'CLOUDFLARE';
      if (userAgentStartsWith('Deno/')) return 'DENO';
      if (userAgentStartsWith('Node.js/')) return 'NODE';
      if (globalThis.Bun && typeof Bun.version == 'string') return 'BUN';
      if (globalThis.Deno && typeof Deno.version == 'object') return 'DENO';
      if (classof(globalThis.process) === 'process') return 'NODE';
      if (globalThis.window && globalThis.document) return 'BROWSER';
      return 'REST';
    }();
    return environment;
  }
  var environmentIsNode;
  var hasRequiredEnvironmentIsNode;
  function requireEnvironmentIsNode() {
    if (hasRequiredEnvironmentIsNode) return environmentIsNode;
    hasRequiredEnvironmentIsNode = 1;
    var ENVIRONMENT = requireEnvironment();
    environmentIsNode = ENVIRONMENT === 'NODE';
    return environmentIsNode;
  }
  var hasRequiredEs_array_reduce;
  function requireEs_array_reduce() {
    if (hasRequiredEs_array_reduce) return es_array_reduce;
    hasRequiredEs_array_reduce = 1;
    var $ = require_export();
    var $reduce = requireArrayReduce().left;
    var arrayMethodIsStrict = requireArrayMethodIsStrict();
    var CHROME_VERSION = requireEnvironmentV8Version();
    var IS_NODE = requireEnvironmentIsNode();
    var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;
    var FORCED = CHROME_BUG || !arrayMethodIsStrict('reduce');
    $({
      target: 'Array',
      proto: true,
      forced: FORCED
    }, {
      reduce: function reduce(callbackfn) {
        var length = arguments.length;
        return $reduce(this, callbackfn, length, length > 1 ? arguments[1] : undefined);
      }
    });
    return es_array_reduce;
  }
  var es_array_reduceRight = {};
  var hasRequiredEs_array_reduceRight;
  function requireEs_array_reduceRight() {
    if (hasRequiredEs_array_reduceRight) return es_array_reduceRight;
    hasRequiredEs_array_reduceRight = 1;
    var $ = require_export();
    var $reduceRight = requireArrayReduce().right;
    var arrayMethodIsStrict = requireArrayMethodIsStrict();
    var CHROME_VERSION = requireEnvironmentV8Version();
    var IS_NODE = requireEnvironmentIsNode();
    var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;
    var FORCED = CHROME_BUG || !arrayMethodIsStrict('reduceRight');
    $({
      target: 'Array',
      proto: true,
      forced: FORCED
    }, {
      reduceRight: function reduceRight(callbackfn) {
        return $reduceRight(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
      }
    });
    return es_array_reduceRight;
  }
  var es_array_reverse = {};
  var hasRequiredEs_array_reverse;
  function requireEs_array_reverse() {
    if (hasRequiredEs_array_reverse) return es_array_reverse;
    hasRequiredEs_array_reverse = 1;
    var $ = require_export();
    var uncurryThis = requireFunctionUncurryThis();
    var isArray = requireIsArray();
    var nativeReverse = uncurryThis([].reverse);
    var test = [1, 2];
    $({
      target: 'Array',
      proto: true,
      forced: String(test) === String(test.reverse())
    }, {
      reverse: function reverse() {
        if (isArray(this)) this.length = this.length;
        return nativeReverse(this);
      }
    });
    return es_array_reverse;
  }
  var es_array_slice = {};
  var hasRequiredEs_array_slice;
  function requireEs_array_slice() {
    if (hasRequiredEs_array_slice) return es_array_slice;
    hasRequiredEs_array_slice = 1;
    var $ = require_export();
    var isArray = requireIsArray();
    var isConstructor = requireIsConstructor();
    var isObject = requireIsObject();
    var toAbsoluteIndex = requireToAbsoluteIndex();
    var lengthOfArrayLike = requireLengthOfArrayLike();
    var toIndexedObject = requireToIndexedObject();
    var createProperty = requireCreateProperty();
    var wellKnownSymbol = requireWellKnownSymbol();
    var arrayMethodHasSpeciesSupport = requireArrayMethodHasSpeciesSupport();
    var nativeSlice = requireArraySlice();
    var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('slice');
    var SPECIES = wellKnownSymbol('species');
    var $Array = Array;
    var max = Math.max;
    $({
      target: 'Array',
      proto: true,
      forced: !HAS_SPECIES_SUPPORT
    }, {
      slice: function slice(start, end) {
        var O = toIndexedObject(this);
        var length = lengthOfArrayLike(O);
        var k = toAbsoluteIndex(start, length);
        var fin = toAbsoluteIndex(end === undefined ? length : end, length);
        var Constructor, result, n;
        if (isArray(O)) {
          Constructor = O.constructor;
          if (isConstructor(Constructor) && (Constructor === $Array || isArray(Constructor.prototype))) {
            Constructor = undefined;
          } else if (isObject(Constructor)) {
            Constructor = Constructor[SPECIES];
            if (Constructor === null) Constructor = undefined;
          }
          if (Constructor === $Array || Constructor === undefined) {
            return nativeSlice(O, k, fin);
          }
        }
        result = new (Constructor === undefined ? $Array : Constructor)(max(fin - k, 0));
        for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
        result.length = n;
        return result;
      }
    });
    return es_array_slice;
  }
  var es_array_some = {};
  var hasRequiredEs_array_some;
  function requireEs_array_some() {
    if (hasRequiredEs_array_some) return es_array_some;
    hasRequiredEs_array_some = 1;
    var $ = require_export();
    var $some = requireArrayIteration().some;
    var arrayMethodIsStrict = requireArrayMethodIsStrict();
    var STRICT_METHOD = arrayMethodIsStrict('some');
    $({
      target: 'Array',
      proto: true,
      forced: !STRICT_METHOD
    }, {
      some: function some(callbackfn) {
        return $some(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
      }
    });
    return es_array_some;
  }
  var es_array_sort = {};
  var arraySort;
  var hasRequiredArraySort;
  function requireArraySort() {
    if (hasRequiredArraySort) return arraySort;
    hasRequiredArraySort = 1;
    var arraySlice = requireArraySlice();
    var floor = Math.floor;
    var _sort = function sort(array, comparefn) {
      var length = array.length;
      if (length < 8) {
        var i = 1;
        var element, j;
        while (i < length) {
          j = i;
          element = array[i];
          while (j && comparefn(array[j - 1], element) > 0) {
            array[j] = array[--j];
          }
          if (j !== i++) array[j] = element;
        }
      } else {
        var middle = floor(length / 2);
        var left = _sort(arraySlice(array, 0, middle), comparefn);
        var right = _sort(arraySlice(array, middle), comparefn);
        var llength = left.length;
        var rlength = right.length;
        var lindex = 0;
        var rindex = 0;
        while (lindex < llength || rindex < rlength) {
          array[lindex + rindex] = lindex < llength && rindex < rlength ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++] : lindex < llength ? left[lindex++] : right[rindex++];
        }
      }
      return array;
    };
    arraySort = _sort;
    return arraySort;
  }
  var environmentFfVersion;
  var hasRequiredEnvironmentFfVersion;
  function requireEnvironmentFfVersion() {
    if (hasRequiredEnvironmentFfVersion) return environmentFfVersion;
    hasRequiredEnvironmentFfVersion = 1;
    var userAgent = requireEnvironmentUserAgent();
    var firefox = userAgent.match(/firefox\/(\d+)/i);
    environmentFfVersion = !!firefox && +firefox[1];
    return environmentFfVersion;
  }
  var environmentIsIeOrEdge;
  var hasRequiredEnvironmentIsIeOrEdge;
  function requireEnvironmentIsIeOrEdge() {
    if (hasRequiredEnvironmentIsIeOrEdge) return environmentIsIeOrEdge;
    hasRequiredEnvironmentIsIeOrEdge = 1;
    var UA = requireEnvironmentUserAgent();
    environmentIsIeOrEdge = /MSIE|Trident/.test(UA);
    return environmentIsIeOrEdge;
  }
  var environmentWebkitVersion;
  var hasRequiredEnvironmentWebkitVersion;
  function requireEnvironmentWebkitVersion() {
    if (hasRequiredEnvironmentWebkitVersion) return environmentWebkitVersion;
    hasRequiredEnvironmentWebkitVersion = 1;
    var userAgent = requireEnvironmentUserAgent();
    var webkit = userAgent.match(/AppleWebKit\/(\d+)\./);
    environmentWebkitVersion = !!webkit && +webkit[1];
    return environmentWebkitVersion;
  }
  var hasRequiredEs_array_sort;
  function requireEs_array_sort() {
    if (hasRequiredEs_array_sort) return es_array_sort;
    hasRequiredEs_array_sort = 1;
    var $ = require_export();
    var uncurryThis = requireFunctionUncurryThis();
    var aCallable = requireACallable();
    var toObject = requireToObject();
    var lengthOfArrayLike = requireLengthOfArrayLike();
    var deletePropertyOrThrow = requireDeletePropertyOrThrow();
    var toString = requireToString();
    var fails = requireFails();
    var internalSort = requireArraySort();
    var arrayMethodIsStrict = requireArrayMethodIsStrict();
    var FF = requireEnvironmentFfVersion();
    var IE_OR_EDGE = requireEnvironmentIsIeOrEdge();
    var V8 = requireEnvironmentV8Version();
    var WEBKIT = requireEnvironmentWebkitVersion();
    var test = [];
    var nativeSort = uncurryThis(test.sort);
    var push = uncurryThis(test.push);
    var FAILS_ON_UNDEFINED = fails(function () {
      test.sort(undefined);
    });
    var FAILS_ON_NULL = fails(function () {
      test.sort(null);
    });
    var STRICT_METHOD = arrayMethodIsStrict('sort');
    var STABLE_SORT = !fails(function () {
      if (V8) return V8 < 70;
      if (FF && FF > 3) return;
      if (IE_OR_EDGE) return true;
      if (WEBKIT) return WEBKIT < 603;
      var result = '';
      var code, chr, value, index;
      for (code = 65; code < 76; code++) {
        chr = String.fromCharCode(code);
        switch (code) {
          case 66:
          case 69:
          case 70:
          case 72:
            value = 3;
            break;
          case 68:
          case 71:
            value = 4;
            break;
          default:
            value = 2;
        }
        for (index = 0; index < 47; index++) {
          test.push({
            k: chr + index,
            v: value
          });
        }
      }
      test.sort(function (a, b) {
        return b.v - a.v;
      });
      for (index = 0; index < test.length; index++) {
        chr = test[index].k.charAt(0);
        if (result.charAt(result.length - 1) !== chr) result += chr;
      }
      return result !== 'DGBEFHACIJK';
    });
    var FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD || !STABLE_SORT;
    var getSortCompare = function getSortCompare(comparefn) {
      return function (x, y) {
        if (y === undefined) return -1;
        if (x === undefined) return 1;
        if (comparefn !== undefined) return +comparefn(x, y) || 0;
        return toString(x) > toString(y) ? 1 : -1;
      };
    };
    $({
      target: 'Array',
      proto: true,
      forced: FORCED
    }, {
      sort: function sort(comparefn) {
        if (comparefn !== undefined) aCallable(comparefn);
        var array = toObject(this);
        if (STABLE_SORT) return comparefn === undefined ? nativeSort(array) : nativeSort(array, comparefn);
        var items = [];
        var arrayLength = lengthOfArrayLike(array);
        var itemsLength, index;
        for (index = 0; index < arrayLength; index++) {
          if (index in array) push(items, array[index]);
        }
        internalSort(items, getSortCompare(comparefn));
        itemsLength = lengthOfArrayLike(items);
        index = 0;
        while (index < itemsLength) array[index] = items[index++];
        while (index < arrayLength) deletePropertyOrThrow(array, index++);
        return array;
      }
    });
    return es_array_sort;
  }
  var es_array_species = {};
  var setSpecies;
  var hasRequiredSetSpecies;
  function requireSetSpecies() {
    if (hasRequiredSetSpecies) return setSpecies;
    hasRequiredSetSpecies = 1;
    var getBuiltIn = requireGetBuiltIn();
    var defineBuiltInAccessor = requireDefineBuiltInAccessor();
    var wellKnownSymbol = requireWellKnownSymbol();
    var DESCRIPTORS = requireDescriptors();
    var SPECIES = wellKnownSymbol('species');
    setSpecies = function setSpecies(CONSTRUCTOR_NAME) {
      var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
      if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
        defineBuiltInAccessor(Constructor, SPECIES, {
          configurable: true,
          get: function get() {
            return this;
          }
        });
      }
    };
    return setSpecies;
  }
  var hasRequiredEs_array_species;
  function requireEs_array_species() {
    if (hasRequiredEs_array_species) return es_array_species;
    hasRequiredEs_array_species = 1;
    var setSpecies = requireSetSpecies();
    setSpecies('Array');
    return es_array_species;
  }
  var es_array_splice = {};
  var hasRequiredEs_array_splice;
  function requireEs_array_splice() {
    if (hasRequiredEs_array_splice) return es_array_splice;
    hasRequiredEs_array_splice = 1;
    var $ = require_export();
    var toObject = requireToObject();
    var toAbsoluteIndex = requireToAbsoluteIndex();
    var toIntegerOrInfinity = requireToIntegerOrInfinity();
    var lengthOfArrayLike = requireLengthOfArrayLike();
    var setArrayLength = requireArraySetLength();
    var doesNotExceedSafeInteger = requireDoesNotExceedSafeInteger();
    var arraySpeciesCreate = requireArraySpeciesCreate();
    var createProperty = requireCreateProperty();
    var deletePropertyOrThrow = requireDeletePropertyOrThrow();
    var arrayMethodHasSpeciesSupport = requireArrayMethodHasSpeciesSupport();
    var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('splice');
    var max = Math.max;
    var min = Math.min;
    $({
      target: 'Array',
      proto: true,
      forced: !HAS_SPECIES_SUPPORT
    }, {
      splice: function splice(start, deleteCount) {
        var O = toObject(this);
        var len = lengthOfArrayLike(O);
        var actualStart = toAbsoluteIndex(start, len);
        var argumentsLength = arguments.length;
        var insertCount, actualDeleteCount, A, k, from, to;
        if (argumentsLength === 0) {
          insertCount = actualDeleteCount = 0;
        } else if (argumentsLength === 1) {
          insertCount = 0;
          actualDeleteCount = len - actualStart;
        } else {
          insertCount = argumentsLength - 2;
          actualDeleteCount = min(max(toIntegerOrInfinity(deleteCount), 0), len - actualStart);
        }
        doesNotExceedSafeInteger(len + insertCount - actualDeleteCount);
        A = arraySpeciesCreate(O, actualDeleteCount);
        for (k = 0; k < actualDeleteCount; k++) {
          from = actualStart + k;
          if (from in O) createProperty(A, k, O[from]);
        }
        A.length = actualDeleteCount;
        if (insertCount < actualDeleteCount) {
          for (k = actualStart; k < len - actualDeleteCount; k++) {
            from = k + actualDeleteCount;
            to = k + insertCount;
            if (from in O) O[to] = O[from];else deletePropertyOrThrow(O, to);
          }
          for (k = len; k > len - actualDeleteCount + insertCount; k--) deletePropertyOrThrow(O, k - 1);
        } else if (insertCount > actualDeleteCount) {
          for (k = len - actualDeleteCount; k > actualStart; k--) {
            from = k + actualDeleteCount - 1;
            to = k + insertCount - 1;
            if (from in O) O[to] = O[from];else deletePropertyOrThrow(O, to);
          }
        }
        for (k = 0; k < insertCount; k++) {
          O[k + actualStart] = arguments[k + 2];
        }
        setArrayLength(O, len - actualDeleteCount + insertCount);
        return A;
      }
    });
    return es_array_splice;
  }
  var es_array_toReversed = {};
  var arrayToReversed;
  var hasRequiredArrayToReversed;
  function requireArrayToReversed() {
    if (hasRequiredArrayToReversed) return arrayToReversed;
    hasRequiredArrayToReversed = 1;
    var lengthOfArrayLike = requireLengthOfArrayLike();
    arrayToReversed = function arrayToReversed(O, C) {
      var len = lengthOfArrayLike(O);
      var A = new C(len);
      var k = 0;
      for (; k < len; k++) A[k] = O[len - k - 1];
      return A;
    };
    return arrayToReversed;
  }
  var hasRequiredEs_array_toReversed;
  function requireEs_array_toReversed() {
    if (hasRequiredEs_array_toReversed) return es_array_toReversed;
    hasRequiredEs_array_toReversed = 1;
    var $ = require_export();
    var arrayToReversed = requireArrayToReversed();
    var toIndexedObject = requireToIndexedObject();
    var addToUnscopables = requireAddToUnscopables();
    var $Array = Array;
    $({
      target: 'Array',
      proto: true
    }, {
      toReversed: function toReversed() {
        return arrayToReversed(toIndexedObject(this), $Array);
      }
    });
    addToUnscopables('toReversed');
    return es_array_toReversed;
  }
  var es_array_toSorted = {};
  var arrayFromConstructorAndList;
  var hasRequiredArrayFromConstructorAndList;
  function requireArrayFromConstructorAndList() {
    if (hasRequiredArrayFromConstructorAndList) return arrayFromConstructorAndList;
    hasRequiredArrayFromConstructorAndList = 1;
    var lengthOfArrayLike = requireLengthOfArrayLike();
    arrayFromConstructorAndList = function arrayFromConstructorAndList(Constructor, list, $length) {
      var index = 0;
      var length = arguments.length > 2 ? $length : lengthOfArrayLike(list);
      var result = new Constructor(length);
      while (length > index) result[index] = list[index++];
      return result;
    };
    return arrayFromConstructorAndList;
  }
  var getBuiltInPrototypeMethod;
  var hasRequiredGetBuiltInPrototypeMethod;
  function requireGetBuiltInPrototypeMethod() {
    if (hasRequiredGetBuiltInPrototypeMethod) return getBuiltInPrototypeMethod;
    hasRequiredGetBuiltInPrototypeMethod = 1;
    var globalThis = requireGlobalThis();
    getBuiltInPrototypeMethod = function getBuiltInPrototypeMethod(CONSTRUCTOR, METHOD) {
      var Constructor = globalThis[CONSTRUCTOR];
      var Prototype = Constructor && Constructor.prototype;
      return Prototype && Prototype[METHOD];
    };
    return getBuiltInPrototypeMethod;
  }
  var hasRequiredEs_array_toSorted;
  function requireEs_array_toSorted() {
    if (hasRequiredEs_array_toSorted) return es_array_toSorted;
    hasRequiredEs_array_toSorted = 1;
    var $ = require_export();
    var uncurryThis = requireFunctionUncurryThis();
    var aCallable = requireACallable();
    var toIndexedObject = requireToIndexedObject();
    var arrayFromConstructorAndList = requireArrayFromConstructorAndList();
    var getBuiltInPrototypeMethod = requireGetBuiltInPrototypeMethod();
    var addToUnscopables = requireAddToUnscopables();
    var $Array = Array;
    var sort = uncurryThis(getBuiltInPrototypeMethod('Array', 'sort'));
    $({
      target: 'Array',
      proto: true
    }, {
      toSorted: function toSorted(compareFn) {
        if (compareFn !== undefined) aCallable(compareFn);
        var O = toIndexedObject(this);
        var A = arrayFromConstructorAndList($Array, O);
        return sort(A, compareFn);
      }
    });
    addToUnscopables('toSorted');
    return es_array_toSorted;
  }
  var es_array_toSpliced = {};
  var hasRequiredEs_array_toSpliced;
  function requireEs_array_toSpliced() {
    if (hasRequiredEs_array_toSpliced) return es_array_toSpliced;
    hasRequiredEs_array_toSpliced = 1;
    var $ = require_export();
    var addToUnscopables = requireAddToUnscopables();
    var doesNotExceedSafeInteger = requireDoesNotExceedSafeInteger();
    var lengthOfArrayLike = requireLengthOfArrayLike();
    var toAbsoluteIndex = requireToAbsoluteIndex();
    var toIndexedObject = requireToIndexedObject();
    var toIntegerOrInfinity = requireToIntegerOrInfinity();
    var $Array = Array;
    var max = Math.max;
    var min = Math.min;
    $({
      target: 'Array',
      proto: true
    }, {
      toSpliced: function toSpliced(start, deleteCount) {
        var O = toIndexedObject(this);
        var len = lengthOfArrayLike(O);
        var actualStart = toAbsoluteIndex(start, len);
        var argumentsLength = arguments.length;
        var k = 0;
        var insertCount, actualDeleteCount, newLen, A;
        if (argumentsLength === 0) {
          insertCount = actualDeleteCount = 0;
        } else if (argumentsLength === 1) {
          insertCount = 0;
          actualDeleteCount = len - actualStart;
        } else {
          insertCount = argumentsLength - 2;
          actualDeleteCount = min(max(toIntegerOrInfinity(deleteCount), 0), len - actualStart);
        }
        newLen = doesNotExceedSafeInteger(len + insertCount - actualDeleteCount);
        A = $Array(newLen);
        for (; k < actualStart; k++) A[k] = O[k];
        for (; k < actualStart + insertCount; k++) A[k] = arguments[k - actualStart + 2];
        for (; k < newLen; k++) A[k] = O[k + actualDeleteCount - insertCount];
        return A;
      }
    });
    addToUnscopables('toSpliced');
    return es_array_toSpliced;
  }
  var es_array_unscopables_flat = {};
  var hasRequiredEs_array_unscopables_flat;
  function requireEs_array_unscopables_flat() {
    if (hasRequiredEs_array_unscopables_flat) return es_array_unscopables_flat;
    hasRequiredEs_array_unscopables_flat = 1;
    var addToUnscopables = requireAddToUnscopables();
    addToUnscopables('flat');
    return es_array_unscopables_flat;
  }
  var es_array_unscopables_flatMap = {};
  var hasRequiredEs_array_unscopables_flatMap;
  function requireEs_array_unscopables_flatMap() {
    if (hasRequiredEs_array_unscopables_flatMap) return es_array_unscopables_flatMap;
    hasRequiredEs_array_unscopables_flatMap = 1;
    var addToUnscopables = requireAddToUnscopables();
    addToUnscopables('flatMap');
    return es_array_unscopables_flatMap;
  }
  var es_array_unshift = {};
  var hasRequiredEs_array_unshift;
  function requireEs_array_unshift() {
    if (hasRequiredEs_array_unshift) return es_array_unshift;
    hasRequiredEs_array_unshift = 1;
    var $ = require_export();
    var toObject = requireToObject();
    var lengthOfArrayLike = requireLengthOfArrayLike();
    var setArrayLength = requireArraySetLength();
    var deletePropertyOrThrow = requireDeletePropertyOrThrow();
    var doesNotExceedSafeInteger = requireDoesNotExceedSafeInteger();
    var INCORRECT_RESULT = [].unshift(0) !== 1;
    var properErrorOnNonWritableLength = function properErrorOnNonWritableLength() {
      try {
        Object.defineProperty([], 'length', {
          writable: false
        }).unshift();
      } catch (error) {
        return error instanceof TypeError;
      }
    };
    var FORCED = INCORRECT_RESULT || !properErrorOnNonWritableLength();
    $({
      target: 'Array',
      proto: true,
      arity: 1,
      forced: FORCED
    }, {
      unshift: function unshift(item) {
        var O = toObject(this);
        var len = lengthOfArrayLike(O);
        var argCount = arguments.length;
        if (argCount) {
          doesNotExceedSafeInteger(len + argCount);
          var k = len;
          while (k--) {
            var to = k + argCount;
            if (k in O) O[to] = O[k];else deletePropertyOrThrow(O, to);
          }
          for (var j = 0; j < argCount; j++) {
            O[j] = arguments[j];
          }
        }
        return setArrayLength(O, len + argCount);
      }
    });
    return es_array_unshift;
  }
  var es_array_with = {};
  var arrayWith;
  var hasRequiredArrayWith;
  function requireArrayWith() {
    if (hasRequiredArrayWith) return arrayWith;
    hasRequiredArrayWith = 1;
    var lengthOfArrayLike = requireLengthOfArrayLike();
    var toIntegerOrInfinity = requireToIntegerOrInfinity();
    var $RangeError = RangeError;
    arrayWith = function arrayWith(O, C, index, value) {
      var len = lengthOfArrayLike(O);
      var relativeIndex = toIntegerOrInfinity(index);
      var actualIndex = relativeIndex < 0 ? len + relativeIndex : relativeIndex;
      if (actualIndex >= len || actualIndex < 0) throw new $RangeError('Incorrect index');
      var A = new C(len);
      var k = 0;
      for (; k < len; k++) A[k] = k === actualIndex ? value : O[k];
      return A;
    };
    return arrayWith;
  }
  var hasRequiredEs_array_with;
  function requireEs_array_with() {
    if (hasRequiredEs_array_with) return es_array_with;
    hasRequiredEs_array_with = 1;
    var $ = require_export();
    var arrayWith = requireArrayWith();
    var toIndexedObject = requireToIndexedObject();
    var $Array = Array;
    var INCORRECT_EXCEPTION_ON_COERCION_FAIL = function () {
      try {
        []['with']({
          valueOf: function valueOf() {
            throw 4;
          }
        }, null);
      } catch (error) {
        return error !== 4;
      }
    }();
    $({
      target: 'Array',
      proto: true,
      forced: INCORRECT_EXCEPTION_ON_COERCION_FAIL
    }, {
      'with': function _with(index, value) {
        return arrayWith(toIndexedObject(this), $Array, index, value);
      }
    });
    return es_array_with;
  }
  var es_arrayBuffer_constructor = {};
  var arrayBufferBasicDetection;
  var hasRequiredArrayBufferBasicDetection;
  function requireArrayBufferBasicDetection() {
    if (hasRequiredArrayBufferBasicDetection) return arrayBufferBasicDetection;
    hasRequiredArrayBufferBasicDetection = 1;
    arrayBufferBasicDetection = typeof ArrayBuffer != 'undefined' && typeof DataView != 'undefined';
    return arrayBufferBasicDetection;
  }
  var defineBuiltIns;
  var hasRequiredDefineBuiltIns;
  function requireDefineBuiltIns() {
    if (hasRequiredDefineBuiltIns) return defineBuiltIns;
    hasRequiredDefineBuiltIns = 1;
    var defineBuiltIn = requireDefineBuiltIn();
    defineBuiltIns = function defineBuiltIns(target, src, options) {
      for (var key in src) defineBuiltIn(target, key, src[key], options);
      return target;
    };
    return defineBuiltIns;
  }
  var anInstance;
  var hasRequiredAnInstance;
  function requireAnInstance() {
    if (hasRequiredAnInstance) return anInstance;
    hasRequiredAnInstance = 1;
    var isPrototypeOf = requireObjectIsPrototypeOf();
    var $TypeError = TypeError;
    anInstance = function anInstance(it, Prototype) {
      if (isPrototypeOf(Prototype, it)) return it;
      throw new $TypeError('Incorrect invocation');
    };
    return anInstance;
  }
  var toIndex;
  var hasRequiredToIndex;
  function requireToIndex() {
    if (hasRequiredToIndex) return toIndex;
    hasRequiredToIndex = 1;
    var toIntegerOrInfinity = requireToIntegerOrInfinity();
    var toLength = requireToLength();
    var $RangeError = RangeError;
    toIndex = function toIndex(it) {
      if (it === undefined) return 0;
      var number = toIntegerOrInfinity(it);
      var length = toLength(number);
      if (number !== length) throw new $RangeError('Wrong length or index');
      return length;
    };
    return toIndex;
  }
  var mathSign;
  var hasRequiredMathSign;
  function requireMathSign() {
    if (hasRequiredMathSign) return mathSign;
    hasRequiredMathSign = 1;
    mathSign = Math.sign || function sign(x) {
      var n = +x;
      return n === 0 || n !== n ? n : n < 0 ? -1 : 1;
    };
    return mathSign;
  }
  var mathRoundTiesToEven;
  var hasRequiredMathRoundTiesToEven;
  function requireMathRoundTiesToEven() {
    if (hasRequiredMathRoundTiesToEven) return mathRoundTiesToEven;
    hasRequiredMathRoundTiesToEven = 1;
    var EPSILON = 2.220446049250313e-16;
    var INVERSE_EPSILON = 1 / EPSILON;
    mathRoundTiesToEven = function mathRoundTiesToEven(n) {
      return n + INVERSE_EPSILON - INVERSE_EPSILON;
    };
    return mathRoundTiesToEven;
  }
  var mathFloatRound;
  var hasRequiredMathFloatRound;
  function requireMathFloatRound() {
    if (hasRequiredMathFloatRound) return mathFloatRound;
    hasRequiredMathFloatRound = 1;
    var sign = requireMathSign();
    var roundTiesToEven = requireMathRoundTiesToEven();
    var abs = Math.abs;
    var EPSILON = 2.220446049250313e-16;
    mathFloatRound = function mathFloatRound(x, FLOAT_EPSILON, FLOAT_MAX_VALUE, FLOAT_MIN_VALUE) {
      var n = +x;
      var absolute = abs(n);
      var s = sign(n);
      if (absolute < FLOAT_MIN_VALUE) return s * roundTiesToEven(absolute / FLOAT_MIN_VALUE / FLOAT_EPSILON) * FLOAT_MIN_VALUE * FLOAT_EPSILON;
      var a = (1 + FLOAT_EPSILON / EPSILON) * absolute;
      var result = a - (a - absolute);
      if (result > FLOAT_MAX_VALUE || result !== result) return s * Infinity;
      return s * result;
    };
    return mathFloatRound;
  }
  var mathFround;
  var hasRequiredMathFround;
  function requireMathFround() {
    if (hasRequiredMathFround) return mathFround;
    hasRequiredMathFround = 1;
    var floatRound = requireMathFloatRound();
    var FLOAT32_EPSILON = 1.1920928955078125e-7;
    var FLOAT32_MAX_VALUE = 3.4028234663852886e+38;
    var FLOAT32_MIN_VALUE = 1.1754943508222875e-38;
    mathFround = Math.fround || function fround(x) {
      return floatRound(x, FLOAT32_EPSILON, FLOAT32_MAX_VALUE, FLOAT32_MIN_VALUE);
    };
    return mathFround;
  }
  var ieee754;
  var hasRequiredIeee754;
  function requireIeee754() {
    if (hasRequiredIeee754) return ieee754;
    hasRequiredIeee754 = 1;
    var $Array = Array;
    var abs = Math.abs;
    var pow = Math.pow;
    var floor = Math.floor;
    var log = Math.log;
    var LN2 = Math.LN2;
    var pack = function pack(number, mantissaLength, bytes) {
      var buffer = $Array(bytes);
      var exponentLength = bytes * 8 - mantissaLength - 1;
      var eMax = (1 << exponentLength) - 1;
      var eBias = eMax >> 1;
      var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
      var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
      var index = 0;
      var exponent, mantissa, c;
      number = abs(number);
      if (number !== number || number === Infinity) {
        mantissa = number !== number ? 1 : 0;
        exponent = eMax;
      } else {
        exponent = floor(log(number) / LN2);
        c = pow(2, -exponent);
        if (number * c < 1) {
          exponent--;
          c *= 2;
        }
        if (exponent + eBias >= 1) {
          number += rt / c;
        } else {
          number += rt * pow(2, 1 - eBias);
        }
        if (number * c >= 2) {
          exponent++;
          c /= 2;
        }
        if (exponent + eBias >= eMax) {
          mantissa = 0;
          exponent = eMax;
        } else if (exponent + eBias >= 1) {
          mantissa = (number * c - 1) * pow(2, mantissaLength);
          exponent += eBias;
        } else {
          mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);
          exponent = 0;
        }
      }
      while (mantissaLength >= 8) {
        buffer[index++] = mantissa & 255;
        mantissa /= 256;
        mantissaLength -= 8;
      }
      exponent = exponent << mantissaLength | mantissa;
      exponentLength += mantissaLength;
      while (exponentLength > 0) {
        buffer[index++] = exponent & 255;
        exponent /= 256;
        exponentLength -= 8;
      }
      buffer[index - 1] |= sign * 128;
      return buffer;
    };
    var unpack = function unpack(buffer, mantissaLength) {
      var bytes = buffer.length;
      var exponentLength = bytes * 8 - mantissaLength - 1;
      var eMax = (1 << exponentLength) - 1;
      var eBias = eMax >> 1;
      var nBits = exponentLength - 7;
      var index = bytes - 1;
      var sign = buffer[index--];
      var exponent = sign & 127;
      var mantissa;
      sign >>= 7;
      while (nBits > 0) {
        exponent = exponent * 256 + buffer[index--];
        nBits -= 8;
      }
      mantissa = exponent & (1 << -nBits) - 1;
      exponent >>= -nBits;
      nBits += mantissaLength;
      while (nBits > 0) {
        mantissa = mantissa * 256 + buffer[index--];
        nBits -= 8;
      }
      if (exponent === 0) {
        exponent = 1 - eBias;
      } else if (exponent === eMax) {
        return mantissa ? NaN : sign ? -Infinity : Infinity;
      } else {
        mantissa += pow(2, mantissaLength);
        exponent -= eBias;
      }
      return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
    };
    ieee754 = {
      pack: pack,
      unpack: unpack
    };
    return ieee754;
  }
  var arrayBuffer;
  var hasRequiredArrayBuffer;
  function requireArrayBuffer() {
    if (hasRequiredArrayBuffer) return arrayBuffer;
    hasRequiredArrayBuffer = 1;
    var globalThis = requireGlobalThis();
    var uncurryThis = requireFunctionUncurryThis();
    var DESCRIPTORS = requireDescriptors();
    var NATIVE_ARRAY_BUFFER = requireArrayBufferBasicDetection();
    var FunctionName = requireFunctionName();
    var createNonEnumerableProperty = requireCreateNonEnumerableProperty();
    var defineBuiltInAccessor = requireDefineBuiltInAccessor();
    var defineBuiltIns = requireDefineBuiltIns();
    var fails = requireFails();
    var anInstance = requireAnInstance();
    var toIntegerOrInfinity = requireToIntegerOrInfinity();
    var toLength = requireToLength();
    var toIndex = requireToIndex();
    var fround = requireMathFround();
    var IEEE754 = requireIeee754();
    var getPrototypeOf = requireObjectGetPrototypeOf();
    var setPrototypeOf = requireObjectSetPrototypeOf();
    var arrayFill = requireArrayFill();
    var arraySlice = requireArraySlice();
    var inheritIfRequired = requireInheritIfRequired();
    var copyConstructorProperties = requireCopyConstructorProperties();
    var setToStringTag = requireSetToStringTag();
    var InternalStateModule = requireInternalState();
    var PROPER_FUNCTION_NAME = FunctionName.PROPER;
    var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
    var ARRAY_BUFFER = 'ArrayBuffer';
    var DATA_VIEW = 'DataView';
    var PROTOTYPE = 'prototype';
    var WRONG_LENGTH = 'Wrong length';
    var WRONG_INDEX = 'Wrong index';
    var getInternalArrayBufferState = InternalStateModule.getterFor(ARRAY_BUFFER);
    var getInternalDataViewState = InternalStateModule.getterFor(DATA_VIEW);
    var setInternalState = InternalStateModule.set;
    var NativeArrayBuffer = globalThis[ARRAY_BUFFER];
    var $ArrayBuffer = NativeArrayBuffer;
    var ArrayBufferPrototype = $ArrayBuffer && $ArrayBuffer[PROTOTYPE];
    var $DataView = globalThis[DATA_VIEW];
    var DataViewPrototype = $DataView && $DataView[PROTOTYPE];
    var ObjectPrototype = Object.prototype;
    var Array = globalThis.Array;
    var RangeError = globalThis.RangeError;
    var fill = uncurryThis(arrayFill);
    var reverse = uncurryThis([].reverse);
    var packIEEE754 = IEEE754.pack;
    var unpackIEEE754 = IEEE754.unpack;
    var packInt8 = function packInt8(number) {
      return [number & 0xFF];
    };
    var packInt16 = function packInt16(number) {
      return [number & 0xFF, number >> 8 & 0xFF];
    };
    var packInt32 = function packInt32(number) {
      return [number & 0xFF, number >> 8 & 0xFF, number >> 16 & 0xFF, number >> 24 & 0xFF];
    };
    var unpackInt32 = function unpackInt32(buffer) {
      return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
    };
    var packFloat32 = function packFloat32(number) {
      return packIEEE754(fround(number), 23, 4);
    };
    var packFloat64 = function packFloat64(number) {
      return packIEEE754(number, 52, 8);
    };
    var addGetter = function addGetter(Constructor, key, getInternalState) {
      defineBuiltInAccessor(Constructor[PROTOTYPE], key, {
        configurable: true,
        get: function get() {
          return getInternalState(this)[key];
        }
      });
    };
    var get = function get(view, count, index, isLittleEndian) {
      var store = getInternalDataViewState(view);
      var intIndex = toIndex(index);
      var boolIsLittleEndian = !!isLittleEndian;
      if (intIndex + count > store.byteLength) throw new RangeError(WRONG_INDEX);
      var bytes = store.bytes;
      var start = intIndex + store.byteOffset;
      var pack = arraySlice(bytes, start, start + count);
      return boolIsLittleEndian ? pack : reverse(pack);
    };
    var set = function set(view, count, index, conversion, value, isLittleEndian) {
      var store = getInternalDataViewState(view);
      var intIndex = toIndex(index);
      var pack = conversion(+value);
      var boolIsLittleEndian = !!isLittleEndian;
      if (intIndex + count > store.byteLength) throw new RangeError(WRONG_INDEX);
      var bytes = store.bytes;
      var start = intIndex + store.byteOffset;
      for (var i = 0; i < count; i++) bytes[start + i] = pack[boolIsLittleEndian ? i : count - i - 1];
    };
    if (!NATIVE_ARRAY_BUFFER) {
      $ArrayBuffer = function ArrayBuffer(length) {
        anInstance(this, ArrayBufferPrototype);
        var byteLength = toIndex(length);
        setInternalState(this, {
          type: ARRAY_BUFFER,
          bytes: fill(Array(byteLength), 0),
          byteLength: byteLength
        });
        if (!DESCRIPTORS) {
          this.byteLength = byteLength;
          this.detached = false;
        }
      };
      ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE];
      $DataView = function DataView(buffer, byteOffset, byteLength) {
        anInstance(this, DataViewPrototype);
        anInstance(buffer, ArrayBufferPrototype);
        var bufferState = getInternalArrayBufferState(buffer);
        var bufferLength = bufferState.byteLength;
        var offset = toIntegerOrInfinity(byteOffset);
        if (offset < 0 || offset > bufferLength) throw new RangeError('Wrong offset');
        byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
        if (offset + byteLength > bufferLength) throw new RangeError(WRONG_LENGTH);
        setInternalState(this, {
          type: DATA_VIEW,
          buffer: buffer,
          byteLength: byteLength,
          byteOffset: offset,
          bytes: bufferState.bytes
        });
        if (!DESCRIPTORS) {
          this.buffer = buffer;
          this.byteLength = byteLength;
          this.byteOffset = offset;
        }
      };
      DataViewPrototype = $DataView[PROTOTYPE];
      if (DESCRIPTORS) {
        addGetter($ArrayBuffer, 'byteLength', getInternalArrayBufferState);
        addGetter($DataView, 'buffer', getInternalDataViewState);
        addGetter($DataView, 'byteLength', getInternalDataViewState);
        addGetter($DataView, 'byteOffset', getInternalDataViewState);
      }
      defineBuiltIns(DataViewPrototype, {
        getInt8: function getInt8(byteOffset) {
          return get(this, 1, byteOffset)[0] << 24 >> 24;
        },
        getUint8: function getUint8(byteOffset) {
          return get(this, 1, byteOffset)[0];
        },
        getInt16: function getInt16(byteOffset) {
          var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : false);
          return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
        },
        getUint16: function getUint16(byteOffset) {
          var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : false);
          return bytes[1] << 8 | bytes[0];
        },
        getInt32: function getInt32(byteOffset) {
          return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : false));
        },
        getUint32: function getUint32(byteOffset) {
          return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : false)) >>> 0;
        },
        getFloat32: function getFloat32(byteOffset) {
          return unpackIEEE754(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : false), 23);
        },
        getFloat64: function getFloat64(byteOffset) {
          return unpackIEEE754(get(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : false), 52);
        },
        setInt8: function setInt8(byteOffset, value) {
          set(this, 1, byteOffset, packInt8, value);
        },
        setUint8: function setUint8(byteOffset, value) {
          set(this, 1, byteOffset, packInt8, value);
        },
        setInt16: function setInt16(byteOffset, value) {
          set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : false);
        },
        setUint16: function setUint16(byteOffset, value) {
          set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : false);
        },
        setInt32: function setInt32(byteOffset, value) {
          set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : false);
        },
        setUint32: function setUint32(byteOffset, value) {
          set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : false);
        },
        setFloat32: function setFloat32(byteOffset, value) {
          set(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : false);
        },
        setFloat64: function setFloat64(byteOffset, value) {
          set(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : false);
        }
      });
    } else {
      var INCORRECT_ARRAY_BUFFER_NAME = PROPER_FUNCTION_NAME && NativeArrayBuffer.name !== ARRAY_BUFFER;
      if (!fails(function () {
        NativeArrayBuffer(1);
      }) || !fails(function () {
        new NativeArrayBuffer(-1);
      }) || fails(function () {
        new NativeArrayBuffer();
        new NativeArrayBuffer(1.5);
        new NativeArrayBuffer(NaN);
        return NativeArrayBuffer.length !== 1 || INCORRECT_ARRAY_BUFFER_NAME && !CONFIGURABLE_FUNCTION_NAME;
      })) {
        $ArrayBuffer = function ArrayBuffer(length) {
          anInstance(this, ArrayBufferPrototype);
          return inheritIfRequired(new NativeArrayBuffer(toIndex(length)), this, $ArrayBuffer);
        };
        $ArrayBuffer[PROTOTYPE] = ArrayBufferPrototype;
        ArrayBufferPrototype.constructor = $ArrayBuffer;
        copyConstructorProperties($ArrayBuffer, NativeArrayBuffer);
      } else if (INCORRECT_ARRAY_BUFFER_NAME && CONFIGURABLE_FUNCTION_NAME) {
        createNonEnumerableProperty(NativeArrayBuffer, 'name', ARRAY_BUFFER);
      }
      if (setPrototypeOf && getPrototypeOf(DataViewPrototype) !== ObjectPrototype) {
        setPrototypeOf(DataViewPrototype, ObjectPrototype);
      }
      var testView = new $DataView(new $ArrayBuffer(2));
      var $setInt8 = uncurryThis(DataViewPrototype.setInt8);
      testView.setInt8(0, 2147483648);
      testView.setInt8(1, 2147483649);
      if (testView.getInt8(0) || !testView.getInt8(1)) defineBuiltIns(DataViewPrototype, {
        setInt8: function setInt8(byteOffset, value) {
          $setInt8(this, byteOffset, value << 24 >> 24);
        },
        setUint8: function setUint8(byteOffset, value) {
          $setInt8(this, byteOffset, value << 24 >> 24);
        }
      }, {
        unsafe: true
      });
    }
    setToStringTag($ArrayBuffer, ARRAY_BUFFER);
    setToStringTag($DataView, DATA_VIEW);
    arrayBuffer = {
      ArrayBuffer: $ArrayBuffer,
      DataView: $DataView
    };
    return arrayBuffer;
  }
  var hasRequiredEs_arrayBuffer_constructor;
  function requireEs_arrayBuffer_constructor() {
    if (hasRequiredEs_arrayBuffer_constructor) return es_arrayBuffer_constructor;
    hasRequiredEs_arrayBuffer_constructor = 1;
    var $ = require_export();
    var globalThis = requireGlobalThis();
    var arrayBufferModule = requireArrayBuffer();
    var setSpecies = requireSetSpecies();
    var ARRAY_BUFFER = 'ArrayBuffer';
    var ArrayBuffer = arrayBufferModule[ARRAY_BUFFER];
    var NativeArrayBuffer = globalThis[ARRAY_BUFFER];
    $({
      global: true,
      constructor: true,
      forced: NativeArrayBuffer !== ArrayBuffer
    }, {
      ArrayBuffer: ArrayBuffer
    });
    setSpecies(ARRAY_BUFFER);
    return es_arrayBuffer_constructor;
  }
  var es_arrayBuffer_isView = {};
  var arrayBufferViewCore;
  var hasRequiredArrayBufferViewCore;
  function requireArrayBufferViewCore() {
    if (hasRequiredArrayBufferViewCore) return arrayBufferViewCore;
    hasRequiredArrayBufferViewCore = 1;
    var NATIVE_ARRAY_BUFFER = requireArrayBufferBasicDetection();
    var DESCRIPTORS = requireDescriptors();
    var globalThis = requireGlobalThis();
    var isCallable = requireIsCallable();
    var isObject = requireIsObject();
    var hasOwn = requireHasOwnProperty();
    var classof = requireClassof();
    var tryToString = requireTryToString();
    var createNonEnumerableProperty = requireCreateNonEnumerableProperty();
    var defineBuiltIn = requireDefineBuiltIn();
    var defineBuiltInAccessor = requireDefineBuiltInAccessor();
    var isPrototypeOf = requireObjectIsPrototypeOf();
    var getPrototypeOf = requireObjectGetPrototypeOf();
    var setPrototypeOf = requireObjectSetPrototypeOf();
    var wellKnownSymbol = requireWellKnownSymbol();
    var uid = requireUid();
    var InternalStateModule = requireInternalState();
    var enforceInternalState = InternalStateModule.enforce;
    var getInternalState = InternalStateModule.get;
    var Int8Array = globalThis.Int8Array;
    var Int8ArrayPrototype = Int8Array && Int8Array.prototype;
    var Uint8ClampedArray = globalThis.Uint8ClampedArray;
    var Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;
    var TypedArray = Int8Array && getPrototypeOf(Int8Array);
    var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);
    var ObjectPrototype = Object.prototype;
    var TypeError = globalThis.TypeError;
    var TO_STRING_TAG = wellKnownSymbol('toStringTag');
    var TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG');
    var TYPED_ARRAY_CONSTRUCTOR = 'TypedArrayConstructor';
    var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(globalThis.opera) !== 'Opera';
    var TYPED_ARRAY_TAG_REQUIRED = false;
    var NAME, Constructor, Prototype;
    var TypedArrayConstructorsList = {
      Int8Array: 1,
      Uint8Array: 1,
      Uint8ClampedArray: 1,
      Int16Array: 2,
      Uint16Array: 2,
      Int32Array: 4,
      Uint32Array: 4,
      Float32Array: 4,
      Float64Array: 8
    };
    var BigIntArrayConstructorsList = {
      BigInt64Array: 8,
      BigUint64Array: 8
    };
    var isView = function isView(it) {
      if (!isObject(it)) return false;
      var klass = classof(it);
      return klass === 'DataView' || hasOwn(TypedArrayConstructorsList, klass) || hasOwn(BigIntArrayConstructorsList, klass);
    };
    var _getTypedArrayConstructor = function getTypedArrayConstructor(it) {
      var proto = getPrototypeOf(it);
      if (!isObject(proto)) return;
      var state = getInternalState(proto);
      return state && hasOwn(state, TYPED_ARRAY_CONSTRUCTOR) ? state[TYPED_ARRAY_CONSTRUCTOR] : _getTypedArrayConstructor(proto);
    };
    var isTypedArray = function isTypedArray(it) {
      if (!isObject(it)) return false;
      var klass = classof(it);
      return hasOwn(TypedArrayConstructorsList, klass) || hasOwn(BigIntArrayConstructorsList, klass);
    };
    var aTypedArray = function aTypedArray(it) {
      if (isTypedArray(it)) return it;
      throw new TypeError('Target is not a typed array');
    };
    var aTypedArrayConstructor = function aTypedArrayConstructor(C) {
      if (isCallable(C) && (!setPrototypeOf || isPrototypeOf(TypedArray, C))) return C;
      throw new TypeError(tryToString(C) + ' is not a typed array constructor');
    };
    var exportTypedArrayMethod = function exportTypedArrayMethod(KEY, property, forced, options) {
      if (!DESCRIPTORS) return;
      if (forced) for (var ARRAY in TypedArrayConstructorsList) {
        var TypedArrayConstructor = globalThis[ARRAY];
        if (TypedArrayConstructor && hasOwn(TypedArrayConstructor.prototype, KEY)) try {
          delete TypedArrayConstructor.prototype[KEY];
        } catch (error) {
          try {
            TypedArrayConstructor.prototype[KEY] = property;
          } catch (error2) {}
        }
      }
      if (!TypedArrayPrototype[KEY] || forced) {
        defineBuiltIn(TypedArrayPrototype, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property, options);
      }
    };
    var exportTypedArrayStaticMethod = function exportTypedArrayStaticMethod(KEY, property, forced) {
      var ARRAY, TypedArrayConstructor;
      if (!DESCRIPTORS) return;
      if (setPrototypeOf) {
        if (forced) for (ARRAY in TypedArrayConstructorsList) {
          TypedArrayConstructor = globalThis[ARRAY];
          if (TypedArrayConstructor && hasOwn(TypedArrayConstructor, KEY)) try {
            delete TypedArrayConstructor[KEY];
          } catch (error) {}
        }
        if (!TypedArray[KEY] || forced) {
          try {
            return defineBuiltIn(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && TypedArray[KEY] || property);
          } catch (error) {}
        } else return;
      }
      for (ARRAY in TypedArrayConstructorsList) {
        TypedArrayConstructor = globalThis[ARRAY];
        if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
          defineBuiltIn(TypedArrayConstructor, KEY, property);
        }
      }
    };
    for (NAME in TypedArrayConstructorsList) {
      Constructor = globalThis[NAME];
      Prototype = Constructor && Constructor.prototype;
      if (Prototype) enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;else NATIVE_ARRAY_BUFFER_VIEWS = false;
    }
    for (NAME in BigIntArrayConstructorsList) {
      Constructor = globalThis[NAME];
      Prototype = Constructor && Constructor.prototype;
      if (Prototype) enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
    }
    if (!NATIVE_ARRAY_BUFFER_VIEWS || !isCallable(TypedArray) || TypedArray === Function.prototype) {
      TypedArray = function TypedArray() {
        throw new TypeError('Incorrect invocation');
      };
      if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
        if (globalThis[NAME]) setPrototypeOf(globalThis[NAME], TypedArray);
      }
    }
    if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {
      TypedArrayPrototype = TypedArray.prototype;
      if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
        if (globalThis[NAME]) setPrototypeOf(globalThis[NAME].prototype, TypedArrayPrototype);
      }
    }
    if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
      setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
    }
    if (DESCRIPTORS && !hasOwn(TypedArrayPrototype, TO_STRING_TAG)) {
      TYPED_ARRAY_TAG_REQUIRED = true;
      defineBuiltInAccessor(TypedArrayPrototype, TO_STRING_TAG, {
        configurable: true,
        get: function get() {
          return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;
        }
      });
      for (NAME in TypedArrayConstructorsList) if (globalThis[NAME]) {
        createNonEnumerableProperty(globalThis[NAME], TYPED_ARRAY_TAG, NAME);
      }
    }
    arrayBufferViewCore = {
      NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,
      TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQUIRED && TYPED_ARRAY_TAG,
      aTypedArray: aTypedArray,
      aTypedArrayConstructor: aTypedArrayConstructor,
      exportTypedArrayMethod: exportTypedArrayMethod,
      exportTypedArrayStaticMethod: exportTypedArrayStaticMethod,
      getTypedArrayConstructor: _getTypedArrayConstructor,
      isView: isView,
      isTypedArray: isTypedArray,
      TypedArray: TypedArray,
      TypedArrayPrototype: TypedArrayPrototype
    };
    return arrayBufferViewCore;
  }
  var hasRequiredEs_arrayBuffer_isView;
  function requireEs_arrayBuffer_isView() {
    if (hasRequiredEs_arrayBuffer_isView) return es_arrayBuffer_isView;
    hasRequiredEs_arrayBuffer_isView = 1;
    var $ = require_export();
    var ArrayBufferViewCore = requireArrayBufferViewCore();
    var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
    $({
      target: 'ArrayBuffer',
      stat: true,
      forced: !NATIVE_ARRAY_BUFFER_VIEWS
    }, {
      isView: ArrayBufferViewCore.isView
    });
    return es_arrayBuffer_isView;
  }
  var es_arrayBuffer_slice = {};
  var hasRequiredEs_arrayBuffer_slice;
  function requireEs_arrayBuffer_slice() {
    if (hasRequiredEs_arrayBuffer_slice) return es_arrayBuffer_slice;
    hasRequiredEs_arrayBuffer_slice = 1;
    var $ = require_export();
    var uncurryThis = requireFunctionUncurryThisClause();
    var fails = requireFails();
    var ArrayBufferModule = requireArrayBuffer();
    var anObject = requireAnObject();
    var toAbsoluteIndex = requireToAbsoluteIndex();
    var toLength = requireToLength();
    var ArrayBuffer = ArrayBufferModule.ArrayBuffer;
    var DataView = ArrayBufferModule.DataView;
    var DataViewPrototype = DataView.prototype;
    var nativeArrayBufferSlice = uncurryThis(ArrayBuffer.prototype.slice);
    var getUint8 = uncurryThis(DataViewPrototype.getUint8);
    var setUint8 = uncurryThis(DataViewPrototype.setUint8);
    var INCORRECT_SLICE = fails(function () {
      return !new ArrayBuffer(2).slice(1, undefined).byteLength;
    });
    $({
      target: 'ArrayBuffer',
      proto: true,
      unsafe: true,
      forced: INCORRECT_SLICE
    }, {
      slice: function slice(start, end) {
        if (nativeArrayBufferSlice && end === undefined) {
          return nativeArrayBufferSlice(anObject(this), start);
        }
        var length = anObject(this).byteLength;
        var first = toAbsoluteIndex(start, length);
        var fin = toAbsoluteIndex(end === undefined ? length : end, length);
        var result = new ArrayBuffer(toLength(fin - first));
        var viewSource = new DataView(this);
        var viewTarget = new DataView(result);
        var index = 0;
        while (first < fin) {
          setUint8(viewTarget, index++, getUint8(viewSource, first++));
        }
        return result;
      }
    });
    return es_arrayBuffer_slice;
  }
  var es_dataView = {};
  var es_dataView_constructor = {};
  var hasRequiredEs_dataView_constructor;
  function requireEs_dataView_constructor() {
    if (hasRequiredEs_dataView_constructor) return es_dataView_constructor;
    hasRequiredEs_dataView_constructor = 1;
    var $ = require_export();
    var ArrayBufferModule = requireArrayBuffer();
    var NATIVE_ARRAY_BUFFER = requireArrayBufferBasicDetection();
    $({
      global: true,
      constructor: true,
      forced: !NATIVE_ARRAY_BUFFER
    }, {
      DataView: ArrayBufferModule.DataView
    });
    return es_dataView_constructor;
  }
  var hasRequiredEs_dataView;
  function requireEs_dataView() {
    if (hasRequiredEs_dataView) return es_dataView;
    hasRequiredEs_dataView = 1;
    requireEs_dataView_constructor();
    return es_dataView;
  }
  var es_dataView_getFloat16 = {};
  var hasRequiredEs_dataView_getFloat16;
  function requireEs_dataView_getFloat16() {
    if (hasRequiredEs_dataView_getFloat16) return es_dataView_getFloat16;
    hasRequiredEs_dataView_getFloat16 = 1;
    var $ = require_export();
    var uncurryThis = requireFunctionUncurryThis();
    var pow = Math.pow;
    var EXP_MASK16 = 31;
    var SIGNIFICAND_MASK16 = 1023;
    var MIN_SUBNORMAL16 = pow(2, -24);
    var SIGNIFICAND_DENOM16 = 0.0009765625;
    var unpackFloat16 = function unpackFloat16(bytes) {
      var sign = bytes >>> 15;
      var exponent = bytes >>> 10 & EXP_MASK16;
      var significand = bytes & SIGNIFICAND_MASK16;
      if (exponent === EXP_MASK16) return significand === 0 ? sign === 0 ? Infinity : -Infinity : NaN;
      if (exponent === 0) return significand * (sign === 0 ? MIN_SUBNORMAL16 : -MIN_SUBNORMAL16);
      return pow(2, exponent - 15) * (sign === 0 ? 1 + significand * SIGNIFICAND_DENOM16 : -1 - significand * SIGNIFICAND_DENOM16);
    };
    var getUint16 = uncurryThis(DataView.prototype.getUint16);
    $({
      target: 'DataView',
      proto: true
    }, {
      getFloat16: function getFloat16(byteOffset) {
        return unpackFloat16(getUint16(this, byteOffset, arguments.length > 1 ? arguments[1] : false));
      }
    });
    return es_dataView_getFloat16;
  }
  var es_dataView_setFloat16 = {};
  var aDataView;
  var hasRequiredADataView;
  function requireADataView() {
    if (hasRequiredADataView) return aDataView;
    hasRequiredADataView = 1;
    var classof = requireClassof();
    var $TypeError = TypeError;
    aDataView = function aDataView(argument) {
      if (classof(argument) === 'DataView') return argument;
      throw new $TypeError('Argument is not a DataView');
    };
    return aDataView;
  }
  var mathLog2;
  var hasRequiredMathLog2;
  function requireMathLog2() {
    if (hasRequiredMathLog2) return mathLog2;
    hasRequiredMathLog2 = 1;
    var log = Math.log;
    var LN2 = Math.LN2;
    mathLog2 = Math.log2 || function log2(x) {
      return log(x) / LN2;
    };
    return mathLog2;
  }
  var hasRequiredEs_dataView_setFloat16;
  function requireEs_dataView_setFloat16() {
    if (hasRequiredEs_dataView_setFloat16) return es_dataView_setFloat16;
    hasRequiredEs_dataView_setFloat16 = 1;
    var $ = require_export();
    var uncurryThis = requireFunctionUncurryThis();
    var aDataView = requireADataView();
    var toIndex = requireToIndex();
    var log2 = requireMathLog2();
    var roundTiesToEven = requireMathRoundTiesToEven();
    var pow = Math.pow;
    var MIN_INFINITY16 = 65520;
    var MIN_NORMAL16 = 0.000061005353927612305;
    var REC_MIN_SUBNORMAL16 = 16777216;
    var REC_SIGNIFICAND_DENOM16 = 1024;
    var packFloat16 = function packFloat16(value) {
      if (value !== value) return 0x7E00;
      if (value === 0) return (1 / value === -Infinity) << 15;
      var neg = value < 0;
      if (neg) value = -value;
      if (value >= MIN_INFINITY16) return neg << 15 | 0x7C00;
      if (value < MIN_NORMAL16) return neg << 15 | roundTiesToEven(value * REC_MIN_SUBNORMAL16);
      var exponent = log2(value) | 0;
      if (exponent === -15) {
        return neg << 15 | REC_SIGNIFICAND_DENOM16;
      }
      var significand = roundTiesToEven((value * pow(2, -exponent) - 1) * REC_SIGNIFICAND_DENOM16);
      if (significand === REC_SIGNIFICAND_DENOM16) {
        return neg << 15 | exponent + 16 << 10;
      }
      return neg << 15 | exponent + 15 << 10 | significand;
    };
    var setUint16 = uncurryThis(DataView.prototype.setUint16);
    $({
      target: 'DataView',
      proto: true
    }, {
      setFloat16: function setFloat16(byteOffset, value) {
        setUint16(aDataView(this), toIndex(byteOffset), packFloat16(+value), arguments.length > 2 ? arguments[2] : false);
      }
    });
    return es_dataView_setFloat16;
  }
  var es_arrayBuffer_detached = {};
  var arrayBufferByteLength;
  var hasRequiredArrayBufferByteLength;
  function requireArrayBufferByteLength() {
    if (hasRequiredArrayBufferByteLength) return arrayBufferByteLength;
    hasRequiredArrayBufferByteLength = 1;
    var globalThis = requireGlobalThis();
    var uncurryThisAccessor = requireFunctionUncurryThisAccessor();
    var classof = requireClassofRaw();
    var ArrayBuffer = globalThis.ArrayBuffer;
    var TypeError = globalThis.TypeError;
    arrayBufferByteLength = ArrayBuffer && uncurryThisAccessor(ArrayBuffer.prototype, 'byteLength', 'get') || function (O) {
      if (classof(O) !== 'ArrayBuffer') throw new TypeError('ArrayBuffer expected');
      return O.byteLength;
    };
    return arrayBufferByteLength;
  }
  var arrayBufferIsDetached;
  var hasRequiredArrayBufferIsDetached;
  function requireArrayBufferIsDetached() {
    if (hasRequiredArrayBufferIsDetached) return arrayBufferIsDetached;
    hasRequiredArrayBufferIsDetached = 1;
    var globalThis = requireGlobalThis();
    var NATIVE_ARRAY_BUFFER = requireArrayBufferBasicDetection();
    var arrayBufferByteLength = requireArrayBufferByteLength();
    var DataView = globalThis.DataView;
    arrayBufferIsDetached = function arrayBufferIsDetached(O) {
      if (!NATIVE_ARRAY_BUFFER || arrayBufferByteLength(O) !== 0) return false;
      try {
        new DataView(O);
        return false;
      } catch (error) {
        return true;
      }
    };
    return arrayBufferIsDetached;
  }
  var hasRequiredEs_arrayBuffer_detached;
  function requireEs_arrayBuffer_detached() {
    if (hasRequiredEs_arrayBuffer_detached) return es_arrayBuffer_detached;
    hasRequiredEs_arrayBuffer_detached = 1;
    var DESCRIPTORS = requireDescriptors();
    var defineBuiltInAccessor = requireDefineBuiltInAccessor();
    var isDetached = requireArrayBufferIsDetached();
    var ArrayBufferPrototype = ArrayBuffer.prototype;
    if (DESCRIPTORS && !('detached' in ArrayBufferPrototype)) {
      defineBuiltInAccessor(ArrayBufferPrototype, 'detached', {
        configurable: true,
        get: function detached() {
          return isDetached(this);
        }
      });
    }
    return es_arrayBuffer_detached;
  }
  var es_arrayBuffer_transfer = {};
  var arrayBufferNotDetached;
  var hasRequiredArrayBufferNotDetached;
  function requireArrayBufferNotDetached() {
    if (hasRequiredArrayBufferNotDetached) return arrayBufferNotDetached;
    hasRequiredArrayBufferNotDetached = 1;
    var isDetached = requireArrayBufferIsDetached();
    var $TypeError = TypeError;
    arrayBufferNotDetached = function arrayBufferNotDetached(it) {
      if (isDetached(it)) throw new $TypeError('ArrayBuffer is detached');
      return it;
    };
    return arrayBufferNotDetached;
  }
  var getBuiltInNodeModule;
  var hasRequiredGetBuiltInNodeModule;
  function requireGetBuiltInNodeModule() {
    if (hasRequiredGetBuiltInNodeModule) return getBuiltInNodeModule;
    hasRequiredGetBuiltInNodeModule = 1;
    var globalThis = requireGlobalThis();
    var IS_NODE = requireEnvironmentIsNode();
    getBuiltInNodeModule = function getBuiltInNodeModule(name) {
      if (IS_NODE) {
        try {
          return globalThis.process.getBuiltinModule(name);
        } catch (error) {}
        try {
          return Function('return require("' + name + '")')();
        } catch (error) {}
      }
    };
    return getBuiltInNodeModule;
  }
  var structuredCloneProperTransfer;
  var hasRequiredStructuredCloneProperTransfer;
  function requireStructuredCloneProperTransfer() {
    if (hasRequiredStructuredCloneProperTransfer) return structuredCloneProperTransfer;
    hasRequiredStructuredCloneProperTransfer = 1;
    var globalThis = requireGlobalThis();
    var fails = requireFails();
    var V8 = requireEnvironmentV8Version();
    var ENVIRONMENT = requireEnvironment();
    var structuredClone = globalThis.structuredClone;
    structuredCloneProperTransfer = !!structuredClone && !fails(function () {
      if (ENVIRONMENT === 'DENO' && V8 > 92 || ENVIRONMENT === 'NODE' && V8 > 94 || ENVIRONMENT === 'BROWSER' && V8 > 97) return false;
      var buffer = new ArrayBuffer(8);
      var clone = structuredClone(buffer, {
        transfer: [buffer]
      });
      return buffer.byteLength !== 0 || clone.byteLength !== 8;
    });
    return structuredCloneProperTransfer;
  }
  var detachTransferable;
  var hasRequiredDetachTransferable;
  function requireDetachTransferable() {
    if (hasRequiredDetachTransferable) return detachTransferable;
    hasRequiredDetachTransferable = 1;
    var globalThis = requireGlobalThis();
    var getBuiltInNodeModule = requireGetBuiltInNodeModule();
    var PROPER_STRUCTURED_CLONE_TRANSFER = requireStructuredCloneProperTransfer();
    var structuredClone = globalThis.structuredClone;
    var $ArrayBuffer = globalThis.ArrayBuffer;
    var $MessageChannel = globalThis.MessageChannel;
    var detach = false;
    var WorkerThreads, channel, buffer, $detach;
    if (PROPER_STRUCTURED_CLONE_TRANSFER) {
      detach = function detach(transferable) {
        structuredClone(transferable, {
          transfer: [transferable]
        });
      };
    } else if ($ArrayBuffer) try {
      if (!$MessageChannel) {
        WorkerThreads = getBuiltInNodeModule('worker_threads');
        if (WorkerThreads) $MessageChannel = WorkerThreads.MessageChannel;
      }
      if ($MessageChannel) {
        channel = new $MessageChannel();
        buffer = new $ArrayBuffer(2);
        $detach = function $detach(transferable) {
          channel.port1.postMessage(null, [transferable]);
        };
        if (buffer.byteLength === 2) {
          $detach(buffer);
          if (buffer.byteLength === 0) detach = $detach;
        }
      }
    } catch (error) {}
    detachTransferable = detach;
    return detachTransferable;
  }
  var arrayBufferTransfer;
  var hasRequiredArrayBufferTransfer;
  function requireArrayBufferTransfer() {
    if (hasRequiredArrayBufferTransfer) return arrayBufferTransfer;
    hasRequiredArrayBufferTransfer = 1;
    var globalThis = requireGlobalThis();
    var uncurryThis = requireFunctionUncurryThis();
    var uncurryThisAccessor = requireFunctionUncurryThisAccessor();
    var toIndex = requireToIndex();
    var notDetached = requireArrayBufferNotDetached();
    var arrayBufferByteLength = requireArrayBufferByteLength();
    var detachTransferable = requireDetachTransferable();
    var PROPER_STRUCTURED_CLONE_TRANSFER = requireStructuredCloneProperTransfer();
    var structuredClone = globalThis.structuredClone;
    var ArrayBuffer = globalThis.ArrayBuffer;
    var DataView = globalThis.DataView;
    var min = Math.min;
    var ArrayBufferPrototype = ArrayBuffer.prototype;
    var DataViewPrototype = DataView.prototype;
    var slice = uncurryThis(ArrayBufferPrototype.slice);
    var isResizable = uncurryThisAccessor(ArrayBufferPrototype, 'resizable', 'get');
    var maxByteLength = uncurryThisAccessor(ArrayBufferPrototype, 'maxByteLength', 'get');
    var getInt8 = uncurryThis(DataViewPrototype.getInt8);
    var setInt8 = uncurryThis(DataViewPrototype.setInt8);
    arrayBufferTransfer = (PROPER_STRUCTURED_CLONE_TRANSFER || detachTransferable) && function (arrayBuffer, newLength, preserveResizability) {
      var byteLength = arrayBufferByteLength(arrayBuffer);
      var newByteLength = newLength === undefined ? byteLength : toIndex(newLength);
      var fixedLength = !isResizable || !isResizable(arrayBuffer);
      var newBuffer;
      notDetached(arrayBuffer);
      if (PROPER_STRUCTURED_CLONE_TRANSFER) {
        arrayBuffer = structuredClone(arrayBuffer, {
          transfer: [arrayBuffer]
        });
        if (byteLength === newByteLength && (preserveResizability || fixedLength)) return arrayBuffer;
      }
      if (byteLength >= newByteLength && (!preserveResizability || fixedLength)) {
        newBuffer = slice(arrayBuffer, 0, newByteLength);
      } else {
        var options = preserveResizability && !fixedLength && maxByteLength ? {
          maxByteLength: maxByteLength(arrayBuffer)
        } : undefined;
        newBuffer = new ArrayBuffer(newByteLength, options);
        var a = new DataView(arrayBuffer);
        var b = new DataView(newBuffer);
        var copyLength = min(newByteLength, byteLength);
        for (var i = 0; i < copyLength; i++) setInt8(b, i, getInt8(a, i));
      }
      if (!PROPER_STRUCTURED_CLONE_TRANSFER) detachTransferable(arrayBuffer);
      return newBuffer;
    };
    return arrayBufferTransfer;
  }
  var hasRequiredEs_arrayBuffer_transfer;
  function requireEs_arrayBuffer_transfer() {
    if (hasRequiredEs_arrayBuffer_transfer) return es_arrayBuffer_transfer;
    hasRequiredEs_arrayBuffer_transfer = 1;
    var $ = require_export();
    var $transfer = requireArrayBufferTransfer();
    if ($transfer) $({
      target: 'ArrayBuffer',
      proto: true
    }, {
      transfer: function transfer() {
        return $transfer(this, arguments.length ? arguments[0] : undefined, true);
      }
    });
    return es_arrayBuffer_transfer;
  }
  var es_arrayBuffer_transferToFixedLength = {};
  var hasRequiredEs_arrayBuffer_transferToFixedLength;
  function requireEs_arrayBuffer_transferToFixedLength() {
    if (hasRequiredEs_arrayBuffer_transferToFixedLength) return es_arrayBuffer_transferToFixedLength;
    hasRequiredEs_arrayBuffer_transferToFixedLength = 1;
    var $ = require_export();
    var $transfer = requireArrayBufferTransfer();
    if ($transfer) $({
      target: 'ArrayBuffer',
      proto: true
    }, {
      transferToFixedLength: function transferToFixedLength() {
        return $transfer(this, arguments.length ? arguments[0] : undefined, false);
      }
    });
    return es_arrayBuffer_transferToFixedLength;
  }
  var es_date_getYear = {};
  var hasRequiredEs_date_getYear;
  function requireEs_date_getYear() {
    if (hasRequiredEs_date_getYear) return es_date_getYear;
    hasRequiredEs_date_getYear = 1;
    var $ = require_export();
    var uncurryThis = requireFunctionUncurryThis();
    var fails = requireFails();
    var FORCED = fails(function () {
      return new Date(16e11).getYear() !== 120;
    });
    var getFullYear = uncurryThis(Date.prototype.getFullYear);
    $({
      target: 'Date',
      proto: true,
      forced: FORCED
    }, {
      getYear: function getYear() {
        return getFullYear(this) - 1900;
      }
    });
    return es_date_getYear;
  }
  var es_date_now = {};
  var hasRequiredEs_date_now;
  function requireEs_date_now() {
    if (hasRequiredEs_date_now) return es_date_now;
    hasRequiredEs_date_now = 1;
    var $ = require_export();
    var uncurryThis = requireFunctionUncurryThis();
    var $Date = Date;
    var thisTimeValue = uncurryThis($Date.prototype.getTime);
    $({
      target: 'Date',
      stat: true
    }, {
      now: function now() {
        return thisTimeValue(new $Date());
      }
    });
    return es_date_now;
  }
  var es_date_setYear = {};
  var hasRequiredEs_date_setYear;
  function requireEs_date_setYear() {
    if (hasRequiredEs_date_setYear) return es_date_setYear;
    hasRequiredEs_date_setYear = 1;
    var $ = require_export();
    var uncurryThis = requireFunctionUncurryThis();
    var toIntegerOrInfinity = requireToIntegerOrInfinity();
    var DatePrototype = Date.prototype;
    var thisTimeValue = uncurryThis(DatePrototype.getTime);
    var setFullYear = uncurryThis(DatePrototype.setFullYear);
    $({
      target: 'Date',
      proto: true
    }, {
      setYear: function setYear(year) {
        thisTimeValue(this);
        var yi = toIntegerOrInfinity(year);
        var yyyy = yi >= 0 && yi <= 99 ? yi + 1900 : yi;
        return setFullYear(this, yyyy);
      }
    });
    return es_date_setYear;
  }
  var es_date_toGmtString = {};
  var hasRequiredEs_date_toGmtString;
  function requireEs_date_toGmtString() {
    if (hasRequiredEs_date_toGmtString) return es_date_toGmtString;
    hasRequiredEs_date_toGmtString = 1;
    var $ = require_export();
    $({
      target: 'Date',
      proto: true
    }, {
      toGMTString: Date.prototype.toUTCString
    });
    return es_date_toGmtString;
  }
  var es_date_toIsoString = {};
  var stringRepeat;
  var hasRequiredStringRepeat;
  function requireStringRepeat() {
    if (hasRequiredStringRepeat) return stringRepeat;
    hasRequiredStringRepeat = 1;
    var toIntegerOrInfinity = requireToIntegerOrInfinity();
    var toString = requireToString();
    var requireObjectCoercible = requireRequireObjectCoercible();
    var $RangeError = RangeError;
    stringRepeat = function repeat(count) {
      var str = toString(requireObjectCoercible(this));
      var result = '';
      var n = toIntegerOrInfinity(count);
      if (n < 0 || n === Infinity) throw new $RangeError('Wrong number of repetitions');
      for (; n > 0; (n >>>= 1) && (str += str)) if (n & 1) result += str;
      return result;
    };
    return stringRepeat;
  }
  var stringPad;
  var hasRequiredStringPad;
  function requireStringPad() {
    if (hasRequiredStringPad) return stringPad;
    hasRequiredStringPad = 1;
    var uncurryThis = requireFunctionUncurryThis();
    var toLength = requireToLength();
    var toString = requireToString();
    var $repeat = requireStringRepeat();
    var requireObjectCoercible = requireRequireObjectCoercible();
    var repeat = uncurryThis($repeat);
    var stringSlice = uncurryThis(''.slice);
    var ceil = Math.ceil;
    var createMethod = function createMethod(IS_END) {
      return function ($this, maxLength, fillString) {
        var S = toString(requireObjectCoercible($this));
        var intMaxLength = toLength(maxLength);
        var stringLength = S.length;
        var fillStr = fillString === undefined ? ' ' : toString(fillString);
        var fillLen, stringFiller;
        if (intMaxLength <= stringLength || fillStr === '') return S;
        fillLen = intMaxLength - stringLength;
        stringFiller = repeat(fillStr, ceil(fillLen / fillStr.length));
        if (stringFiller.length > fillLen) stringFiller = stringSlice(stringFiller, 0, fillLen);
        return IS_END ? S + stringFiller : stringFiller + S;
      };
    };
    stringPad = {
      start: createMethod(false),
      end: createMethod(true)
    };
    return stringPad;
  }
  var dateToIsoString;
  var hasRequiredDateToIsoString;
  function requireDateToIsoString() {
    if (hasRequiredDateToIsoString) return dateToIsoString;
    hasRequiredDateToIsoString = 1;
    var uncurryThis = requireFunctionUncurryThis();
    var fails = requireFails();
    var padStart = requireStringPad().start;
    var $RangeError = RangeError;
    var $isFinite = isFinite;
    var abs = Math.abs;
    var DatePrototype = Date.prototype;
    var nativeDateToISOString = DatePrototype.toISOString;
    var thisTimeValue = uncurryThis(DatePrototype.getTime);
    var getUTCDate = uncurryThis(DatePrototype.getUTCDate);
    var getUTCFullYear = uncurryThis(DatePrototype.getUTCFullYear);
    var getUTCHours = uncurryThis(DatePrototype.getUTCHours);
    var getUTCMilliseconds = uncurryThis(DatePrototype.getUTCMilliseconds);
    var getUTCMinutes = uncurryThis(DatePrototype.getUTCMinutes);
    var getUTCMonth = uncurryThis(DatePrototype.getUTCMonth);
    var getUTCSeconds = uncurryThis(DatePrototype.getUTCSeconds);
    dateToIsoString = fails(function () {
      return nativeDateToISOString.call(new Date(-5e13 - 1)) !== '0385-07-25T07:06:39.999Z';
    }) || !fails(function () {
      nativeDateToISOString.call(new Date(NaN));
    }) ? function toISOString() {
      if (!$isFinite(thisTimeValue(this))) throw new $RangeError('Invalid time value');
      var date = this;
      var year = getUTCFullYear(date);
      var milliseconds = getUTCMilliseconds(date);
      var sign = year < 0 ? '-' : year > 9999 ? '+' : '';
      return sign + padStart(abs(year), sign ? 6 : 4, 0) + '-' + padStart(getUTCMonth(date) + 1, 2, 0) + '-' + padStart(getUTCDate(date), 2, 0) + 'T' + padStart(getUTCHours(date), 2, 0) + ':' + padStart(getUTCMinutes(date), 2, 0) + ':' + padStart(getUTCSeconds(date), 2, 0) + '.' + padStart(milliseconds, 3, 0) + 'Z';
    } : nativeDateToISOString;
    return dateToIsoString;
  }
  var hasRequiredEs_date_toIsoString;
  function requireEs_date_toIsoString() {
    if (hasRequiredEs_date_toIsoString) return es_date_toIsoString;
    hasRequiredEs_date_toIsoString = 1;
    var $ = require_export();
    var toISOString = requireDateToIsoString();
    $({
      target: 'Date',
      proto: true,
      forced: Date.prototype.toISOString !== toISOString
    }, {
      toISOString: toISOString
    });
    return es_date_toIsoString;
  }
  var es_date_toJson = {};
  var hasRequiredEs_date_toJson;
  function requireEs_date_toJson() {
    if (hasRequiredEs_date_toJson) return es_date_toJson;
    hasRequiredEs_date_toJson = 1;
    var $ = require_export();
    var fails = requireFails();
    var toObject = requireToObject();
    var toPrimitive = requireToPrimitive();
    var FORCED = fails(function () {
      return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({
        toISOString: function toISOString() {
          return 1;
        }
      }) !== 1;
    });
    $({
      target: 'Date',
      proto: true,
      arity: 1,
      forced: FORCED
    }, {
      toJSON: function toJSON(key) {
        var O = toObject(this);
        var pv = toPrimitive(O, 'number');
        return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
      }
    });
    return es_date_toJson;
  }
  var es_date_toPrimitive = {};
  var dateToPrimitive;
  var hasRequiredDateToPrimitive;
  function requireDateToPrimitive() {
    if (hasRequiredDateToPrimitive) return dateToPrimitive;
    hasRequiredDateToPrimitive = 1;
    var anObject = requireAnObject();
    var ordinaryToPrimitive = requireOrdinaryToPrimitive();
    var $TypeError = TypeError;
    dateToPrimitive = function dateToPrimitive(hint) {
      anObject(this);
      if (hint === 'string' || hint === 'default') hint = 'string';else if (hint !== 'number') throw new $TypeError('Incorrect hint');
      return ordinaryToPrimitive(this, hint);
    };
    return dateToPrimitive;
  }
  var hasRequiredEs_date_toPrimitive;
  function requireEs_date_toPrimitive() {
    if (hasRequiredEs_date_toPrimitive) return es_date_toPrimitive;
    hasRequiredEs_date_toPrimitive = 1;
    var hasOwn = requireHasOwnProperty();
    var defineBuiltIn = requireDefineBuiltIn();
    var dateToPrimitive = requireDateToPrimitive();
    var wellKnownSymbol = requireWellKnownSymbol();
    var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
    var DatePrototype = Date.prototype;
    if (!hasOwn(DatePrototype, TO_PRIMITIVE)) {
      defineBuiltIn(DatePrototype, TO_PRIMITIVE, dateToPrimitive);
    }
    return es_date_toPrimitive;
  }
  var es_date_toString = {};
  var hasRequiredEs_date_toString;
  function requireEs_date_toString() {
    if (hasRequiredEs_date_toString) return es_date_toString;
    hasRequiredEs_date_toString = 1;
    var uncurryThis = requireFunctionUncurryThis();
    var defineBuiltIn = requireDefineBuiltIn();
    var DatePrototype = Date.prototype;
    var INVALID_DATE = 'Invalid Date';
    var TO_STRING = 'toString';
    var nativeDateToString = uncurryThis(DatePrototype[TO_STRING]);
    var thisTimeValue = uncurryThis(DatePrototype.getTime);
    if (String(new Date(NaN)) !== INVALID_DATE) {
      defineBuiltIn(DatePrototype, TO_STRING, function toString() {
        var value = thisTimeValue(this);
        return value === value ? nativeDateToString(this) : INVALID_DATE;
      });
    }
    return es_date_toString;
  }
  var es_disposableStack_constructor = {};
  var addDisposableResource;
  var hasRequiredAddDisposableResource;
  function requireAddDisposableResource() {
    if (hasRequiredAddDisposableResource) return addDisposableResource;
    hasRequiredAddDisposableResource = 1;
    var getBuiltIn = requireGetBuiltIn();
    var call = requireFunctionCall();
    var uncurryThis = requireFunctionUncurryThis();
    var bind = requireFunctionBindContext();
    var anObject = requireAnObject();
    var aCallable = requireACallable();
    var isNullOrUndefined = requireIsNullOrUndefined();
    var getMethod = requireGetMethod();
    var wellKnownSymbol = requireWellKnownSymbol();
    var ASYNC_DISPOSE = wellKnownSymbol('asyncDispose');
    var DISPOSE = wellKnownSymbol('dispose');
    var push = uncurryThis([].push);
    var getDisposeMethod = function getDisposeMethod(V, hint) {
      if (hint === 'async-dispose') {
        var method = getMethod(V, ASYNC_DISPOSE);
        if (method !== undefined) return method;
        method = getMethod(V, DISPOSE);
        if (method === undefined) return method;
        return function () {
          var O = this;
          var Promise = getBuiltIn('Promise');
          return new Promise(function (resolve) {
            call(method, O);
            resolve(undefined);
          });
        };
      }
      return getMethod(V, DISPOSE);
    };
    var createDisposableResource = function createDisposableResource(V, hint, method) {
      if (arguments.length < 3 && !isNullOrUndefined(V)) {
        method = aCallable(getDisposeMethod(anObject(V), hint));
      }
      return method === undefined ? function () {
        return undefined;
      } : bind(method, V);
    };
    addDisposableResource = function addDisposableResource(disposable, V, hint, method) {
      var resource;
      if (arguments.length < 4) {
        if (isNullOrUndefined(V) && hint === 'sync-dispose') return;
        resource = createDisposableResource(V, hint);
      } else {
        resource = createDisposableResource(undefined, hint, method);
      }
      push(disposable.stack, resource);
    };
    return addDisposableResource;
  }
  var hasRequiredEs_disposableStack_constructor;
  function requireEs_disposableStack_constructor() {
    if (hasRequiredEs_disposableStack_constructor) return es_disposableStack_constructor;
    hasRequiredEs_disposableStack_constructor = 1;
    var $ = require_export();
    var DESCRIPTORS = requireDescriptors();
    var getBuiltIn = requireGetBuiltIn();
    var aCallable = requireACallable();
    var anInstance = requireAnInstance();
    var defineBuiltIn = requireDefineBuiltIn();
    var defineBuiltIns = requireDefineBuiltIns();
    var defineBuiltInAccessor = requireDefineBuiltInAccessor();
    var wellKnownSymbol = requireWellKnownSymbol();
    var InternalStateModule = requireInternalState();
    var addDisposableResource = requireAddDisposableResource();
    var SuppressedError = getBuiltIn('SuppressedError');
    var $ReferenceError = ReferenceError;
    var DISPOSE = wellKnownSymbol('dispose');
    var TO_STRING_TAG = wellKnownSymbol('toStringTag');
    var DISPOSABLE_STACK = 'DisposableStack';
    var setInternalState = InternalStateModule.set;
    var getDisposableStackInternalState = InternalStateModule.getterFor(DISPOSABLE_STACK);
    var HINT = 'sync-dispose';
    var DISPOSED = 'disposed';
    var PENDING = 'pending';
    var getPendingDisposableStackInternalState = function getPendingDisposableStackInternalState(stack) {
      var internalState = getDisposableStackInternalState(stack);
      if (internalState.state === DISPOSED) throw new $ReferenceError(DISPOSABLE_STACK + ' already disposed');
      return internalState;
    };
    var $DisposableStack = function DisposableStack() {
      setInternalState(anInstance(this, DisposableStackPrototype), {
        type: DISPOSABLE_STACK,
        state: PENDING,
        stack: []
      });
      if (!DESCRIPTORS) this.disposed = false;
    };
    var DisposableStackPrototype = $DisposableStack.prototype;
    defineBuiltIns(DisposableStackPrototype, {
      dispose: function dispose() {
        var internalState = getDisposableStackInternalState(this);
        if (internalState.state === DISPOSED) return;
        internalState.state = DISPOSED;
        if (!DESCRIPTORS) this.disposed = true;
        var stack = internalState.stack;
        var i = stack.length;
        var thrown = false;
        var suppressed;
        while (i) {
          var disposeMethod = stack[--i];
          stack[i] = null;
          try {
            disposeMethod();
          } catch (errorResult) {
            if (thrown) {
              suppressed = new SuppressedError(errorResult, suppressed);
            } else {
              thrown = true;
              suppressed = errorResult;
            }
          }
        }
        internalState.stack = null;
        if (thrown) throw suppressed;
      },
      use: function use(value) {
        addDisposableResource(getPendingDisposableStackInternalState(this), value, HINT);
        return value;
      },
      adopt: function adopt(value, onDispose) {
        var internalState = getPendingDisposableStackInternalState(this);
        aCallable(onDispose);
        addDisposableResource(internalState, undefined, HINT, function () {
          onDispose(value);
        });
        return value;
      },
      defer: function defer(onDispose) {
        var internalState = getPendingDisposableStackInternalState(this);
        aCallable(onDispose);
        addDisposableResource(internalState, undefined, HINT, onDispose);
      },
      move: function move() {
        var internalState = getPendingDisposableStackInternalState(this);
        var newDisposableStack = new $DisposableStack();
        getDisposableStackInternalState(newDisposableStack).stack = internalState.stack;
        internalState.stack = [];
        internalState.state = DISPOSED;
        if (!DESCRIPTORS) this.disposed = true;
        return newDisposableStack;
      }
    });
    if (DESCRIPTORS) defineBuiltInAccessor(DisposableStackPrototype, 'disposed', {
      configurable: true,
      get: function disposed() {
        return getDisposableStackInternalState(this).state === DISPOSED;
      }
    });
    defineBuiltIn(DisposableStackPrototype, DISPOSE, DisposableStackPrototype.dispose, {
      name: 'dispose'
    });
    defineBuiltIn(DisposableStackPrototype, TO_STRING_TAG, DISPOSABLE_STACK, {
      nonWritable: true
    });
    $({
      global: true,
      constructor: true
    }, {
      DisposableStack: $DisposableStack
    });
    return es_disposableStack_constructor;
  }
  var es_escape = {};
  var hasRequiredEs_escape;
  function requireEs_escape() {
    if (hasRequiredEs_escape) return es_escape;
    hasRequiredEs_escape = 1;
    var $ = require_export();
    var uncurryThis = requireFunctionUncurryThis();
    var toString = requireToString();
    var charAt = uncurryThis(''.charAt);
    var charCodeAt = uncurryThis(''.charCodeAt);
    var exec = uncurryThis(/./.exec);
    var numberToString = uncurryThis(1.1.toString);
    var toUpperCase = uncurryThis(''.toUpperCase);
    var raw = /[\w*+\-./@]/;
    var hex = function hex(code, length) {
      var result = numberToString(code, 16);
      while (result.length < length) result = '0' + result;
      return result;
    };
    $({
      global: true
    }, {
      escape: function escape(string) {
        var str = toString(string);
        var result = '';
        var length = str.length;
        var index = 0;
        var chr, code;
        while (index < length) {
          chr = charAt(str, index++);
          if (exec(raw, chr)) {
            result += chr;
          } else {
            code = charCodeAt(chr, 0);
            if (code < 256) {
              result += '%' + hex(code, 2);
            } else {
              result += '%u' + toUpperCase(hex(code, 4));
            }
          }
        }
        return result;
      }
    });
    return es_escape;
  }
  var es_function_bind = {};
  var functionBind;
  var hasRequiredFunctionBind;
  function requireFunctionBind() {
    if (hasRequiredFunctionBind) return functionBind;
    hasRequiredFunctionBind = 1;
    var uncurryThis = requireFunctionUncurryThis();
    var aCallable = requireACallable();
    var isObject = requireIsObject();
    var hasOwn = requireHasOwnProperty();
    var arraySlice = requireArraySlice();
    var NATIVE_BIND = requireFunctionBindNative();
    var $Function = Function;
    var concat = uncurryThis([].concat);
    var join = uncurryThis([].join);
    var factories = {};
    var construct = function construct(C, argsLength, args) {
      if (!hasOwn(factories, argsLength)) {
        var list = [];
        var i = 0;
        for (; i < argsLength; i++) list[i] = 'a[' + i + ']';
        factories[argsLength] = $Function('C,a', 'return new C(' + join(list, ',') + ')');
      }
      return factories[argsLength](C, args);
    };
    functionBind = NATIVE_BIND ? $Function.bind : function bind(that) {
      var F = aCallable(this);
      var Prototype = F.prototype;
      var partArgs = arraySlice(arguments, 1);
      var boundFunction = function bound() {
        var args = concat(partArgs, arraySlice(arguments));
        return this instanceof boundFunction ? construct(F, args.length, args) : F.apply(that, args);
      };
      if (isObject(Prototype)) boundFunction.prototype = Prototype;
      return boundFunction;
    };
    return functionBind;
  }
  var hasRequiredEs_function_bind;
  function requireEs_function_bind() {
    if (hasRequiredEs_function_bind) return es_function_bind;
    hasRequiredEs_function_bind = 1;
    var $ = require_export();
    var bind = requireFunctionBind();
    $({
      target: 'Function',
      proto: true,
      forced: Function.bind !== bind
    }, {
      bind: bind
    });
    return es_function_bind;
  }
  var es_function_hasInstance = {};
  var hasRequiredEs_function_hasInstance;
  function requireEs_function_hasInstance() {
    if (hasRequiredEs_function_hasInstance) return es_function_hasInstance;
    hasRequiredEs_function_hasInstance = 1;
    var isCallable = requireIsCallable();
    var isObject = requireIsObject();
    var definePropertyModule = requireObjectDefineProperty();
    var isPrototypeOf = requireObjectIsPrototypeOf();
    var wellKnownSymbol = requireWellKnownSymbol();
    var makeBuiltIn = requireMakeBuiltIn();
    var HAS_INSTANCE = wellKnownSymbol('hasInstance');
    var FunctionPrototype = Function.prototype;
    if (!(HAS_INSTANCE in FunctionPrototype)) {
      definePropertyModule.f(FunctionPrototype, HAS_INSTANCE, {
        value: makeBuiltIn(function (O) {
          if (!isCallable(this) || !isObject(O)) return false;
          var P = this.prototype;
          return isObject(P) ? isPrototypeOf(P, O) : O instanceof this;
        }, HAS_INSTANCE)
      });
    }
    return es_function_hasInstance;
  }
  var es_function_name = {};
  var hasRequiredEs_function_name;
  function requireEs_function_name() {
    if (hasRequiredEs_function_name) return es_function_name;
    hasRequiredEs_function_name = 1;
    var DESCRIPTORS = requireDescriptors();
    var FUNCTION_NAME_EXISTS = requireFunctionName().EXISTS;
    var uncurryThis = requireFunctionUncurryThis();
    var defineBuiltInAccessor = requireDefineBuiltInAccessor();
    var FunctionPrototype = Function.prototype;
    var functionToString = uncurryThis(FunctionPrototype.toString);
    var nameRE = /function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/;
    var regExpExec = uncurryThis(nameRE.exec);
    var NAME = 'name';
    if (DESCRIPTORS && !FUNCTION_NAME_EXISTS) {
      defineBuiltInAccessor(FunctionPrototype, NAME, {
        configurable: true,
        get: function get() {
          try {
            return regExpExec(nameRE, functionToString(this))[1];
          } catch (error) {
            return '';
          }
        }
      });
    }
    return es_function_name;
  }
  var es_globalThis = {};
  var hasRequiredEs_globalThis;
  function requireEs_globalThis() {
    if (hasRequiredEs_globalThis) return es_globalThis;
    hasRequiredEs_globalThis = 1;
    var $ = require_export();
    var globalThis = requireGlobalThis();
    $({
      global: true,
      forced: globalThis.globalThis !== globalThis
    }, {
      globalThis: globalThis
    });
    return es_globalThis;
  }
  var es_iterator_constructor = {};
  var hasRequiredEs_iterator_constructor;
  function requireEs_iterator_constructor() {
    if (hasRequiredEs_iterator_constructor) return es_iterator_constructor;
    hasRequiredEs_iterator_constructor = 1;
    var $ = require_export();
    var globalThis = requireGlobalThis();
    var anInstance = requireAnInstance();
    var anObject = requireAnObject();
    var isCallable = requireIsCallable();
    var getPrototypeOf = requireObjectGetPrototypeOf();
    var defineBuiltInAccessor = requireDefineBuiltInAccessor();
    var createProperty = requireCreateProperty();
    var fails = requireFails();
    var hasOwn = requireHasOwnProperty();
    var wellKnownSymbol = requireWellKnownSymbol();
    var IteratorPrototype = requireIteratorsCore().IteratorPrototype;
    var DESCRIPTORS = requireDescriptors();
    var IS_PURE = requireIsPure();
    var CONSTRUCTOR = 'constructor';
    var ITERATOR = 'Iterator';
    var TO_STRING_TAG = wellKnownSymbol('toStringTag');
    var $TypeError = TypeError;
    var NativeIterator = globalThis[ITERATOR];
    var FORCED = IS_PURE || !isCallable(NativeIterator) || NativeIterator.prototype !== IteratorPrototype || !fails(function () {
      NativeIterator({});
    });
    var IteratorConstructor = function Iterator() {
      anInstance(this, IteratorPrototype);
      if (getPrototypeOf(this) === IteratorPrototype) throw new $TypeError('Abstract class Iterator not directly constructable');
    };
    var defineIteratorPrototypeAccessor = function defineIteratorPrototypeAccessor(key, value) {
      if (DESCRIPTORS) {
        defineBuiltInAccessor(IteratorPrototype, key, {
          configurable: true,
          get: function get() {
            return value;
          },
          set: function set(replacement) {
            anObject(this);
            if (this === IteratorPrototype) throw new $TypeError("You can't redefine this property");
            if (hasOwn(this, key)) this[key] = replacement;else createProperty(this, key, replacement);
          }
        });
      } else IteratorPrototype[key] = value;
    };
    if (!hasOwn(IteratorPrototype, TO_STRING_TAG)) defineIteratorPrototypeAccessor(TO_STRING_TAG, ITERATOR);
    if (FORCED || !hasOwn(IteratorPrototype, CONSTRUCTOR) || IteratorPrototype[CONSTRUCTOR] === Object) {
      defineIteratorPrototypeAccessor(CONSTRUCTOR, IteratorConstructor);
    }
    IteratorConstructor.prototype = IteratorPrototype;
    $({
      global: true,
      constructor: true,
      forced: FORCED
    }, {
      Iterator: IteratorConstructor
    });
    return es_iterator_constructor;
  }
  var es_iterator_dispose = {};
  var hasRequiredEs_iterator_dispose;
  function requireEs_iterator_dispose() {
    if (hasRequiredEs_iterator_dispose) return es_iterator_dispose;
    hasRequiredEs_iterator_dispose = 1;
    var call = requireFunctionCall();
    var defineBuiltIn = requireDefineBuiltIn();
    var getMethod = requireGetMethod();
    var hasOwn = requireHasOwnProperty();
    var wellKnownSymbol = requireWellKnownSymbol();
    var IteratorPrototype = requireIteratorsCore().IteratorPrototype;
    var DISPOSE = wellKnownSymbol('dispose');
    if (!hasOwn(IteratorPrototype, DISPOSE)) {
      defineBuiltIn(IteratorPrototype, DISPOSE, function () {
        var $return = getMethod(this, 'return');
        if ($return) call($return, this);
      });
    }
    return es_iterator_dispose;
  }
  var es_iterator_drop = {};
  var getIteratorDirect;
  var hasRequiredGetIteratorDirect;
  function requireGetIteratorDirect() {
    if (hasRequiredGetIteratorDirect) return getIteratorDirect;
    hasRequiredGetIteratorDirect = 1;
    getIteratorDirect = function getIteratorDirect(obj) {
      return {
        iterator: obj,
        next: obj.next,
        done: false
      };
    };
    return getIteratorDirect;
  }
  var notANan;
  var hasRequiredNotANan;
  function requireNotANan() {
    if (hasRequiredNotANan) return notANan;
    hasRequiredNotANan = 1;
    var $RangeError = RangeError;
    notANan = function notANan(it) {
      if (it === it) return it;
      throw new $RangeError('NaN is not allowed');
    };
    return notANan;
  }
  var toPositiveInteger;
  var hasRequiredToPositiveInteger;
  function requireToPositiveInteger() {
    if (hasRequiredToPositiveInteger) return toPositiveInteger;
    hasRequiredToPositiveInteger = 1;
    var toIntegerOrInfinity = requireToIntegerOrInfinity();
    var $RangeError = RangeError;
    toPositiveInteger = function toPositiveInteger(it) {
      var result = toIntegerOrInfinity(it);
      if (result < 0) throw new $RangeError("The argument can't be less than 0");
      return result;
    };
    return toPositiveInteger;
  }
  var iteratorCloseAll;
  var hasRequiredIteratorCloseAll;
  function requireIteratorCloseAll() {
    if (hasRequiredIteratorCloseAll) return iteratorCloseAll;
    hasRequiredIteratorCloseAll = 1;
    var iteratorClose = requireIteratorClose();
    iteratorCloseAll = function iteratorCloseAll(iters, kind, value) {
      for (var i = iters.length - 1; i >= 0; i--) {
        if (iters[i] === undefined) continue;
        try {
          value = iteratorClose(iters[i].iterator, kind, value);
        } catch (error) {
          kind = 'throw';
          value = error;
        }
      }
      if (kind === 'throw') throw value;
      return value;
    };
    return iteratorCloseAll;
  }
  var iteratorCreateProxy;
  var hasRequiredIteratorCreateProxy;
  function requireIteratorCreateProxy() {
    if (hasRequiredIteratorCreateProxy) return iteratorCreateProxy;
    hasRequiredIteratorCreateProxy = 1;
    var call = requireFunctionCall();
    var create = requireObjectCreate();
    var createNonEnumerableProperty = requireCreateNonEnumerableProperty();
    var defineBuiltIns = requireDefineBuiltIns();
    var wellKnownSymbol = requireWellKnownSymbol();
    var InternalStateModule = requireInternalState();
    var getMethod = requireGetMethod();
    var IteratorPrototype = requireIteratorsCore().IteratorPrototype;
    var createIterResultObject = requireCreateIterResultObject();
    var iteratorClose = requireIteratorClose();
    var iteratorCloseAll = requireIteratorCloseAll();
    var TO_STRING_TAG = wellKnownSymbol('toStringTag');
    var ITERATOR_HELPER = 'IteratorHelper';
    var WRAP_FOR_VALID_ITERATOR = 'WrapForValidIterator';
    var NORMAL = 'normal';
    var THROW = 'throw';
    var setInternalState = InternalStateModule.set;
    var createIteratorProxyPrototype = function createIteratorProxyPrototype(IS_ITERATOR) {
      var getInternalState = InternalStateModule.getterFor(IS_ITERATOR ? WRAP_FOR_VALID_ITERATOR : ITERATOR_HELPER);
      return defineBuiltIns(create(IteratorPrototype), {
        next: function next() {
          var state = getInternalState(this);
          if (IS_ITERATOR) return state.nextHandler();
          if (state.done) return createIterResultObject(undefined, true);
          try {
            var result = state.nextHandler();
            return state.returnHandlerResult ? result : createIterResultObject(result, state.done);
          } catch (error) {
            state.done = true;
            throw error;
          }
        },
        'return': function _return() {
          var state = getInternalState(this);
          var iterator = state.iterator;
          state.done = true;
          if (IS_ITERATOR) {
            var returnMethod = getMethod(iterator, 'return');
            return returnMethod ? call(returnMethod, iterator) : createIterResultObject(undefined, true);
          }
          if (state.inner) try {
            iteratorClose(state.inner.iterator, NORMAL);
          } catch (error) {
            return iteratorClose(iterator, THROW, error);
          }
          if (state.openIters) try {
            iteratorCloseAll(state.openIters, NORMAL);
          } catch (error) {
            return iteratorClose(iterator, THROW, error);
          }
          if (iterator) iteratorClose(iterator, NORMAL);
          return createIterResultObject(undefined, true);
        }
      });
    };
    var WrapForValidIteratorPrototype = createIteratorProxyPrototype(true);
    var IteratorHelperPrototype = createIteratorProxyPrototype(false);
    createNonEnumerableProperty(IteratorHelperPrototype, TO_STRING_TAG, 'Iterator Helper');
    iteratorCreateProxy = function iteratorCreateProxy(nextHandler, IS_ITERATOR, RETURN_HANDLER_RESULT) {
      var IteratorProxy = function Iterator(record, state) {
        if (state) {
          state.iterator = record.iterator;
          state.next = record.next;
        } else state = record;
        state.type = IS_ITERATOR ? WRAP_FOR_VALID_ITERATOR : ITERATOR_HELPER;
        state.returnHandlerResult = !!RETURN_HANDLER_RESULT;
        state.nextHandler = nextHandler;
        state.counter = 0;
        state.done = false;
        setInternalState(this, state);
      };
      IteratorProxy.prototype = IS_ITERATOR ? WrapForValidIteratorPrototype : IteratorHelperPrototype;
      return IteratorProxy;
    };
    return iteratorCreateProxy;
  }
  var iteratorHelperThrowsOnInvalidIterator;
  var hasRequiredIteratorHelperThrowsOnInvalidIterator;
  function requireIteratorHelperThrowsOnInvalidIterator() {
    if (hasRequiredIteratorHelperThrowsOnInvalidIterator) return iteratorHelperThrowsOnInvalidIterator;
    hasRequiredIteratorHelperThrowsOnInvalidIterator = 1;
    iteratorHelperThrowsOnInvalidIterator = function iteratorHelperThrowsOnInvalidIterator(methodName, argument) {
      var method = typeof Iterator == 'function' && Iterator.prototype[methodName];
      if (method) try {
        method.call({
          next: null
        }, argument).next();
      } catch (error) {
        return true;
      }
    };
    return iteratorHelperThrowsOnInvalidIterator;
  }
  var iteratorHelperWithoutClosingOnEarlyError;
  var hasRequiredIteratorHelperWithoutClosingOnEarlyError;
  function requireIteratorHelperWithoutClosingOnEarlyError() {
    if (hasRequiredIteratorHelperWithoutClosingOnEarlyError) return iteratorHelperWithoutClosingOnEarlyError;
    hasRequiredIteratorHelperWithoutClosingOnEarlyError = 1;
    var globalThis = requireGlobalThis();
    iteratorHelperWithoutClosingOnEarlyError = function iteratorHelperWithoutClosingOnEarlyError(METHOD_NAME, ExpectedError) {
      var Iterator = globalThis.Iterator;
      var IteratorPrototype = Iterator && Iterator.prototype;
      var method = IteratorPrototype && IteratorPrototype[METHOD_NAME];
      var CLOSED = false;
      if (method) try {
        method.call({
          next: function next() {
            return {
              done: true
            };
          },
          'return': function _return() {
            CLOSED = true;
          }
        }, -1);
      } catch (error) {
        if (!(error instanceof ExpectedError)) CLOSED = false;
      }
      if (!CLOSED) return method;
    };
    return iteratorHelperWithoutClosingOnEarlyError;
  }
  var hasRequiredEs_iterator_drop;
  function requireEs_iterator_drop() {
    if (hasRequiredEs_iterator_drop) return es_iterator_drop;
    hasRequiredEs_iterator_drop = 1;
    var $ = require_export();
    var call = requireFunctionCall();
    var anObject = requireAnObject();
    var getIteratorDirect = requireGetIteratorDirect();
    var notANaN = requireNotANan();
    var toPositiveInteger = requireToPositiveInteger();
    var iteratorClose = requireIteratorClose();
    var createIteratorProxy = requireIteratorCreateProxy();
    var iteratorHelperThrowsOnInvalidIterator = requireIteratorHelperThrowsOnInvalidIterator();
    var iteratorHelperWithoutClosingOnEarlyError = requireIteratorHelperWithoutClosingOnEarlyError();
    var IS_PURE = requireIsPure();
    var DROP_WITHOUT_THROWING_ON_INVALID_ITERATOR = !IS_PURE && !iteratorHelperThrowsOnInvalidIterator('drop', 0);
    var dropWithoutClosingOnEarlyError = !IS_PURE && !DROP_WITHOUT_THROWING_ON_INVALID_ITERATOR && iteratorHelperWithoutClosingOnEarlyError('drop', RangeError);
    var FORCED = IS_PURE || DROP_WITHOUT_THROWING_ON_INVALID_ITERATOR || dropWithoutClosingOnEarlyError;
    var IteratorProxy = createIteratorProxy(function () {
      var iterator = this.iterator;
      var next = this.next;
      var result, done;
      while (this.remaining) {
        this.remaining--;
        result = anObject(call(next, iterator));
        done = this.done = !!result.done;
        if (done) return;
      }
      result = anObject(call(next, iterator));
      done = this.done = !!result.done;
      if (!done) return result.value;
    });
    $({
      target: 'Iterator',
      proto: true,
      real: true,
      forced: FORCED
    }, {
      drop: function drop(limit) {
        anObject(this);
        var remaining;
        try {
          remaining = toPositiveInteger(notANaN(+limit));
        } catch (error) {
          iteratorClose(this, 'throw', error);
        }
        if (dropWithoutClosingOnEarlyError) return call(dropWithoutClosingOnEarlyError, this, remaining);
        return new IteratorProxy(getIteratorDirect(this), {
          remaining: remaining
        });
      }
    });
    return es_iterator_drop;
  }
  var es_iterator_every = {};
  var hasRequiredEs_iterator_every;
  function requireEs_iterator_every() {
    if (hasRequiredEs_iterator_every) return es_iterator_every;
    hasRequiredEs_iterator_every = 1;
    var $ = require_export();
    var call = requireFunctionCall();
    var iterate = requireIterate();
    var aCallable = requireACallable();
    var anObject = requireAnObject();
    var getIteratorDirect = requireGetIteratorDirect();
    var iteratorClose = requireIteratorClose();
    var iteratorHelperWithoutClosingOnEarlyError = requireIteratorHelperWithoutClosingOnEarlyError();
    var everyWithoutClosingOnEarlyError = iteratorHelperWithoutClosingOnEarlyError('every', TypeError);
    $({
      target: 'Iterator',
      proto: true,
      real: true,
      forced: everyWithoutClosingOnEarlyError
    }, {
      every: function every(predicate) {
        anObject(this);
        try {
          aCallable(predicate);
        } catch (error) {
          iteratorClose(this, 'throw', error);
        }
        if (everyWithoutClosingOnEarlyError) return call(everyWithoutClosingOnEarlyError, this, predicate);
        var record = getIteratorDirect(this);
        var counter = 0;
        return !iterate(record, function (value, stop) {
          if (!predicate(value, counter++)) return stop();
        }, {
          IS_RECORD: true,
          INTERRUPTED: true
        }).stopped;
      }
    });
    return es_iterator_every;
  }
  var es_iterator_filter = {};
  var hasRequiredEs_iterator_filter;
  function requireEs_iterator_filter() {
    if (hasRequiredEs_iterator_filter) return es_iterator_filter;
    hasRequiredEs_iterator_filter = 1;
    var $ = require_export();
    var call = requireFunctionCall();
    var aCallable = requireACallable();
    var anObject = requireAnObject();
    var getIteratorDirect = requireGetIteratorDirect();
    var createIteratorProxy = requireIteratorCreateProxy();
    var callWithSafeIterationClosing = requireCallWithSafeIterationClosing();
    var IS_PURE = requireIsPure();
    var iteratorClose = requireIteratorClose();
    var iteratorHelperThrowsOnInvalidIterator = requireIteratorHelperThrowsOnInvalidIterator();
    var iteratorHelperWithoutClosingOnEarlyError = requireIteratorHelperWithoutClosingOnEarlyError();
    var FILTER_WITHOUT_THROWING_ON_INVALID_ITERATOR = !IS_PURE && !iteratorHelperThrowsOnInvalidIterator('filter', function () {});
    var filterWithoutClosingOnEarlyError = !IS_PURE && !FILTER_WITHOUT_THROWING_ON_INVALID_ITERATOR && iteratorHelperWithoutClosingOnEarlyError('filter', TypeError);
    var FORCED = IS_PURE || FILTER_WITHOUT_THROWING_ON_INVALID_ITERATOR || filterWithoutClosingOnEarlyError;
    var IteratorProxy = createIteratorProxy(function () {
      var iterator = this.iterator;
      var predicate = this.predicate;
      var next = this.next;
      var result, done, value;
      while (true) {
        result = anObject(call(next, iterator));
        done = this.done = !!result.done;
        if (done) return;
        value = result.value;
        if (callWithSafeIterationClosing(iterator, predicate, [value, this.counter++], true)) return value;
      }
    });
    $({
      target: 'Iterator',
      proto: true,
      real: true,
      forced: FORCED
    }, {
      filter: function filter(predicate) {
        anObject(this);
        try {
          aCallable(predicate);
        } catch (error) {
          iteratorClose(this, 'throw', error);
        }
        if (filterWithoutClosingOnEarlyError) return call(filterWithoutClosingOnEarlyError, this, predicate);
        return new IteratorProxy(getIteratorDirect(this), {
          predicate: predicate
        });
      }
    });
    return es_iterator_filter;
  }
  var es_iterator_find = {};
  var hasRequiredEs_iterator_find;
  function requireEs_iterator_find() {
    if (hasRequiredEs_iterator_find) return es_iterator_find;
    hasRequiredEs_iterator_find = 1;
    var $ = require_export();
    var call = requireFunctionCall();
    var iterate = requireIterate();
    var aCallable = requireACallable();
    var anObject = requireAnObject();
    var getIteratorDirect = requireGetIteratorDirect();
    var iteratorClose = requireIteratorClose();
    var iteratorHelperWithoutClosingOnEarlyError = requireIteratorHelperWithoutClosingOnEarlyError();
    var findWithoutClosingOnEarlyError = iteratorHelperWithoutClosingOnEarlyError('find', TypeError);
    $({
      target: 'Iterator',
      proto: true,
      real: true,
      forced: findWithoutClosingOnEarlyError
    }, {
      find: function find(predicate) {
        anObject(this);
        try {
          aCallable(predicate);
        } catch (error) {
          iteratorClose(this, 'throw', error);
        }
        if (findWithoutClosingOnEarlyError) return call(findWithoutClosingOnEarlyError, this, predicate);
        var record = getIteratorDirect(this);
        var counter = 0;
        return iterate(record, function (value, stop) {
          if (predicate(value, counter++)) return stop(value);
        }, {
          IS_RECORD: true,
          INTERRUPTED: true
        }).result;
      }
    });
    return es_iterator_find;
  }
  var es_iterator_flatMap = {};
  var getIteratorFlattenable;
  var hasRequiredGetIteratorFlattenable;
  function requireGetIteratorFlattenable() {
    if (hasRequiredGetIteratorFlattenable) return getIteratorFlattenable;
    hasRequiredGetIteratorFlattenable = 1;
    var call = requireFunctionCall();
    var anObject = requireAnObject();
    var getIteratorDirect = requireGetIteratorDirect();
    var getIteratorMethod = requireGetIteratorMethod();
    getIteratorFlattenable = function getIteratorFlattenable(obj, stringHandling) {
      if (!stringHandling || typeof obj !== 'string') anObject(obj);
      var method = getIteratorMethod(obj);
      return getIteratorDirect(anObject(method !== undefined ? call(method, obj) : obj));
    };
    return getIteratorFlattenable;
  }
  var hasRequiredEs_iterator_flatMap;
  function requireEs_iterator_flatMap() {
    if (hasRequiredEs_iterator_flatMap) return es_iterator_flatMap;
    hasRequiredEs_iterator_flatMap = 1;
    var $ = require_export();
    var call = requireFunctionCall();
    var aCallable = requireACallable();
    var anObject = requireAnObject();
    var getIteratorDirect = requireGetIteratorDirect();
    var getIteratorFlattenable = requireGetIteratorFlattenable();
    var createIteratorProxy = requireIteratorCreateProxy();
    var iteratorClose = requireIteratorClose();
    var IS_PURE = requireIsPure();
    var iteratorHelperThrowsOnInvalidIterator = requireIteratorHelperThrowsOnInvalidIterator();
    var iteratorHelperWithoutClosingOnEarlyError = requireIteratorHelperWithoutClosingOnEarlyError();
    var FLAT_MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR = !IS_PURE && !iteratorHelperThrowsOnInvalidIterator('flatMap', function () {});
    var flatMapWithoutClosingOnEarlyError = !IS_PURE && !FLAT_MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR && iteratorHelperWithoutClosingOnEarlyError('flatMap', TypeError);
    var FORCED = IS_PURE || FLAT_MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR || flatMapWithoutClosingOnEarlyError;
    var IteratorProxy = createIteratorProxy(function () {
      var iterator = this.iterator;
      var mapper = this.mapper;
      var result, inner;
      while (true) {
        if (inner = this.inner) try {
          result = anObject(call(inner.next, inner.iterator));
          if (!result.done) return result.value;
          this.inner = null;
        } catch (error) {
          iteratorClose(iterator, 'throw', error);
        }
        result = anObject(call(this.next, iterator));
        if (this.done = !!result.done) return;
        try {
          this.inner = getIteratorFlattenable(mapper(result.value, this.counter++), false);
        } catch (error) {
          iteratorClose(iterator, 'throw', error);
        }
      }
    });
    $({
      target: 'Iterator',
      proto: true,
      real: true,
      forced: FORCED
    }, {
      flatMap: function flatMap(mapper) {
        anObject(this);
        try {
          aCallable(mapper);
        } catch (error) {
          iteratorClose(this, 'throw', error);
        }
        if (flatMapWithoutClosingOnEarlyError) return call(flatMapWithoutClosingOnEarlyError, this, mapper);
        return new IteratorProxy(getIteratorDirect(this), {
          mapper: mapper,
          inner: null
        });
      }
    });
    return es_iterator_flatMap;
  }
  var es_iterator_forEach = {};
  var hasRequiredEs_iterator_forEach;
  function requireEs_iterator_forEach() {
    if (hasRequiredEs_iterator_forEach) return es_iterator_forEach;
    hasRequiredEs_iterator_forEach = 1;
    var $ = require_export();
    var call = requireFunctionCall();
    var iterate = requireIterate();
    var aCallable = requireACallable();
    var anObject = requireAnObject();
    var getIteratorDirect = requireGetIteratorDirect();
    var iteratorClose = requireIteratorClose();
    var iteratorHelperWithoutClosingOnEarlyError = requireIteratorHelperWithoutClosingOnEarlyError();
    var forEachWithoutClosingOnEarlyError = iteratorHelperWithoutClosingOnEarlyError('forEach', TypeError);
    $({
      target: 'Iterator',
      proto: true,
      real: true,
      forced: forEachWithoutClosingOnEarlyError
    }, {
      forEach: function forEach(fn) {
        anObject(this);
        try {
          aCallable(fn);
        } catch (error) {
          iteratorClose(this, 'throw', error);
        }
        if (forEachWithoutClosingOnEarlyError) return call(forEachWithoutClosingOnEarlyError, this, fn);
        var record = getIteratorDirect(this);
        var counter = 0;
        iterate(record, function (value) {
          fn(value, counter++);
        }, {
          IS_RECORD: true
        });
      }
    });
    return es_iterator_forEach;
  }
  var es_iterator_from = {};
  var hasRequiredEs_iterator_from;
  function requireEs_iterator_from() {
    if (hasRequiredEs_iterator_from) return es_iterator_from;
    hasRequiredEs_iterator_from = 1;
    var $ = require_export();
    var call = requireFunctionCall();
    var toObject = requireToObject();
    var isPrototypeOf = requireObjectIsPrototypeOf();
    var IteratorPrototype = requireIteratorsCore().IteratorPrototype;
    var createIteratorProxy = requireIteratorCreateProxy();
    var getIteratorFlattenable = requireGetIteratorFlattenable();
    var IS_PURE = requireIsPure();
    var FORCED = IS_PURE || function () {
      try {
        Iterator.from({
          'return': null
        })['return']();
      } catch (error) {
        return true;
      }
    }();
    var IteratorProxy = createIteratorProxy(function () {
      return call(this.next, this.iterator);
    }, true);
    $({
      target: 'Iterator',
      stat: true,
      forced: FORCED
    }, {
      from: function from(O) {
        var iteratorRecord = getIteratorFlattenable(typeof O == 'string' ? toObject(O) : O, true);
        return isPrototypeOf(IteratorPrototype, iteratorRecord.iterator) ? iteratorRecord.iterator : new IteratorProxy(iteratorRecord);
      }
    });
    return es_iterator_from;
  }
  var es_iterator_map = {};
  var hasRequiredEs_iterator_map;
  function requireEs_iterator_map() {
    if (hasRequiredEs_iterator_map) return es_iterator_map;
    hasRequiredEs_iterator_map = 1;
    var $ = require_export();
    var call = requireFunctionCall();
    var aCallable = requireACallable();
    var anObject = requireAnObject();
    var getIteratorDirect = requireGetIteratorDirect();
    var createIteratorProxy = requireIteratorCreateProxy();
    var callWithSafeIterationClosing = requireCallWithSafeIterationClosing();
    var iteratorClose = requireIteratorClose();
    var iteratorHelperThrowsOnInvalidIterator = requireIteratorHelperThrowsOnInvalidIterator();
    var iteratorHelperWithoutClosingOnEarlyError = requireIteratorHelperWithoutClosingOnEarlyError();
    var IS_PURE = requireIsPure();
    var MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR = !IS_PURE && !iteratorHelperThrowsOnInvalidIterator('map', function () {});
    var mapWithoutClosingOnEarlyError = !IS_PURE && !MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR && iteratorHelperWithoutClosingOnEarlyError('map', TypeError);
    var FORCED = IS_PURE || MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR || mapWithoutClosingOnEarlyError;
    var IteratorProxy = createIteratorProxy(function () {
      var iterator = this.iterator;
      var result = anObject(call(this.next, iterator));
      var done = this.done = !!result.done;
      if (!done) return callWithSafeIterationClosing(iterator, this.mapper, [result.value, this.counter++], true);
    });
    $({
      target: 'Iterator',
      proto: true,
      real: true,
      forced: FORCED
    }, {
      map: function map(mapper) {
        anObject(this);
        try {
          aCallable(mapper);
        } catch (error) {
          iteratorClose(this, 'throw', error);
        }
        if (mapWithoutClosingOnEarlyError) return call(mapWithoutClosingOnEarlyError, this, mapper);
        return new IteratorProxy(getIteratorDirect(this), {
          mapper: mapper
        });
      }
    });
    return es_iterator_map;
  }
  var es_iterator_reduce = {};
  var hasRequiredEs_iterator_reduce;
  function requireEs_iterator_reduce() {
    if (hasRequiredEs_iterator_reduce) return es_iterator_reduce;
    hasRequiredEs_iterator_reduce = 1;
    var $ = require_export();
    var iterate = requireIterate();
    var aCallable = requireACallable();
    var anObject = requireAnObject();
    var getIteratorDirect = requireGetIteratorDirect();
    var iteratorClose = requireIteratorClose();
    var iteratorHelperWithoutClosingOnEarlyError = requireIteratorHelperWithoutClosingOnEarlyError();
    var apply = requireFunctionApply();
    var fails = requireFails();
    var $TypeError = TypeError;
    var FAILS_ON_INITIAL_UNDEFINED = fails(function () {
      [].keys().reduce(function () {}, undefined);
    });
    var reduceWithoutClosingOnEarlyError = !FAILS_ON_INITIAL_UNDEFINED && iteratorHelperWithoutClosingOnEarlyError('reduce', $TypeError);
    $({
      target: 'Iterator',
      proto: true,
      real: true,
      forced: FAILS_ON_INITIAL_UNDEFINED || reduceWithoutClosingOnEarlyError
    }, {
      reduce: function reduce(reducer) {
        anObject(this);
        try {
          aCallable(reducer);
        } catch (error) {
          iteratorClose(this, 'throw', error);
        }
        var noInitial = arguments.length < 2;
        var accumulator = noInitial ? undefined : arguments[1];
        if (reduceWithoutClosingOnEarlyError) {
          return apply(reduceWithoutClosingOnEarlyError, this, noInitial ? [reducer] : [reducer, accumulator]);
        }
        var record = getIteratorDirect(this);
        var counter = 0;
        iterate(record, function (value) {
          if (noInitial) {
            noInitial = false;
            accumulator = value;
          } else {
            accumulator = reducer(accumulator, value, counter);
          }
          counter++;
        }, {
          IS_RECORD: true
        });
        if (noInitial) throw new $TypeError('Reduce of empty iterator with no initial value');
        return accumulator;
      }
    });
    return es_iterator_reduce;
  }
  var es_iterator_some = {};
  var hasRequiredEs_iterator_some;
  function requireEs_iterator_some() {
    if (hasRequiredEs_iterator_some) return es_iterator_some;
    hasRequiredEs_iterator_some = 1;
    var $ = require_export();
    var call = requireFunctionCall();
    var iterate = requireIterate();
    var aCallable = requireACallable();
    var anObject = requireAnObject();
    var getIteratorDirect = requireGetIteratorDirect();
    var iteratorClose = requireIteratorClose();
    var iteratorHelperWithoutClosingOnEarlyError = requireIteratorHelperWithoutClosingOnEarlyError();
    var someWithoutClosingOnEarlyError = iteratorHelperWithoutClosingOnEarlyError('some', TypeError);
    $({
      target: 'Iterator',
      proto: true,
      real: true,
      forced: someWithoutClosingOnEarlyError
    }, {
      some: function some(predicate) {
        anObject(this);
        try {
          aCallable(predicate);
        } catch (error) {
          iteratorClose(this, 'throw', error);
        }
        if (someWithoutClosingOnEarlyError) return call(someWithoutClosingOnEarlyError, this, predicate);
        var record = getIteratorDirect(this);
        var counter = 0;
        return iterate(record, function (value, stop) {
          if (predicate(value, counter++)) return stop();
        }, {
          IS_RECORD: true,
          INTERRUPTED: true
        }).stopped;
      }
    });
    return es_iterator_some;
  }
  var es_iterator_take = {};
  var hasRequiredEs_iterator_take;
  function requireEs_iterator_take() {
    if (hasRequiredEs_iterator_take) return es_iterator_take;
    hasRequiredEs_iterator_take = 1;
    var $ = require_export();
    var call = requireFunctionCall();
    var anObject = requireAnObject();
    var getIteratorDirect = requireGetIteratorDirect();
    var notANaN = requireNotANan();
    var toPositiveInteger = requireToPositiveInteger();
    var createIteratorProxy = requireIteratorCreateProxy();
    var iteratorClose = requireIteratorClose();
    var iteratorHelperWithoutClosingOnEarlyError = requireIteratorHelperWithoutClosingOnEarlyError();
    var IS_PURE = requireIsPure();
    var takeWithoutClosingOnEarlyError = !IS_PURE && iteratorHelperWithoutClosingOnEarlyError('take', RangeError);
    var IteratorProxy = createIteratorProxy(function () {
      var iterator = this.iterator;
      if (!this.remaining--) {
        this.done = true;
        return iteratorClose(iterator, 'normal', undefined);
      }
      var result = anObject(call(this.next, iterator));
      var done = this.done = !!result.done;
      if (!done) return result.value;
    });
    $({
      target: 'Iterator',
      proto: true,
      real: true,
      forced: IS_PURE || takeWithoutClosingOnEarlyError
    }, {
      take: function take(limit) {
        anObject(this);
        var remaining;
        try {
          remaining = toPositiveInteger(notANaN(+limit));
        } catch (error) {
          iteratorClose(this, 'throw', error);
        }
        if (takeWithoutClosingOnEarlyError) return call(takeWithoutClosingOnEarlyError, this, remaining);
        return new IteratorProxy(getIteratorDirect(this), {
          remaining: remaining
        });
      }
    });
    return es_iterator_take;
  }
  var es_iterator_toArray = {};
  var hasRequiredEs_iterator_toArray;
  function requireEs_iterator_toArray() {
    if (hasRequiredEs_iterator_toArray) return es_iterator_toArray;
    hasRequiredEs_iterator_toArray = 1;
    var $ = require_export();
    var anObject = requireAnObject();
    var iterate = requireIterate();
    var getIteratorDirect = requireGetIteratorDirect();
    var push = [].push;
    $({
      target: 'Iterator',
      proto: true,
      real: true
    }, {
      toArray: function toArray() {
        var result = [];
        iterate(getIteratorDirect(anObject(this)), push, {
          that: result,
          IS_RECORD: true
        });
        return result;
      }
    });
    return es_iterator_toArray;
  }
  var es_json_toStringTag = {};
  var hasRequiredEs_json_toStringTag;
  function requireEs_json_toStringTag() {
    if (hasRequiredEs_json_toStringTag) return es_json_toStringTag;
    hasRequiredEs_json_toStringTag = 1;
    var globalThis = requireGlobalThis();
    var setToStringTag = requireSetToStringTag();
    setToStringTag(globalThis.JSON, 'JSON', true);
    return es_json_toStringTag;
  }
  var es_map = {};
  var es_map_constructor = {};
  var internalMetadata = {
    exports: {}
  };
  var arrayBufferNonExtensible;
  var hasRequiredArrayBufferNonExtensible;
  function requireArrayBufferNonExtensible() {
    if (hasRequiredArrayBufferNonExtensible) return arrayBufferNonExtensible;
    hasRequiredArrayBufferNonExtensible = 1;
    var fails = requireFails();
    arrayBufferNonExtensible = fails(function () {
      if (typeof ArrayBuffer == 'function') {
        var buffer = new ArrayBuffer(8);
        if (Object.isExtensible(buffer)) Object.defineProperty(buffer, 'a', {
          value: 8
        });
      }
    });
    return arrayBufferNonExtensible;
  }
  var objectIsExtensible;
  var hasRequiredObjectIsExtensible;
  function requireObjectIsExtensible() {
    if (hasRequiredObjectIsExtensible) return objectIsExtensible;
    hasRequiredObjectIsExtensible = 1;
    var fails = requireFails();
    var isObject = requireIsObject();
    var classof = requireClassofRaw();
    var ARRAY_BUFFER_NON_EXTENSIBLE = requireArrayBufferNonExtensible();
    var $isExtensible = Object.isExtensible;
    var FAILS_ON_PRIMITIVES = fails(function () {});
    objectIsExtensible = FAILS_ON_PRIMITIVES || ARRAY_BUFFER_NON_EXTENSIBLE ? function isExtensible(it) {
      if (!isObject(it)) return false;
      if (ARRAY_BUFFER_NON_EXTENSIBLE && classof(it) === 'ArrayBuffer') return false;
      return $isExtensible ? $isExtensible(it) : true;
    } : $isExtensible;
    return objectIsExtensible;
  }
  var freezing;
  var hasRequiredFreezing;
  function requireFreezing() {
    if (hasRequiredFreezing) return freezing;
    hasRequiredFreezing = 1;
    var fails = requireFails();
    freezing = !fails(function () {
      return Object.isExtensible(Object.preventExtensions({}));
    });
    return freezing;
  }
  var hasRequiredInternalMetadata;
  function requireInternalMetadata() {
    if (hasRequiredInternalMetadata) return internalMetadata.exports;
    hasRequiredInternalMetadata = 1;
    var $ = require_export();
    var uncurryThis = requireFunctionUncurryThis();
    var hiddenKeys = requireHiddenKeys();
    var isObject = requireIsObject();
    var hasOwn = requireHasOwnProperty();
    var defineProperty = requireObjectDefineProperty().f;
    var getOwnPropertyNamesModule = requireObjectGetOwnPropertyNames();
    var getOwnPropertyNamesExternalModule = requireObjectGetOwnPropertyNamesExternal();
    var isExtensible = requireObjectIsExtensible();
    var uid = requireUid();
    var FREEZING = requireFreezing();
    var REQUIRED = false;
    var METADATA = uid('meta');
    var id = 0;
    var setMetadata = function setMetadata(it) {
      defineProperty(it, METADATA, {
        value: {
          objectID: 'O' + id++,
          weakData: {}
        }
      });
    };
    var fastKey = function fastKey(it, create) {
      if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
      if (!hasOwn(it, METADATA)) {
        if (!isExtensible(it)) return 'F';
        if (!create) return 'E';
        setMetadata(it);
      }
      return it[METADATA].objectID;
    };
    var getWeakData = function getWeakData(it, create) {
      if (!hasOwn(it, METADATA)) {
        if (!isExtensible(it)) return true;
        if (!create) return false;
        setMetadata(it);
      }
      return it[METADATA].weakData;
    };
    var onFreeze = function onFreeze(it) {
      if (FREEZING && REQUIRED && isExtensible(it) && !hasOwn(it, METADATA)) setMetadata(it);
      return it;
    };
    var enable = function enable() {
      meta.enable = function () {};
      REQUIRED = true;
      var getOwnPropertyNames = getOwnPropertyNamesModule.f;
      var splice = uncurryThis([].splice);
      var test = {};
      test[METADATA] = 1;
      if (getOwnPropertyNames(test).length) {
        getOwnPropertyNamesModule.f = function (it) {
          var result = getOwnPropertyNames(it);
          for (var i = 0, length = result.length; i < length; i++) {
            if (result[i] === METADATA) {
              splice(result, i, 1);
              break;
            }
          }
          return result;
        };
        $({
          target: 'Object',
          stat: true,
          forced: true
        }, {
          getOwnPropertyNames: getOwnPropertyNamesExternalModule.f
        });
      }
    };
    var meta = internalMetadata.exports = {
      enable: enable,
      fastKey: fastKey,
      getWeakData: getWeakData,
      onFreeze: onFreeze
    };
    hiddenKeys[METADATA] = true;
    return internalMetadata.exports;
  }
  var collection;
  var hasRequiredCollection;
  function requireCollection() {
    if (hasRequiredCollection) return collection;
    hasRequiredCollection = 1;
    var $ = require_export();
    var globalThis = requireGlobalThis();
    var uncurryThis = requireFunctionUncurryThis();
    var isForced = requireIsForced();
    var defineBuiltIn = requireDefineBuiltIn();
    var InternalMetadataModule = requireInternalMetadata();
    var iterate = requireIterate();
    var anInstance = requireAnInstance();
    var isCallable = requireIsCallable();
    var isNullOrUndefined = requireIsNullOrUndefined();
    var isObject = requireIsObject();
    var fails = requireFails();
    var checkCorrectnessOfIteration = requireCheckCorrectnessOfIteration();
    var setToStringTag = requireSetToStringTag();
    var inheritIfRequired = requireInheritIfRequired();
    collection = function collection(CONSTRUCTOR_NAME, wrapper, common) {
      var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
      var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
      var ADDER = IS_MAP ? 'set' : 'add';
      var NativeConstructor = globalThis[CONSTRUCTOR_NAME];
      var NativePrototype = NativeConstructor && NativeConstructor.prototype;
      var Constructor = NativeConstructor;
      var exported = {};
      var fixMethod = function fixMethod(KEY) {
        var uncurriedNativeMethod = uncurryThis(NativePrototype[KEY]);
        defineBuiltIn(NativePrototype, KEY, KEY === 'add' ? function add(value) {
          uncurriedNativeMethod(this, value === 0 ? 0 : value);
          return this;
        } : KEY === 'delete' ? function (key) {
          return IS_WEAK && !isObject(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
        } : KEY === 'get' ? function get(key) {
          return IS_WEAK && !isObject(key) ? undefined : uncurriedNativeMethod(this, key === 0 ? 0 : key);
        } : KEY === 'has' ? function has(key) {
          return IS_WEAK && !isObject(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
        } : function set(key, value) {
          uncurriedNativeMethod(this, key === 0 ? 0 : key, value);
          return this;
        });
      };
      var REPLACE = isForced(CONSTRUCTOR_NAME, !isCallable(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails(function () {
        new NativeConstructor().entries().next();
      })));
      if (REPLACE) {
        Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
        InternalMetadataModule.enable();
      } else if (isForced(CONSTRUCTOR_NAME, true)) {
        var instance = new Constructor();
        var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) !== instance;
        var THROWS_ON_PRIMITIVES = fails(function () {
          instance.has(1);
        });
        var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) {
          new NativeConstructor(iterable);
        });
        var BUGGY_ZERO = !IS_WEAK && fails(function () {
          var $instance = new NativeConstructor();
          var index = 5;
          while (index--) $instance[ADDER](index, index);
          return !$instance.has(-0);
        });
        if (!ACCEPT_ITERABLES) {
          Constructor = wrapper(function (dummy, iterable) {
            anInstance(dummy, NativePrototype);
            var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
            if (!isNullOrUndefined(iterable)) iterate(iterable, that[ADDER], {
              that: that,
              AS_ENTRIES: IS_MAP
            });
            return that;
          });
          Constructor.prototype = NativePrototype;
          NativePrototype.constructor = Constructor;
        }
        if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
          fixMethod('delete');
          fixMethod('has');
          IS_MAP && fixMethod('get');
        }
        if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
        if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
      }
      exported[CONSTRUCTOR_NAME] = Constructor;
      $({
        global: true,
        constructor: true,
        forced: Constructor !== NativeConstructor
      }, exported);
      setToStringTag(Constructor, CONSTRUCTOR_NAME);
      if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);
      return Constructor;
    };
    return collection;
  }
  var collectionStrong;
  var hasRequiredCollectionStrong;
  function requireCollectionStrong() {
    if (hasRequiredCollectionStrong) return collectionStrong;
    hasRequiredCollectionStrong = 1;
    var create = requireObjectCreate();
    var defineBuiltInAccessor = requireDefineBuiltInAccessor();
    var defineBuiltIns = requireDefineBuiltIns();
    var bind = requireFunctionBindContext();
    var anInstance = requireAnInstance();
    var isNullOrUndefined = requireIsNullOrUndefined();
    var iterate = requireIterate();
    var defineIterator = requireIteratorDefine();
    var createIterResultObject = requireCreateIterResultObject();
    var setSpecies = requireSetSpecies();
    var DESCRIPTORS = requireDescriptors();
    var fastKey = requireInternalMetadata().fastKey;
    var InternalStateModule = requireInternalState();
    var setInternalState = InternalStateModule.set;
    var internalStateGetterFor = InternalStateModule.getterFor;
    collectionStrong = {
      getConstructor: function getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
        var Constructor = wrapper(function (that, iterable) {
          anInstance(that, Prototype);
          setInternalState(that, {
            type: CONSTRUCTOR_NAME,
            index: create(null),
            first: null,
            last: null,
            size: 0
          });
          if (!DESCRIPTORS) that.size = 0;
          if (!isNullOrUndefined(iterable)) iterate(iterable, that[ADDER], {
            that: that,
            AS_ENTRIES: IS_MAP
          });
        });
        var Prototype = Constructor.prototype;
        var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);
        var define = function define(that, key, value) {
          var state = getInternalState(that);
          var entry = getEntry(that, key);
          var previous, index;
          if (entry) {
            entry.value = value;
          } else {
            state.last = entry = {
              index: index = fastKey(key, true),
              key: key,
              value: value,
              previous: previous = state.last,
              next: null,
              removed: false
            };
            if (!state.first) state.first = entry;
            if (previous) previous.next = entry;
            if (DESCRIPTORS) state.size++;else that.size++;
            if (index !== 'F') state.index[index] = entry;
          }
          return that;
        };
        var getEntry = function getEntry(that, key) {
          var state = getInternalState(that);
          var index = fastKey(key);
          var entry;
          if (index !== 'F') return state.index[index];
          for (entry = state.first; entry; entry = entry.next) {
            if (entry.key === key) return entry;
          }
        };
        defineBuiltIns(Prototype, {
          clear: function clear() {
            var that = this;
            var state = getInternalState(that);
            var entry = state.first;
            while (entry) {
              entry.removed = true;
              if (entry.previous) entry.previous = entry.previous.next = null;
              entry = entry.next;
            }
            state.first = state.last = null;
            state.index = create(null);
            if (DESCRIPTORS) state.size = 0;else that.size = 0;
          },
          'delete': function _delete(key) {
            var that = this;
            var state = getInternalState(that);
            var entry = getEntry(that, key);
            if (entry) {
              var next = entry.next;
              var prev = entry.previous;
              delete state.index[entry.index];
              entry.removed = true;
              if (prev) prev.next = next;
              if (next) next.previous = prev;
              if (state.first === entry) state.first = next;
              if (state.last === entry) state.last = prev;
              if (DESCRIPTORS) state.size--;else that.size--;
            }
            return !!entry;
          },
          forEach: function forEach(callbackfn) {
            var state = getInternalState(this);
            var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
            var entry;
            while (entry = entry ? entry.next : state.first) {
              boundFunction(entry.value, entry.key, this);
              while (entry && entry.removed) entry = entry.previous;
            }
          },
          has: function has(key) {
            return !!getEntry(this, key);
          }
        });
        defineBuiltIns(Prototype, IS_MAP ? {
          get: function get(key) {
            var entry = getEntry(this, key);
            return entry && entry.value;
          },
          set: function set(key, value) {
            return define(this, key === 0 ? 0 : key, value);
          }
        } : {
          add: function add(value) {
            return define(this, value = value === 0 ? 0 : value, value);
          }
        });
        if (DESCRIPTORS) defineBuiltInAccessor(Prototype, 'size', {
          configurable: true,
          get: function get() {
            return getInternalState(this).size;
          }
        });
        return Constructor;
      },
      setStrong: function setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP) {
        var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
        var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
        var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
        defineIterator(Constructor, CONSTRUCTOR_NAME, function (iterated, kind) {
          setInternalState(this, {
            type: ITERATOR_NAME,
            target: iterated,
            state: getInternalCollectionState(iterated),
            kind: kind,
            last: null
          });
        }, function () {
          var state = getInternalIteratorState(this);
          var kind = state.kind;
          var entry = state.last;
          while (entry && entry.removed) entry = entry.previous;
          if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
            state.target = null;
            return createIterResultObject(undefined, true);
          }
          if (kind === 'keys') return createIterResultObject(entry.key, false);
          if (kind === 'values') return createIterResultObject(entry.value, false);
          return createIterResultObject([entry.key, entry.value], false);
        }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);
        setSpecies(CONSTRUCTOR_NAME);
      }
    };
    return collectionStrong;
  }
  var hasRequiredEs_map_constructor;
  function requireEs_map_constructor() {
    if (hasRequiredEs_map_constructor) return es_map_constructor;
    hasRequiredEs_map_constructor = 1;
    var collection = requireCollection();
    var collectionStrong = requireCollectionStrong();
    collection('Map', function (init) {
      return function Map() {
        return init(this, arguments.length ? arguments[0] : undefined);
      };
    }, collectionStrong);
    return es_map_constructor;
  }
  var hasRequiredEs_map;
  function requireEs_map() {
    if (hasRequiredEs_map) return es_map;
    hasRequiredEs_map = 1;
    requireEs_map_constructor();
    return es_map;
  }
  var es_map_groupBy = {};
  var mapHelpers;
  var hasRequiredMapHelpers;
  function requireMapHelpers() {
    if (hasRequiredMapHelpers) return mapHelpers;
    hasRequiredMapHelpers = 1;
    var uncurryThis = requireFunctionUncurryThis();
    var MapPrototype = Map.prototype;
    mapHelpers = {
      Map: Map,
      set: uncurryThis(MapPrototype.set),
      get: uncurryThis(MapPrototype.get),
      has: uncurryThis(MapPrototype.has),
      remove: uncurryThis(MapPrototype['delete']),
      proto: MapPrototype
    };
    return mapHelpers;
  }
  var hasRequiredEs_map_groupBy;
  function requireEs_map_groupBy() {
    if (hasRequiredEs_map_groupBy) return es_map_groupBy;
    hasRequiredEs_map_groupBy = 1;
    var $ = require_export();
    var uncurryThis = requireFunctionUncurryThis();
    var aCallable = requireACallable();
    var requireObjectCoercible = requireRequireObjectCoercible();
    var iterate = requireIterate();
    var MapHelpers = requireMapHelpers();
    var IS_PURE = requireIsPure();
    var fails = requireFails();
    var Map = MapHelpers.Map;
    var has = MapHelpers.has;
    var get = MapHelpers.get;
    var set = MapHelpers.set;
    var push = uncurryThis([].push);
    var DOES_NOT_WORK_WITH_PRIMITIVES = IS_PURE || fails(function () {
      return Map.groupBy('ab', function (it) {
        return it;
      }).get('a').length !== 1;
    });
    $({
      target: 'Map',
      stat: true,
      forced: IS_PURE || DOES_NOT_WORK_WITH_PRIMITIVES
    }, {
      groupBy: function groupBy(items, callbackfn) {
        requireObjectCoercible(items);
        aCallable(callbackfn);
        var map = new Map();
        var k = 0;
        iterate(items, function (value) {
          var key = callbackfn(value, k++);
          if (!has(map, key)) set(map, key, [value]);else push(get(map, key), value);
        });
        return map;
      }
    });
    return es_map_groupBy;
  }
  var es_math_acosh = {};
  var mathLog1p;
  var hasRequiredMathLog1p;
  function requireMathLog1p() {
    if (hasRequiredMathLog1p) return mathLog1p;
    hasRequiredMathLog1p = 1;
    var log = Math.log;
    mathLog1p = Math.log1p || function log1p(x) {
      var n = +x;
      return n > -1e-8 && n < 1e-8 ? n - n * n / 2 : log(1 + n);
    };
    return mathLog1p;
  }
  var hasRequiredEs_math_acosh;
  function requireEs_math_acosh() {
    if (hasRequiredEs_math_acosh) return es_math_acosh;
    hasRequiredEs_math_acosh = 1;
    var $ = require_export();
    var log1p = requireMathLog1p();
    var $acosh = Math.acosh;
    var log = Math.log;
    var sqrt = Math.sqrt;
    var LN2 = Math.LN2;
    var FORCED = !$acosh || Math.floor($acosh(Number.MAX_VALUE)) !== 710 || $acosh(Infinity) !== Infinity;
    $({
      target: 'Math',
      stat: true,
      forced: FORCED
    }, {
      acosh: function acosh(x) {
        var n = +x;
        return n < 1 ? NaN : n > 94906265.62425156 ? log(n) + LN2 : log1p(n - 1 + sqrt(n - 1) * sqrt(n + 1));
      }
    });
    return es_math_acosh;
  }
  var es_math_asinh = {};
  var hasRequiredEs_math_asinh;
  function requireEs_math_asinh() {
    if (hasRequiredEs_math_asinh) return es_math_asinh;
    hasRequiredEs_math_asinh = 1;
    var $ = require_export();
    var $asinh = Math.asinh;
    var log = Math.log;
    var sqrt = Math.sqrt;
    function asinh(x) {
      var n = +x;
      return !isFinite(n) || n === 0 ? n : n < 0 ? -asinh(-n) : log(n + sqrt(n * n + 1));
    }
    var FORCED = !($asinh && 1 / $asinh(0) > 0);
    $({
      target: 'Math',
      stat: true,
      forced: FORCED
    }, {
      asinh: asinh
    });
    return es_math_asinh;
  }
  var es_math_atanh = {};
  var hasRequiredEs_math_atanh;
  function requireEs_math_atanh() {
    if (hasRequiredEs_math_atanh) return es_math_atanh;
    hasRequiredEs_math_atanh = 1;
    var $ = require_export();
    var $atanh = Math.atanh;
    var log = Math.log;
    var FORCED = !($atanh && 1 / $atanh(-0) < 0);
    $({
      target: 'Math',
      stat: true,
      forced: FORCED
    }, {
      atanh: function atanh(x) {
        var n = +x;
        return n === 0 ? n : log((1 + n) / (1 - n)) / 2;
      }
    });
    return es_math_atanh;
  }
  var es_math_cbrt = {};
  var hasRequiredEs_math_cbrt;
  function requireEs_math_cbrt() {
    if (hasRequiredEs_math_cbrt) return es_math_cbrt;
    hasRequiredEs_math_cbrt = 1;
    var $ = require_export();
    var sign = requireMathSign();
    var abs = Math.abs;
    var pow = Math.pow;
    $({
      target: 'Math',
      stat: true
    }, {
      cbrt: function cbrt(x) {
        var n = +x;
        return sign(n) * pow(abs(n), 1 / 3);
      }
    });
    return es_math_cbrt;
  }
  var es_math_clz32 = {};
  var hasRequiredEs_math_clz32;
  function requireEs_math_clz32() {
    if (hasRequiredEs_math_clz32) return es_math_clz32;
    hasRequiredEs_math_clz32 = 1;
    var $ = require_export();
    var floor = Math.floor;
    var log = Math.log;
    var LOG2E = Math.LOG2E;
    $({
      target: 'Math',
      stat: true
    }, {
      clz32: function clz32(x) {
        var n = x >>> 0;
        return n ? 31 - floor(log(n + 0.5) * LOG2E) : 32;
      }
    });
    return es_math_clz32;
  }
  var es_math_cosh = {};
  var mathExpm1;
  var hasRequiredMathExpm1;
  function requireMathExpm1() {
    if (hasRequiredMathExpm1) return mathExpm1;
    hasRequiredMathExpm1 = 1;
    var $expm1 = Math.expm1;
    var exp = Math.exp;
    mathExpm1 = !$expm1 || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168 || $expm1(-2e-17) !== -2e-17 ? function expm1(x) {
      var n = +x;
      return n === 0 ? n : n > -1e-6 && n < 1e-6 ? n + n * n / 2 : exp(n) - 1;
    } : $expm1;
    return mathExpm1;
  }
  var hasRequiredEs_math_cosh;
  function requireEs_math_cosh() {
    if (hasRequiredEs_math_cosh) return es_math_cosh;
    hasRequiredEs_math_cosh = 1;
    var $ = require_export();
    var expm1 = requireMathExpm1();
    var $cosh = Math.cosh;
    var abs = Math.abs;
    var E = Math.E;
    var FORCED = !$cosh || $cosh(710) === Infinity;
    $({
      target: 'Math',
      stat: true,
      forced: FORCED
    }, {
      cosh: function cosh(x) {
        var t = expm1(abs(x) - 1) + 1;
        return (t + 1 / (t * E * E)) * (E / 2);
      }
    });
    return es_math_cosh;
  }
  var es_math_expm1 = {};
  var hasRequiredEs_math_expm1;
  function requireEs_math_expm1() {
    if (hasRequiredEs_math_expm1) return es_math_expm1;
    hasRequiredEs_math_expm1 = 1;
    var $ = require_export();
    var expm1 = requireMathExpm1();
    $({
      target: 'Math',
      stat: true,
      forced: expm1 !== Math.expm1
    }, {
      expm1: expm1
    });
    return es_math_expm1;
  }
  var es_math_fround = {};
  var hasRequiredEs_math_fround;
  function requireEs_math_fround() {
    if (hasRequiredEs_math_fround) return es_math_fround;
    hasRequiredEs_math_fround = 1;
    var $ = require_export();
    var fround = requireMathFround();
    $({
      target: 'Math',
      stat: true
    }, {
      fround: fround
    });
    return es_math_fround;
  }
  var es_math_f16round = {};
  var hasRequiredEs_math_f16round;
  function requireEs_math_f16round() {
    if (hasRequiredEs_math_f16round) return es_math_f16round;
    hasRequiredEs_math_f16round = 1;
    var $ = require_export();
    var floatRound = requireMathFloatRound();
    var FLOAT16_EPSILON = 0.0009765625;
    var FLOAT16_MAX_VALUE = 65504;
    var FLOAT16_MIN_VALUE = 6.103515625e-05;
    $({
      target: 'Math',
      stat: true
    }, {
      f16round: function f16round(x) {
        return floatRound(x, FLOAT16_EPSILON, FLOAT16_MAX_VALUE, FLOAT16_MIN_VALUE);
      }
    });
    return es_math_f16round;
  }
  var es_math_hypot = {};
  var hasRequiredEs_math_hypot;
  function requireEs_math_hypot() {
    if (hasRequiredEs_math_hypot) return es_math_hypot;
    hasRequiredEs_math_hypot = 1;
    var $ = require_export();
    var $hypot = Math.hypot;
    var abs = Math.abs;
    var sqrt = Math.sqrt;
    var FORCED = !!$hypot && $hypot(Infinity, NaN) !== Infinity;
    $({
      target: 'Math',
      stat: true,
      arity: 2,
      forced: FORCED
    }, {
      hypot: function hypot(value1, value2) {
        var sum = 0;
        var i = 0;
        var aLen = arguments.length;
        var larg = 0;
        var arg, div;
        while (i < aLen) {
          arg = abs(arguments[i++]);
          if (larg < arg) {
            div = larg / arg;
            sum = sum * div * div + 1;
            larg = arg;
          } else if (arg > 0) {
            div = arg / larg;
            sum += div * div;
          } else sum += arg;
        }
        return larg === Infinity ? Infinity : larg * sqrt(sum);
      }
    });
    return es_math_hypot;
  }
  var es_math_imul = {};
  var hasRequiredEs_math_imul;
  function requireEs_math_imul() {
    if (hasRequiredEs_math_imul) return es_math_imul;
    hasRequiredEs_math_imul = 1;
    var $ = require_export();
    var fails = requireFails();
    var $imul = Math.imul;
    var FORCED = fails(function () {
      return $imul(0xFFFFFFFF, 5) !== -5 || $imul.length !== 2;
    });
    $({
      target: 'Math',
      stat: true,
      forced: FORCED
    }, {
      imul: function imul(x, y) {
        var UINT16 = 0xFFFF;
        var xn = +x;
        var yn = +y;
        var xl = UINT16 & xn;
        var yl = UINT16 & yn;
        return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
      }
    });
    return es_math_imul;
  }
  var es_math_log10 = {};
  var mathLog10;
  var hasRequiredMathLog10;
  function requireMathLog10() {
    if (hasRequiredMathLog10) return mathLog10;
    hasRequiredMathLog10 = 1;
    var log = Math.log;
    var LOG10E = Math.LOG10E;
    mathLog10 = Math.log10 || function log10(x) {
      return log(x) * LOG10E;
    };
    return mathLog10;
  }
  var hasRequiredEs_math_log10;
  function requireEs_math_log10() {
    if (hasRequiredEs_math_log10) return es_math_log10;
    hasRequiredEs_math_log10 = 1;
    var $ = require_export();
    var log10 = requireMathLog10();
    $({
      target: 'Math',
      stat: true
    }, {
      log10: log10
    });
    return es_math_log10;
  }
  var es_math_log1p = {};
  var hasRequiredEs_math_log1p;
  function requireEs_math_log1p() {
    if (hasRequiredEs_math_log1p) return es_math_log1p;
    hasRequiredEs_math_log1p = 1;
    var $ = require_export();
    var log1p = requireMathLog1p();
    $({
      target: 'Math',
      stat: true
    }, {
      log1p: log1p
    });
    return es_math_log1p;
  }
  var es_math_log2 = {};
  var hasRequiredEs_math_log2;
  function requireEs_math_log2() {
    if (hasRequiredEs_math_log2) return es_math_log2;
    hasRequiredEs_math_log2 = 1;
    var $ = require_export();
    var log2 = requireMathLog2();
    $({
      target: 'Math',
      stat: true
    }, {
      log2: log2
    });
    return es_math_log2;
  }
  var es_math_sign = {};
  var hasRequiredEs_math_sign;
  function requireEs_math_sign() {
    if (hasRequiredEs_math_sign) return es_math_sign;
    hasRequiredEs_math_sign = 1;
    var $ = require_export();
    var sign = requireMathSign();
    $({
      target: 'Math',
      stat: true
    }, {
      sign: sign
    });
    return es_math_sign;
  }
  var es_math_sinh = {};
  var hasRequiredEs_math_sinh;
  function requireEs_math_sinh() {
    if (hasRequiredEs_math_sinh) return es_math_sinh;
    hasRequiredEs_math_sinh = 1;
    var $ = require_export();
    var fails = requireFails();
    var expm1 = requireMathExpm1();
    var abs = Math.abs;
    var exp = Math.exp;
    var E = Math.E;
    var FORCED = fails(function () {
      return Math.sinh(-2e-17) !== -2e-17;
    });
    $({
      target: 'Math',
      stat: true,
      forced: FORCED
    }, {
      sinh: function sinh(x) {
        var n = +x;
        return abs(n) < 1 ? (expm1(n) - expm1(-n)) / 2 : (exp(n - 1) - exp(-n - 1)) * (E / 2);
      }
    });
    return es_math_sinh;
  }
  var es_math_sumPrecise = {};
  var hasRequiredEs_math_sumPrecise;
  function requireEs_math_sumPrecise() {
    if (hasRequiredEs_math_sumPrecise) return es_math_sumPrecise;
    hasRequiredEs_math_sumPrecise = 1;
    var $ = require_export();
    var uncurryThis = requireFunctionUncurryThis();
    var iterate = requireIterate();
    var $RangeError = RangeError;
    var $TypeError = TypeError;
    var $Infinity = Infinity;
    var $NaN = NaN;
    var abs = Math.abs;
    var pow = Math.pow;
    var push = uncurryThis([].push);
    var POW_2_1023 = pow(2, 1023);
    var MAX_SAFE_INTEGER = pow(2, 53) - 1;
    var MAX_DOUBLE = Number.MAX_VALUE;
    var MAX_ULP = pow(2, 971);
    var NOT_A_NUMBER = {};
    var MINUS_INFINITY = {};
    var PLUS_INFINITY = {};
    var MINUS_ZERO = {};
    var FINITE = {};
    var twosum = function twosum(x, y) {
      var hi = x + y;
      var lo = y - (hi - x);
      return {
        hi: hi,
        lo: lo
      };
    };
    $({
      target: 'Math',
      stat: true
    }, {
      sumPrecise: function sumPrecise(items) {
        var numbers = [];
        var count = 0;
        var state = MINUS_ZERO;
        iterate(items, function (n) {
          if (++count >= MAX_SAFE_INTEGER) throw new $RangeError('Maximum allowed index exceeded');
          if (typeof n != 'number') throw new $TypeError('Value is not a number');
          if (state !== NOT_A_NUMBER) {
            if (n !== n) state = NOT_A_NUMBER;else if (n === $Infinity) state = state === MINUS_INFINITY ? NOT_A_NUMBER : PLUS_INFINITY;else if (n === -$Infinity) state = state === PLUS_INFINITY ? NOT_A_NUMBER : MINUS_INFINITY;else if ((n !== 0 || 1 / n === $Infinity) && (state === MINUS_ZERO || state === FINITE)) {
              state = FINITE;
              push(numbers, n);
            }
          }
        });
        switch (state) {
          case NOT_A_NUMBER:
            return $NaN;
          case MINUS_INFINITY:
            return -$Infinity;
          case PLUS_INFINITY:
            return $Infinity;
          case MINUS_ZERO:
            return -0;
        }
        var partials = [];
        var overflow = 0;
        var x, y, sum, hi, lo, tmp;
        for (var i = 0; i < numbers.length; i++) {
          x = numbers[i];
          var actuallyUsedPartials = 0;
          for (var j = 0; j < partials.length; j++) {
            y = partials[j];
            if (abs(x) < abs(y)) {
              tmp = x;
              x = y;
              y = tmp;
            }
            sum = twosum(x, y);
            hi = sum.hi;
            lo = sum.lo;
            if (abs(hi) === $Infinity) {
              var sign = hi === $Infinity ? 1 : -1;
              overflow += sign;
              x = x - sign * POW_2_1023 - sign * POW_2_1023;
              if (abs(x) < abs(y)) {
                tmp = x;
                x = y;
                y = tmp;
              }
              sum = twosum(x, y);
              hi = sum.hi;
              lo = sum.lo;
            }
            if (lo !== 0) partials[actuallyUsedPartials++] = lo;
            x = hi;
          }
          partials.length = actuallyUsedPartials;
          if (x !== 0) push(partials, x);
        }
        var n = partials.length - 1;
        hi = 0;
        lo = 0;
        if (overflow !== 0) {
          var next = n >= 0 ? partials[n] : 0;
          n--;
          if (abs(overflow) > 1 || overflow > 0 && next > 0 || overflow < 0 && next < 0) {
            return overflow > 0 ? $Infinity : -$Infinity;
          }
          sum = twosum(overflow * POW_2_1023, next / 2);
          hi = sum.hi;
          lo = sum.lo;
          lo *= 2;
          if (abs(2 * hi) === $Infinity) {
            if (hi > 0) {
              return hi === POW_2_1023 && lo === -(MAX_ULP / 2) && n >= 0 && partials[n] < 0 ? MAX_DOUBLE : $Infinity;
            }
            return hi === -POW_2_1023 && lo === MAX_ULP / 2 && n >= 0 && partials[n] > 0 ? -MAX_DOUBLE : -$Infinity;
          }
          if (lo !== 0) {
            partials[++n] = lo;
            lo = 0;
          }
          hi *= 2;
        }
        while (n >= 0) {
          sum = twosum(hi, partials[n--]);
          hi = sum.hi;
          lo = sum.lo;
          if (lo !== 0) break;
        }
        if (n >= 0 && (lo < 0 && partials[n] < 0 || lo > 0 && partials[n] > 0)) {
          y = lo * 2;
          x = hi + y;
          if (y === x - hi) hi = x;
        }
        return hi;
      }
    });
    return es_math_sumPrecise;
  }
  var es_math_tanh = {};
  var hasRequiredEs_math_tanh;
  function requireEs_math_tanh() {
    if (hasRequiredEs_math_tanh) return es_math_tanh;
    hasRequiredEs_math_tanh = 1;
    var $ = require_export();
    var expm1 = requireMathExpm1();
    var exp = Math.exp;
    $({
      target: 'Math',
      stat: true
    }, {
      tanh: function tanh(x) {
        var n = +x;
        var a = expm1(n);
        var b = expm1(-n);
        return a === Infinity ? 1 : b === Infinity ? -1 : (a - b) / (exp(n) + exp(-n));
      }
    });
    return es_math_tanh;
  }
  var es_math_toStringTag = {};
  var hasRequiredEs_math_toStringTag;
  function requireEs_math_toStringTag() {
    if (hasRequiredEs_math_toStringTag) return es_math_toStringTag;
    hasRequiredEs_math_toStringTag = 1;
    var setToStringTag = requireSetToStringTag();
    setToStringTag(Math, 'Math', true);
    return es_math_toStringTag;
  }
  var es_math_trunc = {};
  var hasRequiredEs_math_trunc;
  function requireEs_math_trunc() {
    if (hasRequiredEs_math_trunc) return es_math_trunc;
    hasRequiredEs_math_trunc = 1;
    var $ = require_export();
    var trunc = requireMathTrunc();
    $({
      target: 'Math',
      stat: true
    }, {
      trunc: trunc
    });
    return es_math_trunc;
  }
  var es_number_constructor = {};
  var thisNumberValue;
  var hasRequiredThisNumberValue;
  function requireThisNumberValue() {
    if (hasRequiredThisNumberValue) return thisNumberValue;
    hasRequiredThisNumberValue = 1;
    var uncurryThis = requireFunctionUncurryThis();
    thisNumberValue = uncurryThis(1.1.valueOf);
    return thisNumberValue;
  }
  var whitespaces;
  var hasRequiredWhitespaces;
  function requireWhitespaces() {
    if (hasRequiredWhitespaces) return whitespaces;
    hasRequiredWhitespaces = 1;
    whitespaces = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002' + '\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';
    return whitespaces;
  }
  var stringTrim;
  var hasRequiredStringTrim;
  function requireStringTrim() {
    if (hasRequiredStringTrim) return stringTrim;
    hasRequiredStringTrim = 1;
    var uncurryThis = requireFunctionUncurryThis();
    var requireObjectCoercible = requireRequireObjectCoercible();
    var toString = requireToString();
    var whitespaces = requireWhitespaces();
    var replace = uncurryThis(''.replace);
    var ltrim = RegExp('^[' + whitespaces + ']+');
    var rtrim = RegExp('(^|[^' + whitespaces + '])[' + whitespaces + ']+$');
    var createMethod = function createMethod(TYPE) {
      return function ($this) {
        var string = toString(requireObjectCoercible($this));
        if (TYPE & 1) string = replace(string, ltrim, '');
        if (TYPE & 2) string = replace(string, rtrim, '$1');
        return string;
      };
    };
    stringTrim = {
      start: createMethod(1),
      end: createMethod(2),
      trim: createMethod(3)
    };
    return stringTrim;
  }
  var hasRequiredEs_number_constructor;
  function requireEs_number_constructor() {
    if (hasRequiredEs_number_constructor) return es_number_constructor;
    hasRequiredEs_number_constructor = 1;
    var $ = require_export();
    var IS_PURE = requireIsPure();
    var DESCRIPTORS = requireDescriptors();
    var globalThis = requireGlobalThis();
    var path = requirePath();
    var uncurryThis = requireFunctionUncurryThis();
    var isForced = requireIsForced();
    var hasOwn = requireHasOwnProperty();
    var inheritIfRequired = requireInheritIfRequired();
    var isPrototypeOf = requireObjectIsPrototypeOf();
    var isSymbol = requireIsSymbol();
    var toPrimitive = requireToPrimitive();
    var fails = requireFails();
    var getOwnPropertyNames = requireObjectGetOwnPropertyNames().f;
    var getOwnPropertyDescriptor = requireObjectGetOwnPropertyDescriptor().f;
    var defineProperty = requireObjectDefineProperty().f;
    var thisNumberValue = requireThisNumberValue();
    var trim = requireStringTrim().trim;
    var NUMBER = 'Number';
    var NativeNumber = globalThis[NUMBER];
    var PureNumberNamespace = path[NUMBER];
    var NumberPrototype = NativeNumber.prototype;
    var TypeError = globalThis.TypeError;
    var stringSlice = uncurryThis(''.slice);
    var charCodeAt = uncurryThis(''.charCodeAt);
    var toNumeric = function toNumeric(value) {
      var primValue = toPrimitive(value, 'number');
      return typeof primValue == 'bigint' ? primValue : toNumber(primValue);
    };
    var toNumber = function toNumber(argument) {
      var it = toPrimitive(argument, 'number');
      var first, third, radix, maxCode, digits, length, index, code;
      if (isSymbol(it)) throw new TypeError('Cannot convert a Symbol value to a number');
      if (typeof it == 'string' && it.length > 2) {
        it = trim(it);
        first = charCodeAt(it, 0);
        if (first === 43 || first === 45) {
          third = charCodeAt(it, 2);
          if (third === 88 || third === 120) return NaN;
        } else if (first === 48) {
          switch (charCodeAt(it, 1)) {
            case 66:
            case 98:
              radix = 2;
              maxCode = 49;
              break;
            case 79:
            case 111:
              radix = 8;
              maxCode = 55;
              break;
            default:
              return +it;
          }
          digits = stringSlice(it, 2);
          length = digits.length;
          for (index = 0; index < length; index++) {
            code = charCodeAt(digits, index);
            if (code < 48 || code > maxCode) return NaN;
          }
          return parseInt(digits, radix);
        }
      }
      return +it;
    };
    var FORCED = isForced(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'));
    var calledWithNew = function calledWithNew(dummy) {
      return isPrototypeOf(NumberPrototype, dummy) && fails(function () {
        thisNumberValue(dummy);
      });
    };
    var NumberWrapper = function Number(value) {
      var n = arguments.length < 1 ? 0 : NativeNumber(toNumeric(value));
      return calledWithNew(this) ? inheritIfRequired(Object(n), this, NumberWrapper) : n;
    };
    NumberWrapper.prototype = NumberPrototype;
    if (FORCED && !IS_PURE) NumberPrototype.constructor = NumberWrapper;
    $({
      global: true,
      constructor: true,
      wrap: true,
      forced: FORCED
    }, {
      Number: NumberWrapper
    });
    var copyConstructorProperties = function copyConstructorProperties(target, source) {
      for (var keys = DESCRIPTORS ? getOwnPropertyNames(source) : ('MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' + 'EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,' + 'fromString,range').split(','), j = 0, key; keys.length > j; j++) {
        if (hasOwn(source, key = keys[j]) && !hasOwn(target, key)) {
          defineProperty(target, key, getOwnPropertyDescriptor(source, key));
        }
      }
    };
    if (IS_PURE && PureNumberNamespace) copyConstructorProperties(path[NUMBER], PureNumberNamespace);
    if (FORCED || IS_PURE) copyConstructorProperties(path[NUMBER], NativeNumber);
    return es_number_constructor;
  }
  var es_number_epsilon = {};
  var hasRequiredEs_number_epsilon;
  function requireEs_number_epsilon() {
    if (hasRequiredEs_number_epsilon) return es_number_epsilon;
    hasRequiredEs_number_epsilon = 1;
    var $ = require_export();
    $({
      target: 'Number',
      stat: true,
      nonConfigurable: true,
      nonWritable: true
    }, {
      EPSILON: Math.pow(2, -52)
    });
    return es_number_epsilon;
  }
  var es_number_isFinite = {};
  var numberIsFinite;
  var hasRequiredNumberIsFinite;
  function requireNumberIsFinite() {
    if (hasRequiredNumberIsFinite) return numberIsFinite;
    hasRequiredNumberIsFinite = 1;
    var globalThis = requireGlobalThis();
    var globalIsFinite = globalThis.isFinite;
    numberIsFinite = Number.isFinite || function isFinite(it) {
      return typeof it == 'number' && globalIsFinite(it);
    };
    return numberIsFinite;
  }
  var hasRequiredEs_number_isFinite;
  function requireEs_number_isFinite() {
    if (hasRequiredEs_number_isFinite) return es_number_isFinite;
    hasRequiredEs_number_isFinite = 1;
    var $ = require_export();
    var numberIsFinite = requireNumberIsFinite();
    $({
      target: 'Number',
      stat: true
    }, {
      isFinite: numberIsFinite
    });
    return es_number_isFinite;
  }
  var es_number_isInteger = {};
  var isIntegralNumber;
  var hasRequiredIsIntegralNumber;
  function requireIsIntegralNumber() {
    if (hasRequiredIsIntegralNumber) return isIntegralNumber;
    hasRequiredIsIntegralNumber = 1;
    var isObject = requireIsObject();
    var floor = Math.floor;
    isIntegralNumber = Number.isInteger || function isInteger(it) {
      return !isObject(it) && isFinite(it) && floor(it) === it;
    };
    return isIntegralNumber;
  }
  var hasRequiredEs_number_isInteger;
  function requireEs_number_isInteger() {
    if (hasRequiredEs_number_isInteger) return es_number_isInteger;
    hasRequiredEs_number_isInteger = 1;
    var $ = require_export();
    var isIntegralNumber = requireIsIntegralNumber();
    $({
      target: 'Number',
      stat: true
    }, {
      isInteger: isIntegralNumber
    });
    return es_number_isInteger;
  }
  var es_number_isNan = {};
  var hasRequiredEs_number_isNan;
  function requireEs_number_isNan() {
    if (hasRequiredEs_number_isNan) return es_number_isNan;
    hasRequiredEs_number_isNan = 1;
    var $ = require_export();
    $({
      target: 'Number',
      stat: true
    }, {
      isNaN: function isNaN(number) {
        return number !== number;
      }
    });
    return es_number_isNan;
  }
  var es_number_isSafeInteger = {};
  var hasRequiredEs_number_isSafeInteger;
  function requireEs_number_isSafeInteger() {
    if (hasRequiredEs_number_isSafeInteger) return es_number_isSafeInteger;
    hasRequiredEs_number_isSafeInteger = 1;
    var $ = require_export();
    var isIntegralNumber = requireIsIntegralNumber();
    var abs = Math.abs;
    $({
      target: 'Number',
      stat: true
    }, {
      isSafeInteger: function isSafeInteger(number) {
        return isIntegralNumber(number) && abs(number) <= 0x1FFFFFFFFFFFFF;
      }
    });
    return es_number_isSafeInteger;
  }
  var es_number_maxSafeInteger = {};
  var hasRequiredEs_number_maxSafeInteger;
  function requireEs_number_maxSafeInteger() {
    if (hasRequiredEs_number_maxSafeInteger) return es_number_maxSafeInteger;
    hasRequiredEs_number_maxSafeInteger = 1;
    var $ = require_export();
    $({
      target: 'Number',
      stat: true,
      nonConfigurable: true,
      nonWritable: true
    }, {
      MAX_SAFE_INTEGER: 0x1FFFFFFFFFFFFF
    });
    return es_number_maxSafeInteger;
  }
  var es_number_minSafeInteger = {};
  var hasRequiredEs_number_minSafeInteger;
  function requireEs_number_minSafeInteger() {
    if (hasRequiredEs_number_minSafeInteger) return es_number_minSafeInteger;
    hasRequiredEs_number_minSafeInteger = 1;
    var $ = require_export();
    $({
      target: 'Number',
      stat: true,
      nonConfigurable: true,
      nonWritable: true
    }, {
      MIN_SAFE_INTEGER: -9007199254740991
    });
    return es_number_minSafeInteger;
  }
  var es_number_parseFloat = {};
  var numberParseFloat;
  var hasRequiredNumberParseFloat;
  function requireNumberParseFloat() {
    if (hasRequiredNumberParseFloat) return numberParseFloat;
    hasRequiredNumberParseFloat = 1;
    var globalThis = requireGlobalThis();
    var fails = requireFails();
    var uncurryThis = requireFunctionUncurryThis();
    var toString = requireToString();
    var trim = requireStringTrim().trim;
    var whitespaces = requireWhitespaces();
    var charAt = uncurryThis(''.charAt);
    var $parseFloat = globalThis.parseFloat;
    var Symbol = globalThis.Symbol;
    var ITERATOR = Symbol && Symbol.iterator;
    var FORCED = 1 / $parseFloat(whitespaces + '-0') !== -Infinity || ITERATOR && !fails(function () {
      $parseFloat(Object(ITERATOR));
    });
    numberParseFloat = FORCED ? function parseFloat(string) {
      var trimmedString = trim(toString(string));
      var result = $parseFloat(trimmedString);
      return result === 0 && charAt(trimmedString, 0) === '-' ? -0 : result;
    } : $parseFloat;
    return numberParseFloat;
  }
  var hasRequiredEs_number_parseFloat;
  function requireEs_number_parseFloat() {
    if (hasRequiredEs_number_parseFloat) return es_number_parseFloat;
    hasRequiredEs_number_parseFloat = 1;
    var $ = require_export();
    var parseFloat = requireNumberParseFloat();
    $({
      target: 'Number',
      stat: true,
      forced: Number.parseFloat !== parseFloat
    }, {
      parseFloat: parseFloat
    });
    return es_number_parseFloat;
  }
  var es_number_parseInt = {};
  var numberParseInt;
  var hasRequiredNumberParseInt;
  function requireNumberParseInt() {
    if (hasRequiredNumberParseInt) return numberParseInt;
    hasRequiredNumberParseInt = 1;
    var globalThis = requireGlobalThis();
    var fails = requireFails();
    var uncurryThis = requireFunctionUncurryThis();
    var toString = requireToString();
    var trim = requireStringTrim().trim;
    var whitespaces = requireWhitespaces();
    var $parseInt = globalThis.parseInt;
    var Symbol = globalThis.Symbol;
    var ITERATOR = Symbol && Symbol.iterator;
    var hex = /^[+-]?0x/i;
    var exec = uncurryThis(hex.exec);
    var FORCED = $parseInt(whitespaces + '08') !== 8 || $parseInt(whitespaces + '0x16') !== 22 || ITERATOR && !fails(function () {
      $parseInt(Object(ITERATOR));
    });
    numberParseInt = FORCED ? function parseInt(string, radix) {
      var S = trim(toString(string));
      return $parseInt(S, radix >>> 0 || (exec(hex, S) ? 16 : 10));
    } : $parseInt;
    return numberParseInt;
  }
  var hasRequiredEs_number_parseInt;
  function requireEs_number_parseInt() {
    if (hasRequiredEs_number_parseInt) return es_number_parseInt;
    hasRequiredEs_number_parseInt = 1;
    var $ = require_export();
    var parseInt = requireNumberParseInt();
    $({
      target: 'Number',
      stat: true,
      forced: Number.parseInt !== parseInt
    }, {
      parseInt: parseInt
    });
    return es_number_parseInt;
  }
  var es_number_toExponential = {};
  var hasRequiredEs_number_toExponential;
  function requireEs_number_toExponential() {
    if (hasRequiredEs_number_toExponential) return es_number_toExponential;
    hasRequiredEs_number_toExponential = 1;
    var $ = require_export();
    var uncurryThis = requireFunctionUncurryThis();
    var toIntegerOrInfinity = requireToIntegerOrInfinity();
    var thisNumberValue = requireThisNumberValue();
    var $repeat = requireStringRepeat();
    var log10 = requireMathLog10();
    var fails = requireFails();
    var $RangeError = RangeError;
    var $String = String;
    var $isFinite = isFinite;
    var abs = Math.abs;
    var floor = Math.floor;
    var pow = Math.pow;
    var round = Math.round;
    var nativeToExponential = uncurryThis(1.1.toExponential);
    var repeat = uncurryThis($repeat);
    var stringSlice = uncurryThis(''.slice);
    var ROUNDS_PROPERLY = nativeToExponential(-69e-12, 4) === '-6.9000e-11' && nativeToExponential(1.255, 2) === '1.25e+0' && nativeToExponential(12345, 3) === '1.235e+4' && nativeToExponential(25, 0) === '3e+1';
    var throwsOnInfinityFraction = function throwsOnInfinityFraction() {
      return fails(function () {
        nativeToExponential(1, Infinity);
      }) && fails(function () {
        nativeToExponential(1, -Infinity);
      });
    };
    var properNonFiniteThisCheck = function properNonFiniteThisCheck() {
      return !fails(function () {
        nativeToExponential(Infinity, Infinity);
        nativeToExponential(NaN, Infinity);
      });
    };
    var FORCED = !ROUNDS_PROPERLY || !throwsOnInfinityFraction() || !properNonFiniteThisCheck();
    $({
      target: 'Number',
      proto: true,
      forced: FORCED
    }, {
      toExponential: function toExponential(fractionDigits) {
        var x = thisNumberValue(this);
        if (fractionDigits === undefined) return nativeToExponential(x);
        var f = toIntegerOrInfinity(fractionDigits);
        if (!$isFinite(x)) return String(x);
        if (f < 0 || f > 20) throw new $RangeError('Incorrect fraction digits');
        if (ROUNDS_PROPERLY) return nativeToExponential(x, f);
        var s = '';
        var m, e, c, d;
        if (x < 0) {
          s = '-';
          x = -x;
        }
        if (x === 0) {
          e = 0;
          m = repeat('0', f + 1);
        } else {
          var l = log10(x);
          e = floor(l);
          var w = pow(10, e - f);
          var n = round(x / w);
          if (2 * x >= (2 * n + 1) * w) {
            n += 1;
          }
          if (n >= pow(10, f + 1)) {
            n /= 10;
            e += 1;
          }
          m = $String(n);
        }
        if (f !== 0) {
          m = stringSlice(m, 0, 1) + '.' + stringSlice(m, 1);
        }
        if (e === 0) {
          c = '+';
          d = '0';
        } else {
          c = e > 0 ? '+' : '-';
          d = $String(abs(e));
        }
        m += 'e' + c + d;
        return s + m;
      }
    });
    return es_number_toExponential;
  }
  var es_number_toFixed = {};
  var hasRequiredEs_number_toFixed;
  function requireEs_number_toFixed() {
    if (hasRequiredEs_number_toFixed) return es_number_toFixed;
    hasRequiredEs_number_toFixed = 1;
    var $ = require_export();
    var uncurryThis = requireFunctionUncurryThis();
    var toIntegerOrInfinity = requireToIntegerOrInfinity();
    var thisNumberValue = requireThisNumberValue();
    var $repeat = requireStringRepeat();
    var fails = requireFails();
    var $RangeError = RangeError;
    var $String = String;
    var floor = Math.floor;
    var repeat = uncurryThis($repeat);
    var stringSlice = uncurryThis(''.slice);
    var nativeToFixed = uncurryThis(1.1.toFixed);
    var _pow = function pow(x, n, acc) {
      return n === 0 ? acc : n % 2 === 1 ? _pow(x, n - 1, acc * x) : _pow(x * x, n / 2, acc);
    };
    var log = function log(x) {
      var n = 0;
      var x2 = x;
      while (x2 >= 4096) {
        n += 12;
        x2 /= 4096;
      }
      while (x2 >= 2) {
        n += 1;
        x2 /= 2;
      }
      return n;
    };
    var multiply = function multiply(data, n, c) {
      var index = -1;
      var c2 = c;
      while (++index < 6) {
        c2 += n * data[index];
        data[index] = c2 % 1e7;
        c2 = floor(c2 / 1e7);
      }
    };
    var divide = function divide(data, n) {
      var index = 6;
      var c = 0;
      while (--index >= 0) {
        c += data[index];
        data[index] = floor(c / n);
        c = c % n * 1e7;
      }
    };
    var dataToString = function dataToString(data) {
      var index = 6;
      var s = '';
      while (--index >= 0) {
        if (s !== '' || index === 0 || data[index] !== 0) {
          var t = $String(data[index]);
          s = s === '' ? t : s + repeat('0', 7 - t.length) + t;
        }
      }
      return s;
    };
    var FORCED = fails(function () {
      return nativeToFixed(0.00008, 3) !== '0.000' || nativeToFixed(0.9, 0) !== '1' || nativeToFixed(1.255, 2) !== '1.25' || nativeToFixed(1000000000000000128.0, 0) !== '1000000000000000128';
    }) || !fails(function () {
      nativeToFixed({});
    });
    $({
      target: 'Number',
      proto: true,
      forced: FORCED
    }, {
      toFixed: function toFixed(fractionDigits) {
        var number = thisNumberValue(this);
        var fractDigits = toIntegerOrInfinity(fractionDigits);
        var data = [0, 0, 0, 0, 0, 0];
        var sign = '';
        var result = '0';
        var e, z, j, k;
        if (fractDigits < 0 || fractDigits > 20) throw new $RangeError('Incorrect fraction digits');
        if (number !== number) return 'NaN';
        if (number <= -1e21 || number >= 1e21) return $String(number);
        if (number < 0) {
          sign = '-';
          number = -number;
        }
        if (number > 1e-21) {
          e = log(number * _pow(2, 69, 1)) - 69;
          z = e < 0 ? number * _pow(2, -e, 1) : number / _pow(2, e, 1);
          z *= 0x10000000000000;
          e = 52 - e;
          if (e > 0) {
            multiply(data, 0, z);
            j = fractDigits;
            while (j >= 7) {
              multiply(data, 1e7, 0);
              j -= 7;
            }
            multiply(data, _pow(10, j, 1), 0);
            j = e - 1;
            while (j >= 23) {
              divide(data, 1 << 23);
              j -= 23;
            }
            divide(data, 1 << j);
            multiply(data, 1, 1);
            divide(data, 2);
            result = dataToString(data);
          } else {
            multiply(data, 0, z);
            multiply(data, 1 << -e, 0);
            result = dataToString(data) + repeat('0', fractDigits);
          }
        }
        if (fractDigits > 0) {
          k = result.length;
          result = sign + (k <= fractDigits ? '0.' + repeat('0', fractDigits - k) + result : stringSlice(result, 0, k - fractDigits) + '.' + stringSlice(result, k - fractDigits));
        } else {
          result = sign + result;
        }
        return result;
      }
    });
    return es_number_toFixed;
  }
  var es_number_toPrecision = {};
  var hasRequiredEs_number_toPrecision;
  function requireEs_number_toPrecision() {
    if (hasRequiredEs_number_toPrecision) return es_number_toPrecision;
    hasRequiredEs_number_toPrecision = 1;
    var $ = require_export();
    var uncurryThis = requireFunctionUncurryThis();
    var fails = requireFails();
    var thisNumberValue = requireThisNumberValue();
    var nativeToPrecision = uncurryThis(1.1.toPrecision);
    var FORCED = fails(function () {
      return nativeToPrecision(1, undefined) !== '1';
    }) || !fails(function () {
      nativeToPrecision({});
    });
    $({
      target: 'Number',
      proto: true,
      forced: FORCED
    }, {
      toPrecision: function toPrecision(precision) {
        return precision === undefined ? nativeToPrecision(thisNumberValue(this)) : nativeToPrecision(thisNumberValue(this), precision);
      }
    });
    return es_number_toPrecision;
  }
  var es_object_assign = {};
  var objectAssign;
  var hasRequiredObjectAssign;
  function requireObjectAssign() {
    if (hasRequiredObjectAssign) return objectAssign;
    hasRequiredObjectAssign = 1;
    var DESCRIPTORS = requireDescriptors();
    var uncurryThis = requireFunctionUncurryThis();
    var call = requireFunctionCall();
    var fails = requireFails();
    var objectKeys = requireObjectKeys();
    var getOwnPropertySymbolsModule = requireObjectGetOwnPropertySymbols();
    var propertyIsEnumerableModule = requireObjectPropertyIsEnumerable();
    var toObject = requireToObject();
    var IndexedObject = requireIndexedObject();
    var $assign = Object.assign;
    var defineProperty = Object.defineProperty;
    var concat = uncurryThis([].concat);
    objectAssign = !$assign || fails(function () {
      if (DESCRIPTORS && $assign({
        b: 1
      }, $assign(defineProperty({}, 'a', {
        enumerable: true,
        get: function get() {
          defineProperty(this, 'b', {
            value: 3,
            enumerable: false
          });
        }
      }), {
        b: 2
      })).b !== 1) return true;
      var A = {};
      var B = {};
      var symbol = Symbol('assign detection');
      var alphabet = 'abcdefghijklmnopqrst';
      A[symbol] = 7;
      alphabet.split('').forEach(function (chr) {
        B[chr] = chr;
      });
      return $assign({}, A)[symbol] !== 7 || objectKeys($assign({}, B)).join('') !== alphabet;
    }) ? function assign(target, source) {
      var T = toObject(target);
      var argumentsLength = arguments.length;
      var index = 1;
      var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
      var propertyIsEnumerable = propertyIsEnumerableModule.f;
      while (argumentsLength > index) {
        var S = IndexedObject(arguments[index++]);
        var keys = getOwnPropertySymbols ? concat(objectKeys(S), getOwnPropertySymbols(S)) : objectKeys(S);
        var length = keys.length;
        var j = 0;
        var key;
        while (length > j) {
          key = keys[j++];
          if (!DESCRIPTORS || call(propertyIsEnumerable, S, key)) T[key] = S[key];
        }
      }
      return T;
    } : $assign;
    return objectAssign;
  }
  var hasRequiredEs_object_assign;
  function requireEs_object_assign() {
    if (hasRequiredEs_object_assign) return es_object_assign;
    hasRequiredEs_object_assign = 1;
    var $ = require_export();
    var assign = requireObjectAssign();
    $({
      target: 'Object',
      stat: true,
      arity: 2,
      forced: Object.assign !== assign
    }, {
      assign: assign
    });
    return es_object_assign;
  }
  var es_object_create = {};
  var hasRequiredEs_object_create;
  function requireEs_object_create() {
    if (hasRequiredEs_object_create) return es_object_create;
    hasRequiredEs_object_create = 1;
    var $ = require_export();
    var DESCRIPTORS = requireDescriptors();
    var create = requireObjectCreate();
    $({
      target: 'Object',
      stat: true,
      sham: !DESCRIPTORS
    }, {
      create: create
    });
    return es_object_create;
  }
  var es_object_defineGetter = {};
  var objectPrototypeAccessorsForced;
  var hasRequiredObjectPrototypeAccessorsForced;
  function requireObjectPrototypeAccessorsForced() {
    if (hasRequiredObjectPrototypeAccessorsForced) return objectPrototypeAccessorsForced;
    hasRequiredObjectPrototypeAccessorsForced = 1;
    var IS_PURE = requireIsPure();
    var globalThis = requireGlobalThis();
    var fails = requireFails();
    var WEBKIT = requireEnvironmentWebkitVersion();
    objectPrototypeAccessorsForced = IS_PURE || !fails(function () {
      if (WEBKIT && WEBKIT < 535) return;
      var key = Math.random();
      __defineSetter__.call(null, key, function () {});
      delete globalThis[key];
    });
    return objectPrototypeAccessorsForced;
  }
  var hasRequiredEs_object_defineGetter;
  function requireEs_object_defineGetter() {
    if (hasRequiredEs_object_defineGetter) return es_object_defineGetter;
    hasRequiredEs_object_defineGetter = 1;
    var $ = require_export();
    var DESCRIPTORS = requireDescriptors();
    var FORCED = requireObjectPrototypeAccessorsForced();
    var aCallable = requireACallable();
    var toObject = requireToObject();
    var definePropertyModule = requireObjectDefineProperty();
    if (DESCRIPTORS) {
      $({
        target: 'Object',
        proto: true,
        forced: FORCED
      }, {
        __defineGetter__: function __defineGetter__(P, getter) {
          definePropertyModule.f(toObject(this), P, {
            get: aCallable(getter),
            enumerable: true,
            configurable: true
          });
        }
      });
    }
    return es_object_defineGetter;
  }
  var es_object_defineProperties = {};
  var hasRequiredEs_object_defineProperties;
  function requireEs_object_defineProperties() {
    if (hasRequiredEs_object_defineProperties) return es_object_defineProperties;
    hasRequiredEs_object_defineProperties = 1;
    var $ = require_export();
    var DESCRIPTORS = requireDescriptors();
    var defineProperties = requireObjectDefineProperties().f;
    $({
      target: 'Object',
      stat: true,
      forced: Object.defineProperties !== defineProperties,
      sham: !DESCRIPTORS
    }, {
      defineProperties: defineProperties
    });
    return es_object_defineProperties;
  }
  var es_object_defineProperty = {};
  var hasRequiredEs_object_defineProperty;
  function requireEs_object_defineProperty() {
    if (hasRequiredEs_object_defineProperty) return es_object_defineProperty;
    hasRequiredEs_object_defineProperty = 1;
    var $ = require_export();
    var DESCRIPTORS = requireDescriptors();
    var defineProperty = requireObjectDefineProperty().f;
    $({
      target: 'Object',
      stat: true,
      forced: Object.defineProperty !== defineProperty,
      sham: !DESCRIPTORS
    }, {
      defineProperty: defineProperty
    });
    return es_object_defineProperty;
  }
  var es_object_defineSetter = {};
  var hasRequiredEs_object_defineSetter;
  function requireEs_object_defineSetter() {
    if (hasRequiredEs_object_defineSetter) return es_object_defineSetter;
    hasRequiredEs_object_defineSetter = 1;
    var $ = require_export();
    var DESCRIPTORS = requireDescriptors();
    var FORCED = requireObjectPrototypeAccessorsForced();
    var aCallable = requireACallable();
    var toObject = requireToObject();
    var definePropertyModule = requireObjectDefineProperty();
    if (DESCRIPTORS) {
      $({
        target: 'Object',
        proto: true,
        forced: FORCED
      }, {
        __defineSetter__: function __defineSetter__(P, setter) {
          definePropertyModule.f(toObject(this), P, {
            set: aCallable(setter),
            enumerable: true,
            configurable: true
          });
        }
      });
    }
    return es_object_defineSetter;
  }
  var es_object_entries = {};
  var objectToArray;
  var hasRequiredObjectToArray;
  function requireObjectToArray() {
    if (hasRequiredObjectToArray) return objectToArray;
    hasRequiredObjectToArray = 1;
    var DESCRIPTORS = requireDescriptors();
    var fails = requireFails();
    var uncurryThis = requireFunctionUncurryThis();
    var objectGetPrototypeOf = requireObjectGetPrototypeOf();
    var objectKeys = requireObjectKeys();
    var toIndexedObject = requireToIndexedObject();
    var $propertyIsEnumerable = requireObjectPropertyIsEnumerable().f;
    var propertyIsEnumerable = uncurryThis($propertyIsEnumerable);
    var push = uncurryThis([].push);
    var IE_BUG = DESCRIPTORS && fails(function () {
      var O = Object.create(null);
      O[2] = 2;
      return !propertyIsEnumerable(O, 2);
    });
    var createMethod = function createMethod(TO_ENTRIES) {
      return function (it) {
        var O = toIndexedObject(it);
        var keys = objectKeys(O);
        var IE_WORKAROUND = IE_BUG && objectGetPrototypeOf(O) === null;
        var length = keys.length;
        var i = 0;
        var result = [];
        var key;
        while (length > i) {
          key = keys[i++];
          if (!DESCRIPTORS || (IE_WORKAROUND ? key in O : propertyIsEnumerable(O, key))) {
            push(result, TO_ENTRIES ? [key, O[key]] : O[key]);
          }
        }
        return result;
      };
    };
    objectToArray = {
      entries: createMethod(true),
      values: createMethod(false)
    };
    return objectToArray;
  }
  var hasRequiredEs_object_entries;
  function requireEs_object_entries() {
    if (hasRequiredEs_object_entries) return es_object_entries;
    hasRequiredEs_object_entries = 1;
    var $ = require_export();
    var $entries = requireObjectToArray().entries;
    $({
      target: 'Object',
      stat: true
    }, {
      entries: function entries(O) {
        return $entries(O);
      }
    });
    return es_object_entries;
  }
  var es_object_freeze = {};
  var hasRequiredEs_object_freeze;
  function requireEs_object_freeze() {
    if (hasRequiredEs_object_freeze) return es_object_freeze;
    hasRequiredEs_object_freeze = 1;
    var $ = require_export();
    var FREEZING = requireFreezing();
    var fails = requireFails();
    var isObject = requireIsObject();
    var onFreeze = requireInternalMetadata().onFreeze;
    var $freeze = Object.freeze;
    var FAILS_ON_PRIMITIVES = fails(function () {
      $freeze(1);
    });
    $({
      target: 'Object',
      stat: true,
      forced: FAILS_ON_PRIMITIVES,
      sham: !FREEZING
    }, {
      freeze: function freeze(it) {
        return $freeze && isObject(it) ? $freeze(onFreeze(it)) : it;
      }
    });
    return es_object_freeze;
  }
  var es_object_fromEntries = {};
  var hasRequiredEs_object_fromEntries;
  function requireEs_object_fromEntries() {
    if (hasRequiredEs_object_fromEntries) return es_object_fromEntries;
    hasRequiredEs_object_fromEntries = 1;
    var $ = require_export();
    var iterate = requireIterate();
    var createProperty = requireCreateProperty();
    $({
      target: 'Object',
      stat: true
    }, {
      fromEntries: function fromEntries(iterable) {
        var obj = {};
        iterate(iterable, function (k, v) {
          createProperty(obj, k, v);
        }, {
          AS_ENTRIES: true
        });
        return obj;
      }
    });
    return es_object_fromEntries;
  }
  var es_object_getOwnPropertyDescriptor = {};
  var hasRequiredEs_object_getOwnPropertyDescriptor;
  function requireEs_object_getOwnPropertyDescriptor() {
    if (hasRequiredEs_object_getOwnPropertyDescriptor) return es_object_getOwnPropertyDescriptor;
    hasRequiredEs_object_getOwnPropertyDescriptor = 1;
    var $ = require_export();
    var fails = requireFails();
    var toIndexedObject = requireToIndexedObject();
    var nativeGetOwnPropertyDescriptor = requireObjectGetOwnPropertyDescriptor().f;
    var DESCRIPTORS = requireDescriptors();
    var FORCED = !DESCRIPTORS || fails(function () {
      nativeGetOwnPropertyDescriptor(1);
    });
    $({
      target: 'Object',
      stat: true,
      forced: FORCED,
      sham: !DESCRIPTORS
    }, {
      getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
        return nativeGetOwnPropertyDescriptor(toIndexedObject(it), key);
      }
    });
    return es_object_getOwnPropertyDescriptor;
  }
  var es_object_getOwnPropertyDescriptors = {};
  var hasRequiredEs_object_getOwnPropertyDescriptors;
  function requireEs_object_getOwnPropertyDescriptors() {
    if (hasRequiredEs_object_getOwnPropertyDescriptors) return es_object_getOwnPropertyDescriptors;
    hasRequiredEs_object_getOwnPropertyDescriptors = 1;
    var $ = require_export();
    var DESCRIPTORS = requireDescriptors();
    var ownKeys = requireOwnKeys();
    var toIndexedObject = requireToIndexedObject();
    var getOwnPropertyDescriptorModule = requireObjectGetOwnPropertyDescriptor();
    var createProperty = requireCreateProperty();
    $({
      target: 'Object',
      stat: true,
      sham: !DESCRIPTORS
    }, {
      getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
        var O = toIndexedObject(object);
        var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
        var keys = ownKeys(O);
        var result = {};
        var index = 0;
        var key, descriptor;
        while (keys.length > index) {
          descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
          if (descriptor !== undefined) createProperty(result, key, descriptor);
        }
        return result;
      }
    });
    return es_object_getOwnPropertyDescriptors;
  }
  var es_object_getOwnPropertyNames = {};
  var hasRequiredEs_object_getOwnPropertyNames;
  function requireEs_object_getOwnPropertyNames() {
    if (hasRequiredEs_object_getOwnPropertyNames) return es_object_getOwnPropertyNames;
    hasRequiredEs_object_getOwnPropertyNames = 1;
    var $ = require_export();
    var fails = requireFails();
    var getOwnPropertyNames = requireObjectGetOwnPropertyNamesExternal().f;
    var FAILS_ON_PRIMITIVES = fails(function () {
      return !Object.getOwnPropertyNames(1);
    });
    $({
      target: 'Object',
      stat: true,
      forced: FAILS_ON_PRIMITIVES
    }, {
      getOwnPropertyNames: getOwnPropertyNames
    });
    return es_object_getOwnPropertyNames;
  }
  var es_object_getPrototypeOf = {};
  var hasRequiredEs_object_getPrototypeOf;
  function requireEs_object_getPrototypeOf() {
    if (hasRequiredEs_object_getPrototypeOf) return es_object_getPrototypeOf;
    hasRequiredEs_object_getPrototypeOf = 1;
    var $ = require_export();
    var fails = requireFails();
    var toObject = requireToObject();
    var nativeGetPrototypeOf = requireObjectGetPrototypeOf();
    var CORRECT_PROTOTYPE_GETTER = requireCorrectPrototypeGetter();
    var FAILS_ON_PRIMITIVES = fails(function () {
      nativeGetPrototypeOf(1);
    });
    $({
      target: 'Object',
      stat: true,
      forced: FAILS_ON_PRIMITIVES,
      sham: !CORRECT_PROTOTYPE_GETTER
    }, {
      getPrototypeOf: function getPrototypeOf(it) {
        return nativeGetPrototypeOf(toObject(it));
      }
    });
    return es_object_getPrototypeOf;
  }
  var es_object_groupBy = {};
  var hasRequiredEs_object_groupBy;
  function requireEs_object_groupBy() {
    if (hasRequiredEs_object_groupBy) return es_object_groupBy;
    hasRequiredEs_object_groupBy = 1;
    var $ = require_export();
    var getBuiltIn = requireGetBuiltIn();
    var uncurryThis = requireFunctionUncurryThis();
    var aCallable = requireACallable();
    var requireObjectCoercible = requireRequireObjectCoercible();
    var toPropertyKey = requireToPropertyKey();
    var iterate = requireIterate();
    var fails = requireFails();
    var nativeGroupBy = Object.groupBy;
    var create = getBuiltIn('Object', 'create');
    var push = uncurryThis([].push);
    var DOES_NOT_WORK_WITH_PRIMITIVES = !nativeGroupBy || fails(function () {
      return nativeGroupBy('ab', function (it) {
        return it;
      }).a.length !== 1;
    });
    $({
      target: 'Object',
      stat: true,
      forced: DOES_NOT_WORK_WITH_PRIMITIVES
    }, {
      groupBy: function groupBy(items, callbackfn) {
        requireObjectCoercible(items);
        aCallable(callbackfn);
        var obj = create(null);
        var k = 0;
        iterate(items, function (value) {
          var key = toPropertyKey(callbackfn(value, k++));
          if (key in obj) push(obj[key], value);else obj[key] = [value];
        });
        return obj;
      }
    });
    return es_object_groupBy;
  }
  var es_object_hasOwn = {};
  var hasRequiredEs_object_hasOwn;
  function requireEs_object_hasOwn() {
    if (hasRequiredEs_object_hasOwn) return es_object_hasOwn;
    hasRequiredEs_object_hasOwn = 1;
    var $ = require_export();
    var hasOwn = requireHasOwnProperty();
    $({
      target: 'Object',
      stat: true
    }, {
      hasOwn: hasOwn
    });
    return es_object_hasOwn;
  }
  var es_object_is = {};
  var sameValue;
  var hasRequiredSameValue;
  function requireSameValue() {
    if (hasRequiredSameValue) return sameValue;
    hasRequiredSameValue = 1;
    sameValue = Object.is || function is(x, y) {
      return x === y ? x !== 0 || 1 / x === 1 / y : x !== x && y !== y;
    };
    return sameValue;
  }
  var hasRequiredEs_object_is;
  function requireEs_object_is() {
    if (hasRequiredEs_object_is) return es_object_is;
    hasRequiredEs_object_is = 1;
    var $ = require_export();
    var is = requireSameValue();
    $({
      target: 'Object',
      stat: true
    }, {
      is: is
    });
    return es_object_is;
  }
  var es_object_isExtensible = {};
  var hasRequiredEs_object_isExtensible;
  function requireEs_object_isExtensible() {
    if (hasRequiredEs_object_isExtensible) return es_object_isExtensible;
    hasRequiredEs_object_isExtensible = 1;
    var $ = require_export();
    var $isExtensible = requireObjectIsExtensible();
    $({
      target: 'Object',
      stat: true,
      forced: Object.isExtensible !== $isExtensible
    }, {
      isExtensible: $isExtensible
    });
    return es_object_isExtensible;
  }
  var es_object_isFrozen = {};
  var hasRequiredEs_object_isFrozen;
  function requireEs_object_isFrozen() {
    if (hasRequiredEs_object_isFrozen) return es_object_isFrozen;
    hasRequiredEs_object_isFrozen = 1;
    var $ = require_export();
    var fails = requireFails();
    var isObject = requireIsObject();
    var classof = requireClassofRaw();
    var ARRAY_BUFFER_NON_EXTENSIBLE = requireArrayBufferNonExtensible();
    var $isFrozen = Object.isFrozen;
    var FORCED = ARRAY_BUFFER_NON_EXTENSIBLE || fails(function () {});
    $({
      target: 'Object',
      stat: true,
      forced: FORCED
    }, {
      isFrozen: function isFrozen(it) {
        if (!isObject(it)) return true;
        if (ARRAY_BUFFER_NON_EXTENSIBLE && classof(it) === 'ArrayBuffer') return true;
        return $isFrozen ? $isFrozen(it) : false;
      }
    });
    return es_object_isFrozen;
  }
  var es_object_isSealed = {};
  var hasRequiredEs_object_isSealed;
  function requireEs_object_isSealed() {
    if (hasRequiredEs_object_isSealed) return es_object_isSealed;
    hasRequiredEs_object_isSealed = 1;
    var $ = require_export();
    var fails = requireFails();
    var isObject = requireIsObject();
    var classof = requireClassofRaw();
    var ARRAY_BUFFER_NON_EXTENSIBLE = requireArrayBufferNonExtensible();
    var $isSealed = Object.isSealed;
    var FORCED = ARRAY_BUFFER_NON_EXTENSIBLE || fails(function () {});
    $({
      target: 'Object',
      stat: true,
      forced: FORCED
    }, {
      isSealed: function isSealed(it) {
        if (!isObject(it)) return true;
        if (ARRAY_BUFFER_NON_EXTENSIBLE && classof(it) === 'ArrayBuffer') return true;
        return $isSealed ? $isSealed(it) : false;
      }
    });
    return es_object_isSealed;
  }
  var es_object_keys = {};
  var hasRequiredEs_object_keys;
  function requireEs_object_keys() {
    if (hasRequiredEs_object_keys) return es_object_keys;
    hasRequiredEs_object_keys = 1;
    var $ = require_export();
    var toObject = requireToObject();
    var nativeKeys = requireObjectKeys();
    var fails = requireFails();
    var FAILS_ON_PRIMITIVES = fails(function () {
      nativeKeys(1);
    });
    $({
      target: 'Object',
      stat: true,
      forced: FAILS_ON_PRIMITIVES
    }, {
      keys: function keys(it) {
        return nativeKeys(toObject(it));
      }
    });
    return es_object_keys;
  }
  var es_object_lookupGetter = {};
  var hasRequiredEs_object_lookupGetter;
  function requireEs_object_lookupGetter() {
    if (hasRequiredEs_object_lookupGetter) return es_object_lookupGetter;
    hasRequiredEs_object_lookupGetter = 1;
    var $ = require_export();
    var DESCRIPTORS = requireDescriptors();
    var FORCED = requireObjectPrototypeAccessorsForced();
    var toObject = requireToObject();
    var toPropertyKey = requireToPropertyKey();
    var getPrototypeOf = requireObjectGetPrototypeOf();
    var getOwnPropertyDescriptor = requireObjectGetOwnPropertyDescriptor().f;
    if (DESCRIPTORS) {
      $({
        target: 'Object',
        proto: true,
        forced: FORCED
      }, {
        __lookupGetter__: function __lookupGetter__(P) {
          var O = toObject(this);
          var key = toPropertyKey(P);
          var desc;
          do {
            if (desc = getOwnPropertyDescriptor(O, key)) return desc.get;
          } while (O = getPrototypeOf(O));
        }
      });
    }
    return es_object_lookupGetter;
  }
  var es_object_lookupSetter = {};
  var hasRequiredEs_object_lookupSetter;
  function requireEs_object_lookupSetter() {
    if (hasRequiredEs_object_lookupSetter) return es_object_lookupSetter;
    hasRequiredEs_object_lookupSetter = 1;
    var $ = require_export();
    var DESCRIPTORS = requireDescriptors();
    var FORCED = requireObjectPrototypeAccessorsForced();
    var toObject = requireToObject();
    var toPropertyKey = requireToPropertyKey();
    var getPrototypeOf = requireObjectGetPrototypeOf();
    var getOwnPropertyDescriptor = requireObjectGetOwnPropertyDescriptor().f;
    if (DESCRIPTORS) {
      $({
        target: 'Object',
        proto: true,
        forced: FORCED
      }, {
        __lookupSetter__: function __lookupSetter__(P) {
          var O = toObject(this);
          var key = toPropertyKey(P);
          var desc;
          do {
            if (desc = getOwnPropertyDescriptor(O, key)) return desc.set;
          } while (O = getPrototypeOf(O));
        }
      });
    }
    return es_object_lookupSetter;
  }
  var es_object_preventExtensions = {};
  var hasRequiredEs_object_preventExtensions;
  function requireEs_object_preventExtensions() {
    if (hasRequiredEs_object_preventExtensions) return es_object_preventExtensions;
    hasRequiredEs_object_preventExtensions = 1;
    var $ = require_export();
    var isObject = requireIsObject();
    var onFreeze = requireInternalMetadata().onFreeze;
    var FREEZING = requireFreezing();
    var fails = requireFails();
    var $preventExtensions = Object.preventExtensions;
    var FAILS_ON_PRIMITIVES = fails(function () {
      $preventExtensions(1);
    });
    $({
      target: 'Object',
      stat: true,
      forced: FAILS_ON_PRIMITIVES,
      sham: !FREEZING
    }, {
      preventExtensions: function preventExtensions(it) {
        return $preventExtensions && isObject(it) ? $preventExtensions(onFreeze(it)) : it;
      }
    });
    return es_object_preventExtensions;
  }
  var es_object_proto = {};
  var hasRequiredEs_object_proto;
  function requireEs_object_proto() {
    if (hasRequiredEs_object_proto) return es_object_proto;
    hasRequiredEs_object_proto = 1;
    var DESCRIPTORS = requireDescriptors();
    var defineBuiltInAccessor = requireDefineBuiltInAccessor();
    var isObject = requireIsObject();
    var isPossiblePrototype = requireIsPossiblePrototype();
    var toObject = requireToObject();
    var requireObjectCoercible = requireRequireObjectCoercible();
    var getPrototypeOf = Object.getPrototypeOf;
    var setPrototypeOf = Object.setPrototypeOf;
    var ObjectPrototype = Object.prototype;
    var PROTO = '__proto__';
    if (DESCRIPTORS && getPrototypeOf && setPrototypeOf && !(PROTO in ObjectPrototype)) try {
      defineBuiltInAccessor(ObjectPrototype, PROTO, {
        configurable: true,
        get: function __proto__() {
          return getPrototypeOf(toObject(this));
        },
        set: function __proto__(proto) {
          var O = requireObjectCoercible(this);
          if (isPossiblePrototype(proto) && isObject(O)) {
            setPrototypeOf(O, proto);
          }
        }
      });
    } catch (error) {}
    return es_object_proto;
  }
  var es_object_seal = {};
  var hasRequiredEs_object_seal;
  function requireEs_object_seal() {
    if (hasRequiredEs_object_seal) return es_object_seal;
    hasRequiredEs_object_seal = 1;
    var $ = require_export();
    var isObject = requireIsObject();
    var onFreeze = requireInternalMetadata().onFreeze;
    var FREEZING = requireFreezing();
    var fails = requireFails();
    var $seal = Object.seal;
    var FAILS_ON_PRIMITIVES = fails(function () {
      $seal(1);
    });
    $({
      target: 'Object',
      stat: true,
      forced: FAILS_ON_PRIMITIVES,
      sham: !FREEZING
    }, {
      seal: function seal(it) {
        return $seal && isObject(it) ? $seal(onFreeze(it)) : it;
      }
    });
    return es_object_seal;
  }
  var es_object_setPrototypeOf = {};
  var hasRequiredEs_object_setPrototypeOf;
  function requireEs_object_setPrototypeOf() {
    if (hasRequiredEs_object_setPrototypeOf) return es_object_setPrototypeOf;
    hasRequiredEs_object_setPrototypeOf = 1;
    var $ = require_export();
    var setPrototypeOf = requireObjectSetPrototypeOf();
    $({
      target: 'Object',
      stat: true
    }, {
      setPrototypeOf: setPrototypeOf
    });
    return es_object_setPrototypeOf;
  }
  var es_object_toString = {};
  var objectToString;
  var hasRequiredObjectToString;
  function requireObjectToString() {
    if (hasRequiredObjectToString) return objectToString;
    hasRequiredObjectToString = 1;
    var TO_STRING_TAG_SUPPORT = requireToStringTagSupport();
    var classof = requireClassof();
    objectToString = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
      return '[object ' + classof(this) + ']';
    };
    return objectToString;
  }
  var hasRequiredEs_object_toString;
  function requireEs_object_toString() {
    if (hasRequiredEs_object_toString) return es_object_toString;
    hasRequiredEs_object_toString = 1;
    var TO_STRING_TAG_SUPPORT = requireToStringTagSupport();
    var defineBuiltIn = requireDefineBuiltIn();
    var toString = requireObjectToString();
    if (!TO_STRING_TAG_SUPPORT) {
      defineBuiltIn(Object.prototype, 'toString', toString, {
        unsafe: true
      });
    }
    return es_object_toString;
  }
  var es_object_values = {};
  var hasRequiredEs_object_values;
  function requireEs_object_values() {
    if (hasRequiredEs_object_values) return es_object_values;
    hasRequiredEs_object_values = 1;
    var $ = require_export();
    var $values = requireObjectToArray().values;
    $({
      target: 'Object',
      stat: true
    }, {
      values: function values(O) {
        return $values(O);
      }
    });
    return es_object_values;
  }
  var es_parseFloat = {};
  var hasRequiredEs_parseFloat;
  function requireEs_parseFloat() {
    if (hasRequiredEs_parseFloat) return es_parseFloat;
    hasRequiredEs_parseFloat = 1;
    var $ = require_export();
    var $parseFloat = requireNumberParseFloat();
    $({
      global: true,
      forced: parseFloat !== $parseFloat
    }, {
      parseFloat: $parseFloat
    });
    return es_parseFloat;
  }
  var es_parseInt = {};
  var hasRequiredEs_parseInt;
  function requireEs_parseInt() {
    if (hasRequiredEs_parseInt) return es_parseInt;
    hasRequiredEs_parseInt = 1;
    var $ = require_export();
    var $parseInt = requireNumberParseInt();
    $({
      global: true,
      forced: parseInt !== $parseInt
    }, {
      parseInt: $parseInt
    });
    return es_parseInt;
  }
  var es_promise = {};
  var es_promise_constructor = {};
  var aConstructor;
  var hasRequiredAConstructor;
  function requireAConstructor() {
    if (hasRequiredAConstructor) return aConstructor;
    hasRequiredAConstructor = 1;
    var isConstructor = requireIsConstructor();
    var tryToString = requireTryToString();
    var $TypeError = TypeError;
    aConstructor = function aConstructor(argument) {
      if (isConstructor(argument)) return argument;
      throw new $TypeError(tryToString(argument) + ' is not a constructor');
    };
    return aConstructor;
  }
  var speciesConstructor;
  var hasRequiredSpeciesConstructor;
  function requireSpeciesConstructor() {
    if (hasRequiredSpeciesConstructor) return speciesConstructor;
    hasRequiredSpeciesConstructor = 1;
    var anObject = requireAnObject();
    var aConstructor = requireAConstructor();
    var isNullOrUndefined = requireIsNullOrUndefined();
    var wellKnownSymbol = requireWellKnownSymbol();
    var SPECIES = wellKnownSymbol('species');
    speciesConstructor = function speciesConstructor(O, defaultConstructor) {
      var C = anObject(O).constructor;
      var S;
      return C === undefined || isNullOrUndefined(S = anObject(C)[SPECIES]) ? defaultConstructor : aConstructor(S);
    };
    return speciesConstructor;
  }
  var validateArgumentsLength;
  var hasRequiredValidateArgumentsLength;
  function requireValidateArgumentsLength() {
    if (hasRequiredValidateArgumentsLength) return validateArgumentsLength;
    hasRequiredValidateArgumentsLength = 1;
    var $TypeError = TypeError;
    validateArgumentsLength = function validateArgumentsLength(passed, required) {
      if (passed < required) throw new $TypeError('Not enough arguments');
      return passed;
    };
    return validateArgumentsLength;
  }
  var environmentIsIos;
  var hasRequiredEnvironmentIsIos;
  function requireEnvironmentIsIos() {
    if (hasRequiredEnvironmentIsIos) return environmentIsIos;
    hasRequiredEnvironmentIsIos = 1;
    var userAgent = requireEnvironmentUserAgent();
    environmentIsIos = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent);
    return environmentIsIos;
  }
  var task;
  var hasRequiredTask;
  function requireTask() {
    if (hasRequiredTask) return task;
    hasRequiredTask = 1;
    var globalThis = requireGlobalThis();
    var apply = requireFunctionApply();
    var bind = requireFunctionBindContext();
    var isCallable = requireIsCallable();
    var hasOwn = requireHasOwnProperty();
    var fails = requireFails();
    var html = requireHtml();
    var arraySlice = requireArraySlice();
    var createElement = requireDocumentCreateElement();
    var validateArgumentsLength = requireValidateArgumentsLength();
    var IS_IOS = requireEnvironmentIsIos();
    var IS_NODE = requireEnvironmentIsNode();
    var set = globalThis.setImmediate;
    var clear = globalThis.clearImmediate;
    var process = globalThis.process;
    var Dispatch = globalThis.Dispatch;
    var Function = globalThis.Function;
    var MessageChannel = globalThis.MessageChannel;
    var String = globalThis.String;
    var counter = 0;
    var queue = {};
    var ONREADYSTATECHANGE = 'onreadystatechange';
    var $location, defer, channel, port;
    fails(function () {
      $location = globalThis.location;
    });
    var run = function run(id) {
      if (hasOwn(queue, id)) {
        var fn = queue[id];
        delete queue[id];
        fn();
      }
    };
    var runner = function runner(id) {
      return function () {
        run(id);
      };
    };
    var eventListener = function eventListener(event) {
      run(event.data);
    };
    var globalPostMessageDefer = function globalPostMessageDefer(id) {
      globalThis.postMessage(String(id), $location.protocol + '//' + $location.host);
    };
    if (!set || !clear) {
      set = function setImmediate(handler) {
        validateArgumentsLength(arguments.length, 1);
        var fn = isCallable(handler) ? handler : Function(handler);
        var args = arraySlice(arguments, 1);
        queue[++counter] = function () {
          apply(fn, undefined, args);
        };
        defer(counter);
        return counter;
      };
      clear = function clearImmediate(id) {
        delete queue[id];
      };
      if (IS_NODE) {
        defer = function defer(id) {
          process.nextTick(runner(id));
        };
      } else if (Dispatch && Dispatch.now) {
        defer = function defer(id) {
          Dispatch.now(runner(id));
        };
      } else if (MessageChannel && !IS_IOS) {
        channel = new MessageChannel();
        port = channel.port2;
        channel.port1.onmessage = eventListener;
        defer = bind(port.postMessage, port);
      } else if (globalThis.addEventListener && isCallable(globalThis.postMessage) && !globalThis.importScripts && $location && $location.protocol !== 'file:' && !fails(globalPostMessageDefer)) {
        defer = globalPostMessageDefer;
        globalThis.addEventListener('message', eventListener, false);
      } else if (ONREADYSTATECHANGE in createElement('script')) {
        defer = function defer(id) {
          html.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () {
            html.removeChild(this);
            run(id);
          };
        };
      } else {
        defer = function defer(id) {
          setTimeout(runner(id), 0);
        };
      }
    }
    task = {
      set: set,
      clear: clear
    };
    return task;
  }
  var safeGetBuiltIn;
  var hasRequiredSafeGetBuiltIn;
  function requireSafeGetBuiltIn() {
    if (hasRequiredSafeGetBuiltIn) return safeGetBuiltIn;
    hasRequiredSafeGetBuiltIn = 1;
    var globalThis = requireGlobalThis();
    var DESCRIPTORS = requireDescriptors();
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    safeGetBuiltIn = function safeGetBuiltIn(name) {
      if (!DESCRIPTORS) return globalThis[name];
      var descriptor = getOwnPropertyDescriptor(globalThis, name);
      return descriptor && descriptor.value;
    };
    return safeGetBuiltIn;
  }
  var queue;
  var hasRequiredQueue;
  function requireQueue() {
    if (hasRequiredQueue) return queue;
    hasRequiredQueue = 1;
    var Queue = function Queue() {
      this.head = null;
      this.tail = null;
    };
    Queue.prototype = {
      add: function add(item) {
        var entry = {
          item: item,
          next: null
        };
        var tail = this.tail;
        if (tail) tail.next = entry;else this.head = entry;
        this.tail = entry;
      },
      get: function get() {
        var entry = this.head;
        if (entry) {
          var next = this.head = entry.next;
          if (next === null) this.tail = null;
          return entry.item;
        }
      }
    };
    queue = Queue;
    return queue;
  }
  var environmentIsIosPebble;
  var hasRequiredEnvironmentIsIosPebble;
  function requireEnvironmentIsIosPebble() {
    if (hasRequiredEnvironmentIsIosPebble) return environmentIsIosPebble;
    hasRequiredEnvironmentIsIosPebble = 1;
    var userAgent = requireEnvironmentUserAgent();
    environmentIsIosPebble = /ipad|iphone|ipod/i.test(userAgent) && typeof Pebble != 'undefined';
    return environmentIsIosPebble;
  }
  var environmentIsWebosWebkit;
  var hasRequiredEnvironmentIsWebosWebkit;
  function requireEnvironmentIsWebosWebkit() {
    if (hasRequiredEnvironmentIsWebosWebkit) return environmentIsWebosWebkit;
    hasRequiredEnvironmentIsWebosWebkit = 1;
    var userAgent = requireEnvironmentUserAgent();
    environmentIsWebosWebkit = /web0s(?!.*chrome)/i.test(userAgent);
    return environmentIsWebosWebkit;
  }
  var microtask_1;
  var hasRequiredMicrotask;
  function requireMicrotask() {
    if (hasRequiredMicrotask) return microtask_1;
    hasRequiredMicrotask = 1;
    var globalThis = requireGlobalThis();
    var safeGetBuiltIn = requireSafeGetBuiltIn();
    var bind = requireFunctionBindContext();
    var macrotask = requireTask().set;
    var Queue = requireQueue();
    var IS_IOS = requireEnvironmentIsIos();
    var IS_IOS_PEBBLE = requireEnvironmentIsIosPebble();
    var IS_WEBOS_WEBKIT = requireEnvironmentIsWebosWebkit();
    var IS_NODE = requireEnvironmentIsNode();
    var MutationObserver = globalThis.MutationObserver || globalThis.WebKitMutationObserver;
    var document = globalThis.document;
    var process = globalThis.process;
    var Promise = globalThis.Promise;
    var microtask = safeGetBuiltIn('queueMicrotask');
    var notify, toggle, node, promise, then;
    if (!microtask) {
      var queue = new Queue();
      var flush = function flush() {
        var parent, fn;
        if (IS_NODE && (parent = process.domain)) parent.exit();
        while (fn = queue.get()) try {
          fn();
        } catch (error) {
          if (queue.head) notify();
          throw error;
        }
        if (parent) parent.enter();
      };
      if (!IS_IOS && !IS_NODE && !IS_WEBOS_WEBKIT && MutationObserver && document) {
        toggle = true;
        node = document.createTextNode('');
        new MutationObserver(flush).observe(node, {
          characterData: true
        });
        notify = function notify() {
          node.data = toggle = !toggle;
        };
      } else if (!IS_IOS_PEBBLE && Promise && Promise.resolve) {
        promise = Promise.resolve(undefined);
        promise.constructor = Promise;
        then = bind(promise.then, promise);
        notify = function notify() {
          then(flush);
        };
      } else if (IS_NODE) {
        notify = function notify() {
          process.nextTick(flush);
        };
      } else {
        macrotask = bind(macrotask, globalThis);
        notify = function notify() {
          macrotask(flush);
        };
      }
      microtask = function microtask(fn) {
        if (!queue.head) notify();
        queue.add(fn);
      };
    }
    microtask_1 = microtask;
    return microtask_1;
  }
  var hostReportErrors;
  var hasRequiredHostReportErrors;
  function requireHostReportErrors() {
    if (hasRequiredHostReportErrors) return hostReportErrors;
    hasRequiredHostReportErrors = 1;
    hostReportErrors = function hostReportErrors(a, b) {
      try {
        arguments.length === 1 ? console.error(a) : console.error(a, b);
      } catch (error) {}
    };
    return hostReportErrors;
  }
  var perform;
  var hasRequiredPerform;
  function requirePerform() {
    if (hasRequiredPerform) return perform;
    hasRequiredPerform = 1;
    perform = function perform(exec) {
      try {
        return {
          error: false,
          value: exec()
        };
      } catch (error) {
        return {
          error: true,
          value: error
        };
      }
    };
    return perform;
  }
  var promiseNativeConstructor;
  var hasRequiredPromiseNativeConstructor;
  function requirePromiseNativeConstructor() {
    if (hasRequiredPromiseNativeConstructor) return promiseNativeConstructor;
    hasRequiredPromiseNativeConstructor = 1;
    var globalThis = requireGlobalThis();
    promiseNativeConstructor = globalThis.Promise;
    return promiseNativeConstructor;
  }
  var promiseConstructorDetection;
  var hasRequiredPromiseConstructorDetection;
  function requirePromiseConstructorDetection() {
    if (hasRequiredPromiseConstructorDetection) return promiseConstructorDetection;
    hasRequiredPromiseConstructorDetection = 1;
    var globalThis = requireGlobalThis();
    var NativePromiseConstructor = requirePromiseNativeConstructor();
    var isCallable = requireIsCallable();
    var isForced = requireIsForced();
    var inspectSource = requireInspectSource();
    var wellKnownSymbol = requireWellKnownSymbol();
    var ENVIRONMENT = requireEnvironment();
    var IS_PURE = requireIsPure();
    var V8_VERSION = requireEnvironmentV8Version();
    var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
    var SPECIES = wellKnownSymbol('species');
    var SUBCLASSING = false;
    var NATIVE_PROMISE_REJECTION_EVENT = isCallable(globalThis.PromiseRejectionEvent);
    var FORCED_PROMISE_CONSTRUCTOR = isForced('Promise', function () {
      var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(NativePromiseConstructor);
      var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor);
      if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66) return true;
      if (IS_PURE && !(NativePromisePrototype['catch'] && NativePromisePrototype['finally'])) return true;
      if (!V8_VERSION || V8_VERSION < 51 || !/native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) {
        var promise = new NativePromiseConstructor(function (resolve) {
          resolve(1);
        });
        var FakePromise = function FakePromise(exec) {
          exec(function () {}, function () {});
        };
        var constructor = promise.constructor = {};
        constructor[SPECIES] = FakePromise;
        SUBCLASSING = promise.then(function () {}) instanceof FakePromise;
        if (!SUBCLASSING) return true;
      }
      return !GLOBAL_CORE_JS_PROMISE && (ENVIRONMENT === 'BROWSER' || ENVIRONMENT === 'DENO') && !NATIVE_PROMISE_REJECTION_EVENT;
    });
    promiseConstructorDetection = {
      CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR,
      REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT,
      SUBCLASSING: SUBCLASSING
    };
    return promiseConstructorDetection;
  }
  var newPromiseCapability = {};
  var hasRequiredNewPromiseCapability;
  function requireNewPromiseCapability() {
    if (hasRequiredNewPromiseCapability) return newPromiseCapability;
    hasRequiredNewPromiseCapability = 1;
    var aCallable = requireACallable();
    var $TypeError = TypeError;
    var PromiseCapability = function PromiseCapability(C) {
      var resolve, reject;
      this.promise = new C(function ($$resolve, $$reject) {
        if (resolve !== undefined || reject !== undefined) throw new $TypeError('Bad Promise constructor');
        resolve = $$resolve;
        reject = $$reject;
      });
      this.resolve = aCallable(resolve);
      this.reject = aCallable(reject);
    };
    newPromiseCapability.f = function (C) {
      return new PromiseCapability(C);
    };
    return newPromiseCapability;
  }
  var hasRequiredEs_promise_constructor;
  function requireEs_promise_constructor() {
    if (hasRequiredEs_promise_constructor) return es_promise_constructor;
    hasRequiredEs_promise_constructor = 1;
    var $ = require_export();
    var IS_PURE = requireIsPure();
    var IS_NODE = requireEnvironmentIsNode();
    var globalThis = requireGlobalThis();
    var path = requirePath();
    var call = requireFunctionCall();
    var defineBuiltIn = requireDefineBuiltIn();
    var setPrototypeOf = requireObjectSetPrototypeOf();
    var setToStringTag = requireSetToStringTag();
    var setSpecies = requireSetSpecies();
    var aCallable = requireACallable();
    var isCallable = requireIsCallable();
    var isObject = requireIsObject();
    var anInstance = requireAnInstance();
    var speciesConstructor = requireSpeciesConstructor();
    var task = requireTask().set;
    var microtask = requireMicrotask();
    var hostReportErrors = requireHostReportErrors();
    var perform = requirePerform();
    var Queue = requireQueue();
    var InternalStateModule = requireInternalState();
    var NativePromiseConstructor = requirePromiseNativeConstructor();
    var PromiseConstructorDetection = requirePromiseConstructorDetection();
    var newPromiseCapabilityModule = requireNewPromiseCapability();
    var PROMISE = 'Promise';
    var FORCED_PROMISE_CONSTRUCTOR = PromiseConstructorDetection.CONSTRUCTOR;
    var NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;
    var NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;
    var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
    var setInternalState = InternalStateModule.set;
    var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
    var PromiseConstructor = NativePromiseConstructor;
    var PromisePrototype = NativePromisePrototype;
    var TypeError = globalThis.TypeError;
    var document = globalThis.document;
    var process = globalThis.process;
    var newPromiseCapability = newPromiseCapabilityModule.f;
    var newGenericPromiseCapability = newPromiseCapability;
    var DISPATCH_EVENT = !!(document && document.createEvent && globalThis.dispatchEvent);
    var UNHANDLED_REJECTION = 'unhandledrejection';
    var REJECTION_HANDLED = 'rejectionhandled';
    var PENDING = 0;
    var FULFILLED = 1;
    var REJECTED = 2;
    var HANDLED = 1;
    var UNHANDLED = 2;
    var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;
    var isThenable = function isThenable(it) {
      var then;
      return isObject(it) && isCallable(then = it.then) ? then : false;
    };
    var callReaction = function callReaction(reaction, state) {
      var value = state.value;
      var ok = state.state === FULFILLED;
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (state.rejection === UNHANDLED) onHandleUnhandled(state);
            state.rejection = HANDLED;
          }
          if (handler === true) result = value;else {
            if (domain) domain.enter();
            result = handler(value);
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(new TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            call(then, result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (error) {
        if (domain && !exited) domain.exit();
        reject(error);
      }
    };
    var notify = function notify(state, isReject) {
      if (state.notified) return;
      state.notified = true;
      microtask(function () {
        var reactions = state.reactions;
        var reaction;
        while (reaction = reactions.get()) {
          callReaction(reaction, state);
        }
        state.notified = false;
        if (isReject && !state.rejection) onUnhandled(state);
      });
    };
    var dispatchEvent = function dispatchEvent(name, promise, reason) {
      var event, handler;
      if (DISPATCH_EVENT) {
        event = document.createEvent('Event');
        event.promise = promise;
        event.reason = reason;
        event.initEvent(name, false, true);
        globalThis.dispatchEvent(event);
      } else event = {
        promise: promise,
        reason: reason
      };
      if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = globalThis['on' + name])) handler(event);else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
    };
    var onUnhandled = function onUnhandled(state) {
      call(task, globalThis, function () {
        var promise = state.facade;
        var value = state.value;
        var IS_UNHANDLED = isUnhandled(state);
        var result;
        if (IS_UNHANDLED) {
          result = perform(function () {
            if (IS_NODE) {
              process.emit('unhandledRejection', value, promise);
            } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
          });
          state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
          if (result.error) throw result.value;
        }
      });
    };
    var isUnhandled = function isUnhandled(state) {
      return state.rejection !== HANDLED && !state.parent;
    };
    var onHandleUnhandled = function onHandleUnhandled(state) {
      call(task, globalThis, function () {
        var promise = state.facade;
        if (IS_NODE) {
          process.emit('rejectionHandled', promise);
        } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
      });
    };
    var bind = function bind(fn, state, unwrap) {
      return function (value) {
        fn(state, value, unwrap);
      };
    };
    var internalReject = function internalReject(state, value, unwrap) {
      if (state.done) return;
      state.done = true;
      if (unwrap) state = unwrap;
      state.value = value;
      state.state = REJECTED;
      notify(state, true);
    };
    var _internalResolve = function internalResolve(state, value, unwrap) {
      if (state.done) return;
      state.done = true;
      if (unwrap) state = unwrap;
      try {
        if (state.facade === value) throw new TypeError("Promise can't be resolved itself");
        var then = isThenable(value);
        if (then) {
          microtask(function () {
            var wrapper = {
              done: false
            };
            try {
              call(then, value, bind(_internalResolve, wrapper, state), bind(internalReject, wrapper, state));
            } catch (error) {
              internalReject(wrapper, error, state);
            }
          });
        } else {
          state.value = value;
          state.state = FULFILLED;
          notify(state, false);
        }
      } catch (error) {
        internalReject({
          done: false
        }, error, state);
      }
    };
    if (FORCED_PROMISE_CONSTRUCTOR) {
      PromiseConstructor = function Promise(executor) {
        anInstance(this, PromisePrototype);
        aCallable(executor);
        call(Internal, this);
        var state = getInternalPromiseState(this);
        try {
          executor(bind(_internalResolve, state), bind(internalReject, state));
        } catch (error) {
          internalReject(state, error);
        }
      };
      PromisePrototype = PromiseConstructor.prototype;
      Internal = function Promise(executor) {
        setInternalState(this, {
          type: PROMISE,
          done: false,
          notified: false,
          parent: false,
          reactions: new Queue(),
          rejection: false,
          state: PENDING,
          value: null
        });
      };
      Internal.prototype = defineBuiltIn(PromisePrototype, 'then', function then(onFulfilled, onRejected) {
        var state = getInternalPromiseState(this);
        var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
        state.parent = true;
        reaction.ok = isCallable(onFulfilled) ? onFulfilled : true;
        reaction.fail = isCallable(onRejected) && onRejected;
        reaction.domain = IS_NODE ? process.domain : undefined;
        if (state.state === PENDING) state.reactions.add(reaction);else microtask(function () {
          callReaction(reaction, state);
        });
        return reaction.promise;
      });
      OwnPromiseCapability = function OwnPromiseCapability() {
        var promise = new Internal();
        var state = getInternalPromiseState(promise);
        this.promise = promise;
        this.resolve = bind(_internalResolve, state);
        this.reject = bind(internalReject, state);
      };
      newPromiseCapabilityModule.f = newPromiseCapability = function newPromiseCapability(C) {
        return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
      };
      if (!IS_PURE && isCallable(NativePromiseConstructor) && NativePromisePrototype !== Object.prototype) {
        nativeThen = NativePromisePrototype.then;
        if (!NATIVE_PROMISE_SUBCLASSING) {
          defineBuiltIn(NativePromisePrototype, 'then', function then(onFulfilled, onRejected) {
            var that = this;
            return new PromiseConstructor(function (resolve, reject) {
              call(nativeThen, that, resolve, reject);
            }).then(onFulfilled, onRejected);
          }, {
            unsafe: true
          });
        }
        try {
          delete NativePromisePrototype.constructor;
        } catch (error) {}
        if (setPrototypeOf) {
          setPrototypeOf(NativePromisePrototype, PromisePrototype);
        }
      }
    }
    $({
      global: true,
      constructor: true,
      wrap: true,
      forced: FORCED_PROMISE_CONSTRUCTOR
    }, {
      Promise: PromiseConstructor
    });
    PromiseWrapper = path.Promise;
    setToStringTag(PromiseConstructor, PROMISE, false, true);
    setSpecies(PROMISE);
    return es_promise_constructor;
  }
  var es_promise_all = {};
  var promiseStaticsIncorrectIteration;
  var hasRequiredPromiseStaticsIncorrectIteration;
  function requirePromiseStaticsIncorrectIteration() {
    if (hasRequiredPromiseStaticsIncorrectIteration) return promiseStaticsIncorrectIteration;
    hasRequiredPromiseStaticsIncorrectIteration = 1;
    var NativePromiseConstructor = requirePromiseNativeConstructor();
    var checkCorrectnessOfIteration = requireCheckCorrectnessOfIteration();
    var FORCED_PROMISE_CONSTRUCTOR = requirePromiseConstructorDetection().CONSTRUCTOR;
    promiseStaticsIncorrectIteration = FORCED_PROMISE_CONSTRUCTOR || !checkCorrectnessOfIteration(function (iterable) {
      NativePromiseConstructor.all(iterable).then(undefined, function () {});
    });
    return promiseStaticsIncorrectIteration;
  }
  var hasRequiredEs_promise_all;
  function requireEs_promise_all() {
    if (hasRequiredEs_promise_all) return es_promise_all;
    hasRequiredEs_promise_all = 1;
    var $ = require_export();
    var call = requireFunctionCall();
    var aCallable = requireACallable();
    var newPromiseCapabilityModule = requireNewPromiseCapability();
    var perform = requirePerform();
    var iterate = requireIterate();
    var PROMISE_STATICS_INCORRECT_ITERATION = requirePromiseStaticsIncorrectIteration();
    $({
      target: 'Promise',
      stat: true,
      forced: PROMISE_STATICS_INCORRECT_ITERATION
    }, {
      all: function all(iterable) {
        var C = this;
        var capability = newPromiseCapabilityModule.f(C);
        var resolve = capability.resolve;
        var reject = capability.reject;
        var result = perform(function () {
          var $promiseResolve = aCallable(C.resolve);
          var values = [];
          var counter = 0;
          var remaining = 1;
          iterate(iterable, function (promise) {
            var index = counter++;
            var alreadyCalled = false;
            remaining++;
            call($promiseResolve, C, promise).then(function (value) {
              if (alreadyCalled) return;
              alreadyCalled = true;
              values[index] = value;
              --remaining || resolve(values);
            }, reject);
          });
          --remaining || resolve(values);
        });
        if (result.error) reject(result.value);
        return capability.promise;
      }
    });
    return es_promise_all;
  }
  var es_promise_catch = {};
  var hasRequiredEs_promise_catch;
  function requireEs_promise_catch() {
    if (hasRequiredEs_promise_catch) return es_promise_catch;
    hasRequiredEs_promise_catch = 1;
    var $ = require_export();
    var IS_PURE = requireIsPure();
    var FORCED_PROMISE_CONSTRUCTOR = requirePromiseConstructorDetection().CONSTRUCTOR;
    var NativePromiseConstructor = requirePromiseNativeConstructor();
    var getBuiltIn = requireGetBuiltIn();
    var isCallable = requireIsCallable();
    var defineBuiltIn = requireDefineBuiltIn();
    var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
    $({
      target: 'Promise',
      proto: true,
      forced: FORCED_PROMISE_CONSTRUCTOR,
      real: true
    }, {
      'catch': function _catch(onRejected) {
        return this.then(undefined, onRejected);
      }
    });
    if (!IS_PURE && isCallable(NativePromiseConstructor)) {
      var method = getBuiltIn('Promise').prototype['catch'];
      if (NativePromisePrototype['catch'] !== method) {
        defineBuiltIn(NativePromisePrototype, 'catch', method, {
          unsafe: true
        });
      }
    }
    return es_promise_catch;
  }
  var es_promise_race = {};
  var hasRequiredEs_promise_race;
  function requireEs_promise_race() {
    if (hasRequiredEs_promise_race) return es_promise_race;
    hasRequiredEs_promise_race = 1;
    var $ = require_export();
    var call = requireFunctionCall();
    var aCallable = requireACallable();
    var newPromiseCapabilityModule = requireNewPromiseCapability();
    var perform = requirePerform();
    var iterate = requireIterate();
    var PROMISE_STATICS_INCORRECT_ITERATION = requirePromiseStaticsIncorrectIteration();
    $({
      target: 'Promise',
      stat: true,
      forced: PROMISE_STATICS_INCORRECT_ITERATION
    }, {
      race: function race(iterable) {
        var C = this;
        var capability = newPromiseCapabilityModule.f(C);
        var reject = capability.reject;
        var result = perform(function () {
          var $promiseResolve = aCallable(C.resolve);
          iterate(iterable, function (promise) {
            call($promiseResolve, C, promise).then(capability.resolve, reject);
          });
        });
        if (result.error) reject(result.value);
        return capability.promise;
      }
    });
    return es_promise_race;
  }
  var es_promise_reject = {};
  var hasRequiredEs_promise_reject;
  function requireEs_promise_reject() {
    if (hasRequiredEs_promise_reject) return es_promise_reject;
    hasRequiredEs_promise_reject = 1;
    var $ = require_export();
    var newPromiseCapabilityModule = requireNewPromiseCapability();
    var FORCED_PROMISE_CONSTRUCTOR = requirePromiseConstructorDetection().CONSTRUCTOR;
    $({
      target: 'Promise',
      stat: true,
      forced: FORCED_PROMISE_CONSTRUCTOR
    }, {
      reject: function reject(r) {
        var capability = newPromiseCapabilityModule.f(this);
        var capabilityReject = capability.reject;
        capabilityReject(r);
        return capability.promise;
      }
    });
    return es_promise_reject;
  }
  var es_promise_resolve = {};
  var promiseResolve;
  var hasRequiredPromiseResolve;
  function requirePromiseResolve() {
    if (hasRequiredPromiseResolve) return promiseResolve;
    hasRequiredPromiseResolve = 1;
    var anObject = requireAnObject();
    var isObject = requireIsObject();
    var newPromiseCapability = requireNewPromiseCapability();
    promiseResolve = function promiseResolve(C, x) {
      anObject(C);
      if (isObject(x) && x.constructor === C) return x;
      var promiseCapability = newPromiseCapability.f(C);
      var resolve = promiseCapability.resolve;
      resolve(x);
      return promiseCapability.promise;
    };
    return promiseResolve;
  }
  var hasRequiredEs_promise_resolve;
  function requireEs_promise_resolve() {
    if (hasRequiredEs_promise_resolve) return es_promise_resolve;
    hasRequiredEs_promise_resolve = 1;
    var $ = require_export();
    var getBuiltIn = requireGetBuiltIn();
    var IS_PURE = requireIsPure();
    var NativePromiseConstructor = requirePromiseNativeConstructor();
    var FORCED_PROMISE_CONSTRUCTOR = requirePromiseConstructorDetection().CONSTRUCTOR;
    var promiseResolve = requirePromiseResolve();
    var PromiseConstructorWrapper = getBuiltIn('Promise');
    var CHECK_WRAPPER = IS_PURE && !FORCED_PROMISE_CONSTRUCTOR;
    $({
      target: 'Promise',
      stat: true,
      forced: IS_PURE || FORCED_PROMISE_CONSTRUCTOR
    }, {
      resolve: function resolve(x) {
        return promiseResolve(CHECK_WRAPPER && this === PromiseConstructorWrapper ? NativePromiseConstructor : this, x);
      }
    });
    return es_promise_resolve;
  }
  var hasRequiredEs_promise;
  function requireEs_promise() {
    if (hasRequiredEs_promise) return es_promise;
    hasRequiredEs_promise = 1;
    requireEs_promise_constructor();
    requireEs_promise_all();
    requireEs_promise_catch();
    requireEs_promise_race();
    requireEs_promise_reject();
    requireEs_promise_resolve();
    return es_promise;
  }
  var es_promise_allSettled = {};
  var hasRequiredEs_promise_allSettled;
  function requireEs_promise_allSettled() {
    if (hasRequiredEs_promise_allSettled) return es_promise_allSettled;
    hasRequiredEs_promise_allSettled = 1;
    var $ = require_export();
    var call = requireFunctionCall();
    var aCallable = requireACallable();
    var newPromiseCapabilityModule = requireNewPromiseCapability();
    var perform = requirePerform();
    var iterate = requireIterate();
    var PROMISE_STATICS_INCORRECT_ITERATION = requirePromiseStaticsIncorrectIteration();
    $({
      target: 'Promise',
      stat: true,
      forced: PROMISE_STATICS_INCORRECT_ITERATION
    }, {
      allSettled: function allSettled(iterable) {
        var C = this;
        var capability = newPromiseCapabilityModule.f(C);
        var resolve = capability.resolve;
        var reject = capability.reject;
        var result = perform(function () {
          var promiseResolve = aCallable(C.resolve);
          var values = [];
          var counter = 0;
          var remaining = 1;
          iterate(iterable, function (promise) {
            var index = counter++;
            var alreadyCalled = false;
            remaining++;
            call(promiseResolve, C, promise).then(function (value) {
              if (alreadyCalled) return;
              alreadyCalled = true;
              values[index] = {
                status: 'fulfilled',
                value: value
              };
              --remaining || resolve(values);
            }, function (error) {
              if (alreadyCalled) return;
              alreadyCalled = true;
              values[index] = {
                status: 'rejected',
                reason: error
              };
              --remaining || resolve(values);
            });
          });
          --remaining || resolve(values);
        });
        if (result.error) reject(result.value);
        return capability.promise;
      }
    });
    return es_promise_allSettled;
  }
  var es_promise_any = {};
  var hasRequiredEs_promise_any;
  function requireEs_promise_any() {
    if (hasRequiredEs_promise_any) return es_promise_any;
    hasRequiredEs_promise_any = 1;
    var $ = require_export();
    var call = requireFunctionCall();
    var aCallable = requireACallable();
    var getBuiltIn = requireGetBuiltIn();
    var newPromiseCapabilityModule = requireNewPromiseCapability();
    var perform = requirePerform();
    var iterate = requireIterate();
    var PROMISE_STATICS_INCORRECT_ITERATION = requirePromiseStaticsIncorrectIteration();
    var PROMISE_ANY_ERROR = 'No one promise resolved';
    $({
      target: 'Promise',
      stat: true,
      forced: PROMISE_STATICS_INCORRECT_ITERATION
    }, {
      any: function any(iterable) {
        var C = this;
        var AggregateError = getBuiltIn('AggregateError');
        var capability = newPromiseCapabilityModule.f(C);
        var resolve = capability.resolve;
        var reject = capability.reject;
        var result = perform(function () {
          var promiseResolve = aCallable(C.resolve);
          var errors = [];
          var counter = 0;
          var remaining = 1;
          var alreadyResolved = false;
          iterate(iterable, function (promise) {
            var index = counter++;
            var alreadyRejected = false;
            remaining++;
            call(promiseResolve, C, promise).then(function (value) {
              if (alreadyRejected || alreadyResolved) return;
              alreadyResolved = true;
              resolve(value);
            }, function (error) {
              if (alreadyRejected || alreadyResolved) return;
              alreadyRejected = true;
              errors[index] = error;
              --remaining || reject(new AggregateError(errors, PROMISE_ANY_ERROR));
            });
          });
          --remaining || reject(new AggregateError(errors, PROMISE_ANY_ERROR));
        });
        if (result.error) reject(result.value);
        return capability.promise;
      }
    });
    return es_promise_any;
  }
  var es_promise_finally = {};
  var hasRequiredEs_promise_finally;
  function requireEs_promise_finally() {
    if (hasRequiredEs_promise_finally) return es_promise_finally;
    hasRequiredEs_promise_finally = 1;
    var $ = require_export();
    var IS_PURE = requireIsPure();
    var NativePromiseConstructor = requirePromiseNativeConstructor();
    var fails = requireFails();
    var getBuiltIn = requireGetBuiltIn();
    var isCallable = requireIsCallable();
    var speciesConstructor = requireSpeciesConstructor();
    var promiseResolve = requirePromiseResolve();
    var defineBuiltIn = requireDefineBuiltIn();
    var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
    var NON_GENERIC = !!NativePromiseConstructor && fails(function () {
      NativePromisePrototype['finally'].call({
        then: function then() {}
      }, function () {});
    });
    $({
      target: 'Promise',
      proto: true,
      real: true,
      forced: NON_GENERIC
    }, {
      'finally': function _finally(onFinally) {
        var C = speciesConstructor(this, getBuiltIn('Promise'));
        var isFunction = isCallable(onFinally);
        return this.then(isFunction ? function (x) {
          return promiseResolve(C, onFinally()).then(function () {
            return x;
          });
        } : onFinally, isFunction ? function (e) {
          return promiseResolve(C, onFinally()).then(function () {
            throw e;
          });
        } : onFinally);
      }
    });
    if (!IS_PURE && isCallable(NativePromiseConstructor)) {
      var method = getBuiltIn('Promise').prototype['finally'];
      if (NativePromisePrototype['finally'] !== method) {
        defineBuiltIn(NativePromisePrototype, 'finally', method, {
          unsafe: true
        });
      }
    }
    return es_promise_finally;
  }
  var es_promise_try = {};
  var hasRequiredEs_promise_try;
  function requireEs_promise_try() {
    if (hasRequiredEs_promise_try) return es_promise_try;
    hasRequiredEs_promise_try = 1;
    var $ = require_export();
    var globalThis = requireGlobalThis();
    var apply = requireFunctionApply();
    var slice = requireArraySlice();
    var newPromiseCapabilityModule = requireNewPromiseCapability();
    var aCallable = requireACallable();
    var perform = requirePerform();
    var Promise = globalThis.Promise;
    var ACCEPT_ARGUMENTS = false;
    var FORCED = !Promise || !Promise['try'] || perform(function () {
      Promise['try'](function (argument) {
        ACCEPT_ARGUMENTS = argument === 8;
      }, 8);
    }).error || !ACCEPT_ARGUMENTS;
    $({
      target: 'Promise',
      stat: true,
      forced: FORCED
    }, {
      'try': function _try(callbackfn) {
        var args = arguments.length > 1 ? slice(arguments, 1) : [];
        var promiseCapability = newPromiseCapabilityModule.f(this);
        var result = perform(function () {
          return apply(aCallable(callbackfn), undefined, args);
        });
        (result.error ? promiseCapability.reject : promiseCapability.resolve)(result.value);
        return promiseCapability.promise;
      }
    });
    return es_promise_try;
  }
  var es_promise_withResolvers = {};
  var hasRequiredEs_promise_withResolvers;
  function requireEs_promise_withResolvers() {
    if (hasRequiredEs_promise_withResolvers) return es_promise_withResolvers;
    hasRequiredEs_promise_withResolvers = 1;
    var $ = require_export();
    var newPromiseCapabilityModule = requireNewPromiseCapability();
    $({
      target: 'Promise',
      stat: true
    }, {
      withResolvers: function withResolvers() {
        var promiseCapability = newPromiseCapabilityModule.f(this);
        return {
          promise: promiseCapability.promise,
          resolve: promiseCapability.resolve,
          reject: promiseCapability.reject
        };
      }
    });
    return es_promise_withResolvers;
  }
  var es_array_fromAsync = {};
  var asyncIteratorPrototype;
  var hasRequiredAsyncIteratorPrototype;
  function requireAsyncIteratorPrototype() {
    if (hasRequiredAsyncIteratorPrototype) return asyncIteratorPrototype;
    hasRequiredAsyncIteratorPrototype = 1;
    var globalThis = requireGlobalThis();
    var shared = requireSharedStore();
    var isCallable = requireIsCallable();
    var create = requireObjectCreate();
    var getPrototypeOf = requireObjectGetPrototypeOf();
    var defineBuiltIn = requireDefineBuiltIn();
    var wellKnownSymbol = requireWellKnownSymbol();
    var IS_PURE = requireIsPure();
    var USE_FUNCTION_CONSTRUCTOR = 'USE_FUNCTION_CONSTRUCTOR';
    var ASYNC_ITERATOR = wellKnownSymbol('asyncIterator');
    var AsyncIterator = globalThis.AsyncIterator;
    var PassedAsyncIteratorPrototype = shared.AsyncIteratorPrototype;
    var AsyncIteratorPrototype, prototype;
    if (PassedAsyncIteratorPrototype) {
      AsyncIteratorPrototype = PassedAsyncIteratorPrototype;
    } else if (isCallable(AsyncIterator)) {
      AsyncIteratorPrototype = AsyncIterator.prototype;
    } else if (shared[USE_FUNCTION_CONSTRUCTOR] || globalThis[USE_FUNCTION_CONSTRUCTOR]) {
      try {
        prototype = getPrototypeOf(getPrototypeOf(getPrototypeOf(Function('return async function*(){}()')())));
        if (getPrototypeOf(prototype) === Object.prototype) AsyncIteratorPrototype = prototype;
      } catch (error) {}
    }
    if (!AsyncIteratorPrototype) AsyncIteratorPrototype = {};else if (IS_PURE) AsyncIteratorPrototype = create(AsyncIteratorPrototype);
    if (!isCallable(AsyncIteratorPrototype[ASYNC_ITERATOR])) {
      defineBuiltIn(AsyncIteratorPrototype, ASYNC_ITERATOR, function () {
        return this;
      });
    }
    asyncIteratorPrototype = AsyncIteratorPrototype;
    return asyncIteratorPrototype;
  }
  var asyncFromSyncIterator;
  var hasRequiredAsyncFromSyncIterator;
  function requireAsyncFromSyncIterator() {
    if (hasRequiredAsyncFromSyncIterator) return asyncFromSyncIterator;
    hasRequiredAsyncFromSyncIterator = 1;
    var call = requireFunctionCall();
    var anObject = requireAnObject();
    var create = requireObjectCreate();
    var getMethod = requireGetMethod();
    var defineBuiltIns = requireDefineBuiltIns();
    var InternalStateModule = requireInternalState();
    var iteratorClose = requireIteratorClose();
    var getBuiltIn = requireGetBuiltIn();
    var AsyncIteratorPrototype = requireAsyncIteratorPrototype();
    var createIterResultObject = requireCreateIterResultObject();
    var Promise = getBuiltIn('Promise');
    var ASYNC_FROM_SYNC_ITERATOR = 'AsyncFromSyncIterator';
    var setInternalState = InternalStateModule.set;
    var getInternalState = InternalStateModule.getterFor(ASYNC_FROM_SYNC_ITERATOR);
    var asyncFromSyncIteratorContinuation = function asyncFromSyncIteratorContinuation(result, resolve, reject, syncIterator, closeOnRejection) {
      var done = result.done;
      Promise.resolve(result.value).then(function (value) {
        resolve(createIterResultObject(value, done));
      }, function (error) {
        if (!done && closeOnRejection) {
          try {
            iteratorClose(syncIterator, 'throw', error);
          } catch (error2) {
            error = error2;
          }
        }
        reject(error);
      });
    };
    var AsyncFromSyncIterator = function AsyncIterator(iteratorRecord) {
      iteratorRecord.type = ASYNC_FROM_SYNC_ITERATOR;
      setInternalState(this, iteratorRecord);
    };
    AsyncFromSyncIterator.prototype = defineBuiltIns(create(AsyncIteratorPrototype), {
      next: function next() {
        var state = getInternalState(this);
        return new Promise(function (resolve, reject) {
          var result = anObject(call(state.next, state.iterator));
          asyncFromSyncIteratorContinuation(result, resolve, reject, state.iterator, true);
        });
      },
      'return': function _return() {
        var iterator = getInternalState(this).iterator;
        return new Promise(function (resolve, reject) {
          var $return = getMethod(iterator, 'return');
          if ($return === undefined) return resolve(createIterResultObject(undefined, true));
          var result = anObject(call($return, iterator));
          asyncFromSyncIteratorContinuation(result, resolve, reject, iterator);
        });
      }
    });
    asyncFromSyncIterator = AsyncFromSyncIterator;
    return asyncFromSyncIterator;
  }
  var getAsyncIterator;
  var hasRequiredGetAsyncIterator;
  function requireGetAsyncIterator() {
    if (hasRequiredGetAsyncIterator) return getAsyncIterator;
    hasRequiredGetAsyncIterator = 1;
    var call = requireFunctionCall();
    var AsyncFromSyncIterator = requireAsyncFromSyncIterator();
    var anObject = requireAnObject();
    var getIterator = requireGetIterator();
    var getIteratorDirect = requireGetIteratorDirect();
    var getMethod = requireGetMethod();
    var wellKnownSymbol = requireWellKnownSymbol();
    var ASYNC_ITERATOR = wellKnownSymbol('asyncIterator');
    getAsyncIterator = function getAsyncIterator(it, usingIterator) {
      var method = arguments.length < 2 ? getMethod(it, ASYNC_ITERATOR) : usingIterator;
      return method ? anObject(call(method, it)) : new AsyncFromSyncIterator(getIteratorDirect(getIterator(it)));
    };
    return getAsyncIterator;
  }
  var asyncIteratorClose;
  var hasRequiredAsyncIteratorClose;
  function requireAsyncIteratorClose() {
    if (hasRequiredAsyncIteratorClose) return asyncIteratorClose;
    hasRequiredAsyncIteratorClose = 1;
    var call = requireFunctionCall();
    var getBuiltIn = requireGetBuiltIn();
    var getMethod = requireGetMethod();
    asyncIteratorClose = function asyncIteratorClose(iterator, method, argument, reject) {
      try {
        var returnMethod = getMethod(iterator, 'return');
        if (returnMethod) {
          return getBuiltIn('Promise').resolve(call(returnMethod, iterator)).then(function () {
            method(argument);
          }, function (error) {
            reject(error);
          });
        }
      } catch (error2) {
        return reject(error2);
      }
      method(argument);
    };
    return asyncIteratorClose;
  }
  var asyncIteratorIteration;
  var hasRequiredAsyncIteratorIteration;
  function requireAsyncIteratorIteration() {
    if (hasRequiredAsyncIteratorIteration) return asyncIteratorIteration;
    hasRequiredAsyncIteratorIteration = 1;
    var call = requireFunctionCall();
    var aCallable = requireACallable();
    var anObject = requireAnObject();
    var isObject = requireIsObject();
    var doesNotExceedSafeInteger = requireDoesNotExceedSafeInteger();
    var getBuiltIn = requireGetBuiltIn();
    var getIteratorDirect = requireGetIteratorDirect();
    var closeAsyncIteration = requireAsyncIteratorClose();
    var createMethod = function createMethod(TYPE) {
      var IS_TO_ARRAY = TYPE === 0;
      var IS_FOR_EACH = TYPE === 1;
      var IS_EVERY = TYPE === 2;
      var IS_SOME = TYPE === 3;
      return function (object, fn, target) {
        anObject(object);
        var MAPPING = fn !== undefined;
        if (MAPPING || !IS_TO_ARRAY) aCallable(fn);
        var record = getIteratorDirect(object);
        var Promise = getBuiltIn('Promise');
        var iterator = record.iterator;
        var next = record.next;
        var counter = 0;
        return new Promise(function (resolve, reject) {
          var ifAbruptCloseAsyncIterator = function ifAbruptCloseAsyncIterator(error) {
            closeAsyncIteration(iterator, reject, error, reject);
          };
          var _loop2 = function loop() {
            try {
              if (MAPPING) try {
                doesNotExceedSafeInteger(counter);
              } catch (error5) {
                ifAbruptCloseAsyncIterator(error5);
              }
              Promise.resolve(anObject(call(next, iterator))).then(function (step) {
                try {
                  if (anObject(step).done) {
                    if (IS_TO_ARRAY) {
                      target.length = counter;
                      resolve(target);
                    } else resolve(IS_SOME ? false : IS_EVERY || undefined);
                  } else {
                    var value = step.value;
                    try {
                      if (MAPPING) {
                        var result = fn(value, counter);
                        var handler = function handler($result) {
                          if (IS_FOR_EACH) {
                            _loop2();
                          } else if (IS_EVERY) {
                            $result ? _loop2() : closeAsyncIteration(iterator, resolve, false, reject);
                          } else if (IS_TO_ARRAY) {
                            try {
                              target[counter++] = $result;
                              _loop2();
                            } catch (error4) {
                              ifAbruptCloseAsyncIterator(error4);
                            }
                          } else {
                            $result ? closeAsyncIteration(iterator, resolve, IS_SOME || value, reject) : _loop2();
                          }
                        };
                        if (isObject(result)) Promise.resolve(result).then(handler, ifAbruptCloseAsyncIterator);else handler(result);
                      } else {
                        target[counter++] = value;
                        _loop2();
                      }
                    } catch (error3) {
                      ifAbruptCloseAsyncIterator(error3);
                    }
                  }
                } catch (error2) {
                  reject(error2);
                }
              }, reject);
            } catch (error) {
              reject(error);
            }
          };
          _loop2();
        });
      };
    };
    asyncIteratorIteration = {
      toArray: createMethod(0),
      forEach: createMethod(1),
      every: createMethod(2),
      some: createMethod(3),
      find: createMethod(4)
    };
    return asyncIteratorIteration;
  }
  var arrayFromAsync;
  var hasRequiredArrayFromAsync;
  function requireArrayFromAsync() {
    if (hasRequiredArrayFromAsync) return arrayFromAsync;
    hasRequiredArrayFromAsync = 1;
    var bind = requireFunctionBindContext();
    var uncurryThis = requireFunctionUncurryThis();
    var toObject = requireToObject();
    var isConstructor = requireIsConstructor();
    var getAsyncIterator = requireGetAsyncIterator();
    var getIterator = requireGetIterator();
    var getIteratorDirect = requireGetIteratorDirect();
    var getIteratorMethod = requireGetIteratorMethod();
    var getMethod = requireGetMethod();
    var getBuiltIn = requireGetBuiltIn();
    var getBuiltInPrototypeMethod = requireGetBuiltInPrototypeMethod();
    var wellKnownSymbol = requireWellKnownSymbol();
    var AsyncFromSyncIterator = requireAsyncFromSyncIterator();
    var toArray = requireAsyncIteratorIteration().toArray;
    var ASYNC_ITERATOR = wellKnownSymbol('asyncIterator');
    var arrayIterator = uncurryThis(getBuiltInPrototypeMethod('Array', 'values'));
    var arrayIteratorNext = uncurryThis(arrayIterator([]).next);
    var safeArrayIterator = function safeArrayIterator() {
      return new SafeArrayIterator(this);
    };
    var SafeArrayIterator = function SafeArrayIterator(O) {
      this.iterator = arrayIterator(O);
    };
    SafeArrayIterator.prototype.next = function () {
      return arrayIteratorNext(this.iterator);
    };
    arrayFromAsync = function fromAsync(asyncItems) {
      var C = this;
      var argumentsLength = arguments.length;
      var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
      var thisArg = argumentsLength > 2 ? arguments[2] : undefined;
      return new (getBuiltIn('Promise'))(function (resolve) {
        var O = toObject(asyncItems);
        if (mapfn !== undefined) mapfn = bind(mapfn, thisArg);
        var usingAsyncIterator = getMethod(O, ASYNC_ITERATOR);
        var usingSyncIterator = usingAsyncIterator ? undefined : getIteratorMethod(O) || safeArrayIterator;
        var A = isConstructor(C) ? new C() : [];
        var iterator = usingAsyncIterator ? getAsyncIterator(O, usingAsyncIterator) : new AsyncFromSyncIterator(getIteratorDirect(getIterator(O, usingSyncIterator)));
        resolve(toArray(iterator, mapfn, A));
      });
    };
    return arrayFromAsync;
  }
  var hasRequiredEs_array_fromAsync;
  function requireEs_array_fromAsync() {
    if (hasRequiredEs_array_fromAsync) return es_array_fromAsync;
    hasRequiredEs_array_fromAsync = 1;
    var $ = require_export();
    var fromAsync = requireArrayFromAsync();
    var fails = requireFails();
    var nativeFromAsync = Array.fromAsync;
    var INCORRECT_CONSTRUCTURING = !nativeFromAsync || fails(function () {
      var counter = 0;
      nativeFromAsync.call(function () {
        counter++;
        return [];
      }, {
        length: 0
      });
      return counter !== 1;
    });
    $({
      target: 'Array',
      stat: true,
      forced: INCORRECT_CONSTRUCTURING
    }, {
      fromAsync: fromAsync
    });
    return es_array_fromAsync;
  }
  var es_asyncDisposableStack_constructor = {};
  var hasRequiredEs_asyncDisposableStack_constructor;
  function requireEs_asyncDisposableStack_constructor() {
    if (hasRequiredEs_asyncDisposableStack_constructor) return es_asyncDisposableStack_constructor;
    hasRequiredEs_asyncDisposableStack_constructor = 1;
    var $ = require_export();
    var DESCRIPTORS = requireDescriptors();
    var getBuiltIn = requireGetBuiltIn();
    var aCallable = requireACallable();
    var anInstance = requireAnInstance();
    var defineBuiltIn = requireDefineBuiltIn();
    var defineBuiltIns = requireDefineBuiltIns();
    var defineBuiltInAccessor = requireDefineBuiltInAccessor();
    var wellKnownSymbol = requireWellKnownSymbol();
    var InternalStateModule = requireInternalState();
    var addDisposableResource = requireAddDisposableResource();
    var V8_VERSION = requireEnvironmentV8Version();
    var Promise = getBuiltIn('Promise');
    var SuppressedError = getBuiltIn('SuppressedError');
    var $ReferenceError = ReferenceError;
    var ASYNC_DISPOSE = wellKnownSymbol('asyncDispose');
    var TO_STRING_TAG = wellKnownSymbol('toStringTag');
    var ASYNC_DISPOSABLE_STACK = 'AsyncDisposableStack';
    var setInternalState = InternalStateModule.set;
    var getAsyncDisposableStackInternalState = InternalStateModule.getterFor(ASYNC_DISPOSABLE_STACK);
    var HINT = 'async-dispose';
    var DISPOSED = 'disposed';
    var PENDING = 'pending';
    var getPendingAsyncDisposableStackInternalState = function getPendingAsyncDisposableStackInternalState(stack) {
      var internalState = getAsyncDisposableStackInternalState(stack);
      if (internalState.state === DISPOSED) throw new $ReferenceError(ASYNC_DISPOSABLE_STACK + ' already disposed');
      return internalState;
    };
    var $AsyncDisposableStack = function AsyncDisposableStack() {
      setInternalState(anInstance(this, AsyncDisposableStackPrototype), {
        type: ASYNC_DISPOSABLE_STACK,
        state: PENDING,
        stack: []
      });
      if (!DESCRIPTORS) this.disposed = false;
    };
    var AsyncDisposableStackPrototype = $AsyncDisposableStack.prototype;
    defineBuiltIns(AsyncDisposableStackPrototype, {
      disposeAsync: function disposeAsync() {
        var asyncDisposableStack = this;
        return new Promise(function (resolve, reject) {
          var internalState = getAsyncDisposableStackInternalState(asyncDisposableStack);
          if (internalState.state === DISPOSED) return resolve(undefined);
          internalState.state = DISPOSED;
          if (!DESCRIPTORS) asyncDisposableStack.disposed = true;
          var stack = internalState.stack;
          var i = stack.length;
          var thrown = false;
          var suppressed;
          var handleError = function handleError(result) {
            if (thrown) {
              suppressed = new SuppressedError(result, suppressed);
            } else {
              thrown = true;
              suppressed = result;
            }
            _loop3();
          };
          var _loop3 = function loop() {
            if (i) {
              var disposeMethod = stack[--i];
              stack[i] = null;
              try {
                Promise.resolve(disposeMethod()).then(_loop3, handleError);
              } catch (error) {
                handleError(error);
              }
            } else {
              internalState.stack = null;
              thrown ? reject(suppressed) : resolve(undefined);
            }
          };
          _loop3();
        });
      },
      use: function use(value) {
        addDisposableResource(getPendingAsyncDisposableStackInternalState(this), value, HINT);
        return value;
      },
      adopt: function adopt(value, onDispose) {
        var internalState = getPendingAsyncDisposableStackInternalState(this);
        aCallable(onDispose);
        addDisposableResource(internalState, undefined, HINT, function () {
          return onDispose(value);
        });
        return value;
      },
      defer: function defer(onDispose) {
        var internalState = getPendingAsyncDisposableStackInternalState(this);
        aCallable(onDispose);
        addDisposableResource(internalState, undefined, HINT, onDispose);
      },
      move: function move() {
        var internalState = getPendingAsyncDisposableStackInternalState(this);
        var newAsyncDisposableStack = new $AsyncDisposableStack();
        getAsyncDisposableStackInternalState(newAsyncDisposableStack).stack = internalState.stack;
        internalState.stack = [];
        internalState.state = DISPOSED;
        if (!DESCRIPTORS) this.disposed = true;
        return newAsyncDisposableStack;
      }
    });
    if (DESCRIPTORS) defineBuiltInAccessor(AsyncDisposableStackPrototype, 'disposed', {
      configurable: true,
      get: function disposed() {
        return getAsyncDisposableStackInternalState(this).state === DISPOSED;
      }
    });
    defineBuiltIn(AsyncDisposableStackPrototype, ASYNC_DISPOSE, AsyncDisposableStackPrototype.disposeAsync, {
      name: 'disposeAsync'
    });
    defineBuiltIn(AsyncDisposableStackPrototype, TO_STRING_TAG, ASYNC_DISPOSABLE_STACK, {
      nonWritable: true
    });
    var SYNC_DISPOSE_RETURNING_PROMISE_RESOLUTION_BUG = V8_VERSION && V8_VERSION < 136;
    $({
      global: true,
      constructor: true,
      forced: SYNC_DISPOSE_RETURNING_PROMISE_RESOLUTION_BUG
    }, {
      AsyncDisposableStack: $AsyncDisposableStack
    });
    return es_asyncDisposableStack_constructor;
  }
  var es_asyncIterator_asyncDispose = {};
  var hasRequiredEs_asyncIterator_asyncDispose;
  function requireEs_asyncIterator_asyncDispose() {
    if (hasRequiredEs_asyncIterator_asyncDispose) return es_asyncIterator_asyncDispose;
    hasRequiredEs_asyncIterator_asyncDispose = 1;
    var call = requireFunctionCall();
    var defineBuiltIn = requireDefineBuiltIn();
    var getBuiltIn = requireGetBuiltIn();
    var getMethod = requireGetMethod();
    var hasOwn = requireHasOwnProperty();
    var wellKnownSymbol = requireWellKnownSymbol();
    var AsyncIteratorPrototype = requireAsyncIteratorPrototype();
    var ASYNC_DISPOSE = wellKnownSymbol('asyncDispose');
    var Promise = getBuiltIn('Promise');
    if (!hasOwn(AsyncIteratorPrototype, ASYNC_DISPOSE)) {
      defineBuiltIn(AsyncIteratorPrototype, ASYNC_DISPOSE, function () {
        var O = this;
        return new Promise(function (resolve, reject) {
          var $return = getMethod(O, 'return');
          if ($return) {
            Promise.resolve(call($return, O)).then(function () {
              resolve(undefined);
            }, reject);
          } else resolve(undefined);
        });
      });
    }
    return es_asyncIterator_asyncDispose;
  }
  var es_reflect_apply = {};
  var hasRequiredEs_reflect_apply;
  function requireEs_reflect_apply() {
    if (hasRequiredEs_reflect_apply) return es_reflect_apply;
    hasRequiredEs_reflect_apply = 1;
    var $ = require_export();
    var functionApply = requireFunctionApply();
    var aCallable = requireACallable();
    var anObject = requireAnObject();
    var fails = requireFails();
    var OPTIONAL_ARGUMENTS_LIST = !fails(function () {
      Reflect.apply(function () {});
    });
    $({
      target: 'Reflect',
      stat: true,
      forced: OPTIONAL_ARGUMENTS_LIST
    }, {
      apply: function apply(target, thisArgument, argumentsList) {
        return functionApply(aCallable(target), thisArgument, anObject(argumentsList));
      }
    });
    return es_reflect_apply;
  }
  var es_reflect_construct = {};
  var hasRequiredEs_reflect_construct;
  function requireEs_reflect_construct() {
    if (hasRequiredEs_reflect_construct) return es_reflect_construct;
    hasRequiredEs_reflect_construct = 1;
    var $ = require_export();
    var getBuiltIn = requireGetBuiltIn();
    var apply = requireFunctionApply();
    var bind = requireFunctionBind();
    var aConstructor = requireAConstructor();
    var anObject = requireAnObject();
    var isObject = requireIsObject();
    var create = requireObjectCreate();
    var fails = requireFails();
    var nativeConstruct = getBuiltIn('Reflect', 'construct');
    var ObjectPrototype = Object.prototype;
    var push = [].push;
    var NEW_TARGET_BUG = fails(function () {
      function F() {}
      return !(nativeConstruct(function () {}, [], F) instanceof F);
    });
    var ARGS_BUG = !fails(function () {
      nativeConstruct(function () {});
    });
    var FORCED = NEW_TARGET_BUG || ARGS_BUG;
    $({
      target: 'Reflect',
      stat: true,
      forced: FORCED,
      sham: FORCED
    }, {
      construct: function construct(Target, args) {
        aConstructor(Target);
        anObject(args);
        var newTarget = arguments.length < 3 ? Target : aConstructor(arguments[2]);
        if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);
        if (Target === newTarget) {
          switch (args.length) {
            case 0:
              return new Target();
            case 1:
              return new Target(args[0]);
            case 2:
              return new Target(args[0], args[1]);
            case 3:
              return new Target(args[0], args[1], args[2]);
            case 4:
              return new Target(args[0], args[1], args[2], args[3]);
          }
          var $args = [null];
          apply(push, $args, args);
          return new (apply(bind, Target, $args))();
        }
        var proto = newTarget.prototype;
        var instance = create(isObject(proto) ? proto : ObjectPrototype);
        var result = apply(Target, instance, args);
        return isObject(result) ? result : instance;
      }
    });
    return es_reflect_construct;
  }
  var es_reflect_defineProperty = {};
  var hasRequiredEs_reflect_defineProperty;
  function requireEs_reflect_defineProperty() {
    if (hasRequiredEs_reflect_defineProperty) return es_reflect_defineProperty;
    hasRequiredEs_reflect_defineProperty = 1;
    var $ = require_export();
    var DESCRIPTORS = requireDescriptors();
    var anObject = requireAnObject();
    var toPropertyKey = requireToPropertyKey();
    var definePropertyModule = requireObjectDefineProperty();
    var fails = requireFails();
    var ERROR_INSTEAD_OF_FALSE = fails(function () {
      Reflect.defineProperty(definePropertyModule.f({}, 1, {
        value: 1
      }), 1, {
        value: 2
      });
    });
    $({
      target: 'Reflect',
      stat: true,
      forced: ERROR_INSTEAD_OF_FALSE,
      sham: !DESCRIPTORS
    }, {
      defineProperty: function defineProperty(target, propertyKey, attributes) {
        anObject(target);
        var key = toPropertyKey(propertyKey);
        anObject(attributes);
        try {
          definePropertyModule.f(target, key, attributes);
          return true;
        } catch (error) {
          return false;
        }
      }
    });
    return es_reflect_defineProperty;
  }
  var es_reflect_deleteProperty = {};
  var hasRequiredEs_reflect_deleteProperty;
  function requireEs_reflect_deleteProperty() {
    if (hasRequiredEs_reflect_deleteProperty) return es_reflect_deleteProperty;
    hasRequiredEs_reflect_deleteProperty = 1;
    var $ = require_export();
    var anObject = requireAnObject();
    var getOwnPropertyDescriptor = requireObjectGetOwnPropertyDescriptor().f;
    $({
      target: 'Reflect',
      stat: true
    }, {
      deleteProperty: function deleteProperty(target, propertyKey) {
        var descriptor = getOwnPropertyDescriptor(anObject(target), propertyKey);
        return descriptor && !descriptor.configurable ? false : delete target[propertyKey];
      }
    });
    return es_reflect_deleteProperty;
  }
  var es_reflect_get = {};
  var isDataDescriptor;
  var hasRequiredIsDataDescriptor;
  function requireIsDataDescriptor() {
    if (hasRequiredIsDataDescriptor) return isDataDescriptor;
    hasRequiredIsDataDescriptor = 1;
    var hasOwn = requireHasOwnProperty();
    isDataDescriptor = function isDataDescriptor(descriptor) {
      return descriptor !== undefined && (hasOwn(descriptor, 'value') || hasOwn(descriptor, 'writable'));
    };
    return isDataDescriptor;
  }
  var hasRequiredEs_reflect_get;
  function requireEs_reflect_get() {
    if (hasRequiredEs_reflect_get) return es_reflect_get;
    hasRequiredEs_reflect_get = 1;
    var $ = require_export();
    var call = requireFunctionCall();
    var isObject = requireIsObject();
    var anObject = requireAnObject();
    var isDataDescriptor = requireIsDataDescriptor();
    var getOwnPropertyDescriptorModule = requireObjectGetOwnPropertyDescriptor();
    var getPrototypeOf = requireObjectGetPrototypeOf();
    function get(target, propertyKey) {
      var receiver = arguments.length < 3 ? target : arguments[2];
      var descriptor, prototype;
      if (anObject(target) === receiver) return target[propertyKey];
      descriptor = getOwnPropertyDescriptorModule.f(target, propertyKey);
      if (descriptor) return isDataDescriptor(descriptor) ? descriptor.value : descriptor.get === undefined ? undefined : call(descriptor.get, receiver);
      if (isObject(prototype = getPrototypeOf(target))) return get(prototype, propertyKey, receiver);
    }
    $({
      target: 'Reflect',
      stat: true
    }, {
      get: get
    });
    return es_reflect_get;
  }
  var es_reflect_getOwnPropertyDescriptor = {};
  var hasRequiredEs_reflect_getOwnPropertyDescriptor;
  function requireEs_reflect_getOwnPropertyDescriptor() {
    if (hasRequiredEs_reflect_getOwnPropertyDescriptor) return es_reflect_getOwnPropertyDescriptor;
    hasRequiredEs_reflect_getOwnPropertyDescriptor = 1;
    var $ = require_export();
    var DESCRIPTORS = requireDescriptors();
    var anObject = requireAnObject();
    var getOwnPropertyDescriptorModule = requireObjectGetOwnPropertyDescriptor();
    $({
      target: 'Reflect',
      stat: true,
      sham: !DESCRIPTORS
    }, {
      getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
        return getOwnPropertyDescriptorModule.f(anObject(target), propertyKey);
      }
    });
    return es_reflect_getOwnPropertyDescriptor;
  }
  var es_reflect_getPrototypeOf = {};
  var hasRequiredEs_reflect_getPrototypeOf;
  function requireEs_reflect_getPrototypeOf() {
    if (hasRequiredEs_reflect_getPrototypeOf) return es_reflect_getPrototypeOf;
    hasRequiredEs_reflect_getPrototypeOf = 1;
    var $ = require_export();
    var anObject = requireAnObject();
    var objectGetPrototypeOf = requireObjectGetPrototypeOf();
    var CORRECT_PROTOTYPE_GETTER = requireCorrectPrototypeGetter();
    $({
      target: 'Reflect',
      stat: true,
      sham: !CORRECT_PROTOTYPE_GETTER
    }, {
      getPrototypeOf: function getPrototypeOf(target) {
        return objectGetPrototypeOf(anObject(target));
      }
    });
    return es_reflect_getPrototypeOf;
  }
  var es_reflect_has = {};
  var hasRequiredEs_reflect_has;
  function requireEs_reflect_has() {
    if (hasRequiredEs_reflect_has) return es_reflect_has;
    hasRequiredEs_reflect_has = 1;
    var $ = require_export();
    $({
      target: 'Reflect',
      stat: true
    }, {
      has: function has(target, propertyKey) {
        return propertyKey in target;
      }
    });
    return es_reflect_has;
  }
  var es_reflect_isExtensible = {};
  var hasRequiredEs_reflect_isExtensible;
  function requireEs_reflect_isExtensible() {
    if (hasRequiredEs_reflect_isExtensible) return es_reflect_isExtensible;
    hasRequiredEs_reflect_isExtensible = 1;
    var $ = require_export();
    var anObject = requireAnObject();
    var $isExtensible = requireObjectIsExtensible();
    $({
      target: 'Reflect',
      stat: true
    }, {
      isExtensible: function isExtensible(target) {
        anObject(target);
        return $isExtensible(target);
      }
    });
    return es_reflect_isExtensible;
  }
  var es_reflect_ownKeys = {};
  var hasRequiredEs_reflect_ownKeys;
  function requireEs_reflect_ownKeys() {
    if (hasRequiredEs_reflect_ownKeys) return es_reflect_ownKeys;
    hasRequiredEs_reflect_ownKeys = 1;
    var $ = require_export();
    var ownKeys = requireOwnKeys();
    $({
      target: 'Reflect',
      stat: true
    }, {
      ownKeys: ownKeys
    });
    return es_reflect_ownKeys;
  }
  var es_reflect_preventExtensions = {};
  var hasRequiredEs_reflect_preventExtensions;
  function requireEs_reflect_preventExtensions() {
    if (hasRequiredEs_reflect_preventExtensions) return es_reflect_preventExtensions;
    hasRequiredEs_reflect_preventExtensions = 1;
    var $ = require_export();
    var getBuiltIn = requireGetBuiltIn();
    var anObject = requireAnObject();
    var FREEZING = requireFreezing();
    $({
      target: 'Reflect',
      stat: true,
      sham: !FREEZING
    }, {
      preventExtensions: function preventExtensions(target) {
        anObject(target);
        try {
          var objectPreventExtensions = getBuiltIn('Object', 'preventExtensions');
          if (objectPreventExtensions) objectPreventExtensions(target);
          return true;
        } catch (error) {
          return false;
        }
      }
    });
    return es_reflect_preventExtensions;
  }
  var es_reflect_set = {};
  var hasRequiredEs_reflect_set;
  function requireEs_reflect_set() {
    if (hasRequiredEs_reflect_set) return es_reflect_set;
    hasRequiredEs_reflect_set = 1;
    var $ = require_export();
    var call = requireFunctionCall();
    var anObject = requireAnObject();
    var isObject = requireIsObject();
    var isDataDescriptor = requireIsDataDescriptor();
    var fails = requireFails();
    var definePropertyModule = requireObjectDefineProperty();
    var getOwnPropertyDescriptorModule = requireObjectGetOwnPropertyDescriptor();
    var getPrototypeOf = requireObjectGetPrototypeOf();
    var createPropertyDescriptor = requireCreatePropertyDescriptor();
    function set(target, propertyKey, V) {
      var receiver = arguments.length < 4 ? target : arguments[3];
      var ownDescriptor = getOwnPropertyDescriptorModule.f(anObject(target), propertyKey);
      var existingDescriptor, prototype, setter;
      if (!ownDescriptor) {
        if (isObject(prototype = getPrototypeOf(target))) {
          return set(prototype, propertyKey, V, receiver);
        }
        ownDescriptor = createPropertyDescriptor(0);
      }
      if (isDataDescriptor(ownDescriptor)) {
        if (ownDescriptor.writable === false || !isObject(receiver)) return false;
        if (existingDescriptor = getOwnPropertyDescriptorModule.f(receiver, propertyKey)) {
          if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
          existingDescriptor.value = V;
          definePropertyModule.f(receiver, propertyKey, existingDescriptor);
        } else definePropertyModule.f(receiver, propertyKey, createPropertyDescriptor(0, V));
      } else {
        setter = ownDescriptor.set;
        if (setter === undefined) return false;
        call(setter, receiver, V);
      }
      return true;
    }
    var MS_EDGE_BUG = fails(function () {
      var Constructor = function Constructor() {};
      var object = definePropertyModule.f(new Constructor(), 'a', {
        configurable: true
      });
      return Reflect.set(Constructor.prototype, 'a', 1, object) !== false;
    });
    $({
      target: 'Reflect',
      stat: true,
      forced: MS_EDGE_BUG
    }, {
      set: set
    });
    return es_reflect_set;
  }
  var es_reflect_setPrototypeOf = {};
  var hasRequiredEs_reflect_setPrototypeOf;
  function requireEs_reflect_setPrototypeOf() {
    if (hasRequiredEs_reflect_setPrototypeOf) return es_reflect_setPrototypeOf;
    hasRequiredEs_reflect_setPrototypeOf = 1;
    var $ = require_export();
    var anObject = requireAnObject();
    var aPossiblePrototype = requireAPossiblePrototype();
    var objectSetPrototypeOf = requireObjectSetPrototypeOf();
    if (objectSetPrototypeOf) $({
      target: 'Reflect',
      stat: true
    }, {
      setPrototypeOf: function setPrototypeOf(target, proto) {
        anObject(target);
        aPossiblePrototype(proto);
        try {
          objectSetPrototypeOf(target, proto);
          return true;
        } catch (error) {
          return false;
        }
      }
    });
    return es_reflect_setPrototypeOf;
  }
  var es_reflect_toStringTag = {};
  var hasRequiredEs_reflect_toStringTag;
  function requireEs_reflect_toStringTag() {
    if (hasRequiredEs_reflect_toStringTag) return es_reflect_toStringTag;
    hasRequiredEs_reflect_toStringTag = 1;
    var $ = require_export();
    var globalThis = requireGlobalThis();
    var setToStringTag = requireSetToStringTag();
    $({
      global: true
    }, {
      Reflect: {}
    });
    setToStringTag(globalThis.Reflect, 'Reflect', true);
    return es_reflect_toStringTag;
  }
  var es_regexp_constructor = {};
  var isRegexp;
  var hasRequiredIsRegexp;
  function requireIsRegexp() {
    if (hasRequiredIsRegexp) return isRegexp;
    hasRequiredIsRegexp = 1;
    var isObject = requireIsObject();
    var classof = requireClassofRaw();
    var wellKnownSymbol = requireWellKnownSymbol();
    var MATCH = wellKnownSymbol('match');
    isRegexp = function isRegexp(it) {
      var isRegExp;
      return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) === 'RegExp');
    };
    return isRegexp;
  }
  var regexpFlagsDetection;
  var hasRequiredRegexpFlagsDetection;
  function requireRegexpFlagsDetection() {
    if (hasRequiredRegexpFlagsDetection) return regexpFlagsDetection;
    hasRequiredRegexpFlagsDetection = 1;
    var globalThis = requireGlobalThis();
    var fails = requireFails();
    var RegExp = globalThis.RegExp;
    var FLAGS_GETTER_IS_CORRECT = !fails(function () {
      var INDICES_SUPPORT = true;
      try {
        RegExp('.', 'd');
      } catch (error) {
        INDICES_SUPPORT = false;
      }
      var O = {};
      var calls = '';
      var expected = INDICES_SUPPORT ? 'dgimsy' : 'gimsy';
      var addGetter = function addGetter(key, chr) {
        Object.defineProperty(O, key, {
          get: function get() {
            calls += chr;
            return true;
          }
        });
      };
      var pairs = {
        dotAll: 's',
        global: 'g',
        ignoreCase: 'i',
        multiline: 'm',
        sticky: 'y'
      };
      if (INDICES_SUPPORT) pairs.hasIndices = 'd';
      for (var key in pairs) addGetter(key, pairs[key]);
      var result = Object.getOwnPropertyDescriptor(RegExp.prototype, 'flags').get.call(O);
      return result !== expected || calls !== expected;
    });
    regexpFlagsDetection = {
      correct: FLAGS_GETTER_IS_CORRECT
    };
    return regexpFlagsDetection;
  }
  var regexpFlags;
  var hasRequiredRegexpFlags;
  function requireRegexpFlags() {
    if (hasRequiredRegexpFlags) return regexpFlags;
    hasRequiredRegexpFlags = 1;
    var anObject = requireAnObject();
    regexpFlags = function regexpFlags() {
      var that = anObject(this);
      var result = '';
      if (that.hasIndices) result += 'd';
      if (that.global) result += 'g';
      if (that.ignoreCase) result += 'i';
      if (that.multiline) result += 'm';
      if (that.dotAll) result += 's';
      if (that.unicode) result += 'u';
      if (that.unicodeSets) result += 'v';
      if (that.sticky) result += 'y';
      return result;
    };
    return regexpFlags;
  }
  var regexpGetFlags;
  var hasRequiredRegexpGetFlags;
  function requireRegexpGetFlags() {
    if (hasRequiredRegexpGetFlags) return regexpGetFlags;
    hasRequiredRegexpGetFlags = 1;
    var call = requireFunctionCall();
    var hasOwn = requireHasOwnProperty();
    var isPrototypeOf = requireObjectIsPrototypeOf();
    var regExpFlagsDetection = requireRegexpFlagsDetection();
    var regExpFlagsGetterImplementation = requireRegexpFlags();
    var RegExpPrototype = RegExp.prototype;
    regexpGetFlags = regExpFlagsDetection.correct ? function (it) {
      return it.flags;
    } : function (it) {
      return !regExpFlagsDetection.correct && isPrototypeOf(RegExpPrototype, it) && !hasOwn(it, 'flags') ? call(regExpFlagsGetterImplementation, it) : it.flags;
    };
    return regexpGetFlags;
  }
  var regexpStickyHelpers;
  var hasRequiredRegexpStickyHelpers;
  function requireRegexpStickyHelpers() {
    if (hasRequiredRegexpStickyHelpers) return regexpStickyHelpers;
    hasRequiredRegexpStickyHelpers = 1;
    var fails = requireFails();
    var globalThis = requireGlobalThis();
    var $RegExp = globalThis.RegExp;
    var UNSUPPORTED_Y = fails(function () {
      var re = $RegExp('a', 'y');
      re.lastIndex = 2;
      return re.exec('abcd') !== null;
    });
    var MISSED_STICKY = UNSUPPORTED_Y || fails(function () {
      return !$RegExp('a', 'y').sticky;
    });
    var BROKEN_CARET = UNSUPPORTED_Y || fails(function () {
      var re = $RegExp('^r', 'gy');
      re.lastIndex = 2;
      return re.exec('str') !== null;
    });
    regexpStickyHelpers = {
      BROKEN_CARET: BROKEN_CARET,
      MISSED_STICKY: MISSED_STICKY,
      UNSUPPORTED_Y: UNSUPPORTED_Y
    };
    return regexpStickyHelpers;
  }
  var regexpUnsupportedDotAll;
  var hasRequiredRegexpUnsupportedDotAll;
  function requireRegexpUnsupportedDotAll() {
    if (hasRequiredRegexpUnsupportedDotAll) return regexpUnsupportedDotAll;
    hasRequiredRegexpUnsupportedDotAll = 1;
    var fails = requireFails();
    var globalThis = requireGlobalThis();
    var $RegExp = globalThis.RegExp;
    regexpUnsupportedDotAll = fails(function () {
      var re = $RegExp('.', 's');
      return !(re.dotAll && re.test('\n') && re.flags === 's');
    });
    return regexpUnsupportedDotAll;
  }
  var regexpUnsupportedNcg;
  var hasRequiredRegexpUnsupportedNcg;
  function requireRegexpUnsupportedNcg() {
    if (hasRequiredRegexpUnsupportedNcg) return regexpUnsupportedNcg;
    hasRequiredRegexpUnsupportedNcg = 1;
    var fails = requireFails();
    var globalThis = requireGlobalThis();
    var $RegExp = globalThis.RegExp;
    regexpUnsupportedNcg = fails(function () {
      var re = $RegExp('(?<a>b)', 'g');
      return re.exec('b').groups.a !== 'b' || 'b'.replace(re, '$<a>c') !== 'bc';
    });
    return regexpUnsupportedNcg;
  }
  var hasRequiredEs_regexp_constructor;
  function requireEs_regexp_constructor() {
    if (hasRequiredEs_regexp_constructor) return es_regexp_constructor;
    hasRequiredEs_regexp_constructor = 1;
    var DESCRIPTORS = requireDescriptors();
    var globalThis = requireGlobalThis();
    var uncurryThis = requireFunctionUncurryThis();
    var isForced = requireIsForced();
    var inheritIfRequired = requireInheritIfRequired();
    var createNonEnumerableProperty = requireCreateNonEnumerableProperty();
    var create = requireObjectCreate();
    var getOwnPropertyNames = requireObjectGetOwnPropertyNames().f;
    var isPrototypeOf = requireObjectIsPrototypeOf();
    var isRegExp = requireIsRegexp();
    var toString = requireToString();
    var getRegExpFlags = requireRegexpGetFlags();
    var stickyHelpers = requireRegexpStickyHelpers();
    var proxyAccessor = requireProxyAccessor();
    var defineBuiltIn = requireDefineBuiltIn();
    var fails = requireFails();
    var hasOwn = requireHasOwnProperty();
    var enforceInternalState = requireInternalState().enforce;
    var setSpecies = requireSetSpecies();
    var wellKnownSymbol = requireWellKnownSymbol();
    var UNSUPPORTED_DOT_ALL = requireRegexpUnsupportedDotAll();
    var UNSUPPORTED_NCG = requireRegexpUnsupportedNcg();
    var MATCH = wellKnownSymbol('match');
    var NativeRegExp = globalThis.RegExp;
    var RegExpPrototype = NativeRegExp.prototype;
    var SyntaxError = globalThis.SyntaxError;
    var exec = uncurryThis(RegExpPrototype.exec);
    var charAt = uncurryThis(''.charAt);
    var replace = uncurryThis(''.replace);
    var stringIndexOf = uncurryThis(''.indexOf);
    var stringSlice = uncurryThis(''.slice);
    var IS_NCG = /^\?<[^\s\d!#%&*+<=>@^][^\s!#%&*+<=>@^]*>/;
    var re1 = /a/g;
    var re2 = /a/g;
    var CORRECT_NEW = new NativeRegExp(re1) !== re1;
    var MISSED_STICKY = stickyHelpers.MISSED_STICKY;
    var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
    var BASE_FORCED = DESCRIPTORS && (!CORRECT_NEW || MISSED_STICKY || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG || fails(function () {
      re2[MATCH] = false;
      return NativeRegExp(re1) !== re1 || NativeRegExp(re2) === re2 || String(NativeRegExp(re1, 'i')) !== '/a/i';
    }));
    var handleDotAll = function handleDotAll(string) {
      var length = string.length;
      var index = 0;
      var result = '';
      var brackets = false;
      var chr;
      for (; index <= length; index++) {
        chr = charAt(string, index);
        if (chr === '\\') {
          result += chr + charAt(string, ++index);
          continue;
        }
        if (!brackets && chr === '.') {
          result += '[\\s\\S]';
        } else {
          if (chr === '[') {
            brackets = true;
          } else if (chr === ']') {
            brackets = false;
          }
          result += chr;
        }
      }
      return result;
    };
    var handleNCG = function handleNCG(string) {
      var length = string.length;
      var index = 0;
      var result = '';
      var named = [];
      var names = create(null);
      var brackets = false;
      var ncg = false;
      var groupid = 0;
      var groupname = '';
      var chr;
      for (; index <= length; index++) {
        chr = charAt(string, index);
        if (chr === '\\') {
          chr += charAt(string, ++index);
        } else if (chr === ']') {
          brackets = false;
        } else if (!brackets) switch (true) {
          case chr === '[':
            brackets = true;
            break;
          case chr === '(':
            result += chr;
            if (stringSlice(string, index + 1, index + 3) === '?:') {
              continue;
            }
            if (exec(IS_NCG, stringSlice(string, index + 1))) {
              index += 2;
              ncg = true;
            }
            groupid++;
            continue;
          case chr === '>' && ncg:
            if (groupname === '' || hasOwn(names, groupname)) {
              throw new SyntaxError('Invalid capture group name');
            }
            names[groupname] = true;
            named[named.length] = [groupname, groupid];
            ncg = false;
            groupname = '';
            continue;
        }
        if (ncg) groupname += chr;else result += chr;
      }
      return [result, named];
    };
    if (isForced('RegExp', BASE_FORCED)) {
      var RegExpWrapper = function RegExp(pattern, flags) {
        var thisIsRegExp = isPrototypeOf(RegExpPrototype, this);
        var patternIsRegExp = isRegExp(pattern);
        var flagsAreUndefined = flags === undefined;
        var groups = [];
        var rawPattern = pattern;
        var rawFlags, dotAll, sticky, handled, result, state;
        if (!thisIsRegExp && patternIsRegExp && flagsAreUndefined && pattern.constructor === RegExpWrapper) {
          return pattern;
        }
        if (patternIsRegExp || isPrototypeOf(RegExpPrototype, pattern)) {
          pattern = pattern.source;
          if (flagsAreUndefined) flags = getRegExpFlags(rawPattern);
        }
        pattern = pattern === undefined ? '' : toString(pattern);
        flags = flags === undefined ? '' : toString(flags);
        rawPattern = pattern;
        if (UNSUPPORTED_DOT_ALL && 'dotAll' in re1) {
          dotAll = !!flags && stringIndexOf(flags, 's') > -1;
          if (dotAll) flags = replace(flags, /s/g, '');
        }
        rawFlags = flags;
        if (MISSED_STICKY && 'sticky' in re1) {
          sticky = !!flags && stringIndexOf(flags, 'y') > -1;
          if (sticky && UNSUPPORTED_Y) flags = replace(flags, /y/g, '');
        }
        if (UNSUPPORTED_NCG) {
          handled = handleNCG(pattern);
          pattern = handled[0];
          groups = handled[1];
        }
        result = inheritIfRequired(NativeRegExp(pattern, flags), thisIsRegExp ? this : RegExpPrototype, RegExpWrapper);
        if (dotAll || sticky || groups.length) {
          state = enforceInternalState(result);
          if (dotAll) {
            state.dotAll = true;
            state.raw = RegExpWrapper(handleDotAll(pattern), rawFlags);
          }
          if (sticky) state.sticky = true;
          if (groups.length) state.groups = groups;
        }
        if (pattern !== rawPattern) try {
          createNonEnumerableProperty(result, 'source', rawPattern === '' ? '(?:)' : rawPattern);
        } catch (error) {}
        return result;
      };
      for (var keys = getOwnPropertyNames(NativeRegExp), index = 0; keys.length > index;) {
        proxyAccessor(RegExpWrapper, NativeRegExp, keys[index++]);
      }
      RegExpPrototype.constructor = RegExpWrapper;
      RegExpWrapper.prototype = RegExpPrototype;
      defineBuiltIn(globalThis, 'RegExp', RegExpWrapper, {
        constructor: true
      });
    }
    setSpecies('RegExp');
    return es_regexp_constructor;
  }
  var es_regexp_escape = {};
  var aString;
  var hasRequiredAString;
  function requireAString() {
    if (hasRequiredAString) return aString;
    hasRequiredAString = 1;
    var $TypeError = TypeError;
    aString = function aString(argument) {
      if (typeof argument == 'string') return argument;
      throw new $TypeError('Argument is not a string');
    };
    return aString;
  }
  var hasRequiredEs_regexp_escape;
  function requireEs_regexp_escape() {
    if (hasRequiredEs_regexp_escape) return es_regexp_escape;
    hasRequiredEs_regexp_escape = 1;
    var $ = require_export();
    var uncurryThis = requireFunctionUncurryThis();
    var aString = requireAString();
    var hasOwn = requireHasOwnProperty();
    var padStart = requireStringPad().start;
    var WHITESPACES = requireWhitespaces();
    var $Array = Array;
    var $escape = RegExp.escape;
    var charAt = uncurryThis(''.charAt);
    var charCodeAt = uncurryThis(''.charCodeAt);
    var numberToString = uncurryThis(1.1.toString);
    var join = uncurryThis([].join);
    var FIRST_DIGIT_OR_ASCII = /^[0-9a-z]/i;
    var SYNTAX_SOLIDUS = /^[$()*+./?[\\\]^{|}]/;
    var OTHER_PUNCTUATORS_AND_WHITESPACES = RegExp('^[!"#%&\',\\-:;<=>@`~' + WHITESPACES + ']');
    var exec = uncurryThis(FIRST_DIGIT_OR_ASCII.exec);
    var ControlEscape = {
      '\u0009': 't',
      '\u000A': 'n',
      '\u000B': 'v',
      '\u000C': 'f',
      '\u000D': 'r'
    };
    var escapeChar = function escapeChar(chr) {
      var hex = numberToString(charCodeAt(chr, 0), 16);
      return hex.length < 3 ? '\\x' + padStart(hex, 2, '0') : '\\u' + padStart(hex, 4, '0');
    };
    var FORCED = !$escape || $escape('ab') !== '\\x61b';
    $({
      target: 'RegExp',
      stat: true,
      forced: FORCED
    }, {
      escape: function escape(S) {
        aString(S);
        var length = S.length;
        var result = $Array(length);
        for (var i = 0; i < length; i++) {
          var chr = charAt(S, i);
          if (i === 0 && exec(FIRST_DIGIT_OR_ASCII, chr)) {
            result[i] = escapeChar(chr);
          } else if (hasOwn(ControlEscape, chr)) {
            result[i] = '\\' + ControlEscape[chr];
          } else if (exec(SYNTAX_SOLIDUS, chr)) {
            result[i] = '\\' + chr;
          } else if (exec(OTHER_PUNCTUATORS_AND_WHITESPACES, chr)) {
            result[i] = escapeChar(chr);
          } else {
            var charCode = charCodeAt(chr, 0);
            if ((charCode & 0xF800) !== 0xD800) result[i] = chr;else if (charCode >= 0xDC00 || i + 1 >= length || (charCodeAt(S, i + 1) & 0xFC00) !== 0xDC00) result[i] = escapeChar(chr);else {
              result[i] = chr;
              result[++i] = charAt(S, i);
            }
          }
        }
        return join(result, '');
      }
    });
    return es_regexp_escape;
  }
  var es_regexp_dotAll = {};
  var hasRequiredEs_regexp_dotAll;
  function requireEs_regexp_dotAll() {
    if (hasRequiredEs_regexp_dotAll) return es_regexp_dotAll;
    hasRequiredEs_regexp_dotAll = 1;
    var DESCRIPTORS = requireDescriptors();
    var UNSUPPORTED_DOT_ALL = requireRegexpUnsupportedDotAll();
    var classof = requireClassofRaw();
    var defineBuiltInAccessor = requireDefineBuiltInAccessor();
    var getInternalState = requireInternalState().get;
    var RegExpPrototype = RegExp.prototype;
    var $TypeError = TypeError;
    if (DESCRIPTORS && UNSUPPORTED_DOT_ALL) {
      defineBuiltInAccessor(RegExpPrototype, 'dotAll', {
        configurable: true,
        get: function dotAll() {
          if (this === RegExpPrototype) return;
          if (classof(this) === 'RegExp') {
            return !!getInternalState(this).dotAll;
          }
          throw new $TypeError('Incompatible receiver, RegExp required');
        }
      });
    }
    return es_regexp_dotAll;
  }
  var es_regexp_exec = {};
  var regexpExec;
  var hasRequiredRegexpExec;
  function requireRegexpExec() {
    if (hasRequiredRegexpExec) return regexpExec;
    hasRequiredRegexpExec = 1;
    var call = requireFunctionCall();
    var uncurryThis = requireFunctionUncurryThis();
    var toString = requireToString();
    var regexpFlags = requireRegexpFlags();
    var stickyHelpers = requireRegexpStickyHelpers();
    var shared = requireShared();
    var create = requireObjectCreate();
    var getInternalState = requireInternalState().get;
    var UNSUPPORTED_DOT_ALL = requireRegexpUnsupportedDotAll();
    var UNSUPPORTED_NCG = requireRegexpUnsupportedNcg();
    var nativeReplace = shared('native-string-replace', String.prototype.replace);
    var nativeExec = RegExp.prototype.exec;
    var patchedExec = nativeExec;
    var charAt = uncurryThis(''.charAt);
    var indexOf = uncurryThis(''.indexOf);
    var replace = uncurryThis(''.replace);
    var stringSlice = uncurryThis(''.slice);
    var UPDATES_LAST_INDEX_WRONG = function () {
      var re1 = /a/;
      var re2 = /b*/g;
      call(nativeExec, re1, 'a');
      call(nativeExec, re2, 'a');
      return re1.lastIndex !== 0 || re2.lastIndex !== 0;
    }();
    var UNSUPPORTED_Y = stickyHelpers.BROKEN_CARET;
    var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;
    var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;
    if (PATCH) {
      patchedExec = function exec(string) {
        var re = this;
        var state = getInternalState(re);
        var str = toString(string);
        var raw = state.raw;
        var result, reCopy, lastIndex, match, i, object, group;
        if (raw) {
          raw.lastIndex = re.lastIndex;
          result = call(patchedExec, raw, str);
          re.lastIndex = raw.lastIndex;
          return result;
        }
        var groups = state.groups;
        var sticky = UNSUPPORTED_Y && re.sticky;
        var flags = call(regexpFlags, re);
        var source = re.source;
        var charsAdded = 0;
        var strCopy = str;
        if (sticky) {
          flags = replace(flags, 'y', '');
          if (indexOf(flags, 'g') === -1) {
            flags += 'g';
          }
          strCopy = stringSlice(str, re.lastIndex);
          if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt(str, re.lastIndex - 1) !== '\n')) {
            source = '(?: ' + source + ')';
            strCopy = ' ' + strCopy;
            charsAdded++;
          }
          reCopy = new RegExp('^(?:' + source + ')', flags);
        }
        if (NPCG_INCLUDED) {
          reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
        }
        if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;
        match = call(nativeExec, sticky ? reCopy : re, strCopy);
        if (sticky) {
          if (match) {
            match.input = stringSlice(match.input, charsAdded);
            match[0] = stringSlice(match[0], charsAdded);
            match.index = re.lastIndex;
            re.lastIndex += match[0].length;
          } else re.lastIndex = 0;
        } else if (UPDATES_LAST_INDEX_WRONG && match) {
          re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
        }
        if (NPCG_INCLUDED && match && match.length > 1) {
          call(nativeReplace, match[0], reCopy, function () {
            for (i = 1; i < arguments.length - 2; i++) {
              if (arguments[i] === undefined) match[i] = undefined;
            }
          });
        }
        if (match && groups) {
          match.groups = object = create(null);
          for (i = 0; i < groups.length; i++) {
            group = groups[i];
            object[group[0]] = match[group[1]];
          }
        }
        return match;
      };
    }
    regexpExec = patchedExec;
    return regexpExec;
  }
  var hasRequiredEs_regexp_exec;
  function requireEs_regexp_exec() {
    if (hasRequiredEs_regexp_exec) return es_regexp_exec;
    hasRequiredEs_regexp_exec = 1;
    var $ = require_export();
    var exec = requireRegexpExec();
    $({
      target: 'RegExp',
      proto: true,
      forced: /./.exec !== exec
    }, {
      exec: exec
    });
    return es_regexp_exec;
  }
  var es_regexp_flags = {};
  var hasRequiredEs_regexp_flags;
  function requireEs_regexp_flags() {
    if (hasRequiredEs_regexp_flags) return es_regexp_flags;
    hasRequiredEs_regexp_flags = 1;
    var DESCRIPTORS = requireDescriptors();
    var defineBuiltInAccessor = requireDefineBuiltInAccessor();
    var regExpFlagsDetection = requireRegexpFlagsDetection();
    var regExpFlagsGetterImplementation = requireRegexpFlags();
    if (DESCRIPTORS && !regExpFlagsDetection.correct) {
      defineBuiltInAccessor(RegExp.prototype, 'flags', {
        configurable: true,
        get: regExpFlagsGetterImplementation
      });
      regExpFlagsDetection.correct = true;
    }
    return es_regexp_flags;
  }
  var es_regexp_sticky = {};
  var hasRequiredEs_regexp_sticky;
  function requireEs_regexp_sticky() {
    if (hasRequiredEs_regexp_sticky) return es_regexp_sticky;
    hasRequiredEs_regexp_sticky = 1;
    var DESCRIPTORS = requireDescriptors();
    var MISSED_STICKY = requireRegexpStickyHelpers().MISSED_STICKY;
    var classof = requireClassofRaw();
    var defineBuiltInAccessor = requireDefineBuiltInAccessor();
    var getInternalState = requireInternalState().get;
    var RegExpPrototype = RegExp.prototype;
    var $TypeError = TypeError;
    if (DESCRIPTORS && MISSED_STICKY) {
      defineBuiltInAccessor(RegExpPrototype, 'sticky', {
        configurable: true,
        get: function sticky() {
          if (this === RegExpPrototype) return;
          if (classof(this) === 'RegExp') {
            return !!getInternalState(this).sticky;
          }
          throw new $TypeError('Incompatible receiver, RegExp required');
        }
      });
    }
    return es_regexp_sticky;
  }
  var es_regexp_test = {};
  var hasRequiredEs_regexp_test;
  function requireEs_regexp_test() {
    if (hasRequiredEs_regexp_test) return es_regexp_test;
    hasRequiredEs_regexp_test = 1;
    requireEs_regexp_exec();
    var $ = require_export();
    var call = requireFunctionCall();
    var isCallable = requireIsCallable();
    var anObject = requireAnObject();
    var toString = requireToString();
    var DELEGATES_TO_EXEC = function () {
      var execCalled = false;
      var re = /[ac]/;
      re.exec = function () {
        execCalled = true;
        return /./.exec.apply(this, arguments);
      };
      return re.test('abc') === true && execCalled;
    }();
    var nativeTest = /./.test;
    $({
      target: 'RegExp',
      proto: true,
      forced: !DELEGATES_TO_EXEC
    }, {
      test: function test(S) {
        var R = anObject(this);
        var string = toString(S);
        var exec = R.exec;
        if (!isCallable(exec)) return call(nativeTest, R, string);
        var result = call(exec, R, string);
        if (result === null) return false;
        anObject(result);
        return true;
      }
    });
    return es_regexp_test;
  }
  var es_regexp_toString = {};
  var hasRequiredEs_regexp_toString;
  function requireEs_regexp_toString() {
    if (hasRequiredEs_regexp_toString) return es_regexp_toString;
    hasRequiredEs_regexp_toString = 1;
    var PROPER_FUNCTION_NAME = requireFunctionName().PROPER;
    var defineBuiltIn = requireDefineBuiltIn();
    var anObject = requireAnObject();
    var $toString = requireToString();
    var fails = requireFails();
    var getRegExpFlags = requireRegexpGetFlags();
    var TO_STRING = 'toString';
    var RegExpPrototype = RegExp.prototype;
    var nativeToString = RegExpPrototype[TO_STRING];
    var NOT_GENERIC = fails(function () {
      return nativeToString.call({
        source: 'a',
        flags: 'b'
      }) !== '/a/b';
    });
    var INCORRECT_NAME = PROPER_FUNCTION_NAME && nativeToString.name !== TO_STRING;
    if (NOT_GENERIC || INCORRECT_NAME) {
      defineBuiltIn(RegExpPrototype, TO_STRING, function toString() {
        var R = anObject(this);
        var pattern = $toString(R.source);
        var flags = $toString(getRegExpFlags(R));
        return '/' + pattern + '/' + flags;
      }, {
        unsafe: true
      });
    }
    return es_regexp_toString;
  }
  var es_set = {};
  var es_set_constructor = {};
  var hasRequiredEs_set_constructor;
  function requireEs_set_constructor() {
    if (hasRequiredEs_set_constructor) return es_set_constructor;
    hasRequiredEs_set_constructor = 1;
    var collection = requireCollection();
    var collectionStrong = requireCollectionStrong();
    collection('Set', function (init) {
      return function Set() {
        return init(this, arguments.length ? arguments[0] : undefined);
      };
    }, collectionStrong);
    return es_set_constructor;
  }
  var hasRequiredEs_set;
  function requireEs_set() {
    if (hasRequiredEs_set) return es_set;
    hasRequiredEs_set = 1;
    requireEs_set_constructor();
    return es_set;
  }
  var es_set_difference_v2 = {};
  var setHelpers;
  var hasRequiredSetHelpers;
  function requireSetHelpers() {
    if (hasRequiredSetHelpers) return setHelpers;
    hasRequiredSetHelpers = 1;
    var uncurryThis = requireFunctionUncurryThis();
    var SetPrototype = Set.prototype;
    setHelpers = {
      Set: Set,
      add: uncurryThis(SetPrototype.add),
      has: uncurryThis(SetPrototype.has),
      remove: uncurryThis(SetPrototype['delete']),
      proto: SetPrototype
    };
    return setHelpers;
  }
  var aSet;
  var hasRequiredASet;
  function requireASet() {
    if (hasRequiredASet) return aSet;
    hasRequiredASet = 1;
    var has = requireSetHelpers().has;
    aSet = function aSet(it) {
      has(it);
      return it;
    };
    return aSet;
  }
  var iterateSimple;
  var hasRequiredIterateSimple;
  function requireIterateSimple() {
    if (hasRequiredIterateSimple) return iterateSimple;
    hasRequiredIterateSimple = 1;
    var call = requireFunctionCall();
    iterateSimple = function iterateSimple(record, fn, ITERATOR_INSTEAD_OF_RECORD) {
      var iterator = ITERATOR_INSTEAD_OF_RECORD ? record : record.iterator;
      var next = record.next;
      var step, result;
      while (!(step = call(next, iterator)).done) {
        result = fn(step.value);
        if (result !== undefined) return result;
      }
    };
    return iterateSimple;
  }
  var setIterate;
  var hasRequiredSetIterate;
  function requireSetIterate() {
    if (hasRequiredSetIterate) return setIterate;
    hasRequiredSetIterate = 1;
    var uncurryThis = requireFunctionUncurryThis();
    var iterateSimple = requireIterateSimple();
    var SetHelpers = requireSetHelpers();
    var Set = SetHelpers.Set;
    var SetPrototype = SetHelpers.proto;
    var forEach = uncurryThis(SetPrototype.forEach);
    var keys = uncurryThis(SetPrototype.keys);
    var next = keys(new Set()).next;
    setIterate = function setIterate(set, fn, interruptible) {
      return interruptible ? iterateSimple({
        iterator: keys(set),
        next: next
      }, fn) : forEach(set, fn);
    };
    return setIterate;
  }
  var setClone;
  var hasRequiredSetClone;
  function requireSetClone() {
    if (hasRequiredSetClone) return setClone;
    hasRequiredSetClone = 1;
    var SetHelpers = requireSetHelpers();
    var iterate = requireSetIterate();
    var Set = SetHelpers.Set;
    var add = SetHelpers.add;
    setClone = function setClone(set) {
      var result = new Set();
      iterate(set, function (it) {
        add(result, it);
      });
      return result;
    };
    return setClone;
  }
  var setSize;
  var hasRequiredSetSize;
  function requireSetSize() {
    if (hasRequiredSetSize) return setSize;
    hasRequiredSetSize = 1;
    var uncurryThisAccessor = requireFunctionUncurryThisAccessor();
    var SetHelpers = requireSetHelpers();
    setSize = uncurryThisAccessor(SetHelpers.proto, 'size', 'get') || function (set) {
      return set.size;
    };
    return setSize;
  }
  var getSetRecord;
  var hasRequiredGetSetRecord;
  function requireGetSetRecord() {
    if (hasRequiredGetSetRecord) return getSetRecord;
    hasRequiredGetSetRecord = 1;
    var aCallable = requireACallable();
    var anObject = requireAnObject();
    var call = requireFunctionCall();
    var toIntegerOrInfinity = requireToIntegerOrInfinity();
    var getIteratorDirect = requireGetIteratorDirect();
    var INVALID_SIZE = 'Invalid size';
    var $RangeError = RangeError;
    var $TypeError = TypeError;
    var max = Math.max;
    var SetRecord = function SetRecord(set, intSize) {
      this.set = set;
      this.size = max(intSize, 0);
      this.has = aCallable(set.has);
      this.keys = aCallable(set.keys);
    };
    SetRecord.prototype = {
      getIterator: function getIterator() {
        return getIteratorDirect(anObject(call(this.keys, this.set)));
      },
      includes: function includes(it) {
        return call(this.has, this.set, it);
      }
    };
    getSetRecord = function getSetRecord(obj) {
      anObject(obj);
      var numSize = +obj.size;
      if (numSize !== numSize) throw new $TypeError(INVALID_SIZE);
      var intSize = toIntegerOrInfinity(numSize);
      if (intSize < 0) throw new $RangeError(INVALID_SIZE);
      return new SetRecord(obj, intSize);
    };
    return getSetRecord;
  }
  var setDifference;
  var hasRequiredSetDifference;
  function requireSetDifference() {
    if (hasRequiredSetDifference) return setDifference;
    hasRequiredSetDifference = 1;
    var aSet = requireASet();
    var SetHelpers = requireSetHelpers();
    var clone = requireSetClone();
    var size = requireSetSize();
    var getSetRecord = requireGetSetRecord();
    var iterateSet = requireSetIterate();
    var iterateSimple = requireIterateSimple();
    var has = SetHelpers.has;
    var remove = SetHelpers.remove;
    setDifference = function difference(other) {
      var O = aSet(this);
      var otherRec = getSetRecord(other);
      var result = clone(O);
      if (size(O) <= otherRec.size) iterateSet(O, function (e) {
        if (otherRec.includes(e)) remove(result, e);
      });else iterateSimple(otherRec.getIterator(), function (e) {
        if (has(result, e)) remove(result, e);
      });
      return result;
    };
    return setDifference;
  }
  var setMethodAcceptSetLike;
  var hasRequiredSetMethodAcceptSetLike;
  function requireSetMethodAcceptSetLike() {
    if (hasRequiredSetMethodAcceptSetLike) return setMethodAcceptSetLike;
    hasRequiredSetMethodAcceptSetLike = 1;
    var getBuiltIn = requireGetBuiltIn();
    var createSetLike = function createSetLike(size) {
      return {
        size: size,
        has: function has() {
          return false;
        },
        keys: function keys() {
          return {
            next: function next() {
              return {
                done: true
              };
            }
          };
        }
      };
    };
    var createSetLikeWithInfinitySize = function createSetLikeWithInfinitySize(size) {
      return {
        size: size,
        has: function has() {
          return true;
        },
        keys: function keys() {
          throw new Error('e');
        }
      };
    };
    setMethodAcceptSetLike = function setMethodAcceptSetLike(name, callback) {
      var Set = getBuiltIn('Set');
      try {
        new Set()[name](createSetLike(0));
        try {
          new Set()[name](createSetLike(-1));
          return false;
        } catch (error2) {
          if (!callback) return true;
          try {
            new Set()[name](createSetLikeWithInfinitySize(-Infinity));
            return false;
          } catch (error) {
            var set = new Set();
            set.add(1);
            set.add(2);
            return callback(set[name](createSetLikeWithInfinitySize(Infinity)));
          }
        }
      } catch (error) {
        return false;
      }
    };
    return setMethodAcceptSetLike;
  }
  var hasRequiredEs_set_difference_v2;
  function requireEs_set_difference_v2() {
    if (hasRequiredEs_set_difference_v2) return es_set_difference_v2;
    hasRequiredEs_set_difference_v2 = 1;
    var $ = require_export();
    var difference = requireSetDifference();
    var fails = requireFails();
    var setMethodAcceptSetLike = requireSetMethodAcceptSetLike();
    var SET_LIKE_INCORRECT_BEHAVIOR = !setMethodAcceptSetLike('difference', function (result) {
      return result.size === 0;
    });
    var FORCED = SET_LIKE_INCORRECT_BEHAVIOR || fails(function () {
      var setLike = {
        size: 1,
        has: function has() {
          return true;
        },
        keys: function keys() {
          var index = 0;
          return {
            next: function next() {
              var done = index++ > 1;
              if (baseSet.has(1)) baseSet.clear();
              return {
                done: done,
                value: 2
              };
            }
          };
        }
      };
      var baseSet = new Set([1, 2, 3, 4]);
      return baseSet.difference(setLike).size !== 3;
    });
    $({
      target: 'Set',
      proto: true,
      real: true,
      forced: FORCED
    }, {
      difference: difference
    });
    return es_set_difference_v2;
  }
  var es_set_intersection_v2 = {};
  var setIntersection;
  var hasRequiredSetIntersection;
  function requireSetIntersection() {
    if (hasRequiredSetIntersection) return setIntersection;
    hasRequiredSetIntersection = 1;
    var aSet = requireASet();
    var SetHelpers = requireSetHelpers();
    var size = requireSetSize();
    var getSetRecord = requireGetSetRecord();
    var iterateSet = requireSetIterate();
    var iterateSimple = requireIterateSimple();
    var Set = SetHelpers.Set;
    var add = SetHelpers.add;
    var has = SetHelpers.has;
    setIntersection = function intersection(other) {
      var O = aSet(this);
      var otherRec = getSetRecord(other);
      var result = new Set();
      if (size(O) > otherRec.size) {
        iterateSimple(otherRec.getIterator(), function (e) {
          if (has(O, e)) add(result, e);
        });
      } else {
        iterateSet(O, function (e) {
          if (otherRec.includes(e)) add(result, e);
        });
      }
      return result;
    };
    return setIntersection;
  }
  var hasRequiredEs_set_intersection_v2;
  function requireEs_set_intersection_v2() {
    if (hasRequiredEs_set_intersection_v2) return es_set_intersection_v2;
    hasRequiredEs_set_intersection_v2 = 1;
    var $ = require_export();
    var fails = requireFails();
    var intersection = requireSetIntersection();
    var setMethodAcceptSetLike = requireSetMethodAcceptSetLike();
    var INCORRECT = !setMethodAcceptSetLike('intersection', function (result) {
      return result.size === 2 && result.has(1) && result.has(2);
    }) || fails(function () {
      return String(Array.from(new Set([1, 2, 3]).intersection(new Set([3, 2])))) !== '3,2';
    });
    $({
      target: 'Set',
      proto: true,
      real: true,
      forced: INCORRECT
    }, {
      intersection: intersection
    });
    return es_set_intersection_v2;
  }
  var es_set_isDisjointFrom_v2 = {};
  var setIsDisjointFrom;
  var hasRequiredSetIsDisjointFrom;
  function requireSetIsDisjointFrom() {
    if (hasRequiredSetIsDisjointFrom) return setIsDisjointFrom;
    hasRequiredSetIsDisjointFrom = 1;
    var aSet = requireASet();
    var has = requireSetHelpers().has;
    var size = requireSetSize();
    var getSetRecord = requireGetSetRecord();
    var iterateSet = requireSetIterate();
    var iterateSimple = requireIterateSimple();
    var iteratorClose = requireIteratorClose();
    setIsDisjointFrom = function isDisjointFrom(other) {
      var O = aSet(this);
      var otherRec = getSetRecord(other);
      if (size(O) <= otherRec.size) return iterateSet(O, function (e) {
        if (otherRec.includes(e)) return false;
      }, true) !== false;
      var iterator = otherRec.getIterator();
      return iterateSimple(iterator, function (e) {
        if (has(O, e)) return iteratorClose(iterator, 'normal', false);
      }) !== false;
    };
    return setIsDisjointFrom;
  }
  var hasRequiredEs_set_isDisjointFrom_v2;
  function requireEs_set_isDisjointFrom_v2() {
    if (hasRequiredEs_set_isDisjointFrom_v2) return es_set_isDisjointFrom_v2;
    hasRequiredEs_set_isDisjointFrom_v2 = 1;
    var $ = require_export();
    var isDisjointFrom = requireSetIsDisjointFrom();
    var setMethodAcceptSetLike = requireSetMethodAcceptSetLike();
    var INCORRECT = !setMethodAcceptSetLike('isDisjointFrom', function (result) {
      return !result;
    });
    $({
      target: 'Set',
      proto: true,
      real: true,
      forced: INCORRECT
    }, {
      isDisjointFrom: isDisjointFrom
    });
    return es_set_isDisjointFrom_v2;
  }
  var es_set_isSubsetOf_v2 = {};
  var setIsSubsetOf;
  var hasRequiredSetIsSubsetOf;
  function requireSetIsSubsetOf() {
    if (hasRequiredSetIsSubsetOf) return setIsSubsetOf;
    hasRequiredSetIsSubsetOf = 1;
    var aSet = requireASet();
    var size = requireSetSize();
    var iterate = requireSetIterate();
    var getSetRecord = requireGetSetRecord();
    setIsSubsetOf = function isSubsetOf(other) {
      var O = aSet(this);
      var otherRec = getSetRecord(other);
      if (size(O) > otherRec.size) return false;
      return iterate(O, function (e) {
        if (!otherRec.includes(e)) return false;
      }, true) !== false;
    };
    return setIsSubsetOf;
  }
  var hasRequiredEs_set_isSubsetOf_v2;
  function requireEs_set_isSubsetOf_v2() {
    if (hasRequiredEs_set_isSubsetOf_v2) return es_set_isSubsetOf_v2;
    hasRequiredEs_set_isSubsetOf_v2 = 1;
    var $ = require_export();
    var isSubsetOf = requireSetIsSubsetOf();
    var setMethodAcceptSetLike = requireSetMethodAcceptSetLike();
    var INCORRECT = !setMethodAcceptSetLike('isSubsetOf', function (result) {
      return result;
    });
    $({
      target: 'Set',
      proto: true,
      real: true,
      forced: INCORRECT
    }, {
      isSubsetOf: isSubsetOf
    });
    return es_set_isSubsetOf_v2;
  }
  var es_set_isSupersetOf_v2 = {};
  var setIsSupersetOf;
  var hasRequiredSetIsSupersetOf;
  function requireSetIsSupersetOf() {
    if (hasRequiredSetIsSupersetOf) return setIsSupersetOf;
    hasRequiredSetIsSupersetOf = 1;
    var aSet = requireASet();
    var has = requireSetHelpers().has;
    var size = requireSetSize();
    var getSetRecord = requireGetSetRecord();
    var iterateSimple = requireIterateSimple();
    var iteratorClose = requireIteratorClose();
    setIsSupersetOf = function isSupersetOf(other) {
      var O = aSet(this);
      var otherRec = getSetRecord(other);
      if (size(O) < otherRec.size) return false;
      var iterator = otherRec.getIterator();
      return iterateSimple(iterator, function (e) {
        if (!has(O, e)) return iteratorClose(iterator, 'normal', false);
      }) !== false;
    };
    return setIsSupersetOf;
  }
  var hasRequiredEs_set_isSupersetOf_v2;
  function requireEs_set_isSupersetOf_v2() {
    if (hasRequiredEs_set_isSupersetOf_v2) return es_set_isSupersetOf_v2;
    hasRequiredEs_set_isSupersetOf_v2 = 1;
    var $ = require_export();
    var isSupersetOf = requireSetIsSupersetOf();
    var setMethodAcceptSetLike = requireSetMethodAcceptSetLike();
    var INCORRECT = !setMethodAcceptSetLike('isSupersetOf', function (result) {
      return !result;
    });
    $({
      target: 'Set',
      proto: true,
      real: true,
      forced: INCORRECT
    }, {
      isSupersetOf: isSupersetOf
    });
    return es_set_isSupersetOf_v2;
  }
  var es_set_symmetricDifference_v2 = {};
  var setSymmetricDifference;
  var hasRequiredSetSymmetricDifference;
  function requireSetSymmetricDifference() {
    if (hasRequiredSetSymmetricDifference) return setSymmetricDifference;
    hasRequiredSetSymmetricDifference = 1;
    var aSet = requireASet();
    var SetHelpers = requireSetHelpers();
    var clone = requireSetClone();
    var getSetRecord = requireGetSetRecord();
    var iterateSimple = requireIterateSimple();
    var add = SetHelpers.add;
    var has = SetHelpers.has;
    var remove = SetHelpers.remove;
    setSymmetricDifference = function symmetricDifference(other) {
      var O = aSet(this);
      var keysIter = getSetRecord(other).getIterator();
      var result = clone(O);
      iterateSimple(keysIter, function (e) {
        if (has(O, e)) remove(result, e);else add(result, e);
      });
      return result;
    };
    return setSymmetricDifference;
  }
  var setMethodGetKeysBeforeCloningDetection;
  var hasRequiredSetMethodGetKeysBeforeCloningDetection;
  function requireSetMethodGetKeysBeforeCloningDetection() {
    if (hasRequiredSetMethodGetKeysBeforeCloningDetection) return setMethodGetKeysBeforeCloningDetection;
    hasRequiredSetMethodGetKeysBeforeCloningDetection = 1;
    setMethodGetKeysBeforeCloningDetection = function setMethodGetKeysBeforeCloningDetection(METHOD_NAME) {
      try {
        var baseSet = new Set();
        var setLike = {
          size: 0,
          has: function has() {
            return true;
          },
          keys: function keys() {
            return Object.defineProperty({}, 'next', {
              get: function get() {
                baseSet.clear();
                baseSet.add(4);
                return function () {
                  return {
                    done: true
                  };
                };
              }
            });
          }
        };
        var result = baseSet[METHOD_NAME](setLike);
        return result.size === 1 && result.values().next().value === 4;
      } catch (error) {
        return false;
      }
    };
    return setMethodGetKeysBeforeCloningDetection;
  }
  var hasRequiredEs_set_symmetricDifference_v2;
  function requireEs_set_symmetricDifference_v2() {
    if (hasRequiredEs_set_symmetricDifference_v2) return es_set_symmetricDifference_v2;
    hasRequiredEs_set_symmetricDifference_v2 = 1;
    var $ = require_export();
    var symmetricDifference = requireSetSymmetricDifference();
    var setMethodGetKeysBeforeCloning = requireSetMethodGetKeysBeforeCloningDetection();
    var setMethodAcceptSetLike = requireSetMethodAcceptSetLike();
    var FORCED = !setMethodAcceptSetLike('symmetricDifference') || !setMethodGetKeysBeforeCloning('symmetricDifference');
    $({
      target: 'Set',
      proto: true,
      real: true,
      forced: FORCED
    }, {
      symmetricDifference: symmetricDifference
    });
    return es_set_symmetricDifference_v2;
  }
  var es_set_union_v2 = {};
  var setUnion;
  var hasRequiredSetUnion;
  function requireSetUnion() {
    if (hasRequiredSetUnion) return setUnion;
    hasRequiredSetUnion = 1;
    var aSet = requireASet();
    var add = requireSetHelpers().add;
    var clone = requireSetClone();
    var getSetRecord = requireGetSetRecord();
    var iterateSimple = requireIterateSimple();
    setUnion = function union(other) {
      var O = aSet(this);
      var keysIter = getSetRecord(other).getIterator();
      var result = clone(O);
      iterateSimple(keysIter, function (it) {
        add(result, it);
      });
      return result;
    };
    return setUnion;
  }
  var hasRequiredEs_set_union_v2;
  function requireEs_set_union_v2() {
    if (hasRequiredEs_set_union_v2) return es_set_union_v2;
    hasRequiredEs_set_union_v2 = 1;
    var $ = require_export();
    var union = requireSetUnion();
    var setMethodGetKeysBeforeCloning = requireSetMethodGetKeysBeforeCloningDetection();
    var setMethodAcceptSetLike = requireSetMethodAcceptSetLike();
    var FORCED = !setMethodAcceptSetLike('union') || !setMethodGetKeysBeforeCloning('union');
    $({
      target: 'Set',
      proto: true,
      real: true,
      forced: FORCED
    }, {
      union: union
    });
    return es_set_union_v2;
  }
  var es_string_atAlternative = {};
  var hasRequiredEs_string_atAlternative;
  function requireEs_string_atAlternative() {
    if (hasRequiredEs_string_atAlternative) return es_string_atAlternative;
    hasRequiredEs_string_atAlternative = 1;
    var $ = require_export();
    var uncurryThis = requireFunctionUncurryThis();
    var requireObjectCoercible = requireRequireObjectCoercible();
    var toIntegerOrInfinity = requireToIntegerOrInfinity();
    var toString = requireToString();
    var fails = requireFails();
    var charAt = uncurryThis(''.charAt);
    var FORCED = fails(function () {
      return '𠮷'.at(-2) !== '\uD842';
    });
    $({
      target: 'String',
      proto: true,
      forced: FORCED
    }, {
      at: function at(index) {
        var S = toString(requireObjectCoercible(this));
        var len = S.length;
        var relativeIndex = toIntegerOrInfinity(index);
        var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
        return k < 0 || k >= len ? undefined : charAt(S, k);
      }
    });
    return es_string_atAlternative;
  }
  var es_string_codePointAt = {};
  var stringMultibyte;
  var hasRequiredStringMultibyte;
  function requireStringMultibyte() {
    if (hasRequiredStringMultibyte) return stringMultibyte;
    hasRequiredStringMultibyte = 1;
    var uncurryThis = requireFunctionUncurryThis();
    var toIntegerOrInfinity = requireToIntegerOrInfinity();
    var toString = requireToString();
    var requireObjectCoercible = requireRequireObjectCoercible();
    var charAt = uncurryThis(''.charAt);
    var charCodeAt = uncurryThis(''.charCodeAt);
    var stringSlice = uncurryThis(''.slice);
    var createMethod = function createMethod(CONVERT_TO_STRING) {
      return function ($this, pos) {
        var S = toString(requireObjectCoercible($this));
        var position = toIntegerOrInfinity(pos);
        var size = S.length;
        var first, second;
        if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
        first = charCodeAt(S, position);
        return first < 0xD800 || first > 0xDBFF || position + 1 === size || (second = charCodeAt(S, position + 1)) < 0xDC00 || second > 0xDFFF ? CONVERT_TO_STRING ? charAt(S, position) : first : CONVERT_TO_STRING ? stringSlice(S, position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
      };
    };
    stringMultibyte = {
      codeAt: createMethod(false),
      charAt: createMethod(true)
    };
    return stringMultibyte;
  }
  var hasRequiredEs_string_codePointAt;
  function requireEs_string_codePointAt() {
    if (hasRequiredEs_string_codePointAt) return es_string_codePointAt;
    hasRequiredEs_string_codePointAt = 1;
    var $ = require_export();
    var codeAt = requireStringMultibyte().codeAt;
    $({
      target: 'String',
      proto: true
    }, {
      codePointAt: function codePointAt(pos) {
        return codeAt(this, pos);
      }
    });
    return es_string_codePointAt;
  }
  var es_string_endsWith = {};
  var notARegexp;
  var hasRequiredNotARegexp;
  function requireNotARegexp() {
    if (hasRequiredNotARegexp) return notARegexp;
    hasRequiredNotARegexp = 1;
    var isRegExp = requireIsRegexp();
    var $TypeError = TypeError;
    notARegexp = function notARegexp(it) {
      if (isRegExp(it)) {
        throw new $TypeError("The method doesn't accept regular expressions");
      }
      return it;
    };
    return notARegexp;
  }
  var correctIsRegexpLogic;
  var hasRequiredCorrectIsRegexpLogic;
  function requireCorrectIsRegexpLogic() {
    if (hasRequiredCorrectIsRegexpLogic) return correctIsRegexpLogic;
    hasRequiredCorrectIsRegexpLogic = 1;
    var wellKnownSymbol = requireWellKnownSymbol();
    var MATCH = wellKnownSymbol('match');
    correctIsRegexpLogic = function correctIsRegexpLogic(METHOD_NAME) {
      var regexp = /./;
      try {
        '/./'[METHOD_NAME](regexp);
      } catch (error1) {
        try {
          regexp[MATCH] = false;
          return '/./'[METHOD_NAME](regexp);
        } catch (error2) {}
      }
      return false;
    };
    return correctIsRegexpLogic;
  }
  var hasRequiredEs_string_endsWith;
  function requireEs_string_endsWith() {
    if (hasRequiredEs_string_endsWith) return es_string_endsWith;
    hasRequiredEs_string_endsWith = 1;
    var $ = require_export();
    var uncurryThis = requireFunctionUncurryThisClause();
    var getOwnPropertyDescriptor = requireObjectGetOwnPropertyDescriptor().f;
    var toLength = requireToLength();
    var toString = requireToString();
    var notARegExp = requireNotARegexp();
    var requireObjectCoercible = requireRequireObjectCoercible();
    var correctIsRegExpLogic = requireCorrectIsRegexpLogic();
    var IS_PURE = requireIsPure();
    var slice = uncurryThis(''.slice);
    var min = Math.min;
    var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic('endsWith');
    var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function () {
      var descriptor = getOwnPropertyDescriptor(String.prototype, 'endsWith');
      return descriptor && !descriptor.writable;
    }();
    $({
      target: 'String',
      proto: true,
      forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC
    }, {
      endsWith: function endsWith(searchString) {
        var that = toString(requireObjectCoercible(this));
        notARegExp(searchString);
        var endPosition = arguments.length > 1 ? arguments[1] : undefined;
        var len = that.length;
        var end = endPosition === undefined ? len : min(toLength(endPosition), len);
        var search = toString(searchString);
        return slice(that, end - search.length, end) === search;
      }
    });
    return es_string_endsWith;
  }
  var es_string_fromCodePoint = {};
  var hasRequiredEs_string_fromCodePoint;
  function requireEs_string_fromCodePoint() {
    if (hasRequiredEs_string_fromCodePoint) return es_string_fromCodePoint;
    hasRequiredEs_string_fromCodePoint = 1;
    var $ = require_export();
    var uncurryThis = requireFunctionUncurryThis();
    var toAbsoluteIndex = requireToAbsoluteIndex();
    var $RangeError = RangeError;
    var fromCharCode = String.fromCharCode;
    var $fromCodePoint = String.fromCodePoint;
    var join = uncurryThis([].join);
    var INCORRECT_LENGTH = !!$fromCodePoint && $fromCodePoint.length !== 1;
    $({
      target: 'String',
      stat: true,
      arity: 1,
      forced: INCORRECT_LENGTH
    }, {
      fromCodePoint: function fromCodePoint(x) {
        var elements = [];
        var length = arguments.length;
        var i = 0;
        var code;
        while (length > i) {
          code = +arguments[i++];
          if (toAbsoluteIndex(code, 0x10FFFF) !== code) throw new $RangeError(code + ' is not a valid code point');
          elements[i] = code < 0x10000 ? fromCharCode(code) : fromCharCode(((code -= 0x10000) >> 10) + 0xD800, code % 0x400 + 0xDC00);
        }
        return join(elements, '');
      }
    });
    return es_string_fromCodePoint;
  }
  var es_string_includes = {};
  var hasRequiredEs_string_includes;
  function requireEs_string_includes() {
    if (hasRequiredEs_string_includes) return es_string_includes;
    hasRequiredEs_string_includes = 1;
    var $ = require_export();
    var uncurryThis = requireFunctionUncurryThis();
    var notARegExp = requireNotARegexp();
    var requireObjectCoercible = requireRequireObjectCoercible();
    var toString = requireToString();
    var correctIsRegExpLogic = requireCorrectIsRegexpLogic();
    var stringIndexOf = uncurryThis(''.indexOf);
    $({
      target: 'String',
      proto: true,
      forced: !correctIsRegExpLogic('includes')
    }, {
      includes: function includes(searchString) {
        return !!~stringIndexOf(toString(requireObjectCoercible(this)), toString(notARegExp(searchString)), arguments.length > 1 ? arguments[1] : undefined);
      }
    });
    return es_string_includes;
  }
  var es_string_isWellFormed = {};
  var hasRequiredEs_string_isWellFormed;
  function requireEs_string_isWellFormed() {
    if (hasRequiredEs_string_isWellFormed) return es_string_isWellFormed;
    hasRequiredEs_string_isWellFormed = 1;
    var $ = require_export();
    var uncurryThis = requireFunctionUncurryThis();
    var requireObjectCoercible = requireRequireObjectCoercible();
    var toString = requireToString();
    var charCodeAt = uncurryThis(''.charCodeAt);
    $({
      target: 'String',
      proto: true
    }, {
      isWellFormed: function isWellFormed() {
        var S = toString(requireObjectCoercible(this));
        var length = S.length;
        for (var i = 0; i < length; i++) {
          var charCode = charCodeAt(S, i);
          if ((charCode & 0xF800) !== 0xD800) continue;
          if (charCode >= 0xDC00 || ++i >= length || (charCodeAt(S, i) & 0xFC00) !== 0xDC00) return false;
        }
        return true;
      }
    });
    return es_string_isWellFormed;
  }
  var es_string_iterator = {};
  var hasRequiredEs_string_iterator;
  function requireEs_string_iterator() {
    if (hasRequiredEs_string_iterator) return es_string_iterator;
    hasRequiredEs_string_iterator = 1;
    var charAt = requireStringMultibyte().charAt;
    var toString = requireToString();
    var InternalStateModule = requireInternalState();
    var defineIterator = requireIteratorDefine();
    var createIterResultObject = requireCreateIterResultObject();
    var STRING_ITERATOR = 'String Iterator';
    var setInternalState = InternalStateModule.set;
    var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);
    defineIterator(String, 'String', function (iterated) {
      setInternalState(this, {
        type: STRING_ITERATOR,
        string: toString(iterated),
        index: 0
      });
    }, function next() {
      var state = getInternalState(this);
      var string = state.string;
      var index = state.index;
      var point;
      if (index >= string.length) return createIterResultObject(undefined, true);
      point = charAt(string, index);
      state.index += point.length;
      return createIterResultObject(point, false);
    });
    return es_string_iterator;
  }
  var es_string_match = {};
  var fixRegexpWellKnownSymbolLogic;
  var hasRequiredFixRegexpWellKnownSymbolLogic;
  function requireFixRegexpWellKnownSymbolLogic() {
    if (hasRequiredFixRegexpWellKnownSymbolLogic) return fixRegexpWellKnownSymbolLogic;
    hasRequiredFixRegexpWellKnownSymbolLogic = 1;
    requireEs_regexp_exec();
    var call = requireFunctionCall();
    var defineBuiltIn = requireDefineBuiltIn();
    var regexpExec = requireRegexpExec();
    var fails = requireFails();
    var wellKnownSymbol = requireWellKnownSymbol();
    var createNonEnumerableProperty = requireCreateNonEnumerableProperty();
    var SPECIES = wellKnownSymbol('species');
    var RegExpPrototype = RegExp.prototype;
    fixRegexpWellKnownSymbolLogic = function fixRegexpWellKnownSymbolLogic(KEY, exec, FORCED, SHAM) {
      var SYMBOL = wellKnownSymbol(KEY);
      var DELEGATES_TO_SYMBOL = !fails(function () {
        var O = {};
        O[SYMBOL] = function () {
          return 7;
        };
        return ''[KEY](O) !== 7;
      });
      var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
        var execCalled = false;
        var re = /a/;
        if (KEY === 'split') {
          re = {};
          re.constructor = {};
          re.constructor[SPECIES] = function () {
            return re;
          };
          re.flags = '';
          re[SYMBOL] = /./[SYMBOL];
        }
        re.exec = function () {
          execCalled = true;
          return null;
        };
        re[SYMBOL]('');
        return !execCalled;
      });
      if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || FORCED) {
        var nativeRegExpMethod = /./[SYMBOL];
        var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
          var $exec = regexp.exec;
          if ($exec === regexpExec || $exec === RegExpPrototype.exec) {
            if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
              return {
                done: true,
                value: call(nativeRegExpMethod, regexp, str, arg2)
              };
            }
            return {
              done: true,
              value: call(nativeMethod, str, regexp, arg2)
            };
          }
          return {
            done: false
          };
        });
        defineBuiltIn(String.prototype, KEY, methods[0]);
        defineBuiltIn(RegExpPrototype, SYMBOL, methods[1]);
      }
      if (SHAM) createNonEnumerableProperty(RegExpPrototype[SYMBOL], 'sham', true);
    };
    return fixRegexpWellKnownSymbolLogic;
  }
  var advanceStringIndex;
  var hasRequiredAdvanceStringIndex;
  function requireAdvanceStringIndex() {
    if (hasRequiredAdvanceStringIndex) return advanceStringIndex;
    hasRequiredAdvanceStringIndex = 1;
    var charAt = requireStringMultibyte().charAt;
    advanceStringIndex = function advanceStringIndex(S, index, unicode) {
      return index + (unicode ? charAt(S, index).length : 1);
    };
    return advanceStringIndex;
  }
  var regexpExecAbstract;
  var hasRequiredRegexpExecAbstract;
  function requireRegexpExecAbstract() {
    if (hasRequiredRegexpExecAbstract) return regexpExecAbstract;
    hasRequiredRegexpExecAbstract = 1;
    var call = requireFunctionCall();
    var anObject = requireAnObject();
    var isCallable = requireIsCallable();
    var classof = requireClassofRaw();
    var regexpExec = requireRegexpExec();
    var $TypeError = TypeError;
    regexpExecAbstract = function regexpExecAbstract(R, S) {
      var exec = R.exec;
      if (isCallable(exec)) {
        var result = call(exec, R, S);
        if (result !== null) anObject(result);
        return result;
      }
      if (classof(R) === 'RegExp') return call(regexpExec, R, S);
      throw new $TypeError('RegExp#exec called on incompatible receiver');
    };
    return regexpExecAbstract;
  }
  var hasRequiredEs_string_match;
  function requireEs_string_match() {
    if (hasRequiredEs_string_match) return es_string_match;
    hasRequiredEs_string_match = 1;
    var call = requireFunctionCall();
    var uncurryThis = requireFunctionUncurryThis();
    var fixRegExpWellKnownSymbolLogic = requireFixRegexpWellKnownSymbolLogic();
    var anObject = requireAnObject();
    var isObject = requireIsObject();
    var toLength = requireToLength();
    var toString = requireToString();
    var requireObjectCoercible = requireRequireObjectCoercible();
    var getMethod = requireGetMethod();
    var advanceStringIndex = requireAdvanceStringIndex();
    var getRegExpFlags = requireRegexpGetFlags();
    var regExpExec = requireRegexpExecAbstract();
    var stringIndexOf = uncurryThis(''.indexOf);
    fixRegExpWellKnownSymbolLogic('match', function (MATCH, nativeMatch, maybeCallNative) {
      return [function match(regexp) {
        var O = requireObjectCoercible(this);
        var matcher = isObject(regexp) ? getMethod(regexp, MATCH) : undefined;
        return matcher ? call(matcher, regexp, O) : new RegExp(regexp)[MATCH](toString(O));
      }, function (string) {
        var rx = anObject(this);
        var S = toString(string);
        var res = maybeCallNative(nativeMatch, rx, S);
        if (res.done) return res.value;
        var flags = toString(getRegExpFlags(rx));
        if (stringIndexOf(flags, 'g') === -1) return regExpExec(rx, S);
        var fullUnicode = stringIndexOf(flags, 'u') !== -1;
        rx.lastIndex = 0;
        var A = [];
        var n = 0;
        var result;
        while ((result = regExpExec(rx, S)) !== null) {
          var matchStr = toString(result[0]);
          A[n] = matchStr;
          if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
          n++;
        }
        return n === 0 ? null : A;
      }];
    });
    return es_string_match;
  }
  var es_string_matchAll = {};
  var hasRequiredEs_string_matchAll;
  function requireEs_string_matchAll() {
    if (hasRequiredEs_string_matchAll) return es_string_matchAll;
    hasRequiredEs_string_matchAll = 1;
    var $ = require_export();
    var call = requireFunctionCall();
    var uncurryThis = requireFunctionUncurryThisClause();
    var createIteratorConstructor = requireIteratorCreateConstructor();
    var createIterResultObject = requireCreateIterResultObject();
    var requireObjectCoercible = requireRequireObjectCoercible();
    var toLength = requireToLength();
    var toString = requireToString();
    var anObject = requireAnObject();
    var isObject = requireIsObject();
    var classof = requireClassofRaw();
    var isRegExp = requireIsRegexp();
    var getRegExpFlags = requireRegexpGetFlags();
    var getMethod = requireGetMethod();
    var defineBuiltIn = requireDefineBuiltIn();
    var fails = requireFails();
    var wellKnownSymbol = requireWellKnownSymbol();
    var speciesConstructor = requireSpeciesConstructor();
    var advanceStringIndex = requireAdvanceStringIndex();
    var regExpExec = requireRegexpExecAbstract();
    var InternalStateModule = requireInternalState();
    var IS_PURE = requireIsPure();
    var MATCH_ALL = wellKnownSymbol('matchAll');
    var REGEXP_STRING = 'RegExp String';
    var REGEXP_STRING_ITERATOR = REGEXP_STRING + ' Iterator';
    var setInternalState = InternalStateModule.set;
    var getInternalState = InternalStateModule.getterFor(REGEXP_STRING_ITERATOR);
    var RegExpPrototype = RegExp.prototype;
    var $TypeError = TypeError;
    var stringIndexOf = uncurryThis(''.indexOf);
    var nativeMatchAll = uncurryThis(''.matchAll);
    var WORKS_WITH_NON_GLOBAL_REGEX = !!nativeMatchAll && !fails(function () {
      nativeMatchAll('a', /./);
    });
    var $RegExpStringIterator = createIteratorConstructor(function RegExpStringIterator(regexp, string, $global, fullUnicode) {
      setInternalState(this, {
        type: REGEXP_STRING_ITERATOR,
        regexp: regexp,
        string: string,
        global: $global,
        unicode: fullUnicode,
        done: false
      });
    }, REGEXP_STRING, function next() {
      var state = getInternalState(this);
      if (state.done) return createIterResultObject(undefined, true);
      var R = state.regexp;
      var S = state.string;
      var match = regExpExec(R, S);
      if (match === null) {
        state.done = true;
        return createIterResultObject(undefined, true);
      }
      if (state.global) {
        if (toString(match[0]) === '') R.lastIndex = advanceStringIndex(S, toLength(R.lastIndex), state.unicode);
        return createIterResultObject(match, false);
      }
      state.done = true;
      return createIterResultObject(match, false);
    });
    var $matchAll = function $matchAll(string) {
      var R = anObject(this);
      var S = toString(string);
      var C = speciesConstructor(R, RegExp);
      var flags = toString(getRegExpFlags(R));
      var matcher, $global, fullUnicode;
      matcher = new C(C === RegExp ? R.source : R, flags);
      $global = !!~stringIndexOf(flags, 'g');
      fullUnicode = !!~stringIndexOf(flags, 'u');
      matcher.lastIndex = toLength(R.lastIndex);
      return new $RegExpStringIterator(matcher, S, $global, fullUnicode);
    };
    $({
      target: 'String',
      proto: true,
      forced: WORKS_WITH_NON_GLOBAL_REGEX
    }, {
      matchAll: function matchAll(regexp) {
        var O = requireObjectCoercible(this);
        var flags, S, matcher, rx;
        if (isObject(regexp)) {
          if (isRegExp(regexp)) {
            flags = toString(requireObjectCoercible(getRegExpFlags(regexp)));
            if (!~stringIndexOf(flags, 'g')) throw new $TypeError('`.matchAll` does not allow non-global regexes');
          }
          if (WORKS_WITH_NON_GLOBAL_REGEX) return nativeMatchAll(O, regexp);
          matcher = getMethod(regexp, MATCH_ALL);
          if (matcher === undefined && IS_PURE && classof(regexp) === 'RegExp') matcher = $matchAll;
          if (matcher) return call(matcher, regexp, O);
        } else if (WORKS_WITH_NON_GLOBAL_REGEX) return nativeMatchAll(O, regexp);
        S = toString(O);
        rx = new RegExp(regexp, 'g');
        return IS_PURE ? call($matchAll, rx, S) : rx[MATCH_ALL](S);
      }
    });
    IS_PURE || MATCH_ALL in RegExpPrototype || defineBuiltIn(RegExpPrototype, MATCH_ALL, $matchAll);
    return es_string_matchAll;
  }
  var es_string_padEnd = {};
  var stringPadWebkitBug;
  var hasRequiredStringPadWebkitBug;
  function requireStringPadWebkitBug() {
    if (hasRequiredStringPadWebkitBug) return stringPadWebkitBug;
    hasRequiredStringPadWebkitBug = 1;
    var userAgent = requireEnvironmentUserAgent();
    stringPadWebkitBug = /Version\/10(?:\.\d+){1,2}(?: [\w./]+)?(?: Mobile\/\w+)? Safari\//.test(userAgent);
    return stringPadWebkitBug;
  }
  var hasRequiredEs_string_padEnd;
  function requireEs_string_padEnd() {
    if (hasRequiredEs_string_padEnd) return es_string_padEnd;
    hasRequiredEs_string_padEnd = 1;
    var $ = require_export();
    var $padEnd = requireStringPad().end;
    var WEBKIT_BUG = requireStringPadWebkitBug();
    $({
      target: 'String',
      proto: true,
      forced: WEBKIT_BUG
    }, {
      padEnd: function padEnd(maxLength) {
        return $padEnd(this, maxLength, arguments.length > 1 ? arguments[1] : undefined);
      }
    });
    return es_string_padEnd;
  }
  var es_string_padStart = {};
  var hasRequiredEs_string_padStart;
  function requireEs_string_padStart() {
    if (hasRequiredEs_string_padStart) return es_string_padStart;
    hasRequiredEs_string_padStart = 1;
    var $ = require_export();
    var $padStart = requireStringPad().start;
    var WEBKIT_BUG = requireStringPadWebkitBug();
    $({
      target: 'String',
      proto: true,
      forced: WEBKIT_BUG
    }, {
      padStart: function padStart(maxLength) {
        return $padStart(this, maxLength, arguments.length > 1 ? arguments[1] : undefined);
      }
    });
    return es_string_padStart;
  }
  var es_string_raw = {};
  var hasRequiredEs_string_raw;
  function requireEs_string_raw() {
    if (hasRequiredEs_string_raw) return es_string_raw;
    hasRequiredEs_string_raw = 1;
    var $ = require_export();
    var uncurryThis = requireFunctionUncurryThis();
    var toIndexedObject = requireToIndexedObject();
    var toObject = requireToObject();
    var toString = requireToString();
    var lengthOfArrayLike = requireLengthOfArrayLike();
    var push = uncurryThis([].push);
    var join = uncurryThis([].join);
    $({
      target: 'String',
      stat: true
    }, {
      raw: function raw(template) {
        var rawTemplate = toIndexedObject(toObject(template).raw);
        var literalSegments = lengthOfArrayLike(rawTemplate);
        if (!literalSegments) return '';
        var argumentsLength = arguments.length;
        var elements = [];
        var i = 0;
        while (true) {
          push(elements, toString(rawTemplate[i++]));
          if (i === literalSegments) return join(elements, '');
          if (i < argumentsLength) push(elements, toString(arguments[i]));
        }
      }
    });
    return es_string_raw;
  }
  var es_string_repeat = {};
  var hasRequiredEs_string_repeat;
  function requireEs_string_repeat() {
    if (hasRequiredEs_string_repeat) return es_string_repeat;
    hasRequiredEs_string_repeat = 1;
    var $ = require_export();
    var repeat = requireStringRepeat();
    $({
      target: 'String',
      proto: true
    }, {
      repeat: repeat
    });
    return es_string_repeat;
  }
  var es_string_replace = {};
  var getSubstitution;
  var hasRequiredGetSubstitution;
  function requireGetSubstitution() {
    if (hasRequiredGetSubstitution) return getSubstitution;
    hasRequiredGetSubstitution = 1;
    var uncurryThis = requireFunctionUncurryThis();
    var toObject = requireToObject();
    var floor = Math.floor;
    var charAt = uncurryThis(''.charAt);
    var replace = uncurryThis(''.replace);
    var stringSlice = uncurryThis(''.slice);
    var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
    var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;
    getSubstitution = function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
      var tailPos = position + matched.length;
      var m = captures.length;
      var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
      if (namedCaptures !== undefined) {
        namedCaptures = toObject(namedCaptures);
        symbols = SUBSTITUTION_SYMBOLS;
      }
      return replace(replacement, symbols, function (match, ch) {
        var capture;
        switch (charAt(ch, 0)) {
          case '$':
            return '$';
          case '&':
            return matched;
          case '`':
            return stringSlice(str, 0, position);
          case "'":
            return stringSlice(str, tailPos);
          case '<':
            capture = namedCaptures[stringSlice(ch, 1, -1)];
            break;
          default:
            var n = +ch;
            if (n === 0) return match;
            if (n > m) {
              var f = floor(n / 10);
              if (f === 0) return match;
              if (f <= m) return captures[f - 1] === undefined ? charAt(ch, 1) : captures[f - 1] + charAt(ch, 1);
              return match;
            }
            capture = captures[n - 1];
        }
        return capture === undefined ? '' : capture;
      });
    };
    return getSubstitution;
  }
  var hasRequiredEs_string_replace;
  function requireEs_string_replace() {
    if (hasRequiredEs_string_replace) return es_string_replace;
    hasRequiredEs_string_replace = 1;
    var apply = requireFunctionApply();
    var call = requireFunctionCall();
    var uncurryThis = requireFunctionUncurryThis();
    var fixRegExpWellKnownSymbolLogic = requireFixRegexpWellKnownSymbolLogic();
    var fails = requireFails();
    var anObject = requireAnObject();
    var isCallable = requireIsCallable();
    var isObject = requireIsObject();
    var toIntegerOrInfinity = requireToIntegerOrInfinity();
    var toLength = requireToLength();
    var toString = requireToString();
    var requireObjectCoercible = requireRequireObjectCoercible();
    var advanceStringIndex = requireAdvanceStringIndex();
    var getMethod = requireGetMethod();
    var getSubstitution = requireGetSubstitution();
    var getRegExpFlags = requireRegexpGetFlags();
    var regExpExec = requireRegexpExecAbstract();
    var wellKnownSymbol = requireWellKnownSymbol();
    var REPLACE = wellKnownSymbol('replace');
    var max = Math.max;
    var min = Math.min;
    var concat = uncurryThis([].concat);
    var push = uncurryThis([].push);
    var stringIndexOf = uncurryThis(''.indexOf);
    var stringSlice = uncurryThis(''.slice);
    var maybeToString = function maybeToString(it) {
      return it === undefined ? it : String(it);
    };
    var REPLACE_KEEPS_$0 = function () {
      return 'a'.replace(/./, '$0') === '$0';
    }();
    var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function () {
      if (/./[REPLACE]) {
        return /./[REPLACE]('a', '$0') === '';
      }
      return false;
    }();
    var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
      var re = /./;
      re.exec = function () {
        var result = [];
        result.groups = {
          a: '7'
        };
        return result;
      };
      return ''.replace(re, '$<a>') !== '7';
    });
    fixRegExpWellKnownSymbolLogic('replace', function (_, nativeReplace, maybeCallNative) {
      var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';
      return [function replace(searchValue, replaceValue) {
        var O = requireObjectCoercible(this);
        var replacer = isObject(searchValue) ? getMethod(searchValue, REPLACE) : undefined;
        return replacer ? call(replacer, searchValue, O, replaceValue) : call(nativeReplace, toString(O), searchValue, replaceValue);
      }, function (string, replaceValue) {
        var rx = anObject(this);
        var S = toString(string);
        if (typeof replaceValue == 'string' && stringIndexOf(replaceValue, UNSAFE_SUBSTITUTE) === -1 && stringIndexOf(replaceValue, '$<') === -1) {
          var res = maybeCallNative(nativeReplace, rx, S, replaceValue);
          if (res.done) return res.value;
        }
        var functionalReplace = isCallable(replaceValue);
        if (!functionalReplace) replaceValue = toString(replaceValue);
        var flags = toString(getRegExpFlags(rx));
        var global = stringIndexOf(flags, 'g') !== -1;
        var fullUnicode;
        if (global) {
          fullUnicode = stringIndexOf(flags, 'u') !== -1;
          rx.lastIndex = 0;
        }
        var results = [];
        var result;
        while (true) {
          result = regExpExec(rx, S);
          if (result === null) break;
          push(results, result);
          if (!global) break;
          var matchStr = toString(result[0]);
          if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
        }
        var accumulatedResult = '';
        var nextSourcePosition = 0;
        for (var i = 0; i < results.length; i++) {
          result = results[i];
          var matched = toString(result[0]);
          var position = max(min(toIntegerOrInfinity(result.index), S.length), 0);
          var captures = [];
          var replacement;
          for (var j = 1; j < result.length; j++) push(captures, maybeToString(result[j]));
          var namedCaptures = result.groups;
          if (functionalReplace) {
            var replacerArgs = concat([matched], captures, position, S);
            if (namedCaptures !== undefined) push(replacerArgs, namedCaptures);
            replacement = toString(apply(replaceValue, undefined, replacerArgs));
          } else {
            replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
          }
          if (position >= nextSourcePosition) {
            accumulatedResult += stringSlice(S, nextSourcePosition, position) + replacement;
            nextSourcePosition = position + matched.length;
          }
        }
        return accumulatedResult + stringSlice(S, nextSourcePosition);
      }];
    }, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);
    return es_string_replace;
  }
  var es_string_replaceAll = {};
  var hasRequiredEs_string_replaceAll;
  function requireEs_string_replaceAll() {
    if (hasRequiredEs_string_replaceAll) return es_string_replaceAll;
    hasRequiredEs_string_replaceAll = 1;
    var $ = require_export();
    var call = requireFunctionCall();
    var uncurryThis = requireFunctionUncurryThis();
    var requireObjectCoercible = requireRequireObjectCoercible();
    var isCallable = requireIsCallable();
    var isObject = requireIsObject();
    var isRegExp = requireIsRegexp();
    var toString = requireToString();
    var getMethod = requireGetMethod();
    var getRegExpFlags = requireRegexpGetFlags();
    var getSubstitution = requireGetSubstitution();
    var wellKnownSymbol = requireWellKnownSymbol();
    var IS_PURE = requireIsPure();
    var REPLACE = wellKnownSymbol('replace');
    var $TypeError = TypeError;
    var indexOf = uncurryThis(''.indexOf);
    var replace = uncurryThis(''.replace);
    var stringSlice = uncurryThis(''.slice);
    var max = Math.max;
    $({
      target: 'String',
      proto: true
    }, {
      replaceAll: function replaceAll(searchValue, replaceValue) {
        var O = requireObjectCoercible(this);
        var IS_REG_EXP, flags, replacer, string, searchString, functionalReplace, searchLength, advanceBy, position, replacement;
        var endOfLastMatch = 0;
        var result = '';
        if (isObject(searchValue)) {
          IS_REG_EXP = isRegExp(searchValue);
          if (IS_REG_EXP) {
            flags = toString(requireObjectCoercible(getRegExpFlags(searchValue)));
            if (!~indexOf(flags, 'g')) throw new $TypeError('`.replaceAll` does not allow non-global regexes');
          }
          replacer = getMethod(searchValue, REPLACE);
          if (replacer) return call(replacer, searchValue, O, replaceValue);
          if (IS_PURE && IS_REG_EXP) return replace(toString(O), searchValue, replaceValue);
        }
        string = toString(O);
        searchString = toString(searchValue);
        functionalReplace = isCallable(replaceValue);
        if (!functionalReplace) replaceValue = toString(replaceValue);
        searchLength = searchString.length;
        advanceBy = max(1, searchLength);
        position = indexOf(string, searchString);
        while (position !== -1) {
          replacement = functionalReplace ? toString(replaceValue(searchString, position, string)) : getSubstitution(searchString, string, position, [], undefined, replaceValue);
          result += stringSlice(string, endOfLastMatch, position) + replacement;
          endOfLastMatch = position + searchLength;
          position = position + advanceBy > string.length ? -1 : indexOf(string, searchString, position + advanceBy);
        }
        if (endOfLastMatch < string.length) {
          result += stringSlice(string, endOfLastMatch);
        }
        return result;
      }
    });
    return es_string_replaceAll;
  }
  var es_string_search = {};
  var hasRequiredEs_string_search;
  function requireEs_string_search() {
    if (hasRequiredEs_string_search) return es_string_search;
    hasRequiredEs_string_search = 1;
    var call = requireFunctionCall();
    var fixRegExpWellKnownSymbolLogic = requireFixRegexpWellKnownSymbolLogic();
    var anObject = requireAnObject();
    var isObject = requireIsObject();
    var requireObjectCoercible = requireRequireObjectCoercible();
    var sameValue = requireSameValue();
    var toString = requireToString();
    var getMethod = requireGetMethod();
    var regExpExec = requireRegexpExecAbstract();
    fixRegExpWellKnownSymbolLogic('search', function (SEARCH, nativeSearch, maybeCallNative) {
      return [function search(regexp) {
        var O = requireObjectCoercible(this);
        var searcher = isObject(regexp) ? getMethod(regexp, SEARCH) : undefined;
        return searcher ? call(searcher, regexp, O) : new RegExp(regexp)[SEARCH](toString(O));
      }, function (string) {
        var rx = anObject(this);
        var S = toString(string);
        var res = maybeCallNative(nativeSearch, rx, S);
        if (res.done) return res.value;
        var previousLastIndex = rx.lastIndex;
        if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
        var result = regExpExec(rx, S);
        if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
        return result === null ? -1 : result.index;
      }];
    });
    return es_string_search;
  }
  var es_string_split = {};
  var hasRequiredEs_string_split;
  function requireEs_string_split() {
    if (hasRequiredEs_string_split) return es_string_split;
    hasRequiredEs_string_split = 1;
    var call = requireFunctionCall();
    var uncurryThis = requireFunctionUncurryThis();
    var fixRegExpWellKnownSymbolLogic = requireFixRegexpWellKnownSymbolLogic();
    var anObject = requireAnObject();
    var isObject = requireIsObject();
    var requireObjectCoercible = requireRequireObjectCoercible();
    var speciesConstructor = requireSpeciesConstructor();
    var advanceStringIndex = requireAdvanceStringIndex();
    var toLength = requireToLength();
    var toString = requireToString();
    var getMethod = requireGetMethod();
    var regExpExec = requireRegexpExecAbstract();
    var stickyHelpers = requireRegexpStickyHelpers();
    var fails = requireFails();
    var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
    var MAX_UINT32 = 0xFFFFFFFF;
    var min = Math.min;
    var push = uncurryThis([].push);
    var stringSlice = uncurryThis(''.slice);
    var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {
      var re = /(?:)/;
      var originalExec = re.exec;
      re.exec = function () {
        return originalExec.apply(this, arguments);
      };
      var result = 'ab'.split(re);
      return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
    });
    var BUGGY = 'abbc'.split(/(b)*/)[1] === 'c' || 'test'.split(/(?:)/, -1).length !== 4 || 'ab'.split(/(?:ab)*/).length !== 2 || '.'.split(/(.?)(.?)/).length !== 4 || '.'.split(/()()/).length > 1 || ''.split(/.?/).length;
    fixRegExpWellKnownSymbolLogic('split', function (SPLIT, nativeSplit, maybeCallNative) {
      var internalSplit = '0'.split(undefined, 0).length ? function (separator, limit) {
        return separator === undefined && limit === 0 ? [] : call(nativeSplit, this, separator, limit);
      } : nativeSplit;
      return [function split(separator, limit) {
        var O = requireObjectCoercible(this);
        var splitter = isObject(separator) ? getMethod(separator, SPLIT) : undefined;
        return splitter ? call(splitter, separator, O, limit) : call(internalSplit, toString(O), separator, limit);
      }, function (string, limit) {
        var rx = anObject(this);
        var S = toString(string);
        if (!BUGGY) {
          var res = maybeCallNative(internalSplit, rx, S, limit, internalSplit !== nativeSplit);
          if (res.done) return res.value;
        }
        var C = speciesConstructor(rx, RegExp);
        var unicodeMatching = rx.unicode;
        var flags = (rx.ignoreCase ? 'i' : '') + (rx.multiline ? 'm' : '') + (rx.unicode ? 'u' : '') + (UNSUPPORTED_Y ? 'g' : 'y');
        var splitter = new C(UNSUPPORTED_Y ? '^(?:' + rx.source + ')' : rx, flags);
        var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
        if (lim === 0) return [];
        if (S.length === 0) return regExpExec(splitter, S) === null ? [S] : [];
        var p = 0;
        var q = 0;
        var A = [];
        while (q < S.length) {
          splitter.lastIndex = UNSUPPORTED_Y ? 0 : q;
          var z = regExpExec(splitter, UNSUPPORTED_Y ? stringSlice(S, q) : S);
          var e;
          if (z === null || (e = min(toLength(splitter.lastIndex + (UNSUPPORTED_Y ? q : 0)), S.length)) === p) {
            q = advanceStringIndex(S, q, unicodeMatching);
          } else {
            push(A, stringSlice(S, p, q));
            if (A.length === lim) return A;
            for (var i = 1; i <= z.length - 1; i++) {
              push(A, z[i]);
              if (A.length === lim) return A;
            }
            q = p = e;
          }
        }
        push(A, stringSlice(S, p));
        return A;
      }];
    }, BUGGY || !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y);
    return es_string_split;
  }
  var es_string_startsWith = {};
  var hasRequiredEs_string_startsWith;
  function requireEs_string_startsWith() {
    if (hasRequiredEs_string_startsWith) return es_string_startsWith;
    hasRequiredEs_string_startsWith = 1;
    var $ = require_export();
    var uncurryThis = requireFunctionUncurryThisClause();
    var getOwnPropertyDescriptor = requireObjectGetOwnPropertyDescriptor().f;
    var toLength = requireToLength();
    var toString = requireToString();
    var notARegExp = requireNotARegexp();
    var requireObjectCoercible = requireRequireObjectCoercible();
    var correctIsRegExpLogic = requireCorrectIsRegexpLogic();
    var IS_PURE = requireIsPure();
    var stringSlice = uncurryThis(''.slice);
    var min = Math.min;
    var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic('startsWith');
    var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function () {
      var descriptor = getOwnPropertyDescriptor(String.prototype, 'startsWith');
      return descriptor && !descriptor.writable;
    }();
    $({
      target: 'String',
      proto: true,
      forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC
    }, {
      startsWith: function startsWith(searchString) {
        var that = toString(requireObjectCoercible(this));
        notARegExp(searchString);
        var index = toLength(min(arguments.length > 1 ? arguments[1] : undefined, that.length));
        var search = toString(searchString);
        return stringSlice(that, index, index + search.length) === search;
      }
    });
    return es_string_startsWith;
  }
  var es_string_substr = {};
  var hasRequiredEs_string_substr;
  function requireEs_string_substr() {
    if (hasRequiredEs_string_substr) return es_string_substr;
    hasRequiredEs_string_substr = 1;
    var $ = require_export();
    var uncurryThis = requireFunctionUncurryThis();
    var requireObjectCoercible = requireRequireObjectCoercible();
    var toIntegerOrInfinity = requireToIntegerOrInfinity();
    var toString = requireToString();
    var stringSlice = uncurryThis(''.slice);
    var max = Math.max;
    var min = Math.min;
    var FORCED = !''.substr || 'ab'.substr(-1) !== 'b';
    $({
      target: 'String',
      proto: true,
      forced: FORCED
    }, {
      substr: function substr(start, length) {
        var that = toString(requireObjectCoercible(this));
        var size = that.length;
        var intStart = toIntegerOrInfinity(start);
        var intLength, intEnd;
        if (intStart === Infinity) intStart = 0;
        if (intStart < 0) intStart = max(size + intStart, 0);
        intLength = length === undefined ? size : toIntegerOrInfinity(length);
        if (intLength <= 0 || intLength === Infinity) return '';
        intEnd = min(intStart + intLength, size);
        return intStart >= intEnd ? '' : stringSlice(that, intStart, intEnd);
      }
    });
    return es_string_substr;
  }
  var es_string_toWellFormed = {};
  var hasRequiredEs_string_toWellFormed;
  function requireEs_string_toWellFormed() {
    if (hasRequiredEs_string_toWellFormed) return es_string_toWellFormed;
    hasRequiredEs_string_toWellFormed = 1;
    var $ = require_export();
    var call = requireFunctionCall();
    var uncurryThis = requireFunctionUncurryThis();
    var requireObjectCoercible = requireRequireObjectCoercible();
    var toString = requireToString();
    var fails = requireFails();
    var $Array = Array;
    var charAt = uncurryThis(''.charAt);
    var charCodeAt = uncurryThis(''.charCodeAt);
    var join = uncurryThis([].join);
    var $toWellFormed = ''.toWellFormed;
    var REPLACEMENT_CHARACTER = '\uFFFD';
    var TO_STRING_CONVERSION_BUG = $toWellFormed && fails(function () {
      return call($toWellFormed, 1) !== '1';
    });
    $({
      target: 'String',
      proto: true,
      forced: TO_STRING_CONVERSION_BUG
    }, {
      toWellFormed: function toWellFormed() {
        var S = toString(requireObjectCoercible(this));
        if (TO_STRING_CONVERSION_BUG) return call($toWellFormed, S);
        var length = S.length;
        var result = $Array(length);
        for (var i = 0; i < length; i++) {
          var charCode = charCodeAt(S, i);
          if ((charCode & 0xF800) !== 0xD800) result[i] = charAt(S, i);else if (charCode >= 0xDC00 || i + 1 >= length || (charCodeAt(S, i + 1) & 0xFC00) !== 0xDC00) result[i] = REPLACEMENT_CHARACTER;else {
            result[i] = charAt(S, i);
            result[++i] = charAt(S, i);
          }
        }
        return join(result, '');
      }
    });
    return es_string_toWellFormed;
  }
  var es_string_trim = {};
  var stringTrimForced;
  var hasRequiredStringTrimForced;
  function requireStringTrimForced() {
    if (hasRequiredStringTrimForced) return stringTrimForced;
    hasRequiredStringTrimForced = 1;
    var PROPER_FUNCTION_NAME = requireFunctionName().PROPER;
    var fails = requireFails();
    var whitespaces = requireWhitespaces();
    var non = '\u200B\u0085\u180E';
    stringTrimForced = function stringTrimForced(METHOD_NAME) {
      return fails(function () {
        return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() !== non || PROPER_FUNCTION_NAME && whitespaces[METHOD_NAME].name !== METHOD_NAME;
      });
    };
    return stringTrimForced;
  }
  var hasRequiredEs_string_trim;
  function requireEs_string_trim() {
    if (hasRequiredEs_string_trim) return es_string_trim;
    hasRequiredEs_string_trim = 1;
    var $ = require_export();
    var $trim = requireStringTrim().trim;
    var forcedStringTrimMethod = requireStringTrimForced();
    $({
      target: 'String',
      proto: true,
      forced: forcedStringTrimMethod('trim')
    }, {
      trim: function trim() {
        return $trim(this);
      }
    });
    return es_string_trim;
  }
  var es_string_trimEnd = {};
  var es_string_trimRight = {};
  var stringTrimEnd;
  var hasRequiredStringTrimEnd;
  function requireStringTrimEnd() {
    if (hasRequiredStringTrimEnd) return stringTrimEnd;
    hasRequiredStringTrimEnd = 1;
    var $trimEnd = requireStringTrim().end;
    var forcedStringTrimMethod = requireStringTrimForced();
    stringTrimEnd = forcedStringTrimMethod('trimEnd') ? function trimEnd() {
      return $trimEnd(this);
    } : ''.trimEnd;
    return stringTrimEnd;
  }
  var hasRequiredEs_string_trimRight;
  function requireEs_string_trimRight() {
    if (hasRequiredEs_string_trimRight) return es_string_trimRight;
    hasRequiredEs_string_trimRight = 1;
    var $ = require_export();
    var trimEnd = requireStringTrimEnd();
    $({
      target: 'String',
      proto: true,
      name: 'trimEnd',
      forced: ''.trimRight !== trimEnd
    }, {
      trimRight: trimEnd
    });
    return es_string_trimRight;
  }
  var hasRequiredEs_string_trimEnd;
  function requireEs_string_trimEnd() {
    if (hasRequiredEs_string_trimEnd) return es_string_trimEnd;
    hasRequiredEs_string_trimEnd = 1;
    requireEs_string_trimRight();
    var $ = require_export();
    var trimEnd = requireStringTrimEnd();
    $({
      target: 'String',
      proto: true,
      name: 'trimEnd',
      forced: ''.trimEnd !== trimEnd
    }, {
      trimEnd: trimEnd
    });
    return es_string_trimEnd;
  }
  var es_string_trimStart = {};
  var es_string_trimLeft = {};
  var stringTrimStart;
  var hasRequiredStringTrimStart;
  function requireStringTrimStart() {
    if (hasRequiredStringTrimStart) return stringTrimStart;
    hasRequiredStringTrimStart = 1;
    var $trimStart = requireStringTrim().start;
    var forcedStringTrimMethod = requireStringTrimForced();
    stringTrimStart = forcedStringTrimMethod('trimStart') ? function trimStart() {
      return $trimStart(this);
    } : ''.trimStart;
    return stringTrimStart;
  }
  var hasRequiredEs_string_trimLeft;
  function requireEs_string_trimLeft() {
    if (hasRequiredEs_string_trimLeft) return es_string_trimLeft;
    hasRequiredEs_string_trimLeft = 1;
    var $ = require_export();
    var trimStart = requireStringTrimStart();
    $({
      target: 'String',
      proto: true,
      name: 'trimStart',
      forced: ''.trimLeft !== trimStart
    }, {
      trimLeft: trimStart
    });
    return es_string_trimLeft;
  }
  var hasRequiredEs_string_trimStart;
  function requireEs_string_trimStart() {
    if (hasRequiredEs_string_trimStart) return es_string_trimStart;
    hasRequiredEs_string_trimStart = 1;
    requireEs_string_trimLeft();
    var $ = require_export();
    var trimStart = requireStringTrimStart();
    $({
      target: 'String',
      proto: true,
      name: 'trimStart',
      forced: ''.trimStart !== trimStart
    }, {
      trimStart: trimStart
    });
    return es_string_trimStart;
  }
  var es_string_anchor = {};
  var createHtml;
  var hasRequiredCreateHtml;
  function requireCreateHtml() {
    if (hasRequiredCreateHtml) return createHtml;
    hasRequiredCreateHtml = 1;
    var uncurryThis = requireFunctionUncurryThis();
    var requireObjectCoercible = requireRequireObjectCoercible();
    var toString = requireToString();
    var quot = /"/g;
    var replace = uncurryThis(''.replace);
    createHtml = function createHtml(string, tag, attribute, value) {
      var S = toString(requireObjectCoercible(string));
      var p1 = '<' + tag;
      if (attribute !== '') p1 += ' ' + attribute + '="' + replace(toString(value), quot, '&quot;') + '"';
      return p1 + '>' + S + '</' + tag + '>';
    };
    return createHtml;
  }
  var stringHtmlForced;
  var hasRequiredStringHtmlForced;
  function requireStringHtmlForced() {
    if (hasRequiredStringHtmlForced) return stringHtmlForced;
    hasRequiredStringHtmlForced = 1;
    var fails = requireFails();
    stringHtmlForced = function stringHtmlForced(METHOD_NAME) {
      return fails(function () {
        var test = ''[METHOD_NAME]('"');
        return test !== test.toLowerCase() || test.split('"').length > 3;
      });
    };
    return stringHtmlForced;
  }
  var hasRequiredEs_string_anchor;
  function requireEs_string_anchor() {
    if (hasRequiredEs_string_anchor) return es_string_anchor;
    hasRequiredEs_string_anchor = 1;
    var $ = require_export();
    var createHTML = requireCreateHtml();
    var forcedStringHTMLMethod = requireStringHtmlForced();
    $({
      target: 'String',
      proto: true,
      forced: forcedStringHTMLMethod('anchor')
    }, {
      anchor: function anchor(name) {
        return createHTML(this, 'a', 'name', name);
      }
    });
    return es_string_anchor;
  }
  var es_string_big = {};
  var hasRequiredEs_string_big;
  function requireEs_string_big() {
    if (hasRequiredEs_string_big) return es_string_big;
    hasRequiredEs_string_big = 1;
    var $ = require_export();
    var createHTML = requireCreateHtml();
    var forcedStringHTMLMethod = requireStringHtmlForced();
    $({
      target: 'String',
      proto: true,
      forced: forcedStringHTMLMethod('big')
    }, {
      big: function big() {
        return createHTML(this, 'big', '', '');
      }
    });
    return es_string_big;
  }
  var es_string_blink = {};
  var hasRequiredEs_string_blink;
  function requireEs_string_blink() {
    if (hasRequiredEs_string_blink) return es_string_blink;
    hasRequiredEs_string_blink = 1;
    var $ = require_export();
    var createHTML = requireCreateHtml();
    var forcedStringHTMLMethod = requireStringHtmlForced();
    $({
      target: 'String',
      proto: true,
      forced: forcedStringHTMLMethod('blink')
    }, {
      blink: function blink() {
        return createHTML(this, 'blink', '', '');
      }
    });
    return es_string_blink;
  }
  var es_string_bold = {};
  var hasRequiredEs_string_bold;
  function requireEs_string_bold() {
    if (hasRequiredEs_string_bold) return es_string_bold;
    hasRequiredEs_string_bold = 1;
    var $ = require_export();
    var createHTML = requireCreateHtml();
    var forcedStringHTMLMethod = requireStringHtmlForced();
    $({
      target: 'String',
      proto: true,
      forced: forcedStringHTMLMethod('bold')
    }, {
      bold: function bold() {
        return createHTML(this, 'b', '', '');
      }
    });
    return es_string_bold;
  }
  var es_string_fixed = {};
  var hasRequiredEs_string_fixed;
  function requireEs_string_fixed() {
    if (hasRequiredEs_string_fixed) return es_string_fixed;
    hasRequiredEs_string_fixed = 1;
    var $ = require_export();
    var createHTML = requireCreateHtml();
    var forcedStringHTMLMethod = requireStringHtmlForced();
    $({
      target: 'String',
      proto: true,
      forced: forcedStringHTMLMethod('fixed')
    }, {
      fixed: function fixed() {
        return createHTML(this, 'tt', '', '');
      }
    });
    return es_string_fixed;
  }
  var es_string_fontcolor = {};
  var hasRequiredEs_string_fontcolor;
  function requireEs_string_fontcolor() {
    if (hasRequiredEs_string_fontcolor) return es_string_fontcolor;
    hasRequiredEs_string_fontcolor = 1;
    var $ = require_export();
    var createHTML = requireCreateHtml();
    var forcedStringHTMLMethod = requireStringHtmlForced();
    $({
      target: 'String',
      proto: true,
      forced: forcedStringHTMLMethod('fontcolor')
    }, {
      fontcolor: function fontcolor(color) {
        return createHTML(this, 'font', 'color', color);
      }
    });
    return es_string_fontcolor;
  }
  var es_string_fontsize = {};
  var hasRequiredEs_string_fontsize;
  function requireEs_string_fontsize() {
    if (hasRequiredEs_string_fontsize) return es_string_fontsize;
    hasRequiredEs_string_fontsize = 1;
    var $ = require_export();
    var createHTML = requireCreateHtml();
    var forcedStringHTMLMethod = requireStringHtmlForced();
    $({
      target: 'String',
      proto: true,
      forced: forcedStringHTMLMethod('fontsize')
    }, {
      fontsize: function fontsize(size) {
        return createHTML(this, 'font', 'size', size);
      }
    });
    return es_string_fontsize;
  }
  var es_string_italics = {};
  var hasRequiredEs_string_italics;
  function requireEs_string_italics() {
    if (hasRequiredEs_string_italics) return es_string_italics;
    hasRequiredEs_string_italics = 1;
    var $ = require_export();
    var createHTML = requireCreateHtml();
    var forcedStringHTMLMethod = requireStringHtmlForced();
    $({
      target: 'String',
      proto: true,
      forced: forcedStringHTMLMethod('italics')
    }, {
      italics: function italics() {
        return createHTML(this, 'i', '', '');
      }
    });
    return es_string_italics;
  }
  var es_string_link = {};
  var hasRequiredEs_string_link;
  function requireEs_string_link() {
    if (hasRequiredEs_string_link) return es_string_link;
    hasRequiredEs_string_link = 1;
    var $ = require_export();
    var createHTML = requireCreateHtml();
    var forcedStringHTMLMethod = requireStringHtmlForced();
    $({
      target: 'String',
      proto: true,
      forced: forcedStringHTMLMethod('link')
    }, {
      link: function link(url) {
        return createHTML(this, 'a', 'href', url);
      }
    });
    return es_string_link;
  }
  var es_string_small = {};
  var hasRequiredEs_string_small;
  function requireEs_string_small() {
    if (hasRequiredEs_string_small) return es_string_small;
    hasRequiredEs_string_small = 1;
    var $ = require_export();
    var createHTML = requireCreateHtml();
    var forcedStringHTMLMethod = requireStringHtmlForced();
    $({
      target: 'String',
      proto: true,
      forced: forcedStringHTMLMethod('small')
    }, {
      small: function small() {
        return createHTML(this, 'small', '', '');
      }
    });
    return es_string_small;
  }
  var es_string_strike = {};
  var hasRequiredEs_string_strike;
  function requireEs_string_strike() {
    if (hasRequiredEs_string_strike) return es_string_strike;
    hasRequiredEs_string_strike = 1;
    var $ = require_export();
    var createHTML = requireCreateHtml();
    var forcedStringHTMLMethod = requireStringHtmlForced();
    $({
      target: 'String',
      proto: true,
      forced: forcedStringHTMLMethod('strike')
    }, {
      strike: function strike() {
        return createHTML(this, 'strike', '', '');
      }
    });
    return es_string_strike;
  }
  var es_string_sub = {};
  var hasRequiredEs_string_sub;
  function requireEs_string_sub() {
    if (hasRequiredEs_string_sub) return es_string_sub;
    hasRequiredEs_string_sub = 1;
    var $ = require_export();
    var createHTML = requireCreateHtml();
    var forcedStringHTMLMethod = requireStringHtmlForced();
    $({
      target: 'String',
      proto: true,
      forced: forcedStringHTMLMethod('sub')
    }, {
      sub: function sub() {
        return createHTML(this, 'sub', '', '');
      }
    });
    return es_string_sub;
  }
  var es_string_sup = {};
  var hasRequiredEs_string_sup;
  function requireEs_string_sup() {
    if (hasRequiredEs_string_sup) return es_string_sup;
    hasRequiredEs_string_sup = 1;
    var $ = require_export();
    var createHTML = requireCreateHtml();
    var forcedStringHTMLMethod = requireStringHtmlForced();
    $({
      target: 'String',
      proto: true,
      forced: forcedStringHTMLMethod('sup')
    }, {
      sup: function sup() {
        return createHTML(this, 'sup', '', '');
      }
    });
    return es_string_sup;
  }
  var es_typedArray_float32Array = {};
  var typedArrayConstructor = {
    exports: {}
  };
  var typedArrayConstructorsRequireWrappers;
  var hasRequiredTypedArrayConstructorsRequireWrappers;
  function requireTypedArrayConstructorsRequireWrappers() {
    if (hasRequiredTypedArrayConstructorsRequireWrappers) return typedArrayConstructorsRequireWrappers;
    hasRequiredTypedArrayConstructorsRequireWrappers = 1;
    var globalThis = requireGlobalThis();
    var fails = requireFails();
    var checkCorrectnessOfIteration = requireCheckCorrectnessOfIteration();
    var NATIVE_ARRAY_BUFFER_VIEWS = requireArrayBufferViewCore().NATIVE_ARRAY_BUFFER_VIEWS;
    var ArrayBuffer = globalThis.ArrayBuffer;
    var Int8Array = globalThis.Int8Array;
    typedArrayConstructorsRequireWrappers = !NATIVE_ARRAY_BUFFER_VIEWS || !fails(function () {
      Int8Array(1);
    }) || !fails(function () {
      new Int8Array(-1);
    }) || !checkCorrectnessOfIteration(function (iterable) {
      new Int8Array();
      new Int8Array(null);
      new Int8Array(1.5);
      new Int8Array(iterable);
    }, true) || fails(function () {
      return new Int8Array(new ArrayBuffer(2), 1, undefined).length !== 1;
    });
    return typedArrayConstructorsRequireWrappers;
  }
  var toOffset;
  var hasRequiredToOffset;
  function requireToOffset() {
    if (hasRequiredToOffset) return toOffset;
    hasRequiredToOffset = 1;
    var toPositiveInteger = requireToPositiveInteger();
    var $RangeError = RangeError;
    toOffset = function toOffset(it, BYTES) {
      var offset = toPositiveInteger(it);
      if (offset % BYTES) throw new $RangeError('Wrong offset');
      return offset;
    };
    return toOffset;
  }
  var toUint8Clamped;
  var hasRequiredToUint8Clamped;
  function requireToUint8Clamped() {
    if (hasRequiredToUint8Clamped) return toUint8Clamped;
    hasRequiredToUint8Clamped = 1;
    var round = Math.round;
    toUint8Clamped = function toUint8Clamped(it) {
      var value = round(it);
      return value < 0 ? 0 : value > 0xFF ? 0xFF : value & 0xFF;
    };
    return toUint8Clamped;
  }
  var isBigIntArray;
  var hasRequiredIsBigIntArray;
  function requireIsBigIntArray() {
    if (hasRequiredIsBigIntArray) return isBigIntArray;
    hasRequiredIsBigIntArray = 1;
    var classof = requireClassof();
    isBigIntArray = function isBigIntArray(it) {
      var klass = classof(it);
      return klass === 'BigInt64Array' || klass === 'BigUint64Array';
    };
    return isBigIntArray;
  }
  var toBigInt;
  var hasRequiredToBigInt;
  function requireToBigInt() {
    if (hasRequiredToBigInt) return toBigInt;
    hasRequiredToBigInt = 1;
    var toPrimitive = requireToPrimitive();
    var $TypeError = TypeError;
    toBigInt = function toBigInt(argument) {
      var prim = toPrimitive(argument, 'number');
      if (typeof prim == 'number') throw new $TypeError("Can't convert number to bigint");
      return BigInt(prim);
    };
    return toBigInt;
  }
  var typedArrayFrom;
  var hasRequiredTypedArrayFrom;
  function requireTypedArrayFrom() {
    if (hasRequiredTypedArrayFrom) return typedArrayFrom;
    hasRequiredTypedArrayFrom = 1;
    var bind = requireFunctionBindContext();
    var call = requireFunctionCall();
    var aConstructor = requireAConstructor();
    var toObject = requireToObject();
    var lengthOfArrayLike = requireLengthOfArrayLike();
    var getIterator = requireGetIterator();
    var getIteratorMethod = requireGetIteratorMethod();
    var isArrayIteratorMethod = requireIsArrayIteratorMethod();
    var isBigIntArray = requireIsBigIntArray();
    var aTypedArrayConstructor = requireArrayBufferViewCore().aTypedArrayConstructor;
    var toBigInt = requireToBigInt();
    typedArrayFrom = function from(source) {
      var C = aConstructor(this);
      var O = toObject(source);
      var argumentsLength = arguments.length;
      var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
      var mapping = mapfn !== undefined;
      var iteratorMethod = getIteratorMethod(O);
      var i, length, result, thisIsBigIntArray, value, step, iterator, next;
      if (iteratorMethod && !isArrayIteratorMethod(iteratorMethod)) {
        iterator = getIterator(O, iteratorMethod);
        next = iterator.next;
        O = [];
        while (!(step = call(next, iterator)).done) {
          O.push(step.value);
        }
      }
      if (mapping && argumentsLength > 2) {
        mapfn = bind(mapfn, arguments[2]);
      }
      length = lengthOfArrayLike(O);
      result = new (aTypedArrayConstructor(C))(length);
      thisIsBigIntArray = isBigIntArray(result);
      for (i = 0; length > i; i++) {
        value = mapping ? mapfn(O[i], i) : O[i];
        result[i] = thisIsBigIntArray ? toBigInt(value) : +value;
      }
      return result;
    };
    return typedArrayFrom;
  }
  var hasRequiredTypedArrayConstructor;
  function requireTypedArrayConstructor() {
    if (hasRequiredTypedArrayConstructor) return typedArrayConstructor.exports;
    hasRequiredTypedArrayConstructor = 1;
    var $ = require_export();
    var globalThis = requireGlobalThis();
    var call = requireFunctionCall();
    var DESCRIPTORS = requireDescriptors();
    var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = requireTypedArrayConstructorsRequireWrappers();
    var ArrayBufferViewCore = requireArrayBufferViewCore();
    var ArrayBufferModule = requireArrayBuffer();
    var anInstance = requireAnInstance();
    var createPropertyDescriptor = requireCreatePropertyDescriptor();
    var createNonEnumerableProperty = requireCreateNonEnumerableProperty();
    var isIntegralNumber = requireIsIntegralNumber();
    var toLength = requireToLength();
    var toIndex = requireToIndex();
    var toOffset = requireToOffset();
    var toUint8Clamped = requireToUint8Clamped();
    var toPropertyKey = requireToPropertyKey();
    var hasOwn = requireHasOwnProperty();
    var classof = requireClassof();
    var isObject = requireIsObject();
    var isSymbol = requireIsSymbol();
    var create = requireObjectCreate();
    var isPrototypeOf = requireObjectIsPrototypeOf();
    var setPrototypeOf = requireObjectSetPrototypeOf();
    var getOwnPropertyNames = requireObjectGetOwnPropertyNames().f;
    var typedArrayFrom = requireTypedArrayFrom();
    var forEach = requireArrayIteration().forEach;
    var setSpecies = requireSetSpecies();
    var defineBuiltInAccessor = requireDefineBuiltInAccessor();
    var definePropertyModule = requireObjectDefineProperty();
    var getOwnPropertyDescriptorModule = requireObjectGetOwnPropertyDescriptor();
    var arrayFromConstructorAndList = requireArrayFromConstructorAndList();
    var InternalStateModule = requireInternalState();
    var inheritIfRequired = requireInheritIfRequired();
    var getInternalState = InternalStateModule.get;
    var setInternalState = InternalStateModule.set;
    var enforceInternalState = InternalStateModule.enforce;
    var nativeDefineProperty = definePropertyModule.f;
    var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
    var RangeError = globalThis.RangeError;
    var ArrayBuffer = ArrayBufferModule.ArrayBuffer;
    var ArrayBufferPrototype = ArrayBuffer.prototype;
    var DataView = ArrayBufferModule.DataView;
    var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
    var TYPED_ARRAY_TAG = ArrayBufferViewCore.TYPED_ARRAY_TAG;
    var TypedArray = ArrayBufferViewCore.TypedArray;
    var TypedArrayPrototype = ArrayBufferViewCore.TypedArrayPrototype;
    var isTypedArray = ArrayBufferViewCore.isTypedArray;
    var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
    var WRONG_LENGTH = 'Wrong length';
    var addGetter = function addGetter(it, key) {
      defineBuiltInAccessor(it, key, {
        configurable: true,
        get: function get() {
          return getInternalState(this)[key];
        }
      });
    };
    var isArrayBuffer = function isArrayBuffer(it) {
      var klass;
      return isPrototypeOf(ArrayBufferPrototype, it) || (klass = classof(it)) === 'ArrayBuffer' || klass === 'SharedArrayBuffer';
    };
    var isTypedArrayIndex = function isTypedArrayIndex(target, key) {
      return isTypedArray(target) && !isSymbol(key) && key in target && isIntegralNumber(+key) && key >= 0;
    };
    var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
      key = toPropertyKey(key);
      return isTypedArrayIndex(target, key) ? createPropertyDescriptor(2, target[key]) : nativeGetOwnPropertyDescriptor(target, key);
    };
    var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
      key = toPropertyKey(key);
      if (isTypedArrayIndex(target, key) && isObject(descriptor) && hasOwn(descriptor, 'value') && !hasOwn(descriptor, 'get') && !hasOwn(descriptor, 'set') && !descriptor.configurable && (!hasOwn(descriptor, 'writable') || descriptor.writable) && (!hasOwn(descriptor, 'enumerable') || descriptor.enumerable)) {
        target[key] = descriptor.value;
        return target;
      }
      return nativeDefineProperty(target, key, descriptor);
    };
    if (DESCRIPTORS) {
      if (!NATIVE_ARRAY_BUFFER_VIEWS) {
        getOwnPropertyDescriptorModule.f = wrappedGetOwnPropertyDescriptor;
        definePropertyModule.f = wrappedDefineProperty;
        addGetter(TypedArrayPrototype, 'buffer');
        addGetter(TypedArrayPrototype, 'byteOffset');
        addGetter(TypedArrayPrototype, 'byteLength');
        addGetter(TypedArrayPrototype, 'length');
      }
      $({
        target: 'Object',
        stat: true,
        forced: !NATIVE_ARRAY_BUFFER_VIEWS
      }, {
        getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
        defineProperty: wrappedDefineProperty
      });
      typedArrayConstructor.exports = function (TYPE, wrapper, CLAMPED) {
        var BYTES = TYPE.match(/\d+/)[0] / 8;
        var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';
        var GETTER = 'get' + TYPE;
        var SETTER = 'set' + TYPE;
        var NativeTypedArrayConstructor = globalThis[CONSTRUCTOR_NAME];
        var TypedArrayConstructor = NativeTypedArrayConstructor;
        var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
        var exported = {};
        var getter = function getter(that, index) {
          var data = getInternalState(that);
          return data.view[GETTER](index * BYTES + data.byteOffset, true);
        };
        var setter = function setter(that, index, value) {
          var data = getInternalState(that);
          data.view[SETTER](index * BYTES + data.byteOffset, CLAMPED ? toUint8Clamped(value) : value, true);
        };
        var addElement = function addElement(that, index) {
          nativeDefineProperty(that, index, {
            get: function get() {
              return getter(this, index);
            },
            set: function set(value) {
              return setter(this, index, value);
            },
            enumerable: true
          });
        };
        if (!NATIVE_ARRAY_BUFFER_VIEWS) {
          TypedArrayConstructor = wrapper(function (that, data, offset, $length) {
            anInstance(that, TypedArrayConstructorPrototype);
            var index = 0;
            var byteOffset = 0;
            var buffer, byteLength, length;
            if (!isObject(data)) {
              length = toIndex(data);
              byteLength = length * BYTES;
              buffer = new ArrayBuffer(byteLength);
            } else if (isArrayBuffer(data)) {
              buffer = data;
              byteOffset = toOffset(offset, BYTES);
              var $len = data.byteLength;
              if ($length === undefined) {
                if ($len % BYTES) throw new RangeError(WRONG_LENGTH);
                byteLength = $len - byteOffset;
                if (byteLength < 0) throw new RangeError(WRONG_LENGTH);
              } else {
                byteLength = toLength($length) * BYTES;
                if (byteLength + byteOffset > $len) throw new RangeError(WRONG_LENGTH);
              }
              length = byteLength / BYTES;
            } else if (isTypedArray(data)) {
              return arrayFromConstructorAndList(TypedArrayConstructor, data);
            } else {
              return call(typedArrayFrom, TypedArrayConstructor, data);
            }
            setInternalState(that, {
              buffer: buffer,
              byteOffset: byteOffset,
              byteLength: byteLength,
              length: length,
              view: new DataView(buffer)
            });
            while (index < length) addElement(that, index++);
          });
          if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
          TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = create(TypedArrayPrototype);
        } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS) {
          TypedArrayConstructor = wrapper(function (dummy, data, typedArrayOffset, $length) {
            anInstance(dummy, TypedArrayConstructorPrototype);
            return inheritIfRequired(function () {
              if (!isObject(data)) return new NativeTypedArrayConstructor(toIndex(data));
              if (isArrayBuffer(data)) return $length !== undefined ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length) : typedArrayOffset !== undefined ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES)) : new NativeTypedArrayConstructor(data);
              if (isTypedArray(data)) return arrayFromConstructorAndList(TypedArrayConstructor, data);
              return call(typedArrayFrom, TypedArrayConstructor, data);
            }(), dummy, TypedArrayConstructor);
          });
          if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
          forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function (key) {
            if (!(key in TypedArrayConstructor)) {
              createNonEnumerableProperty(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
            }
          });
          TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
        }
        if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
          createNonEnumerableProperty(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);
        }
        enforceInternalState(TypedArrayConstructorPrototype).TypedArrayConstructor = TypedArrayConstructor;
        if (TYPED_ARRAY_TAG) {
          createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
        }
        var FORCED = TypedArrayConstructor !== NativeTypedArrayConstructor;
        exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;
        $({
          global: true,
          constructor: true,
          forced: FORCED,
          sham: !NATIVE_ARRAY_BUFFER_VIEWS
        }, exported);
        if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
          createNonEnumerableProperty(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
        }
        if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
          createNonEnumerableProperty(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
        }
        setSpecies(CONSTRUCTOR_NAME);
      };
    } else typedArrayConstructor.exports = function () {};
    return typedArrayConstructor.exports;
  }
  var hasRequiredEs_typedArray_float32Array;
  function requireEs_typedArray_float32Array() {
    if (hasRequiredEs_typedArray_float32Array) return es_typedArray_float32Array;
    hasRequiredEs_typedArray_float32Array = 1;
    var createTypedArrayConstructor = requireTypedArrayConstructor();
    createTypedArrayConstructor('Float32', function (init) {
      return function Float32Array(data, byteOffset, length) {
        return init(this, data, byteOffset, length);
      };
    });
    return es_typedArray_float32Array;
  }
  var es_typedArray_float64Array = {};
  var hasRequiredEs_typedArray_float64Array;
  function requireEs_typedArray_float64Array() {
    if (hasRequiredEs_typedArray_float64Array) return es_typedArray_float64Array;
    hasRequiredEs_typedArray_float64Array = 1;
    var createTypedArrayConstructor = requireTypedArrayConstructor();
    createTypedArrayConstructor('Float64', function (init) {
      return function Float64Array(data, byteOffset, length) {
        return init(this, data, byteOffset, length);
      };
    });
    return es_typedArray_float64Array;
  }
  var es_typedArray_int8Array = {};
  var hasRequiredEs_typedArray_int8Array;
  function requireEs_typedArray_int8Array() {
    if (hasRequiredEs_typedArray_int8Array) return es_typedArray_int8Array;
    hasRequiredEs_typedArray_int8Array = 1;
    var createTypedArrayConstructor = requireTypedArrayConstructor();
    createTypedArrayConstructor('Int8', function (init) {
      return function Int8Array(data, byteOffset, length) {
        return init(this, data, byteOffset, length);
      };
    });
    return es_typedArray_int8Array;
  }
  var es_typedArray_int16Array = {};
  var hasRequiredEs_typedArray_int16Array;
  function requireEs_typedArray_int16Array() {
    if (hasRequiredEs_typedArray_int16Array) return es_typedArray_int16Array;
    hasRequiredEs_typedArray_int16Array = 1;
    var createTypedArrayConstructor = requireTypedArrayConstructor();
    createTypedArrayConstructor('Int16', function (init) {
      return function Int16Array(data, byteOffset, length) {
        return init(this, data, byteOffset, length);
      };
    });
    return es_typedArray_int16Array;
  }
  var es_typedArray_int32Array = {};
  var hasRequiredEs_typedArray_int32Array;
  function requireEs_typedArray_int32Array() {
    if (hasRequiredEs_typedArray_int32Array) return es_typedArray_int32Array;
    hasRequiredEs_typedArray_int32Array = 1;
    var createTypedArrayConstructor = requireTypedArrayConstructor();
    createTypedArrayConstructor('Int32', function (init) {
      return function Int32Array(data, byteOffset, length) {
        return init(this, data, byteOffset, length);
      };
    });
    return es_typedArray_int32Array;
  }
  var es_typedArray_uint8Array = {};
  var hasRequiredEs_typedArray_uint8Array;
  function requireEs_typedArray_uint8Array() {
    if (hasRequiredEs_typedArray_uint8Array) return es_typedArray_uint8Array;
    hasRequiredEs_typedArray_uint8Array = 1;
    var createTypedArrayConstructor = requireTypedArrayConstructor();
    createTypedArrayConstructor('Uint8', function (init) {
      return function Uint8Array(data, byteOffset, length) {
        return init(this, data, byteOffset, length);
      };
    });
    return es_typedArray_uint8Array;
  }
  var es_typedArray_uint8ClampedArray = {};
  var hasRequiredEs_typedArray_uint8ClampedArray;
  function requireEs_typedArray_uint8ClampedArray() {
    if (hasRequiredEs_typedArray_uint8ClampedArray) return es_typedArray_uint8ClampedArray;
    hasRequiredEs_typedArray_uint8ClampedArray = 1;
    var createTypedArrayConstructor = requireTypedArrayConstructor();
    createTypedArrayConstructor('Uint8', function (init) {
      return function Uint8ClampedArray(data, byteOffset, length) {
        return init(this, data, byteOffset, length);
      };
    }, true);
    return es_typedArray_uint8ClampedArray;
  }
  var es_typedArray_uint16Array = {};
  var hasRequiredEs_typedArray_uint16Array;
  function requireEs_typedArray_uint16Array() {
    if (hasRequiredEs_typedArray_uint16Array) return es_typedArray_uint16Array;
    hasRequiredEs_typedArray_uint16Array = 1;
    var createTypedArrayConstructor = requireTypedArrayConstructor();
    createTypedArrayConstructor('Uint16', function (init) {
      return function Uint16Array(data, byteOffset, length) {
        return init(this, data, byteOffset, length);
      };
    });
    return es_typedArray_uint16Array;
  }
  var es_typedArray_uint32Array = {};
  var hasRequiredEs_typedArray_uint32Array;
  function requireEs_typedArray_uint32Array() {
    if (hasRequiredEs_typedArray_uint32Array) return es_typedArray_uint32Array;
    hasRequiredEs_typedArray_uint32Array = 1;
    var createTypedArrayConstructor = requireTypedArrayConstructor();
    createTypedArrayConstructor('Uint32', function (init) {
      return function Uint32Array(data, byteOffset, length) {
        return init(this, data, byteOffset, length);
      };
    });
    return es_typedArray_uint32Array;
  }
  var es_typedArray_at = {};
  var hasRequiredEs_typedArray_at;
  function requireEs_typedArray_at() {
    if (hasRequiredEs_typedArray_at) return es_typedArray_at;
    hasRequiredEs_typedArray_at = 1;
    var ArrayBufferViewCore = requireArrayBufferViewCore();
    var lengthOfArrayLike = requireLengthOfArrayLike();
    var toIntegerOrInfinity = requireToIntegerOrInfinity();
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    exportTypedArrayMethod('at', function at(index) {
      var O = aTypedArray(this);
      var len = lengthOfArrayLike(O);
      var relativeIndex = toIntegerOrInfinity(index);
      var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
      return k < 0 || k >= len ? undefined : O[k];
    });
    return es_typedArray_at;
  }
  var es_typedArray_copyWithin = {};
  var hasRequiredEs_typedArray_copyWithin;
  function requireEs_typedArray_copyWithin() {
    if (hasRequiredEs_typedArray_copyWithin) return es_typedArray_copyWithin;
    hasRequiredEs_typedArray_copyWithin = 1;
    var uncurryThis = requireFunctionUncurryThis();
    var ArrayBufferViewCore = requireArrayBufferViewCore();
    var $ArrayCopyWithin = requireArrayCopyWithin();
    var u$ArrayCopyWithin = uncurryThis($ArrayCopyWithin);
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    exportTypedArrayMethod('copyWithin', function copyWithin(target, start) {
      return u$ArrayCopyWithin(aTypedArray(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    });
    return es_typedArray_copyWithin;
  }
  var es_typedArray_every = {};
  var hasRequiredEs_typedArray_every;
  function requireEs_typedArray_every() {
    if (hasRequiredEs_typedArray_every) return es_typedArray_every;
    hasRequiredEs_typedArray_every = 1;
    var ArrayBufferViewCore = requireArrayBufferViewCore();
    var $every = requireArrayIteration().every;
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    exportTypedArrayMethod('every', function every(callbackfn) {
      return $every(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    });
    return es_typedArray_every;
  }
  var es_typedArray_fill = {};
  var hasRequiredEs_typedArray_fill;
  function requireEs_typedArray_fill() {
    if (hasRequiredEs_typedArray_fill) return es_typedArray_fill;
    hasRequiredEs_typedArray_fill = 1;
    var ArrayBufferViewCore = requireArrayBufferViewCore();
    var $fill = requireArrayFill();
    var toBigInt = requireToBigInt();
    var classof = requireClassof();
    var call = requireFunctionCall();
    var uncurryThis = requireFunctionUncurryThis();
    var fails = requireFails();
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    var slice = uncurryThis(''.slice);
    var CONVERSION_BUG = fails(function () {
      var count = 0;
      new Int8Array(2).fill({
        valueOf: function valueOf() {
          return count++;
        }
      });
      return count !== 1;
    });
    exportTypedArrayMethod('fill', function fill(value) {
      var length = arguments.length;
      aTypedArray(this);
      var actualValue = slice(classof(this), 0, 3) === 'Big' ? toBigInt(value) : +value;
      return call($fill, this, actualValue, length > 1 ? arguments[1] : undefined, length > 2 ? arguments[2] : undefined);
    }, CONVERSION_BUG);
    return es_typedArray_fill;
  }
  var es_typedArray_filter = {};
  var typedArrayFromSameTypeAndList;
  var hasRequiredTypedArrayFromSameTypeAndList;
  function requireTypedArrayFromSameTypeAndList() {
    if (hasRequiredTypedArrayFromSameTypeAndList) return typedArrayFromSameTypeAndList;
    hasRequiredTypedArrayFromSameTypeAndList = 1;
    var arrayFromConstructorAndList = requireArrayFromConstructorAndList();
    var getTypedArrayConstructor = requireArrayBufferViewCore().getTypedArrayConstructor;
    typedArrayFromSameTypeAndList = function typedArrayFromSameTypeAndList(instance, list) {
      return arrayFromConstructorAndList(getTypedArrayConstructor(instance), list);
    };
    return typedArrayFromSameTypeAndList;
  }
  var hasRequiredEs_typedArray_filter;
  function requireEs_typedArray_filter() {
    if (hasRequiredEs_typedArray_filter) return es_typedArray_filter;
    hasRequiredEs_typedArray_filter = 1;
    var ArrayBufferViewCore = requireArrayBufferViewCore();
    var $filter = requireArrayIteration().filter;
    var fromSameTypeAndList = requireTypedArrayFromSameTypeAndList();
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    exportTypedArrayMethod('filter', function filter(callbackfn) {
      var list = $filter(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
      return fromSameTypeAndList(this, list);
    });
    return es_typedArray_filter;
  }
  var es_typedArray_find = {};
  var hasRequiredEs_typedArray_find;
  function requireEs_typedArray_find() {
    if (hasRequiredEs_typedArray_find) return es_typedArray_find;
    hasRequiredEs_typedArray_find = 1;
    var ArrayBufferViewCore = requireArrayBufferViewCore();
    var $find = requireArrayIteration().find;
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    exportTypedArrayMethod('find', function find(predicate) {
      return $find(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    });
    return es_typedArray_find;
  }
  var es_typedArray_findIndex = {};
  var hasRequiredEs_typedArray_findIndex;
  function requireEs_typedArray_findIndex() {
    if (hasRequiredEs_typedArray_findIndex) return es_typedArray_findIndex;
    hasRequiredEs_typedArray_findIndex = 1;
    var ArrayBufferViewCore = requireArrayBufferViewCore();
    var $findIndex = requireArrayIteration().findIndex;
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    exportTypedArrayMethod('findIndex', function findIndex(predicate) {
      return $findIndex(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    });
    return es_typedArray_findIndex;
  }
  var es_typedArray_findLast = {};
  var hasRequiredEs_typedArray_findLast;
  function requireEs_typedArray_findLast() {
    if (hasRequiredEs_typedArray_findLast) return es_typedArray_findLast;
    hasRequiredEs_typedArray_findLast = 1;
    var ArrayBufferViewCore = requireArrayBufferViewCore();
    var $findLast = requireArrayIterationFromLast().findLast;
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    exportTypedArrayMethod('findLast', function findLast(predicate) {
      return $findLast(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    });
    return es_typedArray_findLast;
  }
  var es_typedArray_findLastIndex = {};
  var hasRequiredEs_typedArray_findLastIndex;
  function requireEs_typedArray_findLastIndex() {
    if (hasRequiredEs_typedArray_findLastIndex) return es_typedArray_findLastIndex;
    hasRequiredEs_typedArray_findLastIndex = 1;
    var ArrayBufferViewCore = requireArrayBufferViewCore();
    var $findLastIndex = requireArrayIterationFromLast().findLastIndex;
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    exportTypedArrayMethod('findLastIndex', function findLastIndex(predicate) {
      return $findLastIndex(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    });
    return es_typedArray_findLastIndex;
  }
  var es_typedArray_forEach = {};
  var hasRequiredEs_typedArray_forEach;
  function requireEs_typedArray_forEach() {
    if (hasRequiredEs_typedArray_forEach) return es_typedArray_forEach;
    hasRequiredEs_typedArray_forEach = 1;
    var ArrayBufferViewCore = requireArrayBufferViewCore();
    var $forEach = requireArrayIteration().forEach;
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    exportTypedArrayMethod('forEach', function forEach(callbackfn) {
      $forEach(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    });
    return es_typedArray_forEach;
  }
  var es_typedArray_from = {};
  var hasRequiredEs_typedArray_from;
  function requireEs_typedArray_from() {
    if (hasRequiredEs_typedArray_from) return es_typedArray_from;
    hasRequiredEs_typedArray_from = 1;
    var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = requireTypedArrayConstructorsRequireWrappers();
    var exportTypedArrayStaticMethod = requireArrayBufferViewCore().exportTypedArrayStaticMethod;
    var typedArrayFrom = requireTypedArrayFrom();
    exportTypedArrayStaticMethod('from', typedArrayFrom, TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS);
    return es_typedArray_from;
  }
  var es_typedArray_includes = {};
  var hasRequiredEs_typedArray_includes;
  function requireEs_typedArray_includes() {
    if (hasRequiredEs_typedArray_includes) return es_typedArray_includes;
    hasRequiredEs_typedArray_includes = 1;
    var ArrayBufferViewCore = requireArrayBufferViewCore();
    var $includes = requireArrayIncludes().includes;
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    exportTypedArrayMethod('includes', function includes(searchElement) {
      return $includes(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    });
    return es_typedArray_includes;
  }
  var es_typedArray_indexOf = {};
  var hasRequiredEs_typedArray_indexOf;
  function requireEs_typedArray_indexOf() {
    if (hasRequiredEs_typedArray_indexOf) return es_typedArray_indexOf;
    hasRequiredEs_typedArray_indexOf = 1;
    var ArrayBufferViewCore = requireArrayBufferViewCore();
    var $indexOf = requireArrayIncludes().indexOf;
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    exportTypedArrayMethod('indexOf', function indexOf(searchElement) {
      return $indexOf(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    });
    return es_typedArray_indexOf;
  }
  var es_typedArray_iterator = {};
  var hasRequiredEs_typedArray_iterator;
  function requireEs_typedArray_iterator() {
    if (hasRequiredEs_typedArray_iterator) return es_typedArray_iterator;
    hasRequiredEs_typedArray_iterator = 1;
    var globalThis = requireGlobalThis();
    var fails = requireFails();
    var uncurryThis = requireFunctionUncurryThis();
    var ArrayBufferViewCore = requireArrayBufferViewCore();
    var ArrayIterators = requireEs_array_iterator();
    var wellKnownSymbol = requireWellKnownSymbol();
    var ITERATOR = wellKnownSymbol('iterator');
    var Uint8Array = globalThis.Uint8Array;
    var arrayValues = uncurryThis(ArrayIterators.values);
    var arrayKeys = uncurryThis(ArrayIterators.keys);
    var arrayEntries = uncurryThis(ArrayIterators.entries);
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    var TypedArrayPrototype = Uint8Array && Uint8Array.prototype;
    var GENERIC = !fails(function () {
      TypedArrayPrototype[ITERATOR].call([1]);
    });
    var ITERATOR_IS_VALUES = !!TypedArrayPrototype && TypedArrayPrototype.values && TypedArrayPrototype[ITERATOR] === TypedArrayPrototype.values && TypedArrayPrototype.values.name === 'values';
    var typedArrayValues = function values() {
      return arrayValues(aTypedArray(this));
    };
    exportTypedArrayMethod('entries', function entries() {
      return arrayEntries(aTypedArray(this));
    }, GENERIC);
    exportTypedArrayMethod('keys', function keys() {
      return arrayKeys(aTypedArray(this));
    }, GENERIC);
    exportTypedArrayMethod('values', typedArrayValues, GENERIC || !ITERATOR_IS_VALUES, {
      name: 'values'
    });
    exportTypedArrayMethod(ITERATOR, typedArrayValues, GENERIC || !ITERATOR_IS_VALUES, {
      name: 'values'
    });
    return es_typedArray_iterator;
  }
  var es_typedArray_join = {};
  var hasRequiredEs_typedArray_join;
  function requireEs_typedArray_join() {
    if (hasRequiredEs_typedArray_join) return es_typedArray_join;
    hasRequiredEs_typedArray_join = 1;
    var ArrayBufferViewCore = requireArrayBufferViewCore();
    var uncurryThis = requireFunctionUncurryThis();
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    var $join = uncurryThis([].join);
    exportTypedArrayMethod('join', function join(separator) {
      return $join(aTypedArray(this), separator);
    });
    return es_typedArray_join;
  }
  var es_typedArray_lastIndexOf = {};
  var hasRequiredEs_typedArray_lastIndexOf;
  function requireEs_typedArray_lastIndexOf() {
    if (hasRequiredEs_typedArray_lastIndexOf) return es_typedArray_lastIndexOf;
    hasRequiredEs_typedArray_lastIndexOf = 1;
    var ArrayBufferViewCore = requireArrayBufferViewCore();
    var apply = requireFunctionApply();
    var $lastIndexOf = requireArrayLastIndexOf();
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    exportTypedArrayMethod('lastIndexOf', function lastIndexOf(searchElement) {
      var length = arguments.length;
      return apply($lastIndexOf, aTypedArray(this), length > 1 ? [searchElement, arguments[1]] : [searchElement]);
    });
    return es_typedArray_lastIndexOf;
  }
  var es_typedArray_map = {};
  var hasRequiredEs_typedArray_map;
  function requireEs_typedArray_map() {
    if (hasRequiredEs_typedArray_map) return es_typedArray_map;
    hasRequiredEs_typedArray_map = 1;
    var ArrayBufferViewCore = requireArrayBufferViewCore();
    var $map = requireArrayIteration().map;
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    exportTypedArrayMethod('map', function map(mapfn) {
      return $map(aTypedArray(this), mapfn, arguments.length > 1 ? arguments[1] : undefined, function (O, length) {
        return new (getTypedArrayConstructor(O))(length);
      });
    });
    return es_typedArray_map;
  }
  var es_typedArray_of = {};
  var hasRequiredEs_typedArray_of;
  function requireEs_typedArray_of() {
    if (hasRequiredEs_typedArray_of) return es_typedArray_of;
    hasRequiredEs_typedArray_of = 1;
    var ArrayBufferViewCore = requireArrayBufferViewCore();
    var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = requireTypedArrayConstructorsRequireWrappers();
    var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
    var exportTypedArrayStaticMethod = ArrayBufferViewCore.exportTypedArrayStaticMethod;
    exportTypedArrayStaticMethod('of', function of() {
      var index = 0;
      var length = arguments.length;
      var result = new (aTypedArrayConstructor(this))(length);
      while (length > index) result[index] = arguments[index++];
      return result;
    }, TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS);
    return es_typedArray_of;
  }
  var es_typedArray_reduce = {};
  var hasRequiredEs_typedArray_reduce;
  function requireEs_typedArray_reduce() {
    if (hasRequiredEs_typedArray_reduce) return es_typedArray_reduce;
    hasRequiredEs_typedArray_reduce = 1;
    var ArrayBufferViewCore = requireArrayBufferViewCore();
    var $reduce = requireArrayReduce().left;
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    exportTypedArrayMethod('reduce', function reduce(callbackfn) {
      var length = arguments.length;
      return $reduce(aTypedArray(this), callbackfn, length, length > 1 ? arguments[1] : undefined);
    });
    return es_typedArray_reduce;
  }
  var es_typedArray_reduceRight = {};
  var hasRequiredEs_typedArray_reduceRight;
  function requireEs_typedArray_reduceRight() {
    if (hasRequiredEs_typedArray_reduceRight) return es_typedArray_reduceRight;
    hasRequiredEs_typedArray_reduceRight = 1;
    var ArrayBufferViewCore = requireArrayBufferViewCore();
    var $reduceRight = requireArrayReduce().right;
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    exportTypedArrayMethod('reduceRight', function reduceRight(callbackfn) {
      var length = arguments.length;
      return $reduceRight(aTypedArray(this), callbackfn, length, length > 1 ? arguments[1] : undefined);
    });
    return es_typedArray_reduceRight;
  }
  var es_typedArray_reverse = {};
  var hasRequiredEs_typedArray_reverse;
  function requireEs_typedArray_reverse() {
    if (hasRequiredEs_typedArray_reverse) return es_typedArray_reverse;
    hasRequiredEs_typedArray_reverse = 1;
    var ArrayBufferViewCore = requireArrayBufferViewCore();
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    var floor = Math.floor;
    exportTypedArrayMethod('reverse', function reverse() {
      var that = this;
      var length = aTypedArray(that).length;
      var middle = floor(length / 2);
      var index = 0;
      var value;
      while (index < middle) {
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
      }
      return that;
    });
    return es_typedArray_reverse;
  }
  var es_typedArray_set = {};
  var hasRequiredEs_typedArray_set;
  function requireEs_typedArray_set() {
    if (hasRequiredEs_typedArray_set) return es_typedArray_set;
    hasRequiredEs_typedArray_set = 1;
    var globalThis = requireGlobalThis();
    var call = requireFunctionCall();
    var ArrayBufferViewCore = requireArrayBufferViewCore();
    var lengthOfArrayLike = requireLengthOfArrayLike();
    var toOffset = requireToOffset();
    var toIndexedObject = requireToObject();
    var fails = requireFails();
    var RangeError = globalThis.RangeError;
    var Int8Array = globalThis.Int8Array;
    var Int8ArrayPrototype = Int8Array && Int8Array.prototype;
    var $set = Int8ArrayPrototype && Int8ArrayPrototype.set;
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    var WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS = !fails(function () {
      var array = new Uint8ClampedArray(2);
      call($set, array, {
        length: 1,
        0: 3
      }, 1);
      return array[1] !== 3;
    });
    var TO_OBJECT_BUG = WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS && ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS && fails(function () {
      var array = new Int8Array(2);
      array.set(1);
      array.set('2', 1);
      return array[0] !== 0 || array[1] !== 2;
    });
    exportTypedArrayMethod('set', function set(arrayLike) {
      aTypedArray(this);
      var offset = toOffset(arguments.length > 1 ? arguments[1] : undefined, 1);
      var src = toIndexedObject(arrayLike);
      if (WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS) return call($set, this, src, offset);
      var length = this.length;
      var len = lengthOfArrayLike(src);
      var index = 0;
      if (len + offset > length) throw new RangeError('Wrong length');
      while (index < len) this[offset + index] = src[index++];
    }, !WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS || TO_OBJECT_BUG);
    return es_typedArray_set;
  }
  var es_typedArray_slice = {};
  var hasRequiredEs_typedArray_slice;
  function requireEs_typedArray_slice() {
    if (hasRequiredEs_typedArray_slice) return es_typedArray_slice;
    hasRequiredEs_typedArray_slice = 1;
    var ArrayBufferViewCore = requireArrayBufferViewCore();
    var fails = requireFails();
    var arraySlice = requireArraySlice();
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    var FORCED = fails(function () {
      new Int8Array(1).slice();
    });
    exportTypedArrayMethod('slice', function slice(start, end) {
      var list = arraySlice(aTypedArray(this), start, end);
      var C = getTypedArrayConstructor(this);
      var index = 0;
      var length = list.length;
      var result = new C(length);
      while (length > index) result[index] = list[index++];
      return result;
    }, FORCED);
    return es_typedArray_slice;
  }
  var es_typedArray_some = {};
  var hasRequiredEs_typedArray_some;
  function requireEs_typedArray_some() {
    if (hasRequiredEs_typedArray_some) return es_typedArray_some;
    hasRequiredEs_typedArray_some = 1;
    var ArrayBufferViewCore = requireArrayBufferViewCore();
    var $some = requireArrayIteration().some;
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    exportTypedArrayMethod('some', function some(callbackfn) {
      return $some(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    });
    return es_typedArray_some;
  }
  var es_typedArray_sort = {};
  var hasRequiredEs_typedArray_sort;
  function requireEs_typedArray_sort() {
    if (hasRequiredEs_typedArray_sort) return es_typedArray_sort;
    hasRequiredEs_typedArray_sort = 1;
    var globalThis = requireGlobalThis();
    var uncurryThis = requireFunctionUncurryThisClause();
    var fails = requireFails();
    var aCallable = requireACallable();
    var internalSort = requireArraySort();
    var ArrayBufferViewCore = requireArrayBufferViewCore();
    var FF = requireEnvironmentFfVersion();
    var IE_OR_EDGE = requireEnvironmentIsIeOrEdge();
    var V8 = requireEnvironmentV8Version();
    var WEBKIT = requireEnvironmentWebkitVersion();
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    var Uint16Array = globalThis.Uint16Array;
    var nativeSort = Uint16Array && uncurryThis(Uint16Array.prototype.sort);
    var ACCEPT_INCORRECT_ARGUMENTS = !!nativeSort && !(fails(function () {
      nativeSort(new Uint16Array(2), null);
    }) && fails(function () {
      nativeSort(new Uint16Array(2), {});
    }));
    var STABLE_SORT = !!nativeSort && !fails(function () {
      if (V8) return V8 < 74;
      if (FF) return FF < 67;
      if (IE_OR_EDGE) return true;
      if (WEBKIT) return WEBKIT < 602;
      var array = new Uint16Array(516);
      var expected = Array(516);
      var index, mod;
      for (index = 0; index < 516; index++) {
        mod = index % 4;
        array[index] = 515 - index;
        expected[index] = index - 2 * mod + 3;
      }
      nativeSort(array, function (a, b) {
        return (a / 4 | 0) - (b / 4 | 0);
      });
      for (index = 0; index < 516; index++) {
        if (array[index] !== expected[index]) return true;
      }
    });
    var getSortCompare = function getSortCompare(comparefn) {
      return function (x, y) {
        if (comparefn !== undefined) return +comparefn(x, y) || 0;
        if (y !== y) return -1;
        if (x !== x) return 1;
        if (x === 0 && y === 0) return 1 / x > 0 && 1 / y < 0 ? 1 : -1;
        return x > y;
      };
    };
    exportTypedArrayMethod('sort', function sort(comparefn) {
      if (comparefn !== undefined) aCallable(comparefn);
      if (STABLE_SORT) return nativeSort(this, comparefn);
      return internalSort(aTypedArray(this), getSortCompare(comparefn));
    }, !STABLE_SORT || ACCEPT_INCORRECT_ARGUMENTS);
    return es_typedArray_sort;
  }
  var es_typedArray_subarray = {};
  var hasRequiredEs_typedArray_subarray;
  function requireEs_typedArray_subarray() {
    if (hasRequiredEs_typedArray_subarray) return es_typedArray_subarray;
    hasRequiredEs_typedArray_subarray = 1;
    var ArrayBufferViewCore = requireArrayBufferViewCore();
    var toLength = requireToLength();
    var toAbsoluteIndex = requireToAbsoluteIndex();
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    exportTypedArrayMethod('subarray', function subarray(begin, end) {
      var O = aTypedArray(this);
      var length = O.length;
      var beginIndex = toAbsoluteIndex(begin, length);
      var C = getTypedArrayConstructor(O);
      return new C(O.buffer, O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT, toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - beginIndex));
    });
    return es_typedArray_subarray;
  }
  var es_typedArray_toLocaleString = {};
  var hasRequiredEs_typedArray_toLocaleString;
  function requireEs_typedArray_toLocaleString() {
    if (hasRequiredEs_typedArray_toLocaleString) return es_typedArray_toLocaleString;
    hasRequiredEs_typedArray_toLocaleString = 1;
    var globalThis = requireGlobalThis();
    var apply = requireFunctionApply();
    var ArrayBufferViewCore = requireArrayBufferViewCore();
    var fails = requireFails();
    var arraySlice = requireArraySlice();
    var Int8Array = globalThis.Int8Array;
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    var $toLocaleString = [].toLocaleString;
    var TO_LOCALE_STRING_BUG = !!Int8Array && fails(function () {
      $toLocaleString.call(new Int8Array(1));
    });
    var FORCED = fails(function () {
      return [1, 2].toLocaleString() !== new Int8Array([1, 2]).toLocaleString();
    }) || !fails(function () {
      Int8Array.prototype.toLocaleString.call([1, 2]);
    });
    exportTypedArrayMethod('toLocaleString', function toLocaleString() {
      return apply($toLocaleString, TO_LOCALE_STRING_BUG ? arraySlice(aTypedArray(this)) : aTypedArray(this), arraySlice(arguments));
    }, FORCED);
    return es_typedArray_toLocaleString;
  }
  var es_typedArray_toReversed = {};
  var hasRequiredEs_typedArray_toReversed;
  function requireEs_typedArray_toReversed() {
    if (hasRequiredEs_typedArray_toReversed) return es_typedArray_toReversed;
    hasRequiredEs_typedArray_toReversed = 1;
    var arrayToReversed = requireArrayToReversed();
    var ArrayBufferViewCore = requireArrayBufferViewCore();
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    var getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;
    exportTypedArrayMethod('toReversed', function toReversed() {
      return arrayToReversed(aTypedArray(this), getTypedArrayConstructor(this));
    });
    return es_typedArray_toReversed;
  }
  var es_typedArray_toSorted = {};
  var hasRequiredEs_typedArray_toSorted;
  function requireEs_typedArray_toSorted() {
    if (hasRequiredEs_typedArray_toSorted) return es_typedArray_toSorted;
    hasRequiredEs_typedArray_toSorted = 1;
    var ArrayBufferViewCore = requireArrayBufferViewCore();
    var uncurryThis = requireFunctionUncurryThis();
    var aCallable = requireACallable();
    var arrayFromConstructorAndList = requireArrayFromConstructorAndList();
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    var sort = uncurryThis(ArrayBufferViewCore.TypedArrayPrototype.sort);
    exportTypedArrayMethod('toSorted', function toSorted(compareFn) {
      if (compareFn !== undefined) aCallable(compareFn);
      var O = aTypedArray(this);
      var A = arrayFromConstructorAndList(getTypedArrayConstructor(O), O);
      return sort(A, compareFn);
    });
    return es_typedArray_toSorted;
  }
  var es_typedArray_toString = {};
  var hasRequiredEs_typedArray_toString;
  function requireEs_typedArray_toString() {
    if (hasRequiredEs_typedArray_toString) return es_typedArray_toString;
    hasRequiredEs_typedArray_toString = 1;
    var exportTypedArrayMethod = requireArrayBufferViewCore().exportTypedArrayMethod;
    var fails = requireFails();
    var globalThis = requireGlobalThis();
    var uncurryThis = requireFunctionUncurryThis();
    var Uint8Array = globalThis.Uint8Array;
    var Uint8ArrayPrototype = Uint8Array && Uint8Array.prototype || {};
    var arrayToString = [].toString;
    var join = uncurryThis([].join);
    if (fails(function () {
      arrayToString.call({});
    })) {
      arrayToString = function toString() {
        return join(this);
      };
    }
    var IS_NOT_ARRAY_METHOD = Uint8ArrayPrototype.toString !== arrayToString;
    exportTypedArrayMethod('toString', arrayToString, IS_NOT_ARRAY_METHOD);
    return es_typedArray_toString;
  }
  var es_typedArray_with = {};
  var hasRequiredEs_typedArray_with;
  function requireEs_typedArray_with() {
    if (hasRequiredEs_typedArray_with) return es_typedArray_with;
    hasRequiredEs_typedArray_with = 1;
    var arrayWith = requireArrayWith();
    var ArrayBufferViewCore = requireArrayBufferViewCore();
    var isBigIntArray = requireIsBigIntArray();
    var toIntegerOrInfinity = requireToIntegerOrInfinity();
    var toBigInt = requireToBigInt();
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    var PROPER_ORDER = function () {
      try {
        new Int8Array(1)['with'](2, {
          valueOf: function valueOf() {
            throw 8;
          }
        });
      } catch (error) {
        return error === 8;
      }
    }();
    var THROW_ON_NEGATIVE_FRACTIONAL_INDEX = PROPER_ORDER && function () {
      try {
        new Int8Array(1)['with'](-0.5, 1);
      } catch (error) {
        return true;
      }
    }();
    exportTypedArrayMethod('with', {
      'with': function _with(index, value) {
        var O = aTypedArray(this);
        var relativeIndex = toIntegerOrInfinity(index);
        var actualValue = isBigIntArray(O) ? toBigInt(value) : +value;
        return arrayWith(O, getTypedArrayConstructor(O), relativeIndex, actualValue);
      }
    }['with'], !PROPER_ORDER || THROW_ON_NEGATIVE_FRACTIONAL_INDEX);
    return es_typedArray_with;
  }
  var es_uint8Array_fromBase64 = {};
  var anObjectOrUndefined;
  var hasRequiredAnObjectOrUndefined;
  function requireAnObjectOrUndefined() {
    if (hasRequiredAnObjectOrUndefined) return anObjectOrUndefined;
    hasRequiredAnObjectOrUndefined = 1;
    var isObject = requireIsObject();
    var $String = String;
    var $TypeError = TypeError;
    anObjectOrUndefined = function anObjectOrUndefined(argument) {
      if (argument === undefined || isObject(argument)) return argument;
      throw new $TypeError($String(argument) + ' is not an object or undefined');
    };
    return anObjectOrUndefined;
  }
  var base64Map;
  var hasRequiredBase64Map;
  function requireBase64Map() {
    if (hasRequiredBase64Map) return base64Map;
    hasRequiredBase64Map = 1;
    var commonAlphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    var base64Alphabet = commonAlphabet + '+/';
    var base64UrlAlphabet = commonAlphabet + '-_';
    var inverse = function inverse(characters) {
      var result = {};
      var index = 0;
      for (; index < 64; index++) result[characters.charAt(index)] = index;
      return result;
    };
    base64Map = {
      i2c: base64Alphabet,
      c2i: inverse(base64Alphabet),
      i2cUrl: base64UrlAlphabet,
      c2iUrl: inverse(base64UrlAlphabet)
    };
    return base64Map;
  }
  var getAlphabetOption;
  var hasRequiredGetAlphabetOption;
  function requireGetAlphabetOption() {
    if (hasRequiredGetAlphabetOption) return getAlphabetOption;
    hasRequiredGetAlphabetOption = 1;
    var $TypeError = TypeError;
    getAlphabetOption = function getAlphabetOption(options) {
      var alphabet = options && options.alphabet;
      if (alphabet === undefined || alphabet === 'base64' || alphabet === 'base64url') return alphabet || 'base64';
      throw new $TypeError('Incorrect `alphabet` option');
    };
    return getAlphabetOption;
  }
  var uint8FromBase64;
  var hasRequiredUint8FromBase64;
  function requireUint8FromBase64() {
    if (hasRequiredUint8FromBase64) return uint8FromBase64;
    hasRequiredUint8FromBase64 = 1;
    var globalThis = requireGlobalThis();
    var uncurryThis = requireFunctionUncurryThis();
    var anObjectOrUndefined = requireAnObjectOrUndefined();
    var aString = requireAString();
    var hasOwn = requireHasOwnProperty();
    var base64Map = requireBase64Map();
    var getAlphabetOption = requireGetAlphabetOption();
    var notDetached = requireArrayBufferNotDetached();
    var base64Alphabet = base64Map.c2i;
    var base64UrlAlphabet = base64Map.c2iUrl;
    var SyntaxError = globalThis.SyntaxError;
    var TypeError = globalThis.TypeError;
    var at = uncurryThis(''.charAt);
    var skipAsciiWhitespace = function skipAsciiWhitespace(string, index) {
      var length = string.length;
      for (; index < length; index++) {
        var chr = at(string, index);
        if (chr !== ' ' && chr !== '\t' && chr !== '\n' && chr !== '\f' && chr !== '\r') break;
      }
      return index;
    };
    var decodeBase64Chunk = function decodeBase64Chunk(chunk, alphabet, throwOnExtraBits) {
      var chunkLength = chunk.length;
      if (chunkLength < 4) {
        chunk += chunkLength === 2 ? 'AA' : 'A';
      }
      var triplet = (alphabet[at(chunk, 0)] << 18) + (alphabet[at(chunk, 1)] << 12) + (alphabet[at(chunk, 2)] << 6) + alphabet[at(chunk, 3)];
      var chunkBytes = [triplet >> 16 & 255, triplet >> 8 & 255, triplet & 255];
      if (chunkLength === 2) {
        if (throwOnExtraBits && chunkBytes[1] !== 0) {
          throw new SyntaxError('Extra bits');
        }
        return [chunkBytes[0]];
      }
      if (chunkLength === 3) {
        if (throwOnExtraBits && chunkBytes[2] !== 0) {
          throw new SyntaxError('Extra bits');
        }
        return [chunkBytes[0], chunkBytes[1]];
      }
      return chunkBytes;
    };
    var writeBytes = function writeBytes(bytes, elements, written) {
      var elementsLength = elements.length;
      for (var index = 0; index < elementsLength; index++) {
        bytes[written + index] = elements[index];
      }
      return written + elementsLength;
    };
    uint8FromBase64 = function uint8FromBase64(string, options, into, maxLength) {
      aString(string);
      anObjectOrUndefined(options);
      var alphabet = getAlphabetOption(options) === 'base64' ? base64Alphabet : base64UrlAlphabet;
      var lastChunkHandling = options ? options.lastChunkHandling : undefined;
      if (lastChunkHandling === undefined) lastChunkHandling = 'loose';
      if (lastChunkHandling !== 'loose' && lastChunkHandling !== 'strict' && lastChunkHandling !== 'stop-before-partial') {
        throw new TypeError('Incorrect `lastChunkHandling` option');
      }
      if (into) notDetached(into.buffer);
      var stringLength = string.length;
      var bytes = into || [];
      var written = 0;
      var read = 0;
      var chunk = '';
      var index = 0;
      if (maxLength) while (true) {
        index = skipAsciiWhitespace(string, index);
        if (index === stringLength) {
          if (chunk.length > 0) {
            if (lastChunkHandling === 'stop-before-partial') {
              break;
            }
            if (lastChunkHandling === 'loose') {
              if (chunk.length === 1) {
                throw new SyntaxError('Malformed padding: exactly one additional character');
              }
              written = writeBytes(bytes, decodeBase64Chunk(chunk, alphabet, false), written);
            } else {
              throw new SyntaxError('Missing padding');
            }
          }
          read = stringLength;
          break;
        }
        var chr = at(string, index);
        ++index;
        if (chr === '=') {
          if (chunk.length < 2) {
            throw new SyntaxError('Padding is too early');
          }
          index = skipAsciiWhitespace(string, index);
          if (chunk.length === 2) {
            if (index === stringLength) {
              if (lastChunkHandling === 'stop-before-partial') {
                break;
              }
              throw new SyntaxError('Malformed padding: only one =');
            }
            if (at(string, index) === '=') {
              ++index;
              index = skipAsciiWhitespace(string, index);
            }
          }
          if (index < stringLength) {
            throw new SyntaxError('Unexpected character after padding');
          }
          written = writeBytes(bytes, decodeBase64Chunk(chunk, alphabet, lastChunkHandling === 'strict'), written);
          read = stringLength;
          break;
        }
        if (!hasOwn(alphabet, chr)) {
          throw new SyntaxError('Unexpected character');
        }
        var remainingBytes = maxLength - written;
        if (remainingBytes === 1 && chunk.length === 2 || remainingBytes === 2 && chunk.length === 3) {
          break;
        }
        chunk += chr;
        if (chunk.length === 4) {
          written = writeBytes(bytes, decodeBase64Chunk(chunk, alphabet, false), written);
          chunk = '';
          read = index;
          if (written === maxLength) {
            break;
          }
        }
      }
      return {
        bytes: bytes,
        read: read,
        written: written
      };
    };
    return uint8FromBase64;
  }
  var hasRequiredEs_uint8Array_fromBase64;
  function requireEs_uint8Array_fromBase64() {
    if (hasRequiredEs_uint8Array_fromBase64) return es_uint8Array_fromBase64;
    hasRequiredEs_uint8Array_fromBase64 = 1;
    var $ = require_export();
    var globalThis = requireGlobalThis();
    var arrayFromConstructorAndList = requireArrayFromConstructorAndList();
    var $fromBase64 = requireUint8FromBase64();
    var Uint8Array = globalThis.Uint8Array;
    var INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS = !Uint8Array || !Uint8Array.fromBase64 || !function () {
      try {
        Uint8Array.fromBase64('a');
        return;
      } catch (error) {}
      try {
        Uint8Array.fromBase64('', null);
      } catch (error) {
        return true;
      }
    }();
    if (Uint8Array) $({
      target: 'Uint8Array',
      stat: true,
      forced: INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS
    }, {
      fromBase64: function fromBase64(string) {
        var result = $fromBase64(string, arguments.length > 1 ? arguments[1] : undefined, null, 0x1FFFFFFFFFFFFF);
        return arrayFromConstructorAndList(Uint8Array, result.bytes);
      }
    });
    return es_uint8Array_fromBase64;
  }
  var es_uint8Array_fromHex = {};
  var uint8FromHex;
  var hasRequiredUint8FromHex;
  function requireUint8FromHex() {
    if (hasRequiredUint8FromHex) return uint8FromHex;
    hasRequiredUint8FromHex = 1;
    var globalThis = requireGlobalThis();
    var uncurryThis = requireFunctionUncurryThis();
    var Uint8Array = globalThis.Uint8Array;
    var SyntaxError = globalThis.SyntaxError;
    var parseInt = globalThis.parseInt;
    var min = Math.min;
    var NOT_HEX = /[^\da-f]/i;
    var exec = uncurryThis(NOT_HEX.exec);
    var stringSlice = uncurryThis(''.slice);
    uint8FromHex = function uint8FromHex(string, into) {
      var stringLength = string.length;
      if (stringLength % 2 !== 0) throw new SyntaxError('String should be an even number of characters');
      var maxLength = into ? min(into.length, stringLength / 2) : stringLength / 2;
      var bytes = into || new Uint8Array(maxLength);
      var read = 0;
      var written = 0;
      while (written < maxLength) {
        var hexits = stringSlice(string, read, read += 2);
        if (exec(NOT_HEX, hexits)) throw new SyntaxError('String should only contain hex characters');
        bytes[written++] = parseInt(hexits, 16);
      }
      return {
        bytes: bytes,
        read: read
      };
    };
    return uint8FromHex;
  }
  var hasRequiredEs_uint8Array_fromHex;
  function requireEs_uint8Array_fromHex() {
    if (hasRequiredEs_uint8Array_fromHex) return es_uint8Array_fromHex;
    hasRequiredEs_uint8Array_fromHex = 1;
    var $ = require_export();
    var globalThis = requireGlobalThis();
    var aString = requireAString();
    var $fromHex = requireUint8FromHex();
    if (globalThis.Uint8Array) $({
      target: 'Uint8Array',
      stat: true
    }, {
      fromHex: function fromHex(string) {
        return $fromHex(aString(string)).bytes;
      }
    });
    return es_uint8Array_fromHex;
  }
  var es_uint8Array_setFromBase64 = {};
  var anUint8Array;
  var hasRequiredAnUint8Array;
  function requireAnUint8Array() {
    if (hasRequiredAnUint8Array) return anUint8Array;
    hasRequiredAnUint8Array = 1;
    var classof = requireClassof();
    var $TypeError = TypeError;
    anUint8Array = function anUint8Array(argument) {
      if (classof(argument) === 'Uint8Array') return argument;
      throw new $TypeError('Argument is not an Uint8Array');
    };
    return anUint8Array;
  }
  var hasRequiredEs_uint8Array_setFromBase64;
  function requireEs_uint8Array_setFromBase64() {
    if (hasRequiredEs_uint8Array_setFromBase64) return es_uint8Array_setFromBase64;
    hasRequiredEs_uint8Array_setFromBase64 = 1;
    var $ = require_export();
    var globalThis = requireGlobalThis();
    var $fromBase64 = requireUint8FromBase64();
    var anUint8Array = requireAnUint8Array();
    var Uint8Array = globalThis.Uint8Array;
    var INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS = !Uint8Array || !Uint8Array.prototype.setFromBase64 || !function () {
      var target = new Uint8Array([255, 255, 255, 255, 255]);
      try {
        target.setFromBase64('', null);
        return;
      } catch (error) {}
      try {
        target.setFromBase64('a');
        return;
      } catch (error) {}
      try {
        target.setFromBase64('MjYyZg===');
      } catch (error) {
        return target[0] === 50 && target[1] === 54 && target[2] === 50 && target[3] === 255 && target[4] === 255;
      }
    }();
    if (Uint8Array) $({
      target: 'Uint8Array',
      proto: true,
      forced: INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS
    }, {
      setFromBase64: function setFromBase64(string) {
        anUint8Array(this);
        var result = $fromBase64(string, arguments.length > 1 ? arguments[1] : undefined, this, this.length);
        return {
          read: result.read,
          written: result.written
        };
      }
    });
    return es_uint8Array_setFromBase64;
  }
  var es_uint8Array_setFromHex = {};
  var hasRequiredEs_uint8Array_setFromHex;
  function requireEs_uint8Array_setFromHex() {
    if (hasRequiredEs_uint8Array_setFromHex) return es_uint8Array_setFromHex;
    hasRequiredEs_uint8Array_setFromHex = 1;
    var $ = require_export();
    var globalThis = requireGlobalThis();
    var aString = requireAString();
    var anUint8Array = requireAnUint8Array();
    var notDetached = requireArrayBufferNotDetached();
    var $fromHex = requireUint8FromHex();
    if (globalThis.Uint8Array) $({
      target: 'Uint8Array',
      proto: true
    }, {
      setFromHex: function setFromHex(string) {
        anUint8Array(this);
        aString(string);
        notDetached(this.buffer);
        var read = $fromHex(string, this).read;
        return {
          read: read,
          written: read / 2
        };
      }
    });
    return es_uint8Array_setFromHex;
  }
  var es_uint8Array_toBase64 = {};
  var hasRequiredEs_uint8Array_toBase64;
  function requireEs_uint8Array_toBase64() {
    if (hasRequiredEs_uint8Array_toBase64) return es_uint8Array_toBase64;
    hasRequiredEs_uint8Array_toBase64 = 1;
    var $ = require_export();
    var globalThis = requireGlobalThis();
    var uncurryThis = requireFunctionUncurryThis();
    var anObjectOrUndefined = requireAnObjectOrUndefined();
    var anUint8Array = requireAnUint8Array();
    var notDetached = requireArrayBufferNotDetached();
    var base64Map = requireBase64Map();
    var getAlphabetOption = requireGetAlphabetOption();
    var base64Alphabet = base64Map.i2c;
    var base64UrlAlphabet = base64Map.i2cUrl;
    var charAt = uncurryThis(''.charAt);
    var Uint8Array = globalThis.Uint8Array;
    var INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS = !Uint8Array || !Uint8Array.prototype.toBase64 || !function () {
      try {
        var target = new Uint8Array();
        target.toBase64(null);
      } catch (error) {
        return true;
      }
    }();
    if (Uint8Array) $({
      target: 'Uint8Array',
      proto: true,
      forced: INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS
    }, {
      toBase64: function toBase64() {
        var array = anUint8Array(this);
        var options = arguments.length ? anObjectOrUndefined(arguments[0]) : undefined;
        var alphabet = getAlphabetOption(options) === 'base64' ? base64Alphabet : base64UrlAlphabet;
        var omitPadding = !!options && !!options.omitPadding;
        notDetached(this.buffer);
        var result = '';
        var i = 0;
        var length = array.length;
        var triplet;
        var at = function at(shift) {
          return charAt(alphabet, triplet >> 6 * shift & 63);
        };
        for (; i + 2 < length; i += 3) {
          triplet = (array[i] << 16) + (array[i + 1] << 8) + array[i + 2];
          result += at(3) + at(2) + at(1) + at(0);
        }
        if (i + 2 === length) {
          triplet = (array[i] << 16) + (array[i + 1] << 8);
          result += at(3) + at(2) + at(1) + (omitPadding ? '' : '=');
        } else if (i + 1 === length) {
          triplet = array[i] << 16;
          result += at(3) + at(2) + (omitPadding ? '' : '==');
        }
        return result;
      }
    });
    return es_uint8Array_toBase64;
  }
  var es_uint8Array_toHex = {};
  var hasRequiredEs_uint8Array_toHex;
  function requireEs_uint8Array_toHex() {
    if (hasRequiredEs_uint8Array_toHex) return es_uint8Array_toHex;
    hasRequiredEs_uint8Array_toHex = 1;
    var $ = require_export();
    var globalThis = requireGlobalThis();
    var uncurryThis = requireFunctionUncurryThis();
    var anUint8Array = requireAnUint8Array();
    var notDetached = requireArrayBufferNotDetached();
    var numberToString = uncurryThis(1.1.toString);
    var Uint8Array = globalThis.Uint8Array;
    var INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS = !Uint8Array || !Uint8Array.prototype.toHex || !function () {
      try {
        var target = new Uint8Array([255, 255, 255, 255, 255, 255, 255, 255]);
        return target.toHex() === 'ffffffffffffffff';
      } catch (error) {
        return false;
      }
    }();
    if (Uint8Array) $({
      target: 'Uint8Array',
      proto: true,
      forced: INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS
    }, {
      toHex: function toHex() {
        anUint8Array(this);
        notDetached(this.buffer);
        var result = '';
        for (var i = 0, length = this.length; i < length; i++) {
          var hex = numberToString(this[i], 16);
          result += hex.length === 1 ? '0' + hex : hex;
        }
        return result;
      }
    });
    return es_uint8Array_toHex;
  }
  var es_unescape = {};
  var hasRequiredEs_unescape;
  function requireEs_unescape() {
    if (hasRequiredEs_unescape) return es_unescape;
    hasRequiredEs_unescape = 1;
    var $ = require_export();
    var uncurryThis = requireFunctionUncurryThis();
    var toString = requireToString();
    var fromCharCode = String.fromCharCode;
    var charAt = uncurryThis(''.charAt);
    var exec = uncurryThis(/./.exec);
    var stringSlice = uncurryThis(''.slice);
    var hex2 = /^[\da-f]{2}$/i;
    var hex4 = /^[\da-f]{4}$/i;
    $({
      global: true
    }, {
      unescape: function unescape(string) {
        var str = toString(string);
        var result = '';
        var length = str.length;
        var index = 0;
        var chr, part;
        while (index < length) {
          chr = charAt(str, index++);
          if (chr === '%') {
            if (charAt(str, index) === 'u') {
              part = stringSlice(str, index + 1, index + 5);
              if (exec(hex4, part)) {
                result += fromCharCode(parseInt(part, 16));
                index += 5;
                continue;
              }
            } else {
              part = stringSlice(str, index, index + 2);
              if (exec(hex2, part)) {
                result += fromCharCode(parseInt(part, 16));
                index += 2;
                continue;
              }
            }
          }
          result += chr;
        }
        return result;
      }
    });
    return es_unescape;
  }
  var es_weakMap = {};
  var es_weakMap_constructor = {};
  var collectionWeak;
  var hasRequiredCollectionWeak;
  function requireCollectionWeak() {
    if (hasRequiredCollectionWeak) return collectionWeak;
    hasRequiredCollectionWeak = 1;
    var uncurryThis = requireFunctionUncurryThis();
    var defineBuiltIns = requireDefineBuiltIns();
    var getWeakData = requireInternalMetadata().getWeakData;
    var anInstance = requireAnInstance();
    var anObject = requireAnObject();
    var isNullOrUndefined = requireIsNullOrUndefined();
    var isObject = requireIsObject();
    var iterate = requireIterate();
    var ArrayIterationModule = requireArrayIteration();
    var hasOwn = requireHasOwnProperty();
    var InternalStateModule = requireInternalState();
    var setInternalState = InternalStateModule.set;
    var internalStateGetterFor = InternalStateModule.getterFor;
    var find = ArrayIterationModule.find;
    var findIndex = ArrayIterationModule.findIndex;
    var splice = uncurryThis([].splice);
    var id = 0;
    var uncaughtFrozenStore = function uncaughtFrozenStore(state) {
      return state.frozen || (state.frozen = new UncaughtFrozenStore());
    };
    var UncaughtFrozenStore = function UncaughtFrozenStore() {
      this.entries = [];
    };
    var findUncaughtFrozen = function findUncaughtFrozen(store, key) {
      return find(store.entries, function (it) {
        return it[0] === key;
      });
    };
    UncaughtFrozenStore.prototype = {
      get: function get(key) {
        var entry = findUncaughtFrozen(this, key);
        if (entry) return entry[1];
      },
      has: function has(key) {
        return !!findUncaughtFrozen(this, key);
      },
      set: function set(key, value) {
        var entry = findUncaughtFrozen(this, key);
        if (entry) entry[1] = value;else this.entries.push([key, value]);
      },
      'delete': function _delete(key) {
        var index = findIndex(this.entries, function (it) {
          return it[0] === key;
        });
        if (~index) splice(this.entries, index, 1);
        return !!~index;
      }
    };
    collectionWeak = {
      getConstructor: function getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
        var Constructor = wrapper(function (that, iterable) {
          anInstance(that, Prototype);
          setInternalState(that, {
            type: CONSTRUCTOR_NAME,
            id: id++,
            frozen: null
          });
          if (!isNullOrUndefined(iterable)) iterate(iterable, that[ADDER], {
            that: that,
            AS_ENTRIES: IS_MAP
          });
        });
        var Prototype = Constructor.prototype;
        var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);
        var define = function define(that, key, value) {
          var state = getInternalState(that);
          var data = getWeakData(anObject(key), true);
          if (data === true) uncaughtFrozenStore(state).set(key, value);else data[state.id] = value;
          return that;
        };
        defineBuiltIns(Prototype, {
          'delete': function _delete(key) {
            var state = getInternalState(this);
            if (!isObject(key)) return false;
            var data = getWeakData(key);
            if (data === true) return uncaughtFrozenStore(state)['delete'](key);
            return data && hasOwn(data, state.id) && delete data[state.id];
          },
          has: function has(key) {
            var state = getInternalState(this);
            if (!isObject(key)) return false;
            var data = getWeakData(key);
            if (data === true) return uncaughtFrozenStore(state).has(key);
            return data && hasOwn(data, state.id);
          }
        });
        defineBuiltIns(Prototype, IS_MAP ? {
          get: function get(key) {
            var state = getInternalState(this);
            if (isObject(key)) {
              var data = getWeakData(key);
              if (data === true) return uncaughtFrozenStore(state).get(key);
              if (data) return data[state.id];
            }
          },
          set: function set(key, value) {
            return define(this, key, value);
          }
        } : {
          add: function add(value) {
            return define(this, value, true);
          }
        });
        return Constructor;
      }
    };
    return collectionWeak;
  }
  var hasRequiredEs_weakMap_constructor;
  function requireEs_weakMap_constructor() {
    if (hasRequiredEs_weakMap_constructor) return es_weakMap_constructor;
    hasRequiredEs_weakMap_constructor = 1;
    var FREEZING = requireFreezing();
    var globalThis = requireGlobalThis();
    var uncurryThis = requireFunctionUncurryThis();
    var defineBuiltIns = requireDefineBuiltIns();
    var InternalMetadataModule = requireInternalMetadata();
    var collection = requireCollection();
    var collectionWeak = requireCollectionWeak();
    var isObject = requireIsObject();
    var enforceInternalState = requireInternalState().enforce;
    var fails = requireFails();
    var NATIVE_WEAK_MAP = requireWeakMapBasicDetection();
    var $Object = Object;
    var isArray = Array.isArray;
    var isExtensible = $Object.isExtensible;
    var isFrozen = $Object.isFrozen;
    var isSealed = $Object.isSealed;
    var freeze = $Object.freeze;
    var seal = $Object.seal;
    var IS_IE11 = !globalThis.ActiveXObject && 'ActiveXObject' in globalThis;
    var InternalWeakMap;
    var wrapper = function wrapper(init) {
      return function WeakMap() {
        return init(this, arguments.length ? arguments[0] : undefined);
      };
    };
    var $WeakMap = collection('WeakMap', wrapper, collectionWeak);
    var WeakMapPrototype = $WeakMap.prototype;
    var nativeSet = uncurryThis(WeakMapPrototype.set);
    var hasMSEdgeFreezingBug = function hasMSEdgeFreezingBug() {
      return FREEZING && fails(function () {
        var frozenArray = freeze([]);
        nativeSet(new $WeakMap(), frozenArray, 1);
        return !isFrozen(frozenArray);
      });
    };
    if (NATIVE_WEAK_MAP) if (IS_IE11) {
      InternalWeakMap = collectionWeak.getConstructor(wrapper, 'WeakMap', true);
      InternalMetadataModule.enable();
      var nativeDelete = uncurryThis(WeakMapPrototype['delete']);
      var nativeHas = uncurryThis(WeakMapPrototype.has);
      var nativeGet = uncurryThis(WeakMapPrototype.get);
      defineBuiltIns(WeakMapPrototype, {
        'delete': function _delete(key) {
          if (isObject(key) && !isExtensible(key)) {
            var state = enforceInternalState(this);
            if (!state.frozen) state.frozen = new InternalWeakMap();
            return nativeDelete(this, key) || state.frozen['delete'](key);
          }
          return nativeDelete(this, key);
        },
        has: function has(key) {
          if (isObject(key) && !isExtensible(key)) {
            var state = enforceInternalState(this);
            if (!state.frozen) state.frozen = new InternalWeakMap();
            return nativeHas(this, key) || state.frozen.has(key);
          }
          return nativeHas(this, key);
        },
        get: function get(key) {
          if (isObject(key) && !isExtensible(key)) {
            var state = enforceInternalState(this);
            if (!state.frozen) state.frozen = new InternalWeakMap();
            return nativeHas(this, key) ? nativeGet(this, key) : state.frozen.get(key);
          }
          return nativeGet(this, key);
        },
        set: function set(key, value) {
          if (isObject(key) && !isExtensible(key)) {
            var state = enforceInternalState(this);
            if (!state.frozen) state.frozen = new InternalWeakMap();
            nativeHas(this, key) ? nativeSet(this, key, value) : state.frozen.set(key, value);
          } else nativeSet(this, key, value);
          return this;
        }
      });
    } else if (hasMSEdgeFreezingBug()) {
      defineBuiltIns(WeakMapPrototype, {
        set: function set(key, value) {
          var arrayIntegrityLevel;
          if (isArray(key)) {
            if (isFrozen(key)) arrayIntegrityLevel = freeze;else if (isSealed(key)) arrayIntegrityLevel = seal;
          }
          nativeSet(this, key, value);
          if (arrayIntegrityLevel) arrayIntegrityLevel(key);
          return this;
        }
      });
    }
    return es_weakMap_constructor;
  }
  var hasRequiredEs_weakMap;
  function requireEs_weakMap() {
    if (hasRequiredEs_weakMap) return es_weakMap;
    hasRequiredEs_weakMap = 1;
    requireEs_weakMap_constructor();
    return es_weakMap;
  }
  var es_weakSet = {};
  var es_weakSet_constructor = {};
  var hasRequiredEs_weakSet_constructor;
  function requireEs_weakSet_constructor() {
    if (hasRequiredEs_weakSet_constructor) return es_weakSet_constructor;
    hasRequiredEs_weakSet_constructor = 1;
    var collection = requireCollection();
    var collectionWeak = requireCollectionWeak();
    collection('WeakSet', function (init) {
      return function WeakSet() {
        return init(this, arguments.length ? arguments[0] : undefined);
      };
    }, collectionWeak);
    return es_weakSet_constructor;
  }
  var hasRequiredEs_weakSet;
  function requireEs_weakSet() {
    if (hasRequiredEs_weakSet) return es_weakSet;
    hasRequiredEs_weakSet = 1;
    requireEs_weakSet_constructor();
    return es_weakSet;
  }
  var web_atob = {};
  var hasRequiredWeb_atob;
  function requireWeb_atob() {
    if (hasRequiredWeb_atob) return web_atob;
    hasRequiredWeb_atob = 1;
    var $ = require_export();
    var globalThis = requireGlobalThis();
    var getBuiltIn = requireGetBuiltIn();
    var uncurryThis = requireFunctionUncurryThis();
    var call = requireFunctionCall();
    var fails = requireFails();
    var toString = requireToString();
    var validateArgumentsLength = requireValidateArgumentsLength();
    var c2i = requireBase64Map().c2i;
    var disallowed = /[^\d+/a-z]/i;
    var whitespaces = /[\t\n\f\r ]+/g;
    var finalEq = /[=]{1,2}$/;
    var $atob = getBuiltIn('atob');
    var fromCharCode = String.fromCharCode;
    var charAt = uncurryThis(''.charAt);
    var replace = uncurryThis(''.replace);
    var exec = uncurryThis(disallowed.exec);
    var BASIC = !!$atob && !fails(function () {
      return $atob('aGk=') !== 'hi';
    });
    var NO_SPACES_IGNORE = BASIC && fails(function () {
      return $atob(' ') !== '';
    });
    var NO_ENCODING_CHECK = BASIC && !fails(function () {
      $atob('a');
    });
    var NO_ARG_RECEIVING_CHECK = BASIC && !fails(function () {
      $atob();
    });
    var WRONG_ARITY = BASIC && $atob.length !== 1;
    var FORCED = !BASIC || NO_SPACES_IGNORE || NO_ENCODING_CHECK || NO_ARG_RECEIVING_CHECK || WRONG_ARITY;
    $({
      global: true,
      bind: true,
      enumerable: true,
      forced: FORCED
    }, {
      atob: function atob(data) {
        validateArgumentsLength(arguments.length, 1);
        if (BASIC && !NO_SPACES_IGNORE && !NO_ENCODING_CHECK) return call($atob, globalThis, data);
        var string = replace(toString(data), whitespaces, '');
        var output = '';
        var position = 0;
        var bc = 0;
        var length, chr, bs;
        if (string.length % 4 === 0) {
          string = replace(string, finalEq, '');
        }
        length = string.length;
        if (length % 4 === 1 || exec(disallowed, string)) {
          throw new (getBuiltIn('DOMException'))('The string is not correctly encoded', 'InvalidCharacterError');
        }
        while (position < length) {
          chr = charAt(string, position++);
          bs = bc % 4 ? bs * 64 + c2i[chr] : c2i[chr];
          if (bc++ % 4) output += fromCharCode(255 & bs >> (-2 * bc & 6));
        }
        return output;
      }
    });
    return web_atob;
  }
  var web_btoa = {};
  var hasRequiredWeb_btoa;
  function requireWeb_btoa() {
    if (hasRequiredWeb_btoa) return web_btoa;
    hasRequiredWeb_btoa = 1;
    var $ = require_export();
    var globalThis = requireGlobalThis();
    var getBuiltIn = requireGetBuiltIn();
    var uncurryThis = requireFunctionUncurryThis();
    var call = requireFunctionCall();
    var fails = requireFails();
    var toString = requireToString();
    var validateArgumentsLength = requireValidateArgumentsLength();
    var i2c = requireBase64Map().i2c;
    var $btoa = getBuiltIn('btoa');
    var charAt = uncurryThis(''.charAt);
    var charCodeAt = uncurryThis(''.charCodeAt);
    var BASIC = !!$btoa && !fails(function () {
      return $btoa('hi') !== 'aGk=';
    });
    var NO_ARG_RECEIVING_CHECK = BASIC && !fails(function () {
      $btoa();
    });
    var WRONG_ARG_CONVERSION = BASIC && fails(function () {
      return $btoa(null) !== 'bnVsbA==';
    });
    var WRONG_ARITY = BASIC && $btoa.length !== 1;
    $({
      global: true,
      bind: true,
      enumerable: true,
      forced: !BASIC || NO_ARG_RECEIVING_CHECK || WRONG_ARG_CONVERSION || WRONG_ARITY
    }, {
      btoa: function btoa(data) {
        validateArgumentsLength(arguments.length, 1);
        if (BASIC) return call($btoa, globalThis, toString(data));
        var string = toString(data);
        var output = '';
        var position = 0;
        var map = i2c;
        var block, charCode;
        while (charAt(string, position) || (map = '=', position % 1)) {
          charCode = charCodeAt(string, position += 3 / 4);
          if (charCode > 0xFF) {
            throw new (getBuiltIn('DOMException'))('The string contains characters outside of the Latin1 range', 'InvalidCharacterError');
          }
          block = block << 8 | charCode;
          output += charAt(map, 63 & block >> 8 - position % 1 * 8);
        }
        return output;
      }
    });
    return web_btoa;
  }
  var web_domCollections_forEach = {};
  var domIterables;
  var hasRequiredDomIterables;
  function requireDomIterables() {
    if (hasRequiredDomIterables) return domIterables;
    hasRequiredDomIterables = 1;
    domIterables = {
      CSSRuleList: 0,
      CSSStyleDeclaration: 0,
      CSSValueList: 0,
      ClientRectList: 0,
      DOMRectList: 0,
      DOMStringList: 0,
      DOMTokenList: 1,
      DataTransferItemList: 0,
      FileList: 0,
      HTMLAllCollection: 0,
      HTMLCollection: 0,
      HTMLFormElement: 0,
      HTMLSelectElement: 0,
      MediaList: 0,
      MimeTypeArray: 0,
      NamedNodeMap: 0,
      NodeList: 1,
      PaintRequestList: 0,
      Plugin: 0,
      PluginArray: 0,
      SVGLengthList: 0,
      SVGNumberList: 0,
      SVGPathSegList: 0,
      SVGPointList: 0,
      SVGStringList: 0,
      SVGTransformList: 0,
      SourceBufferList: 0,
      StyleSheetList: 0,
      TextTrackCueList: 0,
      TextTrackList: 0,
      TouchList: 0
    };
    return domIterables;
  }
  var domTokenListPrototype;
  var hasRequiredDomTokenListPrototype;
  function requireDomTokenListPrototype() {
    if (hasRequiredDomTokenListPrototype) return domTokenListPrototype;
    hasRequiredDomTokenListPrototype = 1;
    var documentCreateElement = requireDocumentCreateElement();
    var classList = documentCreateElement('span').classList;
    var DOMTokenListPrototype = classList && classList.constructor && classList.constructor.prototype;
    domTokenListPrototype = DOMTokenListPrototype === Object.prototype ? undefined : DOMTokenListPrototype;
    return domTokenListPrototype;
  }
  var hasRequiredWeb_domCollections_forEach;
  function requireWeb_domCollections_forEach() {
    if (hasRequiredWeb_domCollections_forEach) return web_domCollections_forEach;
    hasRequiredWeb_domCollections_forEach = 1;
    var globalThis = requireGlobalThis();
    var DOMIterables = requireDomIterables();
    var DOMTokenListPrototype = requireDomTokenListPrototype();
    var forEach = requireArrayForEach();
    var createNonEnumerableProperty = requireCreateNonEnumerableProperty();
    var handlePrototype = function handlePrototype(CollectionPrototype) {
      if (CollectionPrototype && CollectionPrototype.forEach !== forEach) try {
        createNonEnumerableProperty(CollectionPrototype, 'forEach', forEach);
      } catch (error) {
        CollectionPrototype.forEach = forEach;
      }
    };
    for (var COLLECTION_NAME in DOMIterables) {
      if (DOMIterables[COLLECTION_NAME]) {
        handlePrototype(globalThis[COLLECTION_NAME] && globalThis[COLLECTION_NAME].prototype);
      }
    }
    handlePrototype(DOMTokenListPrototype);
    return web_domCollections_forEach;
  }
  var web_domCollections_iterator = {};
  var hasRequiredWeb_domCollections_iterator;
  function requireWeb_domCollections_iterator() {
    if (hasRequiredWeb_domCollections_iterator) return web_domCollections_iterator;
    hasRequiredWeb_domCollections_iterator = 1;
    var globalThis = requireGlobalThis();
    var DOMIterables = requireDomIterables();
    var DOMTokenListPrototype = requireDomTokenListPrototype();
    var ArrayIteratorMethods = requireEs_array_iterator();
    var createNonEnumerableProperty = requireCreateNonEnumerableProperty();
    var setToStringTag = requireSetToStringTag();
    var wellKnownSymbol = requireWellKnownSymbol();
    var ITERATOR = wellKnownSymbol('iterator');
    var ArrayValues = ArrayIteratorMethods.values;
    var handlePrototype = function handlePrototype(CollectionPrototype, COLLECTION_NAME) {
      if (CollectionPrototype) {
        if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
          createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
        } catch (error) {
          CollectionPrototype[ITERATOR] = ArrayValues;
        }
        setToStringTag(CollectionPrototype, COLLECTION_NAME, true);
        if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {
          if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
            createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
          } catch (error) {
            CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
          }
        }
      }
    };
    for (var COLLECTION_NAME in DOMIterables) {
      handlePrototype(globalThis[COLLECTION_NAME] && globalThis[COLLECTION_NAME].prototype, COLLECTION_NAME);
    }
    handlePrototype(DOMTokenListPrototype, 'DOMTokenList');
    return web_domCollections_iterator;
  }
  var web_domException_constructor = {};
  var domExceptionConstants;
  var hasRequiredDomExceptionConstants;
  function requireDomExceptionConstants() {
    if (hasRequiredDomExceptionConstants) return domExceptionConstants;
    hasRequiredDomExceptionConstants = 1;
    domExceptionConstants = {
      IndexSizeError: {
        s: 'INDEX_SIZE_ERR',
        c: 1,
        m: 1
      },
      DOMStringSizeError: {
        s: 'DOMSTRING_SIZE_ERR',
        c: 2,
        m: 0
      },
      HierarchyRequestError: {
        s: 'HIERARCHY_REQUEST_ERR',
        c: 3,
        m: 1
      },
      WrongDocumentError: {
        s: 'WRONG_DOCUMENT_ERR',
        c: 4,
        m: 1
      },
      InvalidCharacterError: {
        s: 'INVALID_CHARACTER_ERR',
        c: 5,
        m: 1
      },
      NoDataAllowedError: {
        s: 'NO_DATA_ALLOWED_ERR',
        c: 6,
        m: 0
      },
      NoModificationAllowedError: {
        s: 'NO_MODIFICATION_ALLOWED_ERR',
        c: 7,
        m: 1
      },
      NotFoundError: {
        s: 'NOT_FOUND_ERR',
        c: 8,
        m: 1
      },
      NotSupportedError: {
        s: 'NOT_SUPPORTED_ERR',
        c: 9,
        m: 1
      },
      InUseAttributeError: {
        s: 'INUSE_ATTRIBUTE_ERR',
        c: 10,
        m: 1
      },
      InvalidStateError: {
        s: 'INVALID_STATE_ERR',
        c: 11,
        m: 1
      },
      SyntaxError: {
        s: 'SYNTAX_ERR',
        c: 12,
        m: 1
      },
      InvalidModificationError: {
        s: 'INVALID_MODIFICATION_ERR',
        c: 13,
        m: 1
      },
      NamespaceError: {
        s: 'NAMESPACE_ERR',
        c: 14,
        m: 1
      },
      InvalidAccessError: {
        s: 'INVALID_ACCESS_ERR',
        c: 15,
        m: 1
      },
      ValidationError: {
        s: 'VALIDATION_ERR',
        c: 16,
        m: 0
      },
      TypeMismatchError: {
        s: 'TYPE_MISMATCH_ERR',
        c: 17,
        m: 1
      },
      SecurityError: {
        s: 'SECURITY_ERR',
        c: 18,
        m: 1
      },
      NetworkError: {
        s: 'NETWORK_ERR',
        c: 19,
        m: 1
      },
      AbortError: {
        s: 'ABORT_ERR',
        c: 20,
        m: 1
      },
      URLMismatchError: {
        s: 'URL_MISMATCH_ERR',
        c: 21,
        m: 1
      },
      QuotaExceededError: {
        s: 'QUOTA_EXCEEDED_ERR',
        c: 22,
        m: 1
      },
      TimeoutError: {
        s: 'TIMEOUT_ERR',
        c: 23,
        m: 1
      },
      InvalidNodeTypeError: {
        s: 'INVALID_NODE_TYPE_ERR',
        c: 24,
        m: 1
      },
      DataCloneError: {
        s: 'DATA_CLONE_ERR',
        c: 25,
        m: 1
      }
    };
    return domExceptionConstants;
  }
  var hasRequiredWeb_domException_constructor;
  function requireWeb_domException_constructor() {
    if (hasRequiredWeb_domException_constructor) return web_domException_constructor;
    hasRequiredWeb_domException_constructor = 1;
    var $ = require_export();
    var getBuiltIn = requireGetBuiltIn();
    var getBuiltInNodeModule = requireGetBuiltInNodeModule();
    var fails = requireFails();
    var create = requireObjectCreate();
    var createPropertyDescriptor = requireCreatePropertyDescriptor();
    var defineProperty = requireObjectDefineProperty().f;
    var defineBuiltIn = requireDefineBuiltIn();
    var defineBuiltInAccessor = requireDefineBuiltInAccessor();
    var hasOwn = requireHasOwnProperty();
    var anInstance = requireAnInstance();
    var anObject = requireAnObject();
    var errorToString = requireErrorToString();
    var normalizeStringArgument = requireNormalizeStringArgument();
    var DOMExceptionConstants = requireDomExceptionConstants();
    var clearErrorStack = requireErrorStackClear();
    var InternalStateModule = requireInternalState();
    var DESCRIPTORS = requireDescriptors();
    var IS_PURE = requireIsPure();
    var DOM_EXCEPTION = 'DOMException';
    var DATA_CLONE_ERR = 'DATA_CLONE_ERR';
    var Error = getBuiltIn('Error');
    var NativeDOMException = getBuiltIn(DOM_EXCEPTION) || function () {
      try {
        var MessageChannel = getBuiltIn('MessageChannel') || getBuiltInNodeModule('worker_threads').MessageChannel;
        new MessageChannel().port1.postMessage(new WeakMap());
      } catch (error) {
        if (error.name === DATA_CLONE_ERR && error.code === 25) return error.constructor;
      }
    }();
    var NativeDOMExceptionPrototype = NativeDOMException && NativeDOMException.prototype;
    var ErrorPrototype = Error.prototype;
    var setInternalState = InternalStateModule.set;
    var getInternalState = InternalStateModule.getterFor(DOM_EXCEPTION);
    var HAS_STACK = 'stack' in new Error(DOM_EXCEPTION);
    var codeFor = function codeFor(name) {
      return hasOwn(DOMExceptionConstants, name) && DOMExceptionConstants[name].m ? DOMExceptionConstants[name].c : 0;
    };
    var $DOMException = function DOMException() {
      anInstance(this, DOMExceptionPrototype);
      var argumentsLength = arguments.length;
      var message = normalizeStringArgument(argumentsLength < 1 ? undefined : arguments[0]);
      var name = normalizeStringArgument(argumentsLength < 2 ? undefined : arguments[1], 'Error');
      var code = codeFor(name);
      setInternalState(this, {
        type: DOM_EXCEPTION,
        name: name,
        message: message,
        code: code
      });
      if (!DESCRIPTORS) {
        this.name = name;
        this.message = message;
        this.code = code;
      }
      if (HAS_STACK) {
        var error = new Error(message);
        error.name = DOM_EXCEPTION;
        defineProperty(this, 'stack', createPropertyDescriptor(1, clearErrorStack(error.stack, 1)));
      }
    };
    var DOMExceptionPrototype = $DOMException.prototype = create(ErrorPrototype);
    var createGetterDescriptor = function createGetterDescriptor(get) {
      return {
        enumerable: true,
        configurable: true,
        get: get
      };
    };
    var getterFor = function getterFor(key) {
      return createGetterDescriptor(function () {
        return getInternalState(this)[key];
      });
    };
    if (DESCRIPTORS) {
      defineBuiltInAccessor(DOMExceptionPrototype, 'code', getterFor('code'));
      defineBuiltInAccessor(DOMExceptionPrototype, 'message', getterFor('message'));
      defineBuiltInAccessor(DOMExceptionPrototype, 'name', getterFor('name'));
    }
    defineProperty(DOMExceptionPrototype, 'constructor', createPropertyDescriptor(1, $DOMException));
    var INCORRECT_CONSTRUCTOR = fails(function () {
      return !(new NativeDOMException() instanceof Error);
    });
    var INCORRECT_TO_STRING = INCORRECT_CONSTRUCTOR || fails(function () {
      return ErrorPrototype.toString !== errorToString || String(new NativeDOMException(1, 2)) !== '2: 1';
    });
    var INCORRECT_CODE = INCORRECT_CONSTRUCTOR || fails(function () {
      return new NativeDOMException(1, 'DataCloneError').code !== 25;
    });
    var MISSED_CONSTANTS = INCORRECT_CONSTRUCTOR || NativeDOMException[DATA_CLONE_ERR] !== 25 || NativeDOMExceptionPrototype[DATA_CLONE_ERR] !== 25;
    var FORCED_CONSTRUCTOR = IS_PURE ? INCORRECT_TO_STRING || INCORRECT_CODE || MISSED_CONSTANTS : INCORRECT_CONSTRUCTOR;
    $({
      global: true,
      constructor: true,
      forced: FORCED_CONSTRUCTOR
    }, {
      DOMException: FORCED_CONSTRUCTOR ? $DOMException : NativeDOMException
    });
    var PolyfilledDOMException = getBuiltIn(DOM_EXCEPTION);
    var PolyfilledDOMExceptionPrototype = PolyfilledDOMException.prototype;
    if (INCORRECT_TO_STRING && (IS_PURE || NativeDOMException === PolyfilledDOMException)) {
      defineBuiltIn(PolyfilledDOMExceptionPrototype, 'toString', errorToString);
    }
    if (INCORRECT_CODE && DESCRIPTORS && NativeDOMException === PolyfilledDOMException) {
      defineBuiltInAccessor(PolyfilledDOMExceptionPrototype, 'code', createGetterDescriptor(function () {
        return codeFor(anObject(this).name);
      }));
    }
    for (var key in DOMExceptionConstants) if (hasOwn(DOMExceptionConstants, key)) {
      var constant = DOMExceptionConstants[key];
      var constantName = constant.s;
      var descriptor = createPropertyDescriptor(6, constant.c);
      if (!hasOwn(PolyfilledDOMException, constantName)) {
        defineProperty(PolyfilledDOMException, constantName, descriptor);
      }
      if (!hasOwn(PolyfilledDOMExceptionPrototype, constantName)) {
        defineProperty(PolyfilledDOMExceptionPrototype, constantName, descriptor);
      }
    }
    return web_domException_constructor;
  }
  var web_domException_stack = {};
  var hasRequiredWeb_domException_stack;
  function requireWeb_domException_stack() {
    if (hasRequiredWeb_domException_stack) return web_domException_stack;
    hasRequiredWeb_domException_stack = 1;
    var $ = require_export();
    var globalThis = requireGlobalThis();
    var getBuiltIn = requireGetBuiltIn();
    var createPropertyDescriptor = requireCreatePropertyDescriptor();
    var defineProperty = requireObjectDefineProperty().f;
    var hasOwn = requireHasOwnProperty();
    var anInstance = requireAnInstance();
    var inheritIfRequired = requireInheritIfRequired();
    var normalizeStringArgument = requireNormalizeStringArgument();
    var DOMExceptionConstants = requireDomExceptionConstants();
    var clearErrorStack = requireErrorStackClear();
    var DESCRIPTORS = requireDescriptors();
    var IS_PURE = requireIsPure();
    var DOM_EXCEPTION = 'DOMException';
    var Error = getBuiltIn('Error');
    var NativeDOMException = getBuiltIn(DOM_EXCEPTION);
    var $DOMException = function DOMException() {
      anInstance(this, DOMExceptionPrototype);
      var argumentsLength = arguments.length;
      var message = normalizeStringArgument(argumentsLength < 1 ? undefined : arguments[0]);
      var name = normalizeStringArgument(argumentsLength < 2 ? undefined : arguments[1], 'Error');
      var that = new NativeDOMException(message, name);
      var error = new Error(message);
      error.name = DOM_EXCEPTION;
      defineProperty(that, 'stack', createPropertyDescriptor(1, clearErrorStack(error.stack, 1)));
      inheritIfRequired(that, this, $DOMException);
      return that;
    };
    var DOMExceptionPrototype = $DOMException.prototype = NativeDOMException.prototype;
    var ERROR_HAS_STACK = 'stack' in new Error(DOM_EXCEPTION);
    var DOM_EXCEPTION_HAS_STACK = 'stack' in new NativeDOMException(1, 2);
    var descriptor = NativeDOMException && DESCRIPTORS && Object.getOwnPropertyDescriptor(globalThis, DOM_EXCEPTION);
    var BUGGY_DESCRIPTOR = !!descriptor && !(descriptor.writable && descriptor.configurable);
    var FORCED_CONSTRUCTOR = ERROR_HAS_STACK && !BUGGY_DESCRIPTOR && !DOM_EXCEPTION_HAS_STACK;
    $({
      global: true,
      constructor: true,
      forced: IS_PURE || FORCED_CONSTRUCTOR
    }, {
      DOMException: FORCED_CONSTRUCTOR ? $DOMException : NativeDOMException
    });
    var PolyfilledDOMException = getBuiltIn(DOM_EXCEPTION);
    var PolyfilledDOMExceptionPrototype = PolyfilledDOMException.prototype;
    if (PolyfilledDOMExceptionPrototype.constructor !== PolyfilledDOMException) {
      if (!IS_PURE) {
        defineProperty(PolyfilledDOMExceptionPrototype, 'constructor', createPropertyDescriptor(1, PolyfilledDOMException));
      }
      for (var key in DOMExceptionConstants) if (hasOwn(DOMExceptionConstants, key)) {
        var constant = DOMExceptionConstants[key];
        var constantName = constant.s;
        if (!hasOwn(PolyfilledDOMException, constantName)) {
          defineProperty(PolyfilledDOMException, constantName, createPropertyDescriptor(6, constant.c));
        }
      }
    }
    return web_domException_stack;
  }
  var web_domException_toStringTag = {};
  var hasRequiredWeb_domException_toStringTag;
  function requireWeb_domException_toStringTag() {
    if (hasRequiredWeb_domException_toStringTag) return web_domException_toStringTag;
    hasRequiredWeb_domException_toStringTag = 1;
    var getBuiltIn = requireGetBuiltIn();
    var setToStringTag = requireSetToStringTag();
    var DOM_EXCEPTION = 'DOMException';
    setToStringTag(getBuiltIn(DOM_EXCEPTION), DOM_EXCEPTION);
    return web_domException_toStringTag;
  }
  var web_immediate = {};
  var web_clearImmediate = {};
  var hasRequiredWeb_clearImmediate;
  function requireWeb_clearImmediate() {
    if (hasRequiredWeb_clearImmediate) return web_clearImmediate;
    hasRequiredWeb_clearImmediate = 1;
    var $ = require_export();
    var globalThis = requireGlobalThis();
    var clearImmediate = requireTask().clear;
    $({
      global: true,
      bind: true,
      enumerable: true,
      forced: globalThis.clearImmediate !== clearImmediate
    }, {
      clearImmediate: clearImmediate
    });
    return web_clearImmediate;
  }
  var web_setImmediate = {};
  var schedulersFix;
  var hasRequiredSchedulersFix;
  function requireSchedulersFix() {
    if (hasRequiredSchedulersFix) return schedulersFix;
    hasRequiredSchedulersFix = 1;
    var globalThis = requireGlobalThis();
    var apply = requireFunctionApply();
    var isCallable = requireIsCallable();
    var ENVIRONMENT = requireEnvironment();
    var USER_AGENT = requireEnvironmentUserAgent();
    var arraySlice = requireArraySlice();
    var validateArgumentsLength = requireValidateArgumentsLength();
    var Function = globalThis.Function;
    var WRAP = /MSIE .\./.test(USER_AGENT) || ENVIRONMENT === 'BUN' && function () {
      var version = globalThis.Bun.version.split('.');
      return version.length < 3 || version[0] === '0' && (version[1] < 3 || version[1] === '3' && version[2] === '0');
    }();
    schedulersFix = function schedulersFix(scheduler, hasTimeArg) {
      var firstParamIndex = hasTimeArg ? 2 : 1;
      return WRAP ? function (handler, timeout) {
        var boundArgs = validateArgumentsLength(arguments.length, 1) > firstParamIndex;
        var fn = isCallable(handler) ? handler : Function(handler);
        var params = boundArgs ? arraySlice(arguments, firstParamIndex) : [];
        var callback = boundArgs ? function () {
          apply(fn, this, params);
        } : fn;
        return hasTimeArg ? scheduler(callback, timeout) : scheduler(callback);
      } : scheduler;
    };
    return schedulersFix;
  }
  var hasRequiredWeb_setImmediate;
  function requireWeb_setImmediate() {
    if (hasRequiredWeb_setImmediate) return web_setImmediate;
    hasRequiredWeb_setImmediate = 1;
    var $ = require_export();
    var globalThis = requireGlobalThis();
    var setTask = requireTask().set;
    var schedulersFix = requireSchedulersFix();
    var setImmediate = globalThis.setImmediate ? schedulersFix(setTask, false) : setTask;
    $({
      global: true,
      bind: true,
      enumerable: true,
      forced: globalThis.setImmediate !== setImmediate
    }, {
      setImmediate: setImmediate
    });
    return web_setImmediate;
  }
  var hasRequiredWeb_immediate;
  function requireWeb_immediate() {
    if (hasRequiredWeb_immediate) return web_immediate;
    hasRequiredWeb_immediate = 1;
    requireWeb_clearImmediate();
    requireWeb_setImmediate();
    return web_immediate;
  }
  var web_queueMicrotask = {};
  var hasRequiredWeb_queueMicrotask;
  function requireWeb_queueMicrotask() {
    if (hasRequiredWeb_queueMicrotask) return web_queueMicrotask;
    hasRequiredWeb_queueMicrotask = 1;
    var $ = require_export();
    var globalThis = requireGlobalThis();
    var microtask = requireMicrotask();
    var aCallable = requireACallable();
    var validateArgumentsLength = requireValidateArgumentsLength();
    var fails = requireFails();
    var DESCRIPTORS = requireDescriptors();
    var WRONG_ARITY = fails(function () {
      return DESCRIPTORS && Object.getOwnPropertyDescriptor(globalThis, 'queueMicrotask').value.length !== 1;
    });
    $({
      global: true,
      enumerable: true,
      dontCallGetSet: true,
      forced: WRONG_ARITY
    }, {
      queueMicrotask: function queueMicrotask(fn) {
        validateArgumentsLength(arguments.length, 1);
        microtask(aCallable(fn));
      }
    });
    return web_queueMicrotask;
  }
  var web_self = {};
  var hasRequiredWeb_self;
  function requireWeb_self() {
    if (hasRequiredWeb_self) return web_self;
    hasRequiredWeb_self = 1;
    var $ = require_export();
    var globalThis = requireGlobalThis();
    var defineBuiltInAccessor = requireDefineBuiltInAccessor();
    var DESCRIPTORS = requireDescriptors();
    var $TypeError = TypeError;
    var defineProperty = Object.defineProperty;
    var INCORRECT_VALUE = globalThis.self !== globalThis;
    try {
      if (DESCRIPTORS) {
        var descriptor = Object.getOwnPropertyDescriptor(globalThis, 'self');
        if (INCORRECT_VALUE || !descriptor || !descriptor.get || !descriptor.enumerable) {
          defineBuiltInAccessor(globalThis, 'self', {
            get: function self() {
              return globalThis;
            },
            set: function self(value) {
              if (this !== globalThis) throw new $TypeError('Illegal invocation');
              defineProperty(globalThis, 'self', {
                value: value,
                writable: true,
                configurable: true,
                enumerable: true
              });
            },
            configurable: true,
            enumerable: true
          });
        }
      } else $({
        global: true,
        simple: true,
        forced: INCORRECT_VALUE
      }, {
        self: globalThis
      });
    } catch (error) {}
    return web_self;
  }
  var web_structuredClone = {};
  var hasRequiredWeb_structuredClone;
  function requireWeb_structuredClone() {
    if (hasRequiredWeb_structuredClone) return web_structuredClone;
    hasRequiredWeb_structuredClone = 1;
    var IS_PURE = requireIsPure();
    var $ = require_export();
    var globalThis = requireGlobalThis();
    var getBuiltIn = requireGetBuiltIn();
    var uncurryThis = requireFunctionUncurryThis();
    var fails = requireFails();
    var uid = requireUid();
    var isCallable = requireIsCallable();
    var isConstructor = requireIsConstructor();
    var isNullOrUndefined = requireIsNullOrUndefined();
    var isObject = requireIsObject();
    var isSymbol = requireIsSymbol();
    var iterate = requireIterate();
    var anObject = requireAnObject();
    var classof = requireClassof();
    var hasOwn = requireHasOwnProperty();
    var createProperty = requireCreateProperty();
    var createNonEnumerableProperty = requireCreateNonEnumerableProperty();
    var lengthOfArrayLike = requireLengthOfArrayLike();
    var validateArgumentsLength = requireValidateArgumentsLength();
    var getRegExpFlags = requireRegexpGetFlags();
    var MapHelpers = requireMapHelpers();
    var SetHelpers = requireSetHelpers();
    var setIterate = requireSetIterate();
    var detachTransferable = requireDetachTransferable();
    var ERROR_STACK_INSTALLABLE = requireErrorStackInstallable();
    var PROPER_STRUCTURED_CLONE_TRANSFER = requireStructuredCloneProperTransfer();
    var Object = globalThis.Object;
    var Array = globalThis.Array;
    var Date = globalThis.Date;
    var Error = globalThis.Error;
    var TypeError = globalThis.TypeError;
    var PerformanceMark = globalThis.PerformanceMark;
    var DOMException = getBuiltIn('DOMException');
    var Map = MapHelpers.Map;
    var mapHas = MapHelpers.has;
    var mapGet = MapHelpers.get;
    var mapSet = MapHelpers.set;
    var Set = SetHelpers.Set;
    var setAdd = SetHelpers.add;
    var setHas = SetHelpers.has;
    var objectKeys = getBuiltIn('Object', 'keys');
    var push = uncurryThis([].push);
    var thisBooleanValue = uncurryThis(true.valueOf);
    var thisNumberValue = uncurryThis(1.1.valueOf);
    var thisStringValue = uncurryThis(''.valueOf);
    var thisTimeValue = uncurryThis(Date.prototype.getTime);
    var PERFORMANCE_MARK = uid('structuredClone');
    var DATA_CLONE_ERROR = 'DataCloneError';
    var TRANSFERRING = 'Transferring';
    var checkBasicSemantic = function checkBasicSemantic(structuredCloneImplementation) {
      return !fails(function () {
        var set1 = new globalThis.Set([7]);
        var set2 = structuredCloneImplementation(set1);
        var number = structuredCloneImplementation(Object(7));
        return set2 === set1 || !set2.has(7) || !isObject(number) || +number !== 7;
      }) && structuredCloneImplementation;
    };
    var checkErrorsCloning = function checkErrorsCloning(structuredCloneImplementation, $Error) {
      return !fails(function () {
        var error = new $Error();
        var test = structuredCloneImplementation({
          a: error,
          b: error
        });
        return !(test && test.a === test.b && test.a instanceof $Error && test.a.stack === error.stack);
      });
    };
    var checkNewErrorsCloningSemantic = function checkNewErrorsCloningSemantic(structuredCloneImplementation) {
      return !fails(function () {
        var test = structuredCloneImplementation(new globalThis.AggregateError([1], PERFORMANCE_MARK, {
          cause: 3
        }));
        return test.name !== 'AggregateError' || test.errors[0] !== 1 || test.message !== PERFORMANCE_MARK || test.cause !== 3;
      });
    };
    var nativeStructuredClone = globalThis.structuredClone;
    var FORCED_REPLACEMENT = IS_PURE || !checkErrorsCloning(nativeStructuredClone, Error) || !checkErrorsCloning(nativeStructuredClone, DOMException) || !checkNewErrorsCloningSemantic(nativeStructuredClone);
    var structuredCloneFromMark = !nativeStructuredClone && checkBasicSemantic(function (value) {
      return new PerformanceMark(PERFORMANCE_MARK, {
        detail: value
      }).detail;
    });
    var nativeRestrictedStructuredClone = checkBasicSemantic(nativeStructuredClone) || structuredCloneFromMark;
    var throwUncloneable = function throwUncloneable(type) {
      throw new DOMException('Uncloneable type: ' + type, DATA_CLONE_ERROR);
    };
    var throwUnpolyfillable = function throwUnpolyfillable(type, action) {
      throw new DOMException((action || 'Cloning') + ' of ' + type + ' cannot be properly polyfilled in this engine', DATA_CLONE_ERROR);
    };
    var tryNativeRestrictedStructuredClone = function tryNativeRestrictedStructuredClone(value, type) {
      if (!nativeRestrictedStructuredClone) throwUnpolyfillable(type);
      return nativeRestrictedStructuredClone(value);
    };
    var createDataTransfer = function createDataTransfer() {
      var dataTransfer;
      try {
        dataTransfer = new globalThis.DataTransfer();
      } catch (error) {
        try {
          dataTransfer = new globalThis.ClipboardEvent('').clipboardData;
        } catch (error2) {}
      }
      return dataTransfer && dataTransfer.items && dataTransfer.files ? dataTransfer : null;
    };
    var cloneBuffer = function cloneBuffer(value, map, $type) {
      if (mapHas(map, value)) return mapGet(map, value);
      var type = $type || classof(value);
      var clone, length, options, source, target, i;
      if (type === 'SharedArrayBuffer') {
        if (nativeRestrictedStructuredClone) clone = nativeRestrictedStructuredClone(value);else clone = value;
      } else {
        var DataView = globalThis.DataView;
        if (!DataView && !isCallable(value.slice)) throwUnpolyfillable('ArrayBuffer');
        try {
          if (isCallable(value.slice) && !value.resizable) {
            clone = value.slice(0);
          } else {
            length = value.byteLength;
            options = 'maxByteLength' in value ? {
              maxByteLength: value.maxByteLength
            } : undefined;
            clone = new ArrayBuffer(length, options);
            source = new DataView(value);
            target = new DataView(clone);
            for (i = 0; i < length; i++) {
              target.setUint8(i, source.getUint8(i));
            }
          }
        } catch (error) {
          throw new DOMException('ArrayBuffer is detached', DATA_CLONE_ERROR);
        }
      }
      mapSet(map, value, clone);
      return clone;
    };
    var cloneView = function cloneView(value, type, offset, length, map) {
      var C = globalThis[type];
      if (!isObject(C)) throwUnpolyfillable(type);
      return new C(cloneBuffer(value.buffer, map), offset, length);
    };
    var _structuredCloneInternal = function structuredCloneInternal(value, map) {
      if (isSymbol(value)) throwUncloneable('Symbol');
      if (!isObject(value)) return value;
      if (map) {
        if (mapHas(map, value)) return mapGet(map, value);
      } else map = new Map();
      var type = classof(value);
      var C, name, cloned, dataTransfer, i, length, keys, key;
      switch (type) {
        case 'Array':
          cloned = Array(lengthOfArrayLike(value));
          break;
        case 'Object':
          cloned = {};
          break;
        case 'Map':
          cloned = new Map();
          break;
        case 'Set':
          cloned = new Set();
          break;
        case 'RegExp':
          cloned = new RegExp(value.source, getRegExpFlags(value));
          break;
        case 'Error':
          name = value.name;
          switch (name) {
            case 'AggregateError':
              cloned = new (getBuiltIn(name))([]);
              break;
            case 'EvalError':
            case 'RangeError':
            case 'ReferenceError':
            case 'SuppressedError':
            case 'SyntaxError':
            case 'TypeError':
            case 'URIError':
              cloned = new (getBuiltIn(name))();
              break;
            case 'CompileError':
            case 'LinkError':
            case 'RuntimeError':
              cloned = new (getBuiltIn('WebAssembly', name))();
              break;
            default:
              cloned = new Error();
          }
          break;
        case 'DOMException':
          cloned = new DOMException(value.message, value.name);
          break;
        case 'ArrayBuffer':
        case 'SharedArrayBuffer':
          cloned = cloneBuffer(value, map, type);
          break;
        case 'DataView':
        case 'Int8Array':
        case 'Uint8Array':
        case 'Uint8ClampedArray':
        case 'Int16Array':
        case 'Uint16Array':
        case 'Int32Array':
        case 'Uint32Array':
        case 'Float16Array':
        case 'Float32Array':
        case 'Float64Array':
        case 'BigInt64Array':
        case 'BigUint64Array':
          length = type === 'DataView' ? value.byteLength : value.length;
          cloned = cloneView(value, type, value.byteOffset, length, map);
          break;
        case 'DOMQuad':
          try {
            cloned = new DOMQuad(_structuredCloneInternal(value.p1, map), _structuredCloneInternal(value.p2, map), _structuredCloneInternal(value.p3, map), _structuredCloneInternal(value.p4, map));
          } catch (error) {
            cloned = tryNativeRestrictedStructuredClone(value, type);
          }
          break;
        case 'File':
          if (nativeRestrictedStructuredClone) try {
            cloned = nativeRestrictedStructuredClone(value);
            if (classof(cloned) !== type) cloned = undefined;
          } catch (error) {}
          if (!cloned) try {
            cloned = new File([value], value.name, value);
          } catch (error) {}
          if (!cloned) throwUnpolyfillable(type);
          break;
        case 'FileList':
          dataTransfer = createDataTransfer();
          if (dataTransfer) {
            for (i = 0, length = lengthOfArrayLike(value); i < length; i++) {
              dataTransfer.items.add(_structuredCloneInternal(value[i], map));
            }
            cloned = dataTransfer.files;
          } else cloned = tryNativeRestrictedStructuredClone(value, type);
          break;
        case 'ImageData':
          try {
            cloned = new ImageData(_structuredCloneInternal(value.data, map), value.width, value.height, {
              colorSpace: value.colorSpace
            });
          } catch (error) {
            cloned = tryNativeRestrictedStructuredClone(value, type);
          }
          break;
        default:
          if (nativeRestrictedStructuredClone) {
            cloned = nativeRestrictedStructuredClone(value);
          } else switch (type) {
            case 'BigInt':
              cloned = Object(value.valueOf());
              break;
            case 'Boolean':
              cloned = Object(thisBooleanValue(value));
              break;
            case 'Number':
              cloned = Object(thisNumberValue(value));
              break;
            case 'String':
              cloned = Object(thisStringValue(value));
              break;
            case 'Date':
              cloned = new Date(thisTimeValue(value));
              break;
            case 'Blob':
              try {
                cloned = value.slice(0, value.size, value.type);
              } catch (error) {
                throwUnpolyfillable(type);
              }
              break;
            case 'DOMPoint':
            case 'DOMPointReadOnly':
              C = globalThis[type];
              try {
                cloned = C.fromPoint ? C.fromPoint(value) : new C(value.x, value.y, value.z, value.w);
              } catch (error) {
                throwUnpolyfillable(type);
              }
              break;
            case 'DOMRect':
            case 'DOMRectReadOnly':
              C = globalThis[type];
              try {
                cloned = C.fromRect ? C.fromRect(value) : new C(value.x, value.y, value.width, value.height);
              } catch (error) {
                throwUnpolyfillable(type);
              }
              break;
            case 'DOMMatrix':
            case 'DOMMatrixReadOnly':
              C = globalThis[type];
              try {
                cloned = C.fromMatrix ? C.fromMatrix(value) : new C(value);
              } catch (error) {
                throwUnpolyfillable(type);
              }
              break;
            case 'AudioData':
            case 'VideoFrame':
              if (!isCallable(value.clone)) throwUnpolyfillable(type);
              try {
                cloned = value.clone();
              } catch (error) {
                throwUncloneable(type);
              }
              break;
            case 'CropTarget':
            case 'CryptoKey':
            case 'FileSystemDirectoryHandle':
            case 'FileSystemFileHandle':
            case 'FileSystemHandle':
            case 'GPUCompilationInfo':
            case 'GPUCompilationMessage':
            case 'ImageBitmap':
            case 'RTCCertificate':
            case 'WebAssembly.Module':
              throwUnpolyfillable(type);
            default:
              throwUncloneable(type);
          }
      }
      mapSet(map, value, cloned);
      switch (type) {
        case 'Array':
        case 'Object':
          keys = objectKeys(value);
          for (i = 0, length = lengthOfArrayLike(keys); i < length; i++) {
            key = keys[i];
            createProperty(cloned, key, _structuredCloneInternal(value[key], map));
          }
          break;
        case 'Map':
          value.forEach(function (v, k) {
            mapSet(cloned, _structuredCloneInternal(k, map), _structuredCloneInternal(v, map));
          });
          break;
        case 'Set':
          value.forEach(function (v) {
            setAdd(cloned, _structuredCloneInternal(v, map));
          });
          break;
        case 'Error':
          createNonEnumerableProperty(cloned, 'message', _structuredCloneInternal(value.message, map));
          if (hasOwn(value, 'cause')) {
            createNonEnumerableProperty(cloned, 'cause', _structuredCloneInternal(value.cause, map));
          }
          if (name === 'AggregateError') {
            cloned.errors = _structuredCloneInternal(value.errors, map);
          } else if (name === 'SuppressedError') {
            cloned.error = _structuredCloneInternal(value.error, map);
            cloned.suppressed = _structuredCloneInternal(value.suppressed, map);
          }
        case 'DOMException':
          if (ERROR_STACK_INSTALLABLE) {
            createNonEnumerableProperty(cloned, 'stack', _structuredCloneInternal(value.stack, map));
          }
      }
      return cloned;
    };
    var tryToTransfer = function tryToTransfer(rawTransfer, map) {
      if (!isObject(rawTransfer)) throw new TypeError('Transfer option cannot be converted to a sequence');
      var transfer = [];
      iterate(rawTransfer, function (value) {
        push(transfer, anObject(value));
      });
      var i = 0;
      var length = lengthOfArrayLike(transfer);
      var buffers = new Set();
      var value, type, C, transferred, canvas, context;
      while (i < length) {
        value = transfer[i++];
        type = classof(value);
        if (type === 'ArrayBuffer' ? setHas(buffers, value) : mapHas(map, value)) {
          throw new DOMException('Duplicate transferable', DATA_CLONE_ERROR);
        }
        if (type === 'ArrayBuffer') {
          setAdd(buffers, value);
          continue;
        }
        if (PROPER_STRUCTURED_CLONE_TRANSFER) {
          transferred = nativeStructuredClone(value, {
            transfer: [value]
          });
        } else switch (type) {
          case 'ImageBitmap':
            C = globalThis.OffscreenCanvas;
            if (!isConstructor(C)) throwUnpolyfillable(type, TRANSFERRING);
            try {
              canvas = new C(value.width, value.height);
              context = canvas.getContext('bitmaprenderer');
              context.transferFromImageBitmap(value);
              transferred = canvas.transferToImageBitmap();
            } catch (error) {}
            break;
          case 'AudioData':
          case 'VideoFrame':
            if (!isCallable(value.clone) || !isCallable(value.close)) throwUnpolyfillable(type, TRANSFERRING);
            try {
              transferred = value.clone();
              value.close();
            } catch (error) {}
            break;
          case 'MediaSourceHandle':
          case 'MessagePort':
          case 'MIDIAccess':
          case 'OffscreenCanvas':
          case 'ReadableStream':
          case 'RTCDataChannel':
          case 'TransformStream':
          case 'WebTransportReceiveStream':
          case 'WebTransportSendStream':
          case 'WritableStream':
            throwUnpolyfillable(type, TRANSFERRING);
        }
        if (transferred === undefined) throw new DOMException('This object cannot be transferred: ' + type, DATA_CLONE_ERROR);
        mapSet(map, value, transferred);
      }
      return buffers;
    };
    var detachBuffers = function detachBuffers(buffers) {
      setIterate(buffers, function (buffer) {
        if (PROPER_STRUCTURED_CLONE_TRANSFER) {
          nativeRestrictedStructuredClone(buffer, {
            transfer: [buffer]
          });
        } else if (isCallable(buffer.transfer)) {
          buffer.transfer();
        } else if (detachTransferable) {
          detachTransferable(buffer);
        } else {
          throwUnpolyfillable('ArrayBuffer', TRANSFERRING);
        }
      });
    };
    $({
      global: true,
      enumerable: true,
      sham: !PROPER_STRUCTURED_CLONE_TRANSFER,
      forced: FORCED_REPLACEMENT
    }, {
      structuredClone: function structuredClone(value) {
        var options = validateArgumentsLength(arguments.length, 1) > 1 && !isNullOrUndefined(arguments[1]) ? anObject(arguments[1]) : undefined;
        var transfer = options ? options.transfer : undefined;
        var map, buffers;
        if (transfer !== undefined) {
          map = new Map();
          buffers = tryToTransfer(transfer, map);
        }
        var clone = _structuredCloneInternal(value, map);
        if (buffers) detachBuffers(buffers);
        return clone;
      }
    });
    return web_structuredClone;
  }
  var web_timers = {};
  var web_setInterval = {};
  var hasRequiredWeb_setInterval;
  function requireWeb_setInterval() {
    if (hasRequiredWeb_setInterval) return web_setInterval;
    hasRequiredWeb_setInterval = 1;
    var $ = require_export();
    var globalThis = requireGlobalThis();
    var schedulersFix = requireSchedulersFix();
    var setInterval = schedulersFix(globalThis.setInterval, true);
    $({
      global: true,
      bind: true,
      forced: globalThis.setInterval !== setInterval
    }, {
      setInterval: setInterval
    });
    return web_setInterval;
  }
  var web_setTimeout = {};
  var hasRequiredWeb_setTimeout;
  function requireWeb_setTimeout() {
    if (hasRequiredWeb_setTimeout) return web_setTimeout;
    hasRequiredWeb_setTimeout = 1;
    var $ = require_export();
    var globalThis = requireGlobalThis();
    var schedulersFix = requireSchedulersFix();
    var setTimeout = schedulersFix(globalThis.setTimeout, true);
    $({
      global: true,
      bind: true,
      forced: globalThis.setTimeout !== setTimeout
    }, {
      setTimeout: setTimeout
    });
    return web_setTimeout;
  }
  var hasRequiredWeb_timers;
  function requireWeb_timers() {
    if (hasRequiredWeb_timers) return web_timers;
    hasRequiredWeb_timers = 1;
    requireWeb_setInterval();
    requireWeb_setTimeout();
    return web_timers;
  }
  var web_url = {};
  var web_url_constructor = {};
  var urlConstructorDetection;
  var hasRequiredUrlConstructorDetection;
  function requireUrlConstructorDetection() {
    if (hasRequiredUrlConstructorDetection) return urlConstructorDetection;
    hasRequiredUrlConstructorDetection = 1;
    var fails = requireFails();
    var wellKnownSymbol = requireWellKnownSymbol();
    var DESCRIPTORS = requireDescriptors();
    var IS_PURE = requireIsPure();
    var ITERATOR = wellKnownSymbol('iterator');
    urlConstructorDetection = !fails(function () {
      var url = new URL('b?a=1&b=2&c=3', 'https://a');
      var params = url.searchParams;
      var params2 = new URLSearchParams('a=1&a=2&b=3');
      var result = '';
      url.pathname = 'c%20d';
      params.forEach(function (value, key) {
        params['delete']('b');
        result += key + value;
      });
      params2['delete']('a', 2);
      params2['delete']('b', undefined);
      return IS_PURE && (!url.toJSON || !params2.has('a', 1) || params2.has('a', 2) || !params2.has('a', undefined) || params2.has('b')) || !params.size && (IS_PURE || !DESCRIPTORS) || !params.sort || url.href !== 'https://a/c%20d?a=1&c=3' || params.get('c') !== '3' || String(new URLSearchParams('?a=1')) !== 'a=1' || !params[ITERATOR] || new URL('https://a@b').username !== 'a' || new URLSearchParams(new URLSearchParams('a=b')).get('a') !== 'b' || new URL('https://тест').host !== 'xn--e1aybc' || new URL('https://a#б').hash !== '#%D0%B1' || result !== 'a1c3' || new URL('https://x', undefined).host !== 'x';
    });
    return urlConstructorDetection;
  }
  var stringPunycodeToAscii;
  var hasRequiredStringPunycodeToAscii;
  function requireStringPunycodeToAscii() {
    if (hasRequiredStringPunycodeToAscii) return stringPunycodeToAscii;
    hasRequiredStringPunycodeToAscii = 1;
    var uncurryThis = requireFunctionUncurryThis();
    var maxInt = 2147483647;
    var base = 36;
    var tMin = 1;
    var tMax = 26;
    var skew = 38;
    var damp = 700;
    var initialBias = 72;
    var initialN = 128;
    var delimiter = '-';
    var regexNonASCII = /[^\0-\u007E]/;
    var regexSeparators = /[.\u3002\uFF0E\uFF61]/g;
    var OVERFLOW_ERROR = 'Overflow: input needs wider integers to process';
    var baseMinusTMin = base - tMin;
    var $RangeError = RangeError;
    var exec = uncurryThis(regexSeparators.exec);
    var floor = Math.floor;
    var fromCharCode = String.fromCharCode;
    var charCodeAt = uncurryThis(''.charCodeAt);
    var join = uncurryThis([].join);
    var push = uncurryThis([].push);
    var replace = uncurryThis(''.replace);
    var split = uncurryThis(''.split);
    var toLowerCase = uncurryThis(''.toLowerCase);
    var ucs2decode = function ucs2decode(string) {
      var output = [];
      var counter = 0;
      var length = string.length;
      while (counter < length) {
        var value = charCodeAt(string, counter++);
        if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
          var extra = charCodeAt(string, counter++);
          if ((extra & 0xFC00) === 0xDC00) {
            push(output, ((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
          } else {
            push(output, value);
            counter--;
          }
        } else {
          push(output, value);
        }
      }
      return output;
    };
    var digitToBasic = function digitToBasic(digit) {
      return digit + 22 + 75 * (digit < 26);
    };
    var adapt = function adapt(delta, numPoints, firstTime) {
      var k = 0;
      delta = firstTime ? floor(delta / damp) : delta >> 1;
      delta += floor(delta / numPoints);
      while (delta > baseMinusTMin * tMax >> 1) {
        delta = floor(delta / baseMinusTMin);
        k += base;
      }
      return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    };
    var encode = function encode(input) {
      var output = [];
      input = ucs2decode(input);
      var inputLength = input.length;
      var n = initialN;
      var delta = 0;
      var bias = initialBias;
      var i, currentValue;
      for (i = 0; i < input.length; i++) {
        currentValue = input[i];
        if (currentValue < 0x80) {
          push(output, fromCharCode(currentValue));
        }
      }
      var basicLength = output.length;
      var handledCPCount = basicLength;
      if (basicLength) {
        push(output, delimiter);
      }
      while (handledCPCount < inputLength) {
        var m = maxInt;
        for (i = 0; i < input.length; i++) {
          currentValue = input[i];
          if (currentValue >= n && currentValue < m) {
            m = currentValue;
          }
        }
        var handledCPCountPlusOne = handledCPCount + 1;
        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
          throw new $RangeError(OVERFLOW_ERROR);
        }
        delta += (m - n) * handledCPCountPlusOne;
        n = m;
        for (i = 0; i < input.length; i++) {
          currentValue = input[i];
          if (currentValue < n && ++delta > maxInt) {
            throw new $RangeError(OVERFLOW_ERROR);
          }
          if (currentValue === n) {
            var q = delta;
            var k = base;
            while (true) {
              var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
              if (q < t) break;
              var qMinusT = q - t;
              var baseMinusT = base - t;
              push(output, fromCharCode(digitToBasic(t + qMinusT % baseMinusT)));
              q = floor(qMinusT / baseMinusT);
              k += base;
            }
            push(output, fromCharCode(digitToBasic(q)));
            bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
            delta = 0;
            handledCPCount++;
          }
        }
        delta++;
        n++;
      }
      return join(output, '');
    };
    stringPunycodeToAscii = function stringPunycodeToAscii(input) {
      var encoded = [];
      var labels = split(replace(toLowerCase(input), regexSeparators, '\u002E'), '.');
      var i, label;
      for (i = 0; i < labels.length; i++) {
        label = labels[i];
        push(encoded, exec(regexNonASCII, label) ? 'xn--' + encode(label) : label);
      }
      return join(encoded, '.');
    };
    return stringPunycodeToAscii;
  }
  var web_urlSearchParams_constructor;
  var hasRequiredWeb_urlSearchParams_constructor;
  function requireWeb_urlSearchParams_constructor() {
    if (hasRequiredWeb_urlSearchParams_constructor) return web_urlSearchParams_constructor;
    hasRequiredWeb_urlSearchParams_constructor = 1;
    requireEs_array_iterator();
    requireEs_string_fromCodePoint();
    var $ = require_export();
    var globalThis = requireGlobalThis();
    var safeGetBuiltIn = requireSafeGetBuiltIn();
    var getBuiltIn = requireGetBuiltIn();
    var call = requireFunctionCall();
    var uncurryThis = requireFunctionUncurryThis();
    var DESCRIPTORS = requireDescriptors();
    var USE_NATIVE_URL = requireUrlConstructorDetection();
    var defineBuiltIn = requireDefineBuiltIn();
    var defineBuiltInAccessor = requireDefineBuiltInAccessor();
    var defineBuiltIns = requireDefineBuiltIns();
    var setToStringTag = requireSetToStringTag();
    var createIteratorConstructor = requireIteratorCreateConstructor();
    var InternalStateModule = requireInternalState();
    var anInstance = requireAnInstance();
    var isCallable = requireIsCallable();
    var hasOwn = requireHasOwnProperty();
    var bind = requireFunctionBindContext();
    var classof = requireClassof();
    var anObject = requireAnObject();
    var isObject = requireIsObject();
    var $toString = requireToString();
    var create = requireObjectCreate();
    var createPropertyDescriptor = requireCreatePropertyDescriptor();
    var getIterator = requireGetIterator();
    var getIteratorMethod = requireGetIteratorMethod();
    var createIterResultObject = requireCreateIterResultObject();
    var validateArgumentsLength = requireValidateArgumentsLength();
    var wellKnownSymbol = requireWellKnownSymbol();
    var arraySort = requireArraySort();
    var ITERATOR = wellKnownSymbol('iterator');
    var URL_SEARCH_PARAMS = 'URLSearchParams';
    var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + 'Iterator';
    var setInternalState = InternalStateModule.set;
    var getInternalParamsState = InternalStateModule.getterFor(URL_SEARCH_PARAMS);
    var getInternalIteratorState = InternalStateModule.getterFor(URL_SEARCH_PARAMS_ITERATOR);
    var nativeFetch = safeGetBuiltIn('fetch');
    var NativeRequest = safeGetBuiltIn('Request');
    var Headers = safeGetBuiltIn('Headers');
    var RequestPrototype = NativeRequest && NativeRequest.prototype;
    var HeadersPrototype = Headers && Headers.prototype;
    var TypeError = globalThis.TypeError;
    var encodeURIComponent = globalThis.encodeURIComponent;
    var fromCharCode = String.fromCharCode;
    var fromCodePoint = getBuiltIn('String', 'fromCodePoint');
    var $parseInt = parseInt;
    var charAt = uncurryThis(''.charAt);
    var join = uncurryThis([].join);
    var push = uncurryThis([].push);
    var replace = uncurryThis(''.replace);
    var shift = uncurryThis([].shift);
    var splice = uncurryThis([].splice);
    var split = uncurryThis(''.split);
    var stringSlice = uncurryThis(''.slice);
    var exec = uncurryThis(/./.exec);
    var plus = /\+/g;
    var FALLBACK_REPLACER = '\uFFFD';
    var VALID_HEX = /^[0-9a-f]+$/i;
    var parseHexOctet = function parseHexOctet(string, start) {
      var substr = stringSlice(string, start, start + 2);
      if (!exec(VALID_HEX, substr)) return NaN;
      return $parseInt(substr, 16);
    };
    var getLeadingOnes = function getLeadingOnes(octet) {
      var count = 0;
      for (var mask = 0x80; mask > 0 && (octet & mask) !== 0; mask >>= 1) {
        count++;
      }
      return count;
    };
    var utf8Decode = function utf8Decode(octets) {
      var codePoint = null;
      switch (octets.length) {
        case 1:
          codePoint = octets[0];
          break;
        case 2:
          codePoint = (octets[0] & 0x1F) << 6 | octets[1] & 0x3F;
          break;
        case 3:
          codePoint = (octets[0] & 0x0F) << 12 | (octets[1] & 0x3F) << 6 | octets[2] & 0x3F;
          break;
        case 4:
          codePoint = (octets[0] & 0x07) << 18 | (octets[1] & 0x3F) << 12 | (octets[2] & 0x3F) << 6 | octets[3] & 0x3F;
          break;
      }
      return codePoint > 0x10FFFF ? null : codePoint;
    };
    var decode = function decode(input) {
      input = replace(input, plus, ' ');
      var length = input.length;
      var result = '';
      var i = 0;
      while (i < length) {
        var decodedChar = charAt(input, i);
        if (decodedChar === '%') {
          if (charAt(input, i + 1) === '%' || i + 3 > length) {
            result += '%';
            i++;
            continue;
          }
          var octet = parseHexOctet(input, i + 1);
          if (octet !== octet) {
            result += decodedChar;
            i++;
            continue;
          }
          i += 2;
          var byteSequenceLength = getLeadingOnes(octet);
          if (byteSequenceLength === 0) {
            decodedChar = fromCharCode(octet);
          } else {
            if (byteSequenceLength === 1 || byteSequenceLength > 4) {
              result += FALLBACK_REPLACER;
              i++;
              continue;
            }
            var octets = [octet];
            var sequenceIndex = 1;
            while (sequenceIndex < byteSequenceLength) {
              i++;
              if (i + 3 > length || charAt(input, i) !== '%') break;
              var nextByte = parseHexOctet(input, i + 1);
              if (nextByte !== nextByte) {
                i += 3;
                break;
              }
              if (nextByte > 191 || nextByte < 128) break;
              push(octets, nextByte);
              i += 2;
              sequenceIndex++;
            }
            if (octets.length !== byteSequenceLength) {
              result += FALLBACK_REPLACER;
              continue;
            }
            var codePoint = utf8Decode(octets);
            if (codePoint === null) {
              result += FALLBACK_REPLACER;
            } else {
              decodedChar = fromCodePoint(codePoint);
            }
          }
        }
        result += decodedChar;
        i++;
      }
      return result;
    };
    var find = /[!'()~]|%20/g;
    var replacements = {
      '!': '%21',
      "'": '%27',
      '(': '%28',
      ')': '%29',
      '~': '%7E',
      '%20': '+'
    };
    var replacer = function replacer(match) {
      return replacements[match];
    };
    var _serialize = function serialize(it) {
      return replace(encodeURIComponent(it), find, replacer);
    };
    var URLSearchParamsIterator = createIteratorConstructor(function Iterator(params, kind) {
      setInternalState(this, {
        type: URL_SEARCH_PARAMS_ITERATOR,
        target: getInternalParamsState(params).entries,
        index: 0,
        kind: kind
      });
    }, URL_SEARCH_PARAMS, function next() {
      var state = getInternalIteratorState(this);
      var target = state.target;
      var index = state.index++;
      if (!target || index >= target.length) {
        state.target = null;
        return createIterResultObject(undefined, true);
      }
      var entry = target[index];
      switch (state.kind) {
        case 'keys':
          return createIterResultObject(entry.key, false);
        case 'values':
          return createIterResultObject(entry.value, false);
      }
      return createIterResultObject([entry.key, entry.value], false);
    }, true);
    var URLSearchParamsState = function URLSearchParamsState(init) {
      this.entries = [];
      this.url = null;
      if (init !== undefined) {
        if (isObject(init)) this.parseObject(init);else this.parseQuery(typeof init == 'string' ? charAt(init, 0) === '?' ? stringSlice(init, 1) : init : $toString(init));
      }
    };
    URLSearchParamsState.prototype = {
      type: URL_SEARCH_PARAMS,
      bindURL: function bindURL(url) {
        this.url = url;
        this.update();
      },
      parseObject: function parseObject(object) {
        var entries = this.entries;
        var iteratorMethod = getIteratorMethod(object);
        var iterator, next, step, entryIterator, entryNext, first, second;
        if (iteratorMethod) {
          iterator = getIterator(object, iteratorMethod);
          next = iterator.next;
          while (!(step = call(next, iterator)).done) {
            entryIterator = getIterator(anObject(step.value));
            entryNext = entryIterator.next;
            if ((first = call(entryNext, entryIterator)).done || (second = call(entryNext, entryIterator)).done || !call(entryNext, entryIterator).done) throw new TypeError('Expected sequence with length 2');
            push(entries, {
              key: $toString(first.value),
              value: $toString(second.value)
            });
          }
        } else for (var key in object) if (hasOwn(object, key)) {
          push(entries, {
            key: key,
            value: $toString(object[key])
          });
        }
      },
      parseQuery: function parseQuery(query) {
        if (query) {
          var entries = this.entries;
          var attributes = split(query, '&');
          var index = 0;
          var attribute, entry;
          while (index < attributes.length) {
            attribute = attributes[index++];
            if (attribute.length) {
              entry = split(attribute, '=');
              push(entries, {
                key: decode(shift(entry)),
                value: decode(join(entry, '='))
              });
            }
          }
        }
      },
      serialize: function serialize() {
        var entries = this.entries;
        var result = [];
        var index = 0;
        var entry;
        while (index < entries.length) {
          entry = entries[index++];
          push(result, _serialize(entry.key) + '=' + _serialize(entry.value));
        }
        return join(result, '&');
      },
      update: function update() {
        this.entries.length = 0;
        this.parseQuery(this.url.query);
      },
      updateURL: function updateURL() {
        if (this.url) this.url.update();
      }
    };
    var URLSearchParamsConstructor = function URLSearchParams() {
      anInstance(this, URLSearchParamsPrototype);
      var init = arguments.length > 0 ? arguments[0] : undefined;
      var state = setInternalState(this, new URLSearchParamsState(init));
      if (!DESCRIPTORS) this.size = state.entries.length;
    };
    var URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;
    defineBuiltIns(URLSearchParamsPrototype, {
      append: function append(name, value) {
        var state = getInternalParamsState(this);
        validateArgumentsLength(arguments.length, 2);
        push(state.entries, {
          key: $toString(name),
          value: $toString(value)
        });
        if (!DESCRIPTORS) this.length++;
        state.updateURL();
      },
      'delete': function _delete(name) {
        var state = getInternalParamsState(this);
        var length = validateArgumentsLength(arguments.length, 1);
        var entries = state.entries;
        var key = $toString(name);
        var $value = length < 2 ? undefined : arguments[1];
        var value = $value === undefined ? $value : $toString($value);
        var index = 0;
        while (index < entries.length) {
          var entry = entries[index];
          if (entry.key === key && (value === undefined || entry.value === value)) {
            splice(entries, index, 1);
            if (value !== undefined) break;
          } else index++;
        }
        if (!DESCRIPTORS) this.size = entries.length;
        state.updateURL();
      },
      get: function get(name) {
        var entries = getInternalParamsState(this).entries;
        validateArgumentsLength(arguments.length, 1);
        var key = $toString(name);
        var index = 0;
        for (; index < entries.length; index++) {
          if (entries[index].key === key) return entries[index].value;
        }
        return null;
      },
      getAll: function getAll(name) {
        var entries = getInternalParamsState(this).entries;
        validateArgumentsLength(arguments.length, 1);
        var key = $toString(name);
        var result = [];
        var index = 0;
        for (; index < entries.length; index++) {
          if (entries[index].key === key) push(result, entries[index].value);
        }
        return result;
      },
      has: function has(name) {
        var entries = getInternalParamsState(this).entries;
        var length = validateArgumentsLength(arguments.length, 1);
        var key = $toString(name);
        var $value = length < 2 ? undefined : arguments[1];
        var value = $value === undefined ? $value : $toString($value);
        var index = 0;
        while (index < entries.length) {
          var entry = entries[index++];
          if (entry.key === key && (value === undefined || entry.value === value)) return true;
        }
        return false;
      },
      set: function set(name, value) {
        var state = getInternalParamsState(this);
        validateArgumentsLength(arguments.length, 1);
        var entries = state.entries;
        var found = false;
        var key = $toString(name);
        var val = $toString(value);
        var index = 0;
        var entry;
        for (; index < entries.length; index++) {
          entry = entries[index];
          if (entry.key === key) {
            if (found) splice(entries, index--, 1);else {
              found = true;
              entry.value = val;
            }
          }
        }
        if (!found) push(entries, {
          key: key,
          value: val
        });
        if (!DESCRIPTORS) this.size = entries.length;
        state.updateURL();
      },
      sort: function sort() {
        var state = getInternalParamsState(this);
        arraySort(state.entries, function (a, b) {
          return a.key > b.key ? 1 : -1;
        });
        state.updateURL();
      },
      forEach: function forEach(callback) {
        var entries = getInternalParamsState(this).entries;
        var boundFunction = bind(callback, arguments.length > 1 ? arguments[1] : undefined);
        var index = 0;
        var entry;
        while (index < entries.length) {
          entry = entries[index++];
          boundFunction(entry.value, entry.key, this);
        }
      },
      keys: function keys() {
        return new URLSearchParamsIterator(this, 'keys');
      },
      values: function values() {
        return new URLSearchParamsIterator(this, 'values');
      },
      entries: function entries() {
        return new URLSearchParamsIterator(this, 'entries');
      }
    }, {
      enumerable: true
    });
    defineBuiltIn(URLSearchParamsPrototype, ITERATOR, URLSearchParamsPrototype.entries, {
      name: 'entries'
    });
    defineBuiltIn(URLSearchParamsPrototype, 'toString', function toString() {
      return getInternalParamsState(this).serialize();
    }, {
      enumerable: true
    });
    if (DESCRIPTORS) defineBuiltInAccessor(URLSearchParamsPrototype, 'size', {
      get: function size() {
        return getInternalParamsState(this).entries.length;
      },
      configurable: true,
      enumerable: true
    });
    setToStringTag(URLSearchParamsConstructor, URL_SEARCH_PARAMS);
    $({
      global: true,
      constructor: true,
      forced: !USE_NATIVE_URL
    }, {
      URLSearchParams: URLSearchParamsConstructor
    });
    if (!USE_NATIVE_URL && isCallable(Headers)) {
      var headersHas = uncurryThis(HeadersPrototype.has);
      var headersSet = uncurryThis(HeadersPrototype.set);
      var wrapRequestOptions = function wrapRequestOptions(init) {
        if (isObject(init)) {
          var body = init.body;
          var headers;
          if (classof(body) === URL_SEARCH_PARAMS) {
            headers = init.headers ? new Headers(init.headers) : new Headers();
            if (!headersHas(headers, 'content-type')) {
              headersSet(headers, 'content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
            }
            return create(init, {
              body: createPropertyDescriptor(0, $toString(body)),
              headers: createPropertyDescriptor(0, headers)
            });
          }
        }
        return init;
      };
      if (isCallable(nativeFetch)) {
        $({
          global: true,
          enumerable: true,
          dontCallGetSet: true,
          forced: true
        }, {
          fetch: function fetch(input) {
            return nativeFetch(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
          }
        });
      }
      if (isCallable(NativeRequest)) {
        var RequestConstructor = function Request(input) {
          anInstance(this, RequestPrototype);
          return new NativeRequest(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
        };
        RequestPrototype.constructor = RequestConstructor;
        RequestConstructor.prototype = RequestPrototype;
        $({
          global: true,
          constructor: true,
          dontCallGetSet: true,
          forced: true
        }, {
          Request: RequestConstructor
        });
      }
    }
    web_urlSearchParams_constructor = {
      URLSearchParams: URLSearchParamsConstructor,
      getState: getInternalParamsState
    };
    return web_urlSearchParams_constructor;
  }
  var hasRequiredWeb_url_constructor;
  function requireWeb_url_constructor() {
    if (hasRequiredWeb_url_constructor) return web_url_constructor;
    hasRequiredWeb_url_constructor = 1;
    requireEs_string_iterator();
    var $ = require_export();
    var DESCRIPTORS = requireDescriptors();
    var USE_NATIVE_URL = requireUrlConstructorDetection();
    var globalThis = requireGlobalThis();
    var bind = requireFunctionBindContext();
    var uncurryThis = requireFunctionUncurryThis();
    var defineBuiltIn = requireDefineBuiltIn();
    var defineBuiltInAccessor = requireDefineBuiltInAccessor();
    var anInstance = requireAnInstance();
    var hasOwn = requireHasOwnProperty();
    var assign = requireObjectAssign();
    var arrayFrom = requireArrayFrom();
    var arraySlice = requireArraySlice();
    var codeAt = requireStringMultibyte().codeAt;
    var toASCII = requireStringPunycodeToAscii();
    var $toString = requireToString();
    var setToStringTag = requireSetToStringTag();
    var validateArgumentsLength = requireValidateArgumentsLength();
    var URLSearchParamsModule = requireWeb_urlSearchParams_constructor();
    var InternalStateModule = requireInternalState();
    var setInternalState = InternalStateModule.set;
    var getInternalURLState = InternalStateModule.getterFor('URL');
    var URLSearchParams = URLSearchParamsModule.URLSearchParams;
    var getInternalSearchParamsState = URLSearchParamsModule.getState;
    var NativeURL = globalThis.URL;
    var TypeError = globalThis.TypeError;
    var parseInt = globalThis.parseInt;
    var floor = Math.floor;
    var pow = Math.pow;
    var charAt = uncurryThis(''.charAt);
    var exec = uncurryThis(/./.exec);
    var join = uncurryThis([].join);
    var numberToString = uncurryThis(1.1.toString);
    var pop = uncurryThis([].pop);
    var push = uncurryThis([].push);
    var replace = uncurryThis(''.replace);
    var shift = uncurryThis([].shift);
    var split = uncurryThis(''.split);
    var stringSlice = uncurryThis(''.slice);
    var toLowerCase = uncurryThis(''.toLowerCase);
    var unshift = uncurryThis([].unshift);
    var INVALID_AUTHORITY = 'Invalid authority';
    var INVALID_SCHEME = 'Invalid scheme';
    var INVALID_HOST = 'Invalid host';
    var INVALID_PORT = 'Invalid port';
    var ALPHA = /[a-z]/i;
    var ALPHANUMERIC = /[\d+-.a-z]/i;
    var DIGIT = /\d/;
    var HEX_START = /^0x/i;
    var OCT = /^[0-7]+$/;
    var DEC = /^\d+$/;
    var HEX = /^[\da-f]+$/i;
    var FORBIDDEN_HOST_CODE_POINT = /[\0\t\n\r #%/:<>?@[\\\]^|]/;
    var FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\0\t\n\r #/:<>?@[\\\]^|]/;
    var LEADING_C0_CONTROL_OR_SPACE = /^[\u0000-\u0020]+/;
    var TRAILING_C0_CONTROL_OR_SPACE = /(^|[^\u0000-\u0020])[\u0000-\u0020]+$/;
    var TAB_AND_NEW_LINE = /[\t\n\r]/g;
    var EOF;
    var parseIPv4 = function parseIPv4(input) {
      var parts = split(input, '.');
      var partsLength, numbers, index, part, radix, number, ipv4;
      if (parts.length && parts[parts.length - 1] === '') {
        parts.length--;
      }
      partsLength = parts.length;
      if (partsLength > 4) return input;
      numbers = [];
      for (index = 0; index < partsLength; index++) {
        part = parts[index];
        if (part === '') return input;
        radix = 10;
        if (part.length > 1 && charAt(part, 0) === '0') {
          radix = exec(HEX_START, part) ? 16 : 8;
          part = stringSlice(part, radix === 8 ? 1 : 2);
        }
        if (part === '') {
          number = 0;
        } else {
          if (!exec(radix === 10 ? DEC : radix === 8 ? OCT : HEX, part)) return input;
          number = parseInt(part, radix);
        }
        push(numbers, number);
      }
      for (index = 0; index < partsLength; index++) {
        number = numbers[index];
        if (index === partsLength - 1) {
          if (number >= pow(256, 5 - partsLength)) return null;
        } else if (number > 255) return null;
      }
      ipv4 = pop(numbers);
      for (index = 0; index < numbers.length; index++) {
        ipv4 += numbers[index] * pow(256, 3 - index);
      }
      return ipv4;
    };
    var parseIPv6 = function parseIPv6(input) {
      var address = [0, 0, 0, 0, 0, 0, 0, 0];
      var pieceIndex = 0;
      var compress = null;
      var pointer = 0;
      var value, length, numbersSeen, ipv4Piece, number, swaps, swap;
      var chr = function chr() {
        return charAt(input, pointer);
      };
      if (chr() === ':') {
        if (charAt(input, 1) !== ':') return;
        pointer += 2;
        pieceIndex++;
        compress = pieceIndex;
      }
      while (chr()) {
        if (pieceIndex === 8) return;
        if (chr() === ':') {
          if (compress !== null) return;
          pointer++;
          pieceIndex++;
          compress = pieceIndex;
          continue;
        }
        value = length = 0;
        while (length < 4 && exec(HEX, chr())) {
          value = value * 16 + parseInt(chr(), 16);
          pointer++;
          length++;
        }
        if (chr() === '.') {
          if (length === 0) return;
          pointer -= length;
          if (pieceIndex > 6) return;
          numbersSeen = 0;
          while (chr()) {
            ipv4Piece = null;
            if (numbersSeen > 0) {
              if (chr() === '.' && numbersSeen < 4) pointer++;else return;
            }
            if (!exec(DIGIT, chr())) return;
            while (exec(DIGIT, chr())) {
              number = parseInt(chr(), 10);
              if (ipv4Piece === null) ipv4Piece = number;else if (ipv4Piece === 0) return;else ipv4Piece = ipv4Piece * 10 + number;
              if (ipv4Piece > 255) return;
              pointer++;
            }
            address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
            numbersSeen++;
            if (numbersSeen === 2 || numbersSeen === 4) pieceIndex++;
          }
          if (numbersSeen !== 4) return;
          break;
        } else if (chr() === ':') {
          pointer++;
          if (!chr()) return;
        } else if (chr()) return;
        address[pieceIndex++] = value;
      }
      if (compress !== null) {
        swaps = pieceIndex - compress;
        pieceIndex = 7;
        while (pieceIndex !== 0 && swaps > 0) {
          swap = address[pieceIndex];
          address[pieceIndex--] = address[compress + swaps - 1];
          address[compress + --swaps] = swap;
        }
      } else if (pieceIndex !== 8) return;
      return address;
    };
    var findLongestZeroSequence = function findLongestZeroSequence(ipv6) {
      var maxIndex = null;
      var maxLength = 1;
      var currStart = null;
      var currLength = 0;
      var index = 0;
      for (; index < 8; index++) {
        if (ipv6[index] !== 0) {
          if (currLength > maxLength) {
            maxIndex = currStart;
            maxLength = currLength;
          }
          currStart = null;
          currLength = 0;
        } else {
          if (currStart === null) currStart = index;
          ++currLength;
        }
      }
      return currLength > maxLength ? currStart : maxIndex;
    };
    var serializeHost = function serializeHost(host) {
      var result, index, compress, ignore0;
      if (typeof host == 'number') {
        result = [];
        for (index = 0; index < 4; index++) {
          unshift(result, host % 256);
          host = floor(host / 256);
        }
        return join(result, '.');
      }
      if (typeof host == 'object') {
        result = '';
        compress = findLongestZeroSequence(host);
        for (index = 0; index < 8; index++) {
          if (ignore0 && host[index] === 0) continue;
          if (ignore0) ignore0 = false;
          if (compress === index) {
            result += index ? ':' : '::';
            ignore0 = true;
          } else {
            result += numberToString(host[index], 16);
            if (index < 7) result += ':';
          }
        }
        return '[' + result + ']';
      }
      return host;
    };
    var C0ControlPercentEncodeSet = {};
    var fragmentPercentEncodeSet = assign({}, C0ControlPercentEncodeSet, {
      ' ': 1,
      '"': 1,
      '<': 1,
      '>': 1,
      '`': 1
    });
    var pathPercentEncodeSet = assign({}, fragmentPercentEncodeSet, {
      '#': 1,
      '?': 1,
      '{': 1,
      '}': 1
    });
    var userinfoPercentEncodeSet = assign({}, pathPercentEncodeSet, {
      '/': 1,
      ':': 1,
      ';': 1,
      '=': 1,
      '@': 1,
      '[': 1,
      '\\': 1,
      ']': 1,
      '^': 1,
      '|': 1
    });
    var percentEncode = function percentEncode(chr, set) {
      var code = codeAt(chr, 0);
      return code > 0x20 && code < 0x7F && !hasOwn(set, chr) ? chr : encodeURIComponent(chr);
    };
    var specialSchemes = {
      ftp: 21,
      file: null,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var isWindowsDriveLetter = function isWindowsDriveLetter(string, normalized) {
      var second;
      return string.length === 2 && exec(ALPHA, charAt(string, 0)) && ((second = charAt(string, 1)) === ':' || !normalized && second === '|');
    };
    var startsWithWindowsDriveLetter = function startsWithWindowsDriveLetter(string) {
      var third;
      return string.length > 1 && isWindowsDriveLetter(stringSlice(string, 0, 2)) && (string.length === 2 || (third = charAt(string, 2)) === '/' || third === '\\' || third === '?' || third === '#');
    };
    var isSingleDot = function isSingleDot(segment) {
      return segment === '.' || toLowerCase(segment) === '%2e';
    };
    var isDoubleDot = function isDoubleDot(segment) {
      segment = toLowerCase(segment);
      return segment === '..' || segment === '%2e.' || segment === '.%2e' || segment === '%2e%2e';
    };
    var SCHEME_START = {};
    var SCHEME = {};
    var NO_SCHEME = {};
    var SPECIAL_RELATIVE_OR_AUTHORITY = {};
    var PATH_OR_AUTHORITY = {};
    var RELATIVE = {};
    var RELATIVE_SLASH = {};
    var SPECIAL_AUTHORITY_SLASHES = {};
    var SPECIAL_AUTHORITY_IGNORE_SLASHES = {};
    var AUTHORITY = {};
    var HOST = {};
    var HOSTNAME = {};
    var PORT = {};
    var FILE = {};
    var FILE_SLASH = {};
    var FILE_HOST = {};
    var PATH_START = {};
    var PATH = {};
    var CANNOT_BE_A_BASE_URL_PATH = {};
    var QUERY = {};
    var FRAGMENT = {};
    var _URLState = function URLState(url, isBase, base) {
      var urlString = $toString(url);
      var baseState, failure, searchParams;
      if (isBase) {
        failure = this.parse(urlString);
        if (failure) throw new TypeError(failure);
        this.searchParams = null;
      } else {
        if (base !== undefined) baseState = new _URLState(base, true);
        failure = this.parse(urlString, null, baseState);
        if (failure) throw new TypeError(failure);
        searchParams = getInternalSearchParamsState(new URLSearchParams());
        searchParams.bindURL(this);
        this.searchParams = searchParams;
      }
    };
    _URLState.prototype = {
      type: 'URL',
      parse: function parse(input, stateOverride, base) {
        var url = this;
        var state = stateOverride || SCHEME_START;
        var pointer = 0;
        var buffer = '';
        var seenAt = false;
        var seenBracket = false;
        var seenPasswordToken = false;
        var codePoints, chr, bufferCodePoints, failure;
        input = $toString(input);
        if (!stateOverride) {
          url.scheme = '';
          url.username = '';
          url.password = '';
          url.host = null;
          url.port = null;
          url.path = [];
          url.query = null;
          url.fragment = null;
          url.cannotBeABaseURL = false;
          input = replace(input, LEADING_C0_CONTROL_OR_SPACE, '');
          input = replace(input, TRAILING_C0_CONTROL_OR_SPACE, '$1');
        }
        input = replace(input, TAB_AND_NEW_LINE, '');
        codePoints = arrayFrom(input);
        while (pointer <= codePoints.length) {
          chr = codePoints[pointer];
          switch (state) {
            case SCHEME_START:
              if (chr && exec(ALPHA, chr)) {
                buffer += toLowerCase(chr);
                state = SCHEME;
              } else if (!stateOverride) {
                state = NO_SCHEME;
                continue;
              } else return INVALID_SCHEME;
              break;
            case SCHEME:
              if (chr && (exec(ALPHANUMERIC, chr) || chr === '+' || chr === '-' || chr === '.')) {
                buffer += toLowerCase(chr);
              } else if (chr === ':') {
                if (stateOverride && (url.isSpecial() !== hasOwn(specialSchemes, buffer) || buffer === 'file' && (url.includesCredentials() || url.port !== null) || url.scheme === 'file' && !url.host)) return;
                url.scheme = buffer;
                if (stateOverride) {
                  if (url.isSpecial() && specialSchemes[url.scheme] === url.port) url.port = null;
                  return;
                }
                buffer = '';
                if (url.scheme === 'file') {
                  state = FILE;
                } else if (url.isSpecial() && base && base.scheme === url.scheme) {
                  state = SPECIAL_RELATIVE_OR_AUTHORITY;
                } else if (url.isSpecial()) {
                  state = SPECIAL_AUTHORITY_SLASHES;
                } else if (codePoints[pointer + 1] === '/') {
                  state = PATH_OR_AUTHORITY;
                  pointer++;
                } else {
                  url.cannotBeABaseURL = true;
                  push(url.path, '');
                  state = CANNOT_BE_A_BASE_URL_PATH;
                }
              } else if (!stateOverride) {
                buffer = '';
                state = NO_SCHEME;
                pointer = 0;
                continue;
              } else return INVALID_SCHEME;
              break;
            case NO_SCHEME:
              if (!base || base.cannotBeABaseURL && chr !== '#') return INVALID_SCHEME;
              if (base.cannotBeABaseURL && chr === '#') {
                url.scheme = base.scheme;
                url.path = arraySlice(base.path);
                url.query = base.query;
                url.fragment = '';
                url.cannotBeABaseURL = true;
                state = FRAGMENT;
                break;
              }
              state = base.scheme === 'file' ? FILE : RELATIVE;
              continue;
            case SPECIAL_RELATIVE_OR_AUTHORITY:
              if (chr === '/' && codePoints[pointer + 1] === '/') {
                state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
                pointer++;
              } else {
                state = RELATIVE;
                continue;
              }
              break;
            case PATH_OR_AUTHORITY:
              if (chr === '/') {
                state = AUTHORITY;
                break;
              } else {
                state = PATH;
                continue;
              }
            case RELATIVE:
              url.scheme = base.scheme;
              if (chr === EOF) {
                url.username = base.username;
                url.password = base.password;
                url.host = base.host;
                url.port = base.port;
                url.path = arraySlice(base.path);
                url.query = base.query;
              } else if (chr === '/' || chr === '\\' && url.isSpecial()) {
                state = RELATIVE_SLASH;
              } else if (chr === '?') {
                url.username = base.username;
                url.password = base.password;
                url.host = base.host;
                url.port = base.port;
                url.path = arraySlice(base.path);
                url.query = '';
                state = QUERY;
              } else if (chr === '#') {
                url.username = base.username;
                url.password = base.password;
                url.host = base.host;
                url.port = base.port;
                url.path = arraySlice(base.path);
                url.query = base.query;
                url.fragment = '';
                state = FRAGMENT;
              } else {
                url.username = base.username;
                url.password = base.password;
                url.host = base.host;
                url.port = base.port;
                url.path = arraySlice(base.path);
                url.path.length--;
                state = PATH;
                continue;
              }
              break;
            case RELATIVE_SLASH:
              if (url.isSpecial() && (chr === '/' || chr === '\\')) {
                state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
              } else if (chr === '/') {
                state = AUTHORITY;
              } else {
                url.username = base.username;
                url.password = base.password;
                url.host = base.host;
                url.port = base.port;
                state = PATH;
                continue;
              }
              break;
            case SPECIAL_AUTHORITY_SLASHES:
              state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
              if (chr !== '/' || charAt(buffer, pointer + 1) !== '/') continue;
              pointer++;
              break;
            case SPECIAL_AUTHORITY_IGNORE_SLASHES:
              if (chr !== '/' && chr !== '\\') {
                state = AUTHORITY;
                continue;
              }
              break;
            case AUTHORITY:
              if (chr === '@') {
                if (seenAt) buffer = '%40' + buffer;
                seenAt = true;
                bufferCodePoints = arrayFrom(buffer);
                for (var i = 0; i < bufferCodePoints.length; i++) {
                  var codePoint = bufferCodePoints[i];
                  if (codePoint === ':' && !seenPasswordToken) {
                    seenPasswordToken = true;
                    continue;
                  }
                  var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);
                  if (seenPasswordToken) url.password += encodedCodePoints;else url.username += encodedCodePoints;
                }
                buffer = '';
              } else if (chr === EOF || chr === '/' || chr === '?' || chr === '#' || chr === '\\' && url.isSpecial()) {
                if (seenAt && buffer === '') return INVALID_AUTHORITY;
                pointer -= arrayFrom(buffer).length + 1;
                buffer = '';
                state = HOST;
              } else buffer += chr;
              break;
            case HOST:
            case HOSTNAME:
              if (stateOverride && url.scheme === 'file') {
                state = FILE_HOST;
                continue;
              } else if (chr === ':' && !seenBracket) {
                if (buffer === '') return INVALID_HOST;
                failure = url.parseHost(buffer);
                if (failure) return failure;
                buffer = '';
                state = PORT;
                if (stateOverride === HOSTNAME) return;
              } else if (chr === EOF || chr === '/' || chr === '?' || chr === '#' || chr === '\\' && url.isSpecial()) {
                if (url.isSpecial() && buffer === '') return INVALID_HOST;
                if (stateOverride && buffer === '' && (url.includesCredentials() || url.port !== null)) return;
                failure = url.parseHost(buffer);
                if (failure) return failure;
                buffer = '';
                state = PATH_START;
                if (stateOverride) return;
                continue;
              } else {
                if (chr === '[') seenBracket = true;else if (chr === ']') seenBracket = false;
                buffer += chr;
              }
              break;
            case PORT:
              if (exec(DIGIT, chr)) {
                buffer += chr;
              } else if (chr === EOF || chr === '/' || chr === '?' || chr === '#' || chr === '\\' && url.isSpecial() || stateOverride) {
                if (buffer !== '') {
                  var port = parseInt(buffer, 10);
                  if (port > 0xFFFF) return INVALID_PORT;
                  url.port = url.isSpecial() && port === specialSchemes[url.scheme] ? null : port;
                  buffer = '';
                }
                if (stateOverride) return;
                state = PATH_START;
                continue;
              } else return INVALID_PORT;
              break;
            case FILE:
              url.scheme = 'file';
              if (chr === '/' || chr === '\\') state = FILE_SLASH;else if (base && base.scheme === 'file') {
                switch (chr) {
                  case EOF:
                    url.host = base.host;
                    url.path = arraySlice(base.path);
                    url.query = base.query;
                    break;
                  case '?':
                    url.host = base.host;
                    url.path = arraySlice(base.path);
                    url.query = '';
                    state = QUERY;
                    break;
                  case '#':
                    url.host = base.host;
                    url.path = arraySlice(base.path);
                    url.query = base.query;
                    url.fragment = '';
                    state = FRAGMENT;
                    break;
                  default:
                    if (!startsWithWindowsDriveLetter(join(arraySlice(codePoints, pointer), ''))) {
                      url.host = base.host;
                      url.path = arraySlice(base.path);
                      url.shortenPath();
                    }
                    state = PATH;
                    continue;
                }
              } else {
                state = PATH;
                continue;
              }
              break;
            case FILE_SLASH:
              if (chr === '/' || chr === '\\') {
                state = FILE_HOST;
                break;
              }
              if (base && base.scheme === 'file' && !startsWithWindowsDriveLetter(join(arraySlice(codePoints, pointer), ''))) {
                if (isWindowsDriveLetter(base.path[0], true)) push(url.path, base.path[0]);else url.host = base.host;
              }
              state = PATH;
              continue;
            case FILE_HOST:
              if (chr === EOF || chr === '/' || chr === '\\' || chr === '?' || chr === '#') {
                if (!stateOverride && isWindowsDriveLetter(buffer)) {
                  state = PATH;
                } else if (buffer === '') {
                  url.host = '';
                  if (stateOverride) return;
                  state = PATH_START;
                } else {
                  failure = url.parseHost(buffer);
                  if (failure) return failure;
                  if (url.host === 'localhost') url.host = '';
                  if (stateOverride) return;
                  buffer = '';
                  state = PATH_START;
                }
                continue;
              } else buffer += chr;
              break;
            case PATH_START:
              if (url.isSpecial()) {
                state = PATH;
                if (chr !== '/' && chr !== '\\') continue;
              } else if (!stateOverride && chr === '?') {
                url.query = '';
                state = QUERY;
              } else if (!stateOverride && chr === '#') {
                url.fragment = '';
                state = FRAGMENT;
              } else if (chr !== EOF) {
                state = PATH;
                if (chr !== '/') continue;
              }
              break;
            case PATH:
              if (chr === EOF || chr === '/' || chr === '\\' && url.isSpecial() || !stateOverride && (chr === '?' || chr === '#')) {
                if (isDoubleDot(buffer)) {
                  url.shortenPath();
                  if (chr !== '/' && !(chr === '\\' && url.isSpecial())) {
                    push(url.path, '');
                  }
                } else if (isSingleDot(buffer)) {
                  if (chr !== '/' && !(chr === '\\' && url.isSpecial())) {
                    push(url.path, '');
                  }
                } else {
                  if (url.scheme === 'file' && !url.path.length && isWindowsDriveLetter(buffer)) {
                    if (url.host) url.host = '';
                    buffer = charAt(buffer, 0) + ':';
                  }
                  push(url.path, buffer);
                }
                buffer = '';
                if (url.scheme === 'file' && (chr === EOF || chr === '?' || chr === '#')) {
                  while (url.path.length > 1 && url.path[0] === '') {
                    shift(url.path);
                  }
                }
                if (chr === '?') {
                  url.query = '';
                  state = QUERY;
                } else if (chr === '#') {
                  url.fragment = '';
                  state = FRAGMENT;
                }
              } else {
                buffer += percentEncode(chr, pathPercentEncodeSet);
              }
              break;
            case CANNOT_BE_A_BASE_URL_PATH:
              if (chr === '?') {
                url.query = '';
                state = QUERY;
              } else if (chr === '#') {
                url.fragment = '';
                state = FRAGMENT;
              } else if (chr !== EOF) {
                url.path[0] += percentEncode(chr, C0ControlPercentEncodeSet);
              }
              break;
            case QUERY:
              if (!stateOverride && chr === '#') {
                url.fragment = '';
                state = FRAGMENT;
              } else if (chr !== EOF) {
                if (chr === "'" && url.isSpecial()) url.query += '%27';else if (chr === '#') url.query += '%23';else url.query += percentEncode(chr, C0ControlPercentEncodeSet);
              }
              break;
            case FRAGMENT:
              if (chr !== EOF) url.fragment += percentEncode(chr, fragmentPercentEncodeSet);
              break;
          }
          pointer++;
        }
      },
      parseHost: function parseHost(input) {
        var result, codePoints, index;
        if (charAt(input, 0) === '[') {
          if (charAt(input, input.length - 1) !== ']') return INVALID_HOST;
          result = parseIPv6(stringSlice(input, 1, -1));
          if (!result) return INVALID_HOST;
          this.host = result;
        } else if (!this.isSpecial()) {
          if (exec(FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT, input)) return INVALID_HOST;
          result = '';
          codePoints = arrayFrom(input);
          for (index = 0; index < codePoints.length; index++) {
            result += percentEncode(codePoints[index], C0ControlPercentEncodeSet);
          }
          this.host = result;
        } else {
          input = toASCII(input);
          if (exec(FORBIDDEN_HOST_CODE_POINT, input)) return INVALID_HOST;
          result = parseIPv4(input);
          if (result === null) return INVALID_HOST;
          this.host = result;
        }
      },
      cannotHaveUsernamePasswordPort: function cannotHaveUsernamePasswordPort() {
        return !this.host || this.cannotBeABaseURL || this.scheme === 'file';
      },
      includesCredentials: function includesCredentials() {
        return this.username !== '' || this.password !== '';
      },
      isSpecial: function isSpecial() {
        return hasOwn(specialSchemes, this.scheme);
      },
      shortenPath: function shortenPath() {
        var path = this.path;
        var pathSize = path.length;
        if (pathSize && (this.scheme !== 'file' || pathSize !== 1 || !isWindowsDriveLetter(path[0], true))) {
          path.length--;
        }
      },
      serialize: function serialize() {
        var url = this;
        var scheme = url.scheme;
        var username = url.username;
        var password = url.password;
        var host = url.host;
        var port = url.port;
        var path = url.path;
        var query = url.query;
        var fragment = url.fragment;
        var output = scheme + ':';
        if (host !== null) {
          output += '//';
          if (url.includesCredentials()) {
            output += username + (password ? ':' + password : '') + '@';
          }
          output += serializeHost(host);
          if (port !== null) output += ':' + port;
        } else if (scheme === 'file') output += '//';
        output += url.cannotBeABaseURL ? path[0] : path.length ? '/' + join(path, '/') : '';
        if (query !== null) output += '?' + query;
        if (fragment !== null) output += '#' + fragment;
        return output;
      },
      setHref: function setHref(href) {
        var failure = this.parse(href);
        if (failure) throw new TypeError(failure);
        this.searchParams.update();
      },
      getOrigin: function getOrigin() {
        var scheme = this.scheme;
        var port = this.port;
        if (scheme === 'blob') try {
          return new URLConstructor(scheme.path[0]).origin;
        } catch (error) {
          return 'null';
        }
        if (scheme === 'file' || !this.isSpecial()) return 'null';
        return scheme + '://' + serializeHost(this.host) + (port !== null ? ':' + port : '');
      },
      getProtocol: function getProtocol() {
        return this.scheme + ':';
      },
      setProtocol: function setProtocol(protocol) {
        this.parse($toString(protocol) + ':', SCHEME_START);
      },
      getUsername: function getUsername() {
        return this.username;
      },
      setUsername: function setUsername(username) {
        var codePoints = arrayFrom($toString(username));
        if (this.cannotHaveUsernamePasswordPort()) return;
        this.username = '';
        for (var i = 0; i < codePoints.length; i++) {
          this.username += percentEncode(codePoints[i], userinfoPercentEncodeSet);
        }
      },
      getPassword: function getPassword() {
        return this.password;
      },
      setPassword: function setPassword(password) {
        var codePoints = arrayFrom($toString(password));
        if (this.cannotHaveUsernamePasswordPort()) return;
        this.password = '';
        for (var i = 0; i < codePoints.length; i++) {
          this.password += percentEncode(codePoints[i], userinfoPercentEncodeSet);
        }
      },
      getHost: function getHost() {
        var host = this.host;
        var port = this.port;
        return host === null ? '' : port === null ? serializeHost(host) : serializeHost(host) + ':' + port;
      },
      setHost: function setHost(host) {
        if (this.cannotBeABaseURL) return;
        this.parse(host, HOST);
      },
      getHostname: function getHostname() {
        var host = this.host;
        return host === null ? '' : serializeHost(host);
      },
      setHostname: function setHostname(hostname) {
        if (this.cannotBeABaseURL) return;
        this.parse(hostname, HOSTNAME);
      },
      getPort: function getPort() {
        var port = this.port;
        return port === null ? '' : $toString(port);
      },
      setPort: function setPort(port) {
        if (this.cannotHaveUsernamePasswordPort()) return;
        port = $toString(port);
        if (port === '') this.port = null;else this.parse(port, PORT);
      },
      getPathname: function getPathname() {
        var path = this.path;
        return this.cannotBeABaseURL ? path[0] : path.length ? '/' + join(path, '/') : '';
      },
      setPathname: function setPathname(pathname) {
        if (this.cannotBeABaseURL) return;
        this.path = [];
        this.parse(pathname, PATH_START);
      },
      getSearch: function getSearch() {
        var query = this.query;
        return query ? '?' + query : '';
      },
      setSearch: function setSearch(search) {
        search = $toString(search);
        if (search === '') {
          this.query = null;
        } else {
          if (charAt(search, 0) === '?') search = stringSlice(search, 1);
          this.query = '';
          this.parse(search, QUERY);
        }
        this.searchParams.update();
      },
      getSearchParams: function getSearchParams() {
        return this.searchParams.facade;
      },
      getHash: function getHash() {
        var fragment = this.fragment;
        return fragment ? '#' + fragment : '';
      },
      setHash: function setHash(hash) {
        hash = $toString(hash);
        if (hash === '') {
          this.fragment = null;
          return;
        }
        if (charAt(hash, 0) === '#') hash = stringSlice(hash, 1);
        this.fragment = '';
        this.parse(hash, FRAGMENT);
      },
      update: function update() {
        this.query = this.searchParams.serialize() || null;
      }
    };
    var URLConstructor = function URL(url) {
      var that = anInstance(this, URLPrototype);
      var base = validateArgumentsLength(arguments.length, 1) > 1 ? arguments[1] : undefined;
      var state = setInternalState(that, new _URLState(url, false, base));
      if (!DESCRIPTORS) {
        that.href = state.serialize();
        that.origin = state.getOrigin();
        that.protocol = state.getProtocol();
        that.username = state.getUsername();
        that.password = state.getPassword();
        that.host = state.getHost();
        that.hostname = state.getHostname();
        that.port = state.getPort();
        that.pathname = state.getPathname();
        that.search = state.getSearch();
        that.searchParams = state.getSearchParams();
        that.hash = state.getHash();
      }
    };
    var URLPrototype = URLConstructor.prototype;
    var accessorDescriptor = function accessorDescriptor(getter, setter) {
      return {
        get: function get() {
          return getInternalURLState(this)[getter]();
        },
        set: setter && function (value) {
          return getInternalURLState(this)[setter](value);
        },
        configurable: true,
        enumerable: true
      };
    };
    if (DESCRIPTORS) {
      defineBuiltInAccessor(URLPrototype, 'href', accessorDescriptor('serialize', 'setHref'));
      defineBuiltInAccessor(URLPrototype, 'origin', accessorDescriptor('getOrigin'));
      defineBuiltInAccessor(URLPrototype, 'protocol', accessorDescriptor('getProtocol', 'setProtocol'));
      defineBuiltInAccessor(URLPrototype, 'username', accessorDescriptor('getUsername', 'setUsername'));
      defineBuiltInAccessor(URLPrototype, 'password', accessorDescriptor('getPassword', 'setPassword'));
      defineBuiltInAccessor(URLPrototype, 'host', accessorDescriptor('getHost', 'setHost'));
      defineBuiltInAccessor(URLPrototype, 'hostname', accessorDescriptor('getHostname', 'setHostname'));
      defineBuiltInAccessor(URLPrototype, 'port', accessorDescriptor('getPort', 'setPort'));
      defineBuiltInAccessor(URLPrototype, 'pathname', accessorDescriptor('getPathname', 'setPathname'));
      defineBuiltInAccessor(URLPrototype, 'search', accessorDescriptor('getSearch', 'setSearch'));
      defineBuiltInAccessor(URLPrototype, 'searchParams', accessorDescriptor('getSearchParams'));
      defineBuiltInAccessor(URLPrototype, 'hash', accessorDescriptor('getHash', 'setHash'));
    }
    defineBuiltIn(URLPrototype, 'toJSON', function toJSON() {
      return getInternalURLState(this).serialize();
    }, {
      enumerable: true
    });
    defineBuiltIn(URLPrototype, 'toString', function toString() {
      return getInternalURLState(this).serialize();
    }, {
      enumerable: true
    });
    if (NativeURL) {
      var nativeCreateObjectURL = NativeURL.createObjectURL;
      var nativeRevokeObjectURL = NativeURL.revokeObjectURL;
      if (nativeCreateObjectURL) defineBuiltIn(URLConstructor, 'createObjectURL', bind(nativeCreateObjectURL, NativeURL));
      if (nativeRevokeObjectURL) defineBuiltIn(URLConstructor, 'revokeObjectURL', bind(nativeRevokeObjectURL, NativeURL));
    }
    setToStringTag(URLConstructor, 'URL');
    $({
      global: true,
      constructor: true,
      forced: !USE_NATIVE_URL,
      sham: !DESCRIPTORS
    }, {
      URL: URLConstructor
    });
    return web_url_constructor;
  }
  var hasRequiredWeb_url;
  function requireWeb_url() {
    if (hasRequiredWeb_url) return web_url;
    hasRequiredWeb_url = 1;
    requireWeb_url_constructor();
    return web_url;
  }
  var web_url_canParse = {};
  var hasRequiredWeb_url_canParse;
  function requireWeb_url_canParse() {
    if (hasRequiredWeb_url_canParse) return web_url_canParse;
    hasRequiredWeb_url_canParse = 1;
    var $ = require_export();
    var getBuiltIn = requireGetBuiltIn();
    var fails = requireFails();
    var validateArgumentsLength = requireValidateArgumentsLength();
    var toString = requireToString();
    var USE_NATIVE_URL = requireUrlConstructorDetection();
    var URL = getBuiltIn('URL');
    var THROWS_WITHOUT_ARGUMENTS = USE_NATIVE_URL && fails(function () {
      URL.canParse();
    });
    var WRONG_ARITY = fails(function () {
      return URL.canParse.length !== 1;
    });
    $({
      target: 'URL',
      stat: true,
      forced: !THROWS_WITHOUT_ARGUMENTS || WRONG_ARITY
    }, {
      canParse: function canParse(url) {
        var length = validateArgumentsLength(arguments.length, 1);
        var urlString = toString(url);
        var base = length < 2 || arguments[1] === undefined ? undefined : toString(arguments[1]);
        try {
          return !!new URL(urlString, base);
        } catch (error) {
          return false;
        }
      }
    });
    return web_url_canParse;
  }
  var web_url_parse = {};
  var hasRequiredWeb_url_parse;
  function requireWeb_url_parse() {
    if (hasRequiredWeb_url_parse) return web_url_parse;
    hasRequiredWeb_url_parse = 1;
    var $ = require_export();
    var getBuiltIn = requireGetBuiltIn();
    var validateArgumentsLength = requireValidateArgumentsLength();
    var toString = requireToString();
    var USE_NATIVE_URL = requireUrlConstructorDetection();
    var URL = getBuiltIn('URL');
    $({
      target: 'URL',
      stat: true,
      forced: !USE_NATIVE_URL
    }, {
      parse: function parse(url) {
        var length = validateArgumentsLength(arguments.length, 1);
        var urlString = toString(url);
        var base = length < 2 || arguments[1] === undefined ? undefined : toString(arguments[1]);
        try {
          return new URL(urlString, base);
        } catch (error) {
          return null;
        }
      }
    });
    return web_url_parse;
  }
  var web_url_toJson = {};
  var hasRequiredWeb_url_toJson;
  function requireWeb_url_toJson() {
    if (hasRequiredWeb_url_toJson) return web_url_toJson;
    hasRequiredWeb_url_toJson = 1;
    var $ = require_export();
    var call = requireFunctionCall();
    $({
      target: 'URL',
      proto: true,
      enumerable: true
    }, {
      toJSON: function toJSON() {
        return call(URL.prototype.toString, this);
      }
    });
    return web_url_toJson;
  }
  var web_urlSearchParams = {};
  var hasRequiredWeb_urlSearchParams;
  function requireWeb_urlSearchParams() {
    if (hasRequiredWeb_urlSearchParams) return web_urlSearchParams;
    hasRequiredWeb_urlSearchParams = 1;
    requireWeb_urlSearchParams_constructor();
    return web_urlSearchParams;
  }
  var web_urlSearchParams_delete = {};
  var hasRequiredWeb_urlSearchParams_delete;
  function requireWeb_urlSearchParams_delete() {
    if (hasRequiredWeb_urlSearchParams_delete) return web_urlSearchParams_delete;
    hasRequiredWeb_urlSearchParams_delete = 1;
    var defineBuiltIn = requireDefineBuiltIn();
    var uncurryThis = requireFunctionUncurryThis();
    var toString = requireToString();
    var validateArgumentsLength = requireValidateArgumentsLength();
    var $URLSearchParams = URLSearchParams;
    var URLSearchParamsPrototype = $URLSearchParams.prototype;
    var append = uncurryThis(URLSearchParamsPrototype.append);
    var $delete = uncurryThis(URLSearchParamsPrototype['delete']);
    var forEach = uncurryThis(URLSearchParamsPrototype.forEach);
    var push = uncurryThis([].push);
    var params = new $URLSearchParams('a=1&a=2&b=3');
    params['delete']('a', 1);
    params['delete']('b', undefined);
    if (params + '' !== 'a=2') {
      defineBuiltIn(URLSearchParamsPrototype, 'delete', function (name) {
        var length = arguments.length;
        var $value = length < 2 ? undefined : arguments[1];
        if (length && $value === undefined) return $delete(this, name);
        var entries = [];
        forEach(this, function (v, k) {
          push(entries, {
            key: k,
            value: v
          });
        });
        validateArgumentsLength(length, 1);
        var key = toString(name);
        var value = toString($value);
        var index = 0;
        var dindex = 0;
        var found = false;
        var entriesLength = entries.length;
        var entry;
        while (index < entriesLength) {
          entry = entries[index++];
          if (found || entry.key === key) {
            found = true;
            $delete(this, entry.key);
          } else dindex++;
        }
        while (dindex < entriesLength) {
          entry = entries[dindex++];
          if (!(entry.key === key && entry.value === value)) append(this, entry.key, entry.value);
        }
      }, {
        enumerable: true,
        unsafe: true
      });
    }
    return web_urlSearchParams_delete;
  }
  var web_urlSearchParams_has = {};
  var hasRequiredWeb_urlSearchParams_has;
  function requireWeb_urlSearchParams_has() {
    if (hasRequiredWeb_urlSearchParams_has) return web_urlSearchParams_has;
    hasRequiredWeb_urlSearchParams_has = 1;
    var defineBuiltIn = requireDefineBuiltIn();
    var uncurryThis = requireFunctionUncurryThis();
    var toString = requireToString();
    var validateArgumentsLength = requireValidateArgumentsLength();
    var $URLSearchParams = URLSearchParams;
    var URLSearchParamsPrototype = $URLSearchParams.prototype;
    var getAll = uncurryThis(URLSearchParamsPrototype.getAll);
    var $has = uncurryThis(URLSearchParamsPrototype.has);
    var params = new $URLSearchParams('a=1');
    if (params.has('a', 2) || !params.has('a', undefined)) {
      defineBuiltIn(URLSearchParamsPrototype, 'has', function has(name) {
        var length = arguments.length;
        var $value = length < 2 ? undefined : arguments[1];
        if (length && $value === undefined) return $has(this, name);
        var values = getAll(this, name);
        validateArgumentsLength(length, 1);
        var value = toString($value);
        var index = 0;
        while (index < values.length) {
          if (values[index++] === value) return true;
        }
        return false;
      }, {
        enumerable: true,
        unsafe: true
      });
    }
    return web_urlSearchParams_has;
  }
  var web_urlSearchParams_size = {};
  var hasRequiredWeb_urlSearchParams_size;
  function requireWeb_urlSearchParams_size() {
    if (hasRequiredWeb_urlSearchParams_size) return web_urlSearchParams_size;
    hasRequiredWeb_urlSearchParams_size = 1;
    var DESCRIPTORS = requireDescriptors();
    var uncurryThis = requireFunctionUncurryThis();
    var defineBuiltInAccessor = requireDefineBuiltInAccessor();
    var URLSearchParamsPrototype = URLSearchParams.prototype;
    var forEach = uncurryThis(URLSearchParamsPrototype.forEach);
    if (DESCRIPTORS && !('size' in URLSearchParamsPrototype)) {
      defineBuiltInAccessor(URLSearchParamsPrototype, 'size', {
        get: function size() {
          var count = 0;
          forEach(this, function () {
            count++;
          });
          return count;
        },
        configurable: true,
        enumerable: true
      });
    }
    return web_urlSearchParams_size;
  }
  var stable;
  var hasRequiredStable;
  function requireStable() {
    if (hasRequiredStable) return stable;
    hasRequiredStable = 1;
    requireEs_symbol();
    requireEs_symbol_description();
    requireEs_symbol_asyncDispose();
    requireEs_symbol_asyncIterator();
    requireEs_symbol_dispose();
    requireEs_symbol_hasInstance();
    requireEs_symbol_isConcatSpreadable();
    requireEs_symbol_iterator();
    requireEs_symbol_match();
    requireEs_symbol_matchAll();
    requireEs_symbol_replace();
    requireEs_symbol_search();
    requireEs_symbol_species();
    requireEs_symbol_split();
    requireEs_symbol_toPrimitive();
    requireEs_symbol_toStringTag();
    requireEs_symbol_unscopables();
    requireEs_error_cause();
    requireEs_error_isError();
    requireEs_error_toString();
    requireEs_aggregateError();
    requireEs_aggregateError_cause();
    requireEs_suppressedError_constructor();
    requireEs_array_at();
    requireEs_array_concat();
    requireEs_array_copyWithin();
    requireEs_array_every();
    requireEs_array_fill();
    requireEs_array_filter();
    requireEs_array_find();
    requireEs_array_findIndex();
    requireEs_array_findLast();
    requireEs_array_findLastIndex();
    requireEs_array_flat();
    requireEs_array_flatMap();
    requireEs_array_forEach();
    requireEs_array_from();
    requireEs_array_includes();
    requireEs_array_indexOf();
    requireEs_array_isArray();
    requireEs_array_iterator();
    requireEs_array_join();
    requireEs_array_lastIndexOf();
    requireEs_array_map();
    requireEs_array_of();
    requireEs_array_push();
    requireEs_array_reduce();
    requireEs_array_reduceRight();
    requireEs_array_reverse();
    requireEs_array_slice();
    requireEs_array_some();
    requireEs_array_sort();
    requireEs_array_species();
    requireEs_array_splice();
    requireEs_array_toReversed();
    requireEs_array_toSorted();
    requireEs_array_toSpliced();
    requireEs_array_unscopables_flat();
    requireEs_array_unscopables_flatMap();
    requireEs_array_unshift();
    requireEs_array_with();
    requireEs_arrayBuffer_constructor();
    requireEs_arrayBuffer_isView();
    requireEs_arrayBuffer_slice();
    requireEs_dataView();
    requireEs_dataView_getFloat16();
    requireEs_dataView_setFloat16();
    requireEs_arrayBuffer_detached();
    requireEs_arrayBuffer_transfer();
    requireEs_arrayBuffer_transferToFixedLength();
    requireEs_date_getYear();
    requireEs_date_now();
    requireEs_date_setYear();
    requireEs_date_toGmtString();
    requireEs_date_toIsoString();
    requireEs_date_toJson();
    requireEs_date_toPrimitive();
    requireEs_date_toString();
    requireEs_disposableStack_constructor();
    requireEs_escape();
    requireEs_function_bind();
    requireEs_function_hasInstance();
    requireEs_function_name();
    requireEs_globalThis();
    requireEs_iterator_constructor();
    requireEs_iterator_dispose();
    requireEs_iterator_drop();
    requireEs_iterator_every();
    requireEs_iterator_filter();
    requireEs_iterator_find();
    requireEs_iterator_flatMap();
    requireEs_iterator_forEach();
    requireEs_iterator_from();
    requireEs_iterator_map();
    requireEs_iterator_reduce();
    requireEs_iterator_some();
    requireEs_iterator_take();
    requireEs_iterator_toArray();
    requireEs_json_stringify();
    requireEs_json_toStringTag();
    requireEs_map();
    requireEs_map_groupBy();
    requireEs_math_acosh();
    requireEs_math_asinh();
    requireEs_math_atanh();
    requireEs_math_cbrt();
    requireEs_math_clz32();
    requireEs_math_cosh();
    requireEs_math_expm1();
    requireEs_math_fround();
    requireEs_math_f16round();
    requireEs_math_hypot();
    requireEs_math_imul();
    requireEs_math_log10();
    requireEs_math_log1p();
    requireEs_math_log2();
    requireEs_math_sign();
    requireEs_math_sinh();
    requireEs_math_sumPrecise();
    requireEs_math_tanh();
    requireEs_math_toStringTag();
    requireEs_math_trunc();
    requireEs_number_constructor();
    requireEs_number_epsilon();
    requireEs_number_isFinite();
    requireEs_number_isInteger();
    requireEs_number_isNan();
    requireEs_number_isSafeInteger();
    requireEs_number_maxSafeInteger();
    requireEs_number_minSafeInteger();
    requireEs_number_parseFloat();
    requireEs_number_parseInt();
    requireEs_number_toExponential();
    requireEs_number_toFixed();
    requireEs_number_toPrecision();
    requireEs_object_assign();
    requireEs_object_create();
    requireEs_object_defineGetter();
    requireEs_object_defineProperties();
    requireEs_object_defineProperty();
    requireEs_object_defineSetter();
    requireEs_object_entries();
    requireEs_object_freeze();
    requireEs_object_fromEntries();
    requireEs_object_getOwnPropertyDescriptor();
    requireEs_object_getOwnPropertyDescriptors();
    requireEs_object_getOwnPropertyNames();
    requireEs_object_getPrototypeOf();
    requireEs_object_groupBy();
    requireEs_object_hasOwn();
    requireEs_object_is();
    requireEs_object_isExtensible();
    requireEs_object_isFrozen();
    requireEs_object_isSealed();
    requireEs_object_keys();
    requireEs_object_lookupGetter();
    requireEs_object_lookupSetter();
    requireEs_object_preventExtensions();
    requireEs_object_proto();
    requireEs_object_seal();
    requireEs_object_setPrototypeOf();
    requireEs_object_toString();
    requireEs_object_values();
    requireEs_parseFloat();
    requireEs_parseInt();
    requireEs_promise();
    requireEs_promise_allSettled();
    requireEs_promise_any();
    requireEs_promise_finally();
    requireEs_promise_try();
    requireEs_promise_withResolvers();
    requireEs_array_fromAsync();
    requireEs_asyncDisposableStack_constructor();
    requireEs_asyncIterator_asyncDispose();
    requireEs_reflect_apply();
    requireEs_reflect_construct();
    requireEs_reflect_defineProperty();
    requireEs_reflect_deleteProperty();
    requireEs_reflect_get();
    requireEs_reflect_getOwnPropertyDescriptor();
    requireEs_reflect_getPrototypeOf();
    requireEs_reflect_has();
    requireEs_reflect_isExtensible();
    requireEs_reflect_ownKeys();
    requireEs_reflect_preventExtensions();
    requireEs_reflect_set();
    requireEs_reflect_setPrototypeOf();
    requireEs_reflect_toStringTag();
    requireEs_regexp_constructor();
    requireEs_regexp_escape();
    requireEs_regexp_dotAll();
    requireEs_regexp_exec();
    requireEs_regexp_flags();
    requireEs_regexp_sticky();
    requireEs_regexp_test();
    requireEs_regexp_toString();
    requireEs_set();
    requireEs_set_difference_v2();
    requireEs_set_intersection_v2();
    requireEs_set_isDisjointFrom_v2();
    requireEs_set_isSubsetOf_v2();
    requireEs_set_isSupersetOf_v2();
    requireEs_set_symmetricDifference_v2();
    requireEs_set_union_v2();
    requireEs_string_atAlternative();
    requireEs_string_codePointAt();
    requireEs_string_endsWith();
    requireEs_string_fromCodePoint();
    requireEs_string_includes();
    requireEs_string_isWellFormed();
    requireEs_string_iterator();
    requireEs_string_match();
    requireEs_string_matchAll();
    requireEs_string_padEnd();
    requireEs_string_padStart();
    requireEs_string_raw();
    requireEs_string_repeat();
    requireEs_string_replace();
    requireEs_string_replaceAll();
    requireEs_string_search();
    requireEs_string_split();
    requireEs_string_startsWith();
    requireEs_string_substr();
    requireEs_string_toWellFormed();
    requireEs_string_trim();
    requireEs_string_trimEnd();
    requireEs_string_trimStart();
    requireEs_string_anchor();
    requireEs_string_big();
    requireEs_string_blink();
    requireEs_string_bold();
    requireEs_string_fixed();
    requireEs_string_fontcolor();
    requireEs_string_fontsize();
    requireEs_string_italics();
    requireEs_string_link();
    requireEs_string_small();
    requireEs_string_strike();
    requireEs_string_sub();
    requireEs_string_sup();
    requireEs_typedArray_float32Array();
    requireEs_typedArray_float64Array();
    requireEs_typedArray_int8Array();
    requireEs_typedArray_int16Array();
    requireEs_typedArray_int32Array();
    requireEs_typedArray_uint8Array();
    requireEs_typedArray_uint8ClampedArray();
    requireEs_typedArray_uint16Array();
    requireEs_typedArray_uint32Array();
    requireEs_typedArray_at();
    requireEs_typedArray_copyWithin();
    requireEs_typedArray_every();
    requireEs_typedArray_fill();
    requireEs_typedArray_filter();
    requireEs_typedArray_find();
    requireEs_typedArray_findIndex();
    requireEs_typedArray_findLast();
    requireEs_typedArray_findLastIndex();
    requireEs_typedArray_forEach();
    requireEs_typedArray_from();
    requireEs_typedArray_includes();
    requireEs_typedArray_indexOf();
    requireEs_typedArray_iterator();
    requireEs_typedArray_join();
    requireEs_typedArray_lastIndexOf();
    requireEs_typedArray_map();
    requireEs_typedArray_of();
    requireEs_typedArray_reduce();
    requireEs_typedArray_reduceRight();
    requireEs_typedArray_reverse();
    requireEs_typedArray_set();
    requireEs_typedArray_slice();
    requireEs_typedArray_some();
    requireEs_typedArray_sort();
    requireEs_typedArray_subarray();
    requireEs_typedArray_toLocaleString();
    requireEs_typedArray_toReversed();
    requireEs_typedArray_toSorted();
    requireEs_typedArray_toString();
    requireEs_typedArray_with();
    requireEs_uint8Array_fromBase64();
    requireEs_uint8Array_fromHex();
    requireEs_uint8Array_setFromBase64();
    requireEs_uint8Array_setFromHex();
    requireEs_uint8Array_toBase64();
    requireEs_uint8Array_toHex();
    requireEs_unescape();
    requireEs_weakMap();
    requireEs_weakSet();
    requireWeb_atob();
    requireWeb_btoa();
    requireWeb_domCollections_forEach();
    requireWeb_domCollections_iterator();
    requireWeb_domException_constructor();
    requireWeb_domException_stack();
    requireWeb_domException_toStringTag();
    requireWeb_immediate();
    requireWeb_queueMicrotask();
    requireWeb_self();
    requireWeb_structuredClone();
    requireWeb_timers();
    requireWeb_url();
    requireWeb_url_canParse();
    requireWeb_url_parse();
    requireWeb_url_toJson();
    requireWeb_urlSearchParams();
    requireWeb_urlSearchParams_delete();
    requireWeb_urlSearchParams_has();
    requireWeb_urlSearchParams_size();
    stable = requirePath();
    return stable;
  }
  requireStable();
  var runtime = {
    exports: {}
  };
  var hasRequiredRuntime;
  function requireRuntime() {
    if (hasRequiredRuntime) return runtime.exports;
    hasRequiredRuntime = 1;
    (function (module) {
      var runtime = function (exports) {
        var Op = Object.prototype;
        var hasOwn = Op.hasOwnProperty;
        var defineProperty = Object.defineProperty || function (obj, key, desc) {
          obj[key] = desc.value;
        };
        var undefined$1;
        var $Symbol = typeof Symbol === "function" ? Symbol : {};
        var iteratorSymbol = $Symbol.iterator || "@@iterator";
        var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
        var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
        function define(obj, key, value) {
          Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
          });
          return obj[key];
        }
        try {
          define({}, "");
        } catch (err) {
          define = function define(obj, key, value) {
            return obj[key] = value;
          };
        }
        function wrap(innerFn, outerFn, self, tryLocsList) {
          var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
          var generator = Object.create(protoGenerator.prototype);
          var context = new Context(tryLocsList || []);
          defineProperty(generator, "_invoke", {
            value: makeInvokeMethod(innerFn, self, context)
          });
          return generator;
        }
        exports.wrap = wrap;
        function tryCatch(fn, obj, arg) {
          try {
            return {
              type: "normal",
              arg: fn.call(obj, arg)
            };
          } catch (err) {
            return {
              type: "throw",
              arg: err
            };
          }
        }
        var GenStateSuspendedStart = "suspendedStart";
        var GenStateSuspendedYield = "suspendedYield";
        var GenStateExecuting = "executing";
        var GenStateCompleted = "completed";
        var ContinueSentinel = {};
        function Generator() {}
        function GeneratorFunction() {}
        function GeneratorFunctionPrototype() {}
        var IteratorPrototype = {};
        define(IteratorPrototype, iteratorSymbol, function () {
          return this;
        });
        var getProto = Object.getPrototypeOf;
        var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
        if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
          IteratorPrototype = NativeIteratorPrototype;
        }
        var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
        GeneratorFunction.prototype = GeneratorFunctionPrototype;
        defineProperty(Gp, "constructor", {
          value: GeneratorFunctionPrototype,
          configurable: true
        });
        defineProperty(GeneratorFunctionPrototype, "constructor", {
          value: GeneratorFunction,
          configurable: true
        });
        GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction");
        function defineIteratorMethods(prototype) {
          ["next", "throw", "return"].forEach(function (method) {
            define(prototype, method, function (arg) {
              return this._invoke(method, arg);
            });
          });
        }
        exports.isGeneratorFunction = function (genFun) {
          var ctor = typeof genFun === "function" && genFun.constructor;
          return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
        };
        exports.mark = function (genFun) {
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
          } else {
            genFun.__proto__ = GeneratorFunctionPrototype;
            define(genFun, toStringTagSymbol, "GeneratorFunction");
          }
          genFun.prototype = Object.create(Gp);
          return genFun;
        };
        exports.awrap = function (arg) {
          return {
            __await: arg
          };
        };
        function AsyncIterator(generator, PromiseImpl) {
          function invoke(method, arg, resolve, reject) {
            var record = tryCatch(generator[method], generator, arg);
            if (record.type === "throw") {
              reject(record.arg);
            } else {
              var result = record.arg;
              var value = result.value;
              if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
                return PromiseImpl.resolve(value.__await).then(function (value) {
                  invoke("next", value, resolve, reject);
                }, function (err) {
                  invoke("throw", err, resolve, reject);
                });
              }
              return PromiseImpl.resolve(value).then(function (unwrapped) {
                result.value = unwrapped;
                resolve(result);
              }, function (error) {
                return invoke("throw", error, resolve, reject);
              });
            }
          }
          var previousPromise;
          function enqueue(method, arg) {
            function callInvokeWithMethodAndArg() {
              return new PromiseImpl(function (resolve, reject) {
                invoke(method, arg, resolve, reject);
              });
            }
            return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
          }
          defineProperty(this, "_invoke", {
            value: enqueue
          });
        }
        defineIteratorMethods(AsyncIterator.prototype);
        define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
          return this;
        });
        exports.AsyncIterator = AsyncIterator;
        exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
          if (PromiseImpl === void 0) PromiseImpl = Promise;
          var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
          return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
            return result.done ? result.value : iter.next();
          });
        };
        function makeInvokeMethod(innerFn, self, context) {
          var state = GenStateSuspendedStart;
          return function invoke(method, arg) {
            if (state === GenStateExecuting) {
              throw new Error("Generator is already running");
            }
            if (state === GenStateCompleted) {
              if (method === "throw") {
                throw arg;
              }
              return doneResult();
            }
            context.method = method;
            context.arg = arg;
            while (true) {
              var delegate = context.delegate;
              if (delegate) {
                var delegateResult = maybeInvokeDelegate(delegate, context);
                if (delegateResult) {
                  if (delegateResult === ContinueSentinel) continue;
                  return delegateResult;
                }
              }
              if (context.method === "next") {
                context.sent = context._sent = context.arg;
              } else if (context.method === "throw") {
                if (state === GenStateSuspendedStart) {
                  state = GenStateCompleted;
                  throw context.arg;
                }
                context.dispatchException(context.arg);
              } else if (context.method === "return") {
                context.abrupt("return", context.arg);
              }
              state = GenStateExecuting;
              var record = tryCatch(innerFn, self, context);
              if (record.type === "normal") {
                state = context.done ? GenStateCompleted : GenStateSuspendedYield;
                if (record.arg === ContinueSentinel) {
                  continue;
                }
                return {
                  value: record.arg,
                  done: context.done
                };
              } else if (record.type === "throw") {
                state = GenStateCompleted;
                context.method = "throw";
                context.arg = record.arg;
              }
            }
          };
        }
        function maybeInvokeDelegate(delegate, context) {
          var methodName = context.method;
          var method = delegate.iterator[methodName];
          if (method === undefined$1) {
            context.delegate = null;
            if (methodName === "throw" && delegate.iterator["return"]) {
              context.method = "return";
              context.arg = undefined$1;
              maybeInvokeDelegate(delegate, context);
              if (context.method === "throw") {
                return ContinueSentinel;
              }
            }
            if (methodName !== "return") {
              context.method = "throw";
              context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method");
            }
            return ContinueSentinel;
          }
          var record = tryCatch(method, delegate.iterator, context.arg);
          if (record.type === "throw") {
            context.method = "throw";
            context.arg = record.arg;
            context.delegate = null;
            return ContinueSentinel;
          }
          var info = record.arg;
          if (!info) {
            context.method = "throw";
            context.arg = new TypeError("iterator result is not an object");
            context.delegate = null;
            return ContinueSentinel;
          }
          if (info.done) {
            context[delegate.resultName] = info.value;
            context.next = delegate.nextLoc;
            if (context.method !== "return") {
              context.method = "next";
              context.arg = undefined$1;
            }
          } else {
            return info;
          }
          context.delegate = null;
          return ContinueSentinel;
        }
        defineIteratorMethods(Gp);
        define(Gp, toStringTagSymbol, "Generator");
        define(Gp, iteratorSymbol, function () {
          return this;
        });
        define(Gp, "toString", function () {
          return "[object Generator]";
        });
        function pushTryEntry(locs) {
          var entry = {
            tryLoc: locs[0]
          };
          if (1 in locs) {
            entry.catchLoc = locs[1];
          }
          if (2 in locs) {
            entry.finallyLoc = locs[2];
            entry.afterLoc = locs[3];
          }
          this.tryEntries.push(entry);
        }
        function resetTryEntry(entry) {
          var record = entry.completion || {};
          record.type = "normal";
          delete record.arg;
          entry.completion = record;
        }
        function Context(tryLocsList) {
          this.tryEntries = [{
            tryLoc: "root"
          }];
          tryLocsList.forEach(pushTryEntry, this);
          this.reset(true);
        }
        exports.keys = function (val) {
          var object = Object(val);
          var keys = [];
          for (var key in object) {
            keys.push(key);
          }
          keys.reverse();
          return function next() {
            while (keys.length) {
              var key = keys.pop();
              if (key in object) {
                next.value = key;
                next.done = false;
                return next;
              }
            }
            next.done = true;
            return next;
          };
        };
        function values(iterable) {
          if (iterable != null) {
            var iteratorMethod = iterable[iteratorSymbol];
            if (iteratorMethod) {
              return iteratorMethod.call(iterable);
            }
            if (typeof iterable.next === "function") {
              return iterable;
            }
            if (!isNaN(iterable.length)) {
              var i = -1,
                next = function next() {
                  while (++i < iterable.length) {
                    if (hasOwn.call(iterable, i)) {
                      next.value = iterable[i];
                      next.done = false;
                      return next;
                    }
                  }
                  next.value = undefined$1;
                  next.done = true;
                  return next;
                };
              return next.next = next;
            }
          }
          throw new TypeError(typeof iterable + " is not iterable");
        }
        exports.values = values;
        function doneResult() {
          return {
            value: undefined$1,
            done: true
          };
        }
        Context.prototype = {
          constructor: Context,
          reset: function reset(skipTempReset) {
            this.prev = 0;
            this.next = 0;
            this.sent = this._sent = undefined$1;
            this.done = false;
            this.delegate = null;
            this.method = "next";
            this.arg = undefined$1;
            this.tryEntries.forEach(resetTryEntry);
            if (!skipTempReset) {
              for (var name in this) {
                if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                  this[name] = undefined$1;
                }
              }
            }
          },
          stop: function stop() {
            this.done = true;
            var rootEntry = this.tryEntries[0];
            var rootRecord = rootEntry.completion;
            if (rootRecord.type === "throw") {
              throw rootRecord.arg;
            }
            return this.rval;
          },
          dispatchException: function dispatchException(exception) {
            if (this.done) {
              throw exception;
            }
            var context = this;
            function handle(loc, caught) {
              record.type = "throw";
              record.arg = exception;
              context.next = loc;
              if (caught) {
                context.method = "next";
                context.arg = undefined$1;
              }
              return !!caught;
            }
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];
              var record = entry.completion;
              if (entry.tryLoc === "root") {
                return handle("end");
              }
              if (entry.tryLoc <= this.prev) {
                var hasCatch = hasOwn.call(entry, "catchLoc");
                var hasFinally = hasOwn.call(entry, "finallyLoc");
                if (hasCatch && hasFinally) {
                  if (this.prev < entry.catchLoc) {
                    return handle(entry.catchLoc, true);
                  } else if (this.prev < entry.finallyLoc) {
                    return handle(entry.finallyLoc);
                  }
                } else if (hasCatch) {
                  if (this.prev < entry.catchLoc) {
                    return handle(entry.catchLoc, true);
                  }
                } else if (hasFinally) {
                  if (this.prev < entry.finallyLoc) {
                    return handle(entry.finallyLoc);
                  }
                } else {
                  throw new Error("try statement without catch or finally");
                }
              }
            }
          },
          abrupt: function abrupt(type, arg) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];
              if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
                var finallyEntry = entry;
                break;
              }
            }
            if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
              finallyEntry = null;
            }
            var record = finallyEntry ? finallyEntry.completion : {};
            record.type = type;
            record.arg = arg;
            if (finallyEntry) {
              this.method = "next";
              this.next = finallyEntry.finallyLoc;
              return ContinueSentinel;
            }
            return this.complete(record);
          },
          complete: function complete(record, afterLoc) {
            if (record.type === "throw") {
              throw record.arg;
            }
            if (record.type === "break" || record.type === "continue") {
              this.next = record.arg;
            } else if (record.type === "return") {
              this.rval = this.arg = record.arg;
              this.method = "return";
              this.next = "end";
            } else if (record.type === "normal" && afterLoc) {
              this.next = afterLoc;
            }
            return ContinueSentinel;
          },
          finish: function finish(finallyLoc) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];
              if (entry.finallyLoc === finallyLoc) {
                this.complete(entry.completion, entry.afterLoc);
                resetTryEntry(entry);
                return ContinueSentinel;
              }
            }
          },
          "catch": function _catch(tryLoc) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];
              if (entry.tryLoc === tryLoc) {
                var record = entry.completion;
                if (record.type === "throw") {
                  var thrown = record.arg;
                  resetTryEntry(entry);
                }
                return thrown;
              }
            }
            throw new Error("illegal catch attempt");
          },
          delegateYield: function delegateYield(iterable, resultName, nextLoc) {
            this.delegate = {
              iterator: values(iterable),
              resultName: resultName,
              nextLoc: nextLoc
            };
            if (this.method === "next") {
              this.arg = undefined$1;
            }
            return ContinueSentinel;
          }
        };
        return exports;
      }(module.exports);
      try {
        regeneratorRuntime = runtime;
      } catch (accidentalStrictMode) {
        if (typeof globalThis === "object") {
          globalThis.regeneratorRuntime = runtime;
        } else {
          Function("r", "regeneratorRuntime = r")(runtime);
        }
      }
    })(runtime);
    return runtime.exports;
  }
  requireRuntime();
  var structuredClone$1;
  var hasRequiredStructuredClone$1;
  function requireStructuredClone$1() {
    if (hasRequiredStructuredClone$1) return structuredClone$1;
    hasRequiredStructuredClone$1 = 1;
    requireEs_error_toString();
    requireEs_array_iterator();
    requireEs_object_keys();
    requireEs_object_toString();
    requireEs_map();
    requireEs_set();
    requireWeb_domException_constructor();
    requireWeb_domException_stack();
    requireWeb_domException_toStringTag();
    requireWeb_structuredClone();
    var path = requirePath();
    structuredClone$1 = path.structuredClone;
    return structuredClone$1;
  }
  var structuredClone;
  var hasRequiredStructuredClone;
  function requireStructuredClone() {
    if (hasRequiredStructuredClone) return structuredClone;
    hasRequiredStructuredClone = 1;
    var parent = requireStructuredClone$1();
    structuredClone = parent;
    return structuredClone;
  }
  requireStructuredClone();
  var diagramUrl = 'https://cdn.statically.io/gh/bpmn-io/bpmn-js-examples/dfceecba/starter/diagram.bpmn';
  var bpmnModeler = new window.BpmnJS({
    container: '#canvas'
  });
  function exportDiagram() {
    return _exportDiagram.apply(this, arguments);
  }
  function _exportDiagram() {
    _exportDiagram = _asyncToGenerator(_regenerator().m(function _callee() {
      var result, _t;
      return _regenerator().w(function (_context) {
        while (1) switch (_context.p = _context.n) {
          case 0:
            _context.p = 0;
            _context.n = 1;
            return bpmnModeler.saveXML({
              format: true
            });
          case 1:
            result = _context.v;
            window.alert('Diagram exported. Check the developer tools!');
            window.console.log('DIAGRAM', result.xml);
            _context.n = 3;
            break;
          case 2:
            _context.p = 2;
            _t = _context.v;
            window.console.error('could not save BPMN 2.0 diagram', _t);
          case 3:
            return _context.a(2);
        }
      }, _callee, null, [[0, 2]]);
    }));
    return _exportDiagram.apply(this, arguments);
  }
  function openDiagram(_x) {
    return _openDiagram.apply(this, arguments);
  }
  function _openDiagram() {
    _openDiagram = _asyncToGenerator(_regenerator().m(function _callee2(bpmnXML) {
      var canvas, overlays, _t2;
      return _regenerator().w(function (_context2) {
        while (1) switch (_context2.p = _context2.n) {
          case 0:
            _context2.p = 0;
            _context2.n = 1;
            return bpmnModeler.importXML(bpmnXML);
          case 1:
            canvas = bpmnModeler.get('canvas');
            overlays = bpmnModeler.get('overlays');
            canvas.zoom('fit-viewport');
            overlays.add('SCAN_OK', 'note', {
              position: {
                bottom: 0,
                right: 0
              },
              html: '<div class="diagram-note">Mixed up the labels?</div>'
            });
            canvas.addMarker('SCAN_OK', 'needs-discussion');
            _context2.n = 3;
            break;
          case 2:
            _context2.p = 2;
            _t2 = _context2.v;
            window.console.error('could not import BPMN 2.0 diagram', _t2);
          case 3:
            return _context2.a(2);
        }
      }, _callee2, null, [[0, 2]]);
    }));
    return _openDiagram.apply(this, arguments);
  }
  window.$.get(diagramUrl, openDiagram, 'text');
  window.$('#save-button').click(exportDiagram);
})();
